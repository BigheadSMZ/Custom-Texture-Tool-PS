#==============================================================================================================================================================================================
$global:ScriptName = 'Custom Texture Tool PS v51.0'
# By: Bighead
#==============================================================================================================================================================================================
#  LOAD MICROSOFT .NET FRAMEWORK ASSEMBLIES
#==============================================================================================================================================================================================
Add-Type -AssemblyName 'System.Windows.Forms'
Add-Type -AssemblyName 'System.Drawing'
Add-Type -AssemblyName 'System.IO.Compression'
Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
Add-Type -AssemblyName 'System.Linq'
Add-Type -AssemblyName 'System.Runtime.InteropServices'
#==============================================================================================================================================================================================
#  CONSTANT VARIABLES: FILE EXTENSIONS
#==============================================================================================================================================================================================
New-Variable -Name 'PNG'  -Value '.png'  -Option Constant
New-Variable -Name 'DDS'  -Value '.dds'  -Option Constant
New-Variable -Name 'JPG'  -Value '.jpg'  -Option Constant
New-Variable -Name 'BMP'  -Value '.bmp'  -Option Constant
New-Variable -Name 'TGA'  -Value '.tga'  -Option Constant
New-Variable -Name 'TIF'  -Value '.tif'  -Option Constant
New-Variable -Name 'TIFF' -Value '.tiff' -Option Constant
New-Variable -Name 'WEBP' -Value '.webp' -Option Constant
New-Variable -Name 'ICO'  -Value '.ico'  -Option Constant
New-Variable -Name 'NUL'  -Value '.nul'  -Option Constant
New-Variable -Name 'ZIP'  -Value '.zip'  -Option Constant
New-Variable -Name 'PKA'  -Value '.pka'  -Option Constant
New-Variable -Name 'PKG'  -Value '.pkg'  -Option Constant
New-Variable -Name 'CTT'  -Value '.ctt'  -Option Constant
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - CTT-PS Options
#==============================================================================================================================================================================================
$global:CTTPSSelectedMode       = "Dolphin Mode"
$global:TextureListMode         = "Window"
$global:TexListAutoScroll       = $true
$global:StoredOperation         = "Scan Dolphin Textures For Issues"
$global:StoredFormatMenu        = "PNG"
$global:StoreTexListSizes       = $false
$global:TexListWidth            = 1172
$global:TexListHeight           = 600
$global:TexListColumnSizeA      = 230
$global:TexListColumnSizeB      = 100
$global:TexListColumnSizeC      = 100
$global:TexListColumnSizeD      = 80
$global:TexListColumnSizeE      = 85
$global:TexListColumnSizeF      = 85
$global:TexListColumnSizeG      = 180
$global:TexListColumnSizeH      = 70
$global:TexListColumnSizeI      = 210
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - Input/Output Path
#==============================================================================================================================================================================================
$global:StoreInputFolder        = $false
$global:StoreOutputFolder       = $false
$global:SavedInputFolder        = ""
$global:SavedOutputFolder       = ""
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - DDS Options
#==============================================================================================================================================================================================
$global:DDSCreatorTool          = "ImageMagick"
$global:DDSBlkCompress          = "BC1/BC3"
$global:DDSFlagRemoval          = "New & Base"
$global:DDSFallbackCompress     = "BC1/BC3"
$global:DDSForceDX10Header      = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - DDS Options - Compressonator Config
#==============================================================================================================================================================================================
$global:CompressEncodeWith      = "CPU"
$global:CompressDecodeWith      = "CPU"
$global:CompressSwizzle         = $false
$global:CompressNumThreads      = 0
$global:CompressBC7Quality      = "Auto"
$global:CompressNoPerformance   = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - DDS Options - TexConv Config
#==============================================================================================================================================================================================
$global:TexConvCompSpeed        = "Standard"
$global:TexConvAlphaType        = "No Force"
$global:TexConvFlipImage        = "Disabled"
$global:TexConvForceSRGB        = $true
$global:TexConvDisableGPU       = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - DDS Options - ImageMagick Config
#==============================================================================================================================================================================================
$global:MagickAlphaWeight       = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - PNG Options
#==============================================================================================================================================================================================
$global:PNGFlipResult           = $false
$global:PNGPalettedImage        = $false
$global:PNGBC7Converter         = "TexConv"
$global:PNGSaveAlphaPixels      = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - JPG Options
#==============================================================================================================================================================================================
$global:JPGQualityValue         = 90
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - BMP Options
#==============================================================================================================================================================================================
$global:BMPLimitColors          = $false
$global:BMPBitmapVersion        = 4
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - TIFF Options
#==============================================================================================================================================================================================
$global:TIFFNoResizeMipmap      = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - Mipmap Options
#==============================================================================================================================================================================================
$global:DisableMipmaps          = $false
$global:ForceNewMipmaps         = $false
$global:MipmapTopLevelBase      = $false
$global:MaxMipmapEnabled        = $false
$global:MaxMipmapLevels         = 2
$global:ExternalDDSMipmaps      = $false
$global:ForceCreateMipmaps      = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Main - Process Selected
#==============================================================================================================================================================================================
$global:ProcessFastMode         = $false
$global:ProcessOverwrite        = $false
$global:ProcessKeepOriginal     = $false
$global:ProcessOverride         = $false
$global:ProcessOverridePath     = ""
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Create Texture Size Database
#==============================================================================================================================================================================================
$global:DatabaseOverwrite       = $false
$global:DatabaseMissing         = $false
$global:DatabaseMissCopy        = $false
$global:DatabaseName            = "TextureSizes.tdb"
$global:DatabasePath            = ""
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Scan Dolphin/Database Textures For Issues
#==============================================================================================================================================================================================
$global:RepairTextures          = $false
$global:CopyBadTextures         = $false
$global:HideOKTextures          = $false
$global:IgnoreDuplicates        = $false
$global:AllowNotHD              = $true
$global:ScaleThreshold          = 0.65
$global:AspectThreshold         = 0.05
$global:UserScaleValues         = $false
$global:AcceptedScales          = ""
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Shared between Convert/Rescale/Resize.
#==============================================================================================================================================================================================
$global:CopyNonTextures         = $true
$global:EnableSharpen           = $true
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Convert Textures to Another Format
#==============================================================================================================================================================================================
$global:ConvertFormat           = $PNG
$global:ConvertRepair           = $false
$global:ConvertIconSizes        = "16,24,32,48,64,128,256"
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Rescale Textures With New Scaling Factor
#==============================================================================================================================================================================================
$global:RescaleFactor           = 4.00
$global:RescaleFormat           = $PNG
$global:RescaleScaling          = "Always"
$global:RescaleDolphinReal      = $false
$global:ManualRescale           = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Resize Textures With Specific Dimensions
#==============================================================================================================================================================================================
$global:ResizeWidth             = 128
$global:ResizeHeight            = 128
$global:ResizeFormat            = $PNG
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Add Identifying Watermark to All Textures
#==============================================================================================================================================================================================
$global:WM_Length               = 0
$global:WM_FontSize             = 8
$global:WM_FontColor            = "#FF0000"
$global:WM_BGColor              = "#00FF00"
$global:WM_FontFace             = "Courier-New-Bold"
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Create Materials With Material Map Generator
#==============================================================================================================================================================================================
$global:MatMapTileSize          = "512x512"
$global:MatMapEdgePixels        = "None"
$global:MatMapDisableGPU        = $false
$global:MatMapCreateMaps        = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Create Material Maps With Ishiiruka Tool
#==============================================================================================================================================================================================
$global:IshiirukaFormat         = $PNG
$global:InPlaceMaterial         = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Optimize PNG Textures With Optimizer Program
#==============================================================================================================================================================================================
$global:OptimizerTool           = "OptiPNG"
$global:OptimizeTests           = 3
$global:OptimizeThreads         = 1
$global:OptimizeInPlace         = $false
$global:OptimizeStripMeta       = $false
$global:OptimizeLossless        = $false
$global:OptimizeReuseColors     = $false
$global:OptiDolphinCheck        = $true
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Apply Upscaling Filter to All Textures
#==============================================================================================================================================================================================
$global:FilterSelected          = "Point"
$global:UpscaleFactor           = 4
$global:SeamlessMethod          = "Disable"
$global:SeamlessPixels          = 24
$global:UpscaleFormat           = $PNG
$global:UpscaleAsTarget         = $false
$global:Waifu2xModel            = "anime_style_art_rgb"
$global:Waifu2xCMode            = "noise_scale"
$global:Waifu2xNoise            = 2
$global:Waifu2xDisableGPU       = $false
$global:Waifu2xOpenCL           = $false
$global:ESRGANModel             = "RRDB_ESRGAN_x4"
$global:SFTGANModel             = "SFTGAN_torch"
$global:ESRGANDisableGPU        = $false
$global:ESRGANSaveAlpha         = $true
$global:ESRGANUseSegments       = $true
$global:ESRGANMaxSegment        = "256x256"
$global:ESRGANExtraPixels       = 24
$global:ESRGANPixelBuffer       = "Standard"
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Generate New Mipmaps For Dolphin Textures 
#==============================================================================================================================================================================================
$global:InPlaceMipmaps          = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Extract Internal Mipmaps
#==============================================================================================================================================================================================
$global:InPlaceExtractDDS       = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Combine Multiple Textures
#==============================================================================================================================================================================================
$global:TextureRows             = 2
$global:TextureCols             = 2
$global:CTTIncludeTextures      = $false
$global:CombineButtonSizeX      = 100
$global:CombineButtonSizeY      = 100
$global:CombinedName            = "CombinedTexture"
$global:CombineFontColor        = "#000000"
$global:CombineTileColor        = "#00FF00"
$global:CombineAutoArrange      = $false
$global:UserSpecifyTopLeft      = $false
$global:CombineOverlapEnable    = $false
$global:CombineOverlapValue     = 0
$global:CombinePixelCrop        = $false
$global:CombinePixelCropT       = 0
$global:CombinePixelCropB       = 0
$global:CombinePixelCropL       = 0
$global:CombinePixelCropR       = 0
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Split Combined Multi-Texture
#==============================================================================================================================================================================================
$global:SplitBatchImages        = $false
$global:SplitDefineBoundary     = $false
$global:SplitBoundaryWidth      = 0
$global:SplitBoundaryHeight     = 0
$global:SplitOverlapEnable      = $false
$global:SplitPixelOverlap       = 0
$global:SplitZeldaRestore       = $false
$global:SplitPixelRestoreT      = 0
$global:SplitPixelRestoreB      = 0
$global:SplitPixelRestoreL      = 0
$global:SplitPixelRestoreR      = 0
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Add/Remove Arbitrary Mipmap Suffix
#==============================================================================================================================================================================================
$global:ArbSuffixChoice         = "Add Suffix"
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - PNG Alpha Pixel Manipulation
#==============================================================================================================================================================================================
$global:AlphaPixelMode          = 0
$global:InPlaceAlphaPixel       = $false
$global:AlphaSearch             = "No Color Data"
$global:AlphaThreshold          = 0
$global:BAlphaRed               = $true
$global:CAlphaRed               = 0
$global:BAlphaGrn               = $true
$global:CAlphaGrn               = 0
$global:BAlphaBlu               = $true
$global:CAlphaBlu               = 0
$global:BAlphaAlp               = $true
$global:CAlphaAlp               = 0
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Separate/Combine Texture RGBA Channels
#==============================================================================================================================================================================================
$global:RGBAChannelChoice       = "Split into Channels"
$global:RGBABackGroundChoice    = "Black"
$global:RGBAUtilizeAlpha        = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Dolphin Resource Pack Manager
#==============================================================================================================================================================================================
$global:ResourceOperation       = "Create a Resource Pack"
$global:ResourceCompress        = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Various "Phyre Mode" Options
#==============================================================================================================================================================================================
$global:PhyrePKAType            = "All Possible Files"
$global:PhyreSwizzle            = $true
$global:PhyreSaveHeader         = $true
$global:PhyreSaveMipmaps        = $false
$global:PhyrePreviousPath       = $true
$global:PhyreOnlyScan           = $false
$global:PhyreExtension          = $NUL
$global:PhyreImageFormat        = "Source"
$global:PhyreXMLUpdate          = $true
$global:PhyreDXT1AToDXT5        = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Operation - Various "Metroid Prime Mode" Options
#==============================================================================================================================================================================================
$global:MetroidHighQuality      = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Options - Extract Textures With TextureExtraction Tool
#==============================================================================================================================================================================================
$global:ExtractForceUnknown     = $false
$global:ExtractRawImages        = $false
$global:ExtractCombineRGBA      = $false
$global:ExtractCleanType        = "Default"
$global:ExtractCleanCount       = 7
$global:ExtractTasksEnable      = $false
$global:ExtractTasksCount       = 4
$global:ExtractTexMipmaps       = $false
$global:ExtractDolphinMipmap    = $true
$global:ExtractArbMipmap        = $true
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Options - Preferences
#==============================================================================================================================================================================================
$global:EnableStoring           = $true
$global:StoreToAppData          = $true
$global:CreateLogFile           = $true
$global:DirectoryRecursion      = $true
$global:AlwaysOverwrite         = $true
$global:AutoCleanOutput         = $true
$global:DialogUpdateRate        = 25
$global:DisableTopMost          = $true
$global:MinimizeSingle          = $true
$global:EnableVisualStyle       = $true
$global:ShowQuickHelpIcon       = $true
$global:ShowWebLinkIcons        = $true
$global:ClickClearText          = $true
$global:AutoShutdownPC          = $false
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Options - Exclusions
#==============================================================================================================================================================================================
$global:ExcludePNG              = $true
$global:ExcludeDDS              = $true
$global:ExcludeJPG              = $true
$global:ExcludeTGA              = $true
$global:ExcludeTIF              = $true
$global:ExcludeIsMipmap         = $true
$global:ExcludeHasMipmap        = $true
$global:ExcludeNoAlpha          = $true
$global:ExcludeHasAlpha         = $true
$global:ExcludeHasMats          = $true
$global:ExcludeHasMatMaps       = $true
$global:ExcludeTransparency     = "Allow All (Fastest)"
$global:ExcludeMinWidth         = 0
$global:ExcludeMinHeight        = 0
$global:ExcludeMaxWidth         = 0
$global:ExcludeMaxHeight        = 0
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Options - Debug
#==============================================================================================================================================================================================
$global:WinDarkModeEnabled      = $false
$global:EnableThePSConsole      = $false
$global:DisableAutoConsole      = $false
$global:ForceShowBC7Format      = $false
$global:UseStockDDSHeaders      = $false
$global:DumpCTTPSIconAsPNG      = $false
$global:CloseNoSaveButtons      = $false
$global:SplitCombineLimits      = 120
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Options - Tool Paths
#==============================================================================================================================================================================================
$global:UseToolsMasterPath      = $false
$global:ToolsMasterPath         = ""
$global:ImageMagick             = ""
$global:TexConvTool             = ""
$global:Compressonator          = ""
$global:IshiirukaTool           = ""
$global:MatMapGenPath           = ""
$global:TexExtractTool          = ""
$global:OptiPNGPath             = ""
$global:OxiPNGPath              = ""
$global:PingoPath               = ""
$global:ECTPath                 = ""
$global:ScalerTestPath          = ""
$global:Waifu2xPath             = ""
$global:7ZipPath                = ""
$global:PhyrePKGTool            = ""
$global:Python                  = ""
$global:ESRGANBasePath          = ""
$global:SFTGANBasePath          = ""
$global:SuperScalersPath        = ""
#==============================================================================================================================================================================================
#  GLOBAL VARIABLES: Script-only variables that are updated here but not stored to the "StoredOptions.ini" file.
#==============================================================================================================================================================================================
$global:TextureToolData         = "C:\Users\Bighead\AppData\Local\CTT-PS Data"
$global:DisableHighDPIMode      = $false
#=============================================================================================================================================================================================
#  ENDGLOBALS - Do not delete this line! It is used as an exit point for loops when saving/importing stored options and retrieving the variable names/values.
#==============================================================================================================================================================================================
#  EXTERNAL LINKS
#==============================================================================================================================================================================================
#  It gets tedious updating these from time to time, so collect them all here so they are easier to update.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$global:Link_Magick    = "http://www.imagemagick.org/script/download.php#windows"
$global:Link_TexConv   = "https://github.com/Microsoft/DirectXTex/releases"
$global:Link_Compress  = "https://github.com/GPUOpen-Tools/Compressonator/releases"
$global:Link_Ishiiruka = "https://drive.google.com/drive/folders/0B_-yAcIE2LcJfjJXb2o2dUU1SWNYOGI1LXViaGluUHBJdEgyWE4xaGM1OXBKZmE1RnpwcjA?resourcekey=0-NopeWS4AEGwshDPFnq2Saw"
$global:Link_MatMapGen = "https://github.com/JoeyBallentine/Material-Map-Generator/"
$global:Link_DolTexExt = "https://github.com/Venomalia/DolphinTextureExtraction-tool/releases"
$global:Link_OptiPNG   = "http://optipng.sourceforge.net/"
$global:Link_OxiPNG    = "https://github.com/shssoichiro/oxipng/releases"
$global:Link_Pingo     = "https://css-ig.net/pingo"
$global:Link_ECT       = "https://github.com/fhanau/Efficient-Compression-Tool/releases"
$global:Link_xBRZ      = "https://sourceforge.net/projects/xbrz/"
$global:Link_W2x_Caffe = "https://github.com/lltcggie/waifu2x-caffe/releases"
$global:Link_W2x_CPP   = "https://github.com/DeadSix27/waifu2x-converter-cpp/releases"
$global:Link_SevZip    = "https://www.7-zip.org/download.html"
$global:Link_PKGSharp  = "https://github.com/Sewer56/Sen-no-Kiseki-PKG-Sharp/releases"
$global:Link_PKGTool   = "https://github.com/thesupersonic16/PKGTool/releases"
$global:Link_NETCore   = "https://dotnet.microsoft.com/download/dotnet-core/thank-you/runtime-2.2.8-windows-x64-installer"
$global:Link_Python    = "https://www.python.org/ftp/python/3.9.9/python-3.9.9-amd64.exe"
$global:Link_CUDA      = "https://developer.nvidia.com/cuda-11.3.0-download-archive"
$global:Link_ESRGAN    = "https://github.com/rapka/ESRGAN"
$global:Link_ESRGAND   = "https://github.com/rapka/ESRGAN/archive/master.zip"
$global:Link_SFTGAN    = "https://github.com/xinntao/SFTGAN"
$global:Link_SFTGAND   = "https://github.com/xinntao/SFTGAN/archive/master.zip"
$global:Link_SFTGANM   = "https://drive.google.com/drive/folders/16owosaM_ADAm2FmVI9eKmuYzULVeBy7t"
$global:Link_CTTPS     = "https://forums.dolphin-emu.org/Thread-custom-texture-tool-ps-v49-0"
$global:Link_CTTPSA    = "http://www.mediafire.com/folder/2x5jbi26qg7y8/CTT-PS%20Programs"
$global:Link_CTTPSB    = "https://drive.google.com/open?id=1MfAqUdY7rSYT2ZsvsYfGZ1AXsKtwyX0z"
$global:Link_CTTPSC    = "https://mega.nz/#F!L2Z3jAQK!QeDIMJsMrRMBw62ew8l9hw"
$global:Link_Bighead   = "http://bhemuhelp.unaux.com/"
$global:Link_Donate    = "http://bhemuhelp.unaux.com/donate.html"
#==============================================================================================================================================================================================
#  IMPORTED CODE: FAST FILE ENUMERATION
#==============================================================================================================================================================================================
#  A solution to enumerate files in a directory using multiple filter options that is really fast.
#  Source: https://stackoverflow.com/questions/3754118/how-to-filter-directory-enumeratefiles-with-multiple-criteria
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
public static class Enumerate
{
  public static IEnumerable<string> GetFiles(string path, string[] searchPatterns, SearchOption searchOption = SearchOption.TopDirectoryOnly)
  {
    return searchPatterns.AsParallel().SelectMany(searchPattern => Directory.EnumerateFiles(path, searchPattern, searchOption).Where(f => !new FileInfo(f).Attributes.HasFlag(FileAttributes.Hidden | FileAttributes.System)));
  }
}
"@
# Add the code so it can be used in PowerShell.
Add-Type -TypeDefinition $Source -Language 'CSharp'

# Create a powershell function to easily access the "GetFiles" C# function.
function EnumerateFiles([string]$LiteralPath, [string[]]$Filter='*.*', [switch]$Recurse)
{
  # Enable directory recursion if the switch is set.
  switch ($Recurse) 
  { 
    # "AllDirectories" recurses through subfolders while "TopDirectoryOnly" just searches the base folder.
    $true  { $SearchType = [IO.SearchOption]::AllDirectories } 
    $false { $SearchType = [IO.SearchOption]::TopDirectoryOnly }
  }
  # Return an array of files.
  return [Enumerate]::GetFiles($LiteralPath, $Filter, $SearchType)
}
#==============================================================================================================================================================================================
#  FAST FOLDER ENUMERATION
#==============================================================================================================================================================================================
#  Just uses a simple .NET function to get directories. Since it similar to the above, figured I'd just put it here.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function EnumerateFolders([string]$LiteralPath, [string]$Filter='*', [switch]$Recurse)
{
  # Enable directory recursion if the switch is set.
  switch ($Recurse) 
  { 
    # "AllDirectories" recurses through subfolders while "TopDirectoryOnly" just searches the base folder.
    $true  { $SearchType = [IO.SearchOption]::AllDirectories }
    $false { $SearchType = [IO.SearchOption]::TopDirectoryOnly }
  }
  # Return an array of folders.
  return [IO.Directory]::GetDirectories($LiteralPath, $Filter, $SearchType)
}
#=============================================================================================================================================================================================
#  FILE/PATH TEST CREATE AND REMOVE FUNCTIONS
#==============================================================================================================================================================================================
#  Checks if a path exists. Avoids use of using it directly which can generate an error if the tested path is null.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TestPath([string]$LiteralPath, [string]$PathType = 'Any')
{
  # Make sure the path isn't null to avoid errors.
  if ($LiteralPath -ne '')
  {
    # Check to see if the path exists.
    if (Test-Path -LiteralPath $LiteralPath -PathType $PathType -ErrorAction 'SilentlyContinue')
    {
      # The path exists.
      return $true
    }
  }
  # The path is bunk.
  return $false
}
#==============================================================================================================================================================================================
#  Creates a folder if it does not already exist. Returns the parameter so it can be set to a variable when called.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePath([string]$LiteralPath, [switch]$NoReturn)
{
  # Make sure the path isn't null to avoid errors.
  if ($LiteralPath -ne '')
  {
    # Check to see if the path does not exist.
    if (!(Test-Path -LiteralPath $LiteralPath))
    {
      # Create the path.
      New-Item -Path $LiteralPath -ItemType 'Directory' | Out-Null
    }
  }
  # Return the path so it can be set to a variable when creating.
  if (!$NoReturn) { return $LiteralPath }
}
#==============================================================================================================================================================================================
#  Removes a file or folder if it exists.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemovePath([string]$LiteralPath)
{
  # Make sure the path isn't null to avoid errors.
  if ($LiteralPath -ne '')
  {
    # Check to see if the path exists.
    if (Test-Path -LiteralPath $LiteralPath)
    {
      # Remove the file/folder and all children.
      Remove-Item -LiteralPath $LiteralPath -Recurse -Force -ErrorAction 'SilentlyContinue' | Out-Null
    }
  }
}
#==============================================================================================================================================================================================
#  Cleans out all items from a folder without actually removing the folder itself.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ClearPath([string]$LiteralPath, [string]$Exclude)
{
  # Make sure the path isn't null to avoid errors.
  if ($LiteralPath -ne '')
  {
    # Check to see if the path exists.
    if (Test-Path -LiteralPath $LiteralPath)
    {
      # Remove all files from the input folder.
      foreach ($File in EnumerateFiles -LiteralPath $LiteralPath)
      {
        if ($File -like $Exclude) { continue }
        Remove-Item -LiteralPath $File -Recurse -Force -ErrorAction 'SilentlyContinue' | Out-Null 
      }
      # Remove all folders from the input folder.
      foreach ($Path in EnumerateFolders -LiteralPath $LiteralPath)
      {
        if ($Path -like $Exclude) { continue }
        Remove-Item -LiteralPath $Path -Recurse -Force -ErrorAction 'SilentlyContinue' | Out-Null
      }
    }
  }
}
#==============================================================================================================================================================================================
#  IMPORTED CODE: SHOW / HIDE POWERSHELL CONSOLE
#==============================================================================================================================================================================================
#  Awesome function that can show or hide the PowerShell console window.
#  Source: http://powershell.cz/2013/04/04/hide-and-show-console-window-from-gui/
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
[DllImport("Kernel32.dll")]
public static extern IntPtr GetConsoleWindow();
[DllImport("user32.dll")]
public static extern bool ShowWindow(IntPtr hWnd, Int32 nCmdShow);
"@
Add-Type -Namespace Console -Name Window -MemberDefinition $Source

# Function that shows or hides the console window.
function ShowPowerShellConsole([bool]$ShowConsole)
{
  switch ($ShowConsole)
  {
    $true   { [Console.Window]::ShowWindow([Console.Window]::GetConsoleWindow(), 5) | Out-Null }
    $false  { [Console.Window]::ShowWindow([Console.Window]::GetConsoleWindow(), 0) | Out-Null }
  }
}
#==============================================================================================================================================================================================
#  IMPORTED CODE: SET POWERSHELL CONSOLE POSITION
#==============================================================================================================================================================================================
#  While not technically "imported" since it was heavily rewritten, I still have to give credit where it is due.
#  Source: https://superuser.com/questions/1324007/setting-window-size-and-position-in-powershell-5-and-6
#==============================================================================================================================================================================================
#  A chunk of code that creates a rectangle.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
using System;
using System.Runtime.InteropServices;
public class Window
{
  [DllImport("user32.dll")]
  [return: MarshalAs(UnmanagedType.Bool)]
  public static extern bool GetWindowRect(IntPtr hWnd, out Rectangle lpRect);

  [DllImport("user32.dll")]
  public extern static bool MoveWindow(IntPtr handle, int x, int y, int width, int height, bool redraw);
}
public struct Rectangle
{
  public int Left;        // x position of upper-left corner
  public int Top;         // y position of upper-left corner
  public int Right;       // x position of lower-right corner
  public int Bottom;      // y position of lower-right corner
}
"@
# Add the code to the current instance.
Add-Type -TypeDefinition $Source -Language 'CSharp'
#==============================================================================================================================================================================================
#  Gets the properties of the current PowerShell console window such as width, height, position, etc.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPowerShellInfo()
{
  # Store the values in a hash table.
  $PSInfo = @{}

  # Get the handle to PowerShell and create a rectangle to get the coordinates. 
  $PSProcess = Get-Process -Name 'powershell' -ErrorAction SilentlyContinue
  $Rectangle = New-Object Rectangle  # [System.Drawing.Rectangle] does not work here.
  $PSInfo.Handle  = $PSProcess.MainWindowHandle

  # If there is no process to be had then exit now.
  if ($PSInfo.Handle -eq [System.IntPtr]::Zero) { return }

  # Check to see if we successfully have the handle and rectable.
  $Return = [Window]::GetWindowRect($PSInfo.Handle, [ref]$Rectangle)

  # Get the width and height of the window in pixels.
  $PSInfo.Width  = $Rectangle.Right - $Rectangle.Left            
  $PSInfo.Height = $Rectangle.Bottom - $Rectangle.Top

  # (Unused) Grab a few other properties since the function this one was derived from had them.
  $PSInfo.Size = New-Object System.Management.Automation.Host.Size -ArgumentList $PSInfo.Width, $PSInfo.Height
  $PSInfo.TopLeft = New-Object System.Management.Automation.Host.Coordinates -ArgumentList $Rectangle.Left, $Rectangle.Top
  $PSInfo.BottomRight = New-Object System.Management.Automation.Host.Coordinates -ArgumentList $Rectangle.Right, $Rectangle.Bottom

  # Return the properties.
  return $PSInfo
}
#==============================================================================================================================================================================================
#  IMPORTED CODE: SET POWERSHELL CONSOLE ICON
#==============================================================================================================================================================================================
#  Source: https://gallery.technet.microsoft.com/scriptcenter/9d476461-899f-4c98-9d63-03b99596c2c3
#  Source: https://stackoverflow.com/questions/22040398/powershell-change-taskbar-icon-of-running-console-application
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Set-ConsoleIcon($Icon)
{
  $consoleHandle  = Invoke-Win32 "kernel32.dll" ([intPtr]) "GetConsoleWindow"
  $parameterTypes = @([intPtr], [int], [int], [int])
  $parameters     = @($consoleHandle, 128, 0, [int]$Icon.Handle)
  Invoke-Win32 "user32.dll" ([int]) "SendMessage" $parameterTypes $parameters | Out-Null
}
function Invoke-Win32([string]$dllName, [type]$returnType, [string]$methodName, [type[]]$parameterTypes, [object[]]$parameters)
{
  # Begin to build the dynamic assembly.
  $domain = [AppDomain]::CurrentDomain
  $name = New-Object Reflection.AssemblyName 'PInvokeAssembly'
  $assembly = $domain.DefineDynamicAssembly($name, 'Run')
  $module = $assembly.DefineDynamicModule('PInvokeModule')
  $type = $module.DefineType('PInvokeType', "Public,BeforeFieldInit")

  # Go through all of the parameters passed to us. As we do this, we clone the user's inputs into another array that we will use for the P/Invoke call.
  $inputParameters = @()
  $refParameters = @()

  for ($counter = 1; $counter -le $parameterTypes.Length; $counter++)
  {
    # If an item is a PSReference, then the user wants an [out] parameter.
    if ($parameterTypes[$counter - 1] -eq [Ref])
    {
      # Remember which parameters are used for [Out] parameters.
      $refParameters += $counter

      # On the cloned array, we replace the PSReference type with the .Net reference type that represents the value of the PSReference, and the value with the value held by the PSReference.
      $parameterTypes[$counter - 1] = $parameters[$counter - 1].Value.GetType().MakeByRefType()
      $inputParameters += $parameters[$counter - 1].Value
    }
    else
    {
      # Otherwise, just add their actual parameter to the input array.
      $inputParameters += $parameters[$counter - 1]
    }
  }
  # Define the actual P/Invoke method, adding the [Out] attribute for any parameters that were originally [Ref] parameters.
  $method = $type.DefineMethod($methodName, 'Public,HideBySig,Static,PinvokeImpl', $returnType, $parameterTypes)
  foreach ($refParameter in $refParameters)
  {
    $method.DefineParameter($refParameter, "Out", $null)
  }
  # Apply the P/Invoke constructor
  $ctor = [Runtime.InteropServices.DllImportAttribute].GetConstructor([string])
  $attr = New-Object Reflection.Emit.CustomAttributeBuilder $ctor, $dllName
  $method.SetCustomAttribute($attr)

  # Create the temporary type, and invoke the method.
  $realType = $type.CreateType()
  $realType.InvokeMember($methodName, 'Public,Static,InvokeMethod', $null, $null, $inputParameters)

  # Finally, go through all of the reference parameters, and update the values of the PSReference objects that the user passed in.
  foreach ($refParameter in $refParameters)
  {
    $parameters[$refParameter - 1].Value = $inputParameters[$refParameter - 1]
  }
}
#==============================================================================================================================================================================================
#  IMPORTED CODE: FORCE WINDOW FORWARD
#==============================================================================================================================================================================================
#  Forces a window to the front, or at least that is the idea behind it.
#  Source: https://stackoverflow.com/questions/12801563/powershell-setforegroundwindow
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
  using System;
  using System.Runtime.InteropServices;
  public class SFW {
     [DllImport("user32.dll")]
     [return: MarshalAs(UnmanagedType.Bool)]
     public static extern bool SetForegroundWindow(IntPtr hWnd);
  }
"@
# Add this to the list of things I'll barely ever use.
Add-Type -TypeDefinition $Source -Language 'CSharp'

# I don't know if this actually works but here it is. I called this function since v40.0, but it never existed until v47.0!
function Set-ForegroundWindow($Process)
{
  $Handle = (Get-Process $Process).MainWindowHandle
  [SFW]::SetForegroundWindow($Handle)
}
#==============================================================================================================================================================================================
#  IMPORTED CODE: WINDOWS FORM DOUBLE BUFFERING FOR CONTROLS TO AVOID FLICKER
#==============================================================================================================================================================================================
#  Enables double buffering on a form object to prevent things like the "Texture List" from flickering. I failed to accomplish this in PowerShell, so import some C# code.
#  Credits: https://www.fluxbytes.com/csharp/enable-double-buffering-for-controls-to-reduce-flickering/
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
namespace Bonus
{
  public static class Feature 
  { 
    public static void SetControlDoubleBuffering(System.Windows.Forms.Control control, bool enabled)
    {
      System.Reflection.PropertyInfo controlProperty = typeof(System.Windows.Forms.Control).GetProperty("DoubleBuffered", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
      controlProperty.SetValue(control, enabled, null);
    }
  }
}
"@
# Add the code as a type definition in C# language so we can make use of it.
$RefAssem = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
Add-Type -TypeDefinition $Source -ReferencedAssemblies $RefAssem -Language 'CSharp'
#==============================================================================================================================================================================================
# This works around a nasty flickering issue when the a listview is updated.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetDoubleBuffering($Control, [switch]$Enabled = $false)
{
  # I probably could just use this directly but the above is easier to remember.
  [Bonus.Feature]::SetControlDoubleBuffering($Control, $Enabled)
}
#==============================================================================================================================================================================================
#  IMPORTED CODE: VISTA STYLE OPEN FOLDER DIALOG
#==============================================================================================================================================================================================
#  Implements a much nicer folder selection dialog that I guess existed since Vista? Not sure why it was never actually just replaced in forms directly.
#  Credits: https://stackoverflow.com/questions/66823581/use-the-upgraded-folderbrowserdialog-vista-style-in-powershell
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
using System;
using System.Diagnostics;
using System.Reflection;
using System.Windows.Forms;
#pragma warning disable 0219, 0414, 0162
public class FolderSelectDialog {
    private string _initialDirectory;
    private string _title;
    private string _message;
    private string _fileName = "";
    public string InitialDirectory {
        get { return string.IsNullOrEmpty(_initialDirectory) ? Environment.CurrentDirectory : _initialDirectory; }
        set { _initialDirectory = value; }
    }
    public string Title {
        get { return _title ?? "Select a folder"; }
        set { _title = value; }
    }
    public string Message {
        get { return _message ?? _title ?? "Select a folder"; }
        set { _message = value; }
    }
    public string FileName { get { return _fileName; } }
    public FolderSelectDialog(string defaultPath="MyComputer", string title="Select a folder", string message=""){
        InitialDirectory = defaultPath;
        Title = title;
        Message = message;
    }
    public bool Show() { return Show(IntPtr.Zero); }
    public bool Show(IntPtr? hWndOwnerNullable=null) {
        IntPtr hWndOwner = IntPtr.Zero;
        if(hWndOwnerNullable!=null)
            hWndOwner = (IntPtr)hWndOwnerNullable;
        if(Environment.OSVersion.Version.Major >= 6){
            try{
                var resulta = VistaDialog.Show(hWndOwner, InitialDirectory, Title, Message);
                _fileName = resulta.FileName;
                return resulta.Result;
            }
            catch(Exception){
                var resultb = ShowXpDialog(hWndOwner, InitialDirectory, Title, Message);
                _fileName = resultb.FileName;
                return resultb.Result;
            }
        }
        var result = ShowXpDialog(hWndOwner, InitialDirectory, Title, Message);
        _fileName = result.FileName;
        return result.Result;
    }
    private struct ShowDialogResult {
        public bool Result { get; set; }
        public string FileName { get; set; }
    }
    private static ShowDialogResult ShowXpDialog(IntPtr ownerHandle, string initialDirectory, string title, string message) {
        var folderBrowserDialog = new FolderBrowserDialog {
            Description = message,
            SelectedPath = initialDirectory,
            ShowNewFolderButton = true
        };
        var dialogResult = new ShowDialogResult();
        if (folderBrowserDialog.ShowDialog(new WindowWrapper(ownerHandle)) == DialogResult.OK) {
            dialogResult.Result = true;
            dialogResult.FileName = folderBrowserDialog.SelectedPath;
        }
        return dialogResult;
    }
    private static class VistaDialog {
        private const string c_foldersFilter = "Folders|\n";
        private const BindingFlags c_flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
        private readonly static Assembly s_windowsFormsAssembly = typeof(FileDialog).Assembly;
        private readonly static Type s_iFileDialogType = s_windowsFormsAssembly.GetType("System.Windows.Forms.FileDialogNative+IFileDialog");
        private readonly static MethodInfo s_createVistaDialogMethodInfo = typeof(OpenFileDialog).GetMethod("CreateVistaDialog", c_flags);
        private readonly static MethodInfo s_onBeforeVistaDialogMethodInfo = typeof(OpenFileDialog).GetMethod("OnBeforeVistaDialog", c_flags);
        private readonly static MethodInfo s_getOptionsMethodInfo = typeof(FileDialog).GetMethod("GetOptions", c_flags);
        private readonly static MethodInfo s_setOptionsMethodInfo = s_iFileDialogType.GetMethod("SetOptions", c_flags);
        private readonly static uint s_fosPickFoldersBitFlag = (uint) s_windowsFormsAssembly
            .GetType("System.Windows.Forms.FileDialogNative+FOS")
            .GetField("FOS_PICKFOLDERS")
            .GetValue(null);
        private readonly static ConstructorInfo s_vistaDialogEventsConstructorInfo = s_windowsFormsAssembly
            .GetType("System.Windows.Forms.FileDialog+VistaDialogEvents")
            .GetConstructor(c_flags, null, new[] { typeof(FileDialog) }, null);
        private readonly static MethodInfo s_adviseMethodInfo = s_iFileDialogType.GetMethod("Advise");
        private readonly static MethodInfo s_unAdviseMethodInfo = s_iFileDialogType.GetMethod("Unadvise");
        private readonly static MethodInfo s_showMethodInfo = s_iFileDialogType.GetMethod("Show");
        public static ShowDialogResult Show(IntPtr ownerHandle, string initialDirectory, string title, string description) {
            var openFileDialog = new OpenFileDialog {
                AddExtension = false,
                CheckFileExists = false,
                DereferenceLinks = true,
                Filter = c_foldersFilter,
                InitialDirectory = initialDirectory,
                Multiselect = false,
                Title = title
            };
            var iFileDialog = s_createVistaDialogMethodInfo.Invoke(openFileDialog, new object[] { });
            s_onBeforeVistaDialogMethodInfo.Invoke(openFileDialog, new[] { iFileDialog });
            s_setOptionsMethodInfo.Invoke(iFileDialog, new object[] { (uint) s_getOptionsMethodInfo.Invoke(openFileDialog, new object[] { }) | s_fosPickFoldersBitFlag });
            var adviseParametersWithOutputConnectionToken = new[] { s_vistaDialogEventsConstructorInfo.Invoke(new object[] { openFileDialog }), 0U };
            s_adviseMethodInfo.Invoke(iFileDialog, adviseParametersWithOutputConnectionToken);
            try {
                int retVal = (int) s_showMethodInfo.Invoke(iFileDialog, new object[] { ownerHandle });
                return new ShowDialogResult {
                    Result = retVal == 0,
                    FileName = openFileDialog.FileName
                };
            }
            finally {
                s_unAdviseMethodInfo.Invoke(iFileDialog, new[] { adviseParametersWithOutputConnectionToken[1] });
            }
        }
    }
    private class WindowWrapper : IWin32Window {
        private readonly IntPtr _handle;
        public WindowWrapper(IntPtr handle) { _handle = handle; }
        public IntPtr Handle { get { return _handle; } }
    }
    public string getPath(){
        if (Show()){
            return FileName;
        }
        return "";
    }
}
"@
# Add the code as a type definition in C# language so we can make use of it.
$RefAssem = "System.Windows.Forms", "System.ComponentModel.Primitives"
Add-Type -Language CSharp -TypeDefinition $Source -ReferencedAssemblies $RefAssem
#==============================================================================================================================================================================================
#  IMPORTED CODE: PYTHON SCRIPT TO EXTRACT COLD STEEL III/IV PKG FILES
#==============================================================================================================================================================================================
#  Decompress most packages in ..\The Legend of Heroes Trails of Cold Steel III\data\asset\D3D11_us
#  Can use Noesis and https://zenhax.com/viewtopic.php?p=33383#p33383 plugin to view
#  https://github.com/Sewer56/Sen-no-Kiseki-PKG-Sharp/issues#issuecomment-632975223
#  Credit: CeruleanSky 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$global:PKGScriptContent = @"
from lz4.block import decompress
import argparse
from struct import unpack
import glob

parser = argparse.ArgumentParser()
parser.add_argument("-v","--verbose", help="be more verbose", action="store_true")
parser.add_argument("files", type=str, nargs="+", help="file(s) to decompress")

args = parser.parse_args()
files = []

print(args)
for x in args.files:
    files.extend( glob.glob(x))

for file in files:
    with open(file,'rb') as f:
        pkg = f.read()
        try:
            num_of_files = unpack('L',pkg[0x4:0x8])[0]
            for file_num in range(num_of_files):
                i = 0x8+file_num*0x50
                filename = pkg[i:i+pkg[i:].find(0)]
                unpacked_length=unpack('L',pkg[i+0x40:i+0x40+0x4])[0]
                block_size = unpack('L',pkg[i+0x44:i+0x44+0x4])[0]
                block_offset = unpack('L',pkg[i+0x48:i+0x48+0x4])[0]
                comp_type = pkg[i+0x4C]
                if comp_type == 4:
                    z = decompress(pkg[block_offset:block_offset+block_size],uncompressed_size=unpacked_length)
                elif comp_type == 0:
                    z = pkg[block_offset:block_offset+block_size]
                else: 
                    print("Compression type " + hex(comp_type) + " for filename " + str(filename) + " is unsupported in pkg:" + file)
                with open(filename,'wb') as o:
                    if args.verbose: print(filename)
                    o.write(z)
        except:
            print("Something went wrong such as unsupported file type or variation" + str(args.files))
"@
#==============================================================================================================================================================================================
#  IMPORTED CODE: PYTHON SCRIPT TO EXTRACT COLD STEEL III/IV PKA FILES
#==============================================================================================================================================================================================
#  Decompress most packages in ..\The Legend of Heroes Trails of Cold Steel III\data\asset\D3D11_us
#  Can use Noesis and https://zenhax.com/viewtopic.php?p=33383#p33383 plugin to view
#  https://gist.github.com/CeruleanSky/c34400510c2b2484d179548f8db4ba41
#  Credit: CeruleanSky 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$global:PKAScriptContent = @"
from struct import unpack
from lz4.block import decompress
import os
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-v","--verbose", help="be more verbose", action="store_true")
parser.add_argument("-l","--listfiles", help="list files in packages in package archive use with -p if you want to see the package name above the files", action="store_true")
parser.add_argument("-p","--listpackages", help="list packages inside package archive", action="store_true")
parser.add_argument("package_archive", type=argparse.FileType('rb'), help="package archive to extract")
parser.add_argument("packages", type=str, default="all", nargs="*", help="specific packages(s) to extract decompress, defaults to all packages")

args = parser.parse_args()

f = args.package_archive
if 0x7ff7cf0d != unpack('L',f.read(4))[0]:
    print("Unsupported file. This program only has been tested with Cold Steel III v1.05 pka if you want to try others edit this source code and comment out the below line")
    #exit()
pka_index = {}
num_pkgs = unpack('L',f.read(4))[0]

#parse package information and add to pka_index
for pkg in range(num_pkgs):
    pkg_header = f.read(0x20) 
    pkg_name = pkg_header[0:pkg_header[0:].find(0)]
    if args.listpackages or args.verbose:
        print(pkg_name.decode("ANSI"))
    num_of_files = unpack('L',f.read(4))[0]
    file_entries = f.read(0x60*num_of_files)
    for file_num in range(num_of_files):
        i = file_num*0x60
        filename = file_entries[i:i+file_entries[i:].find(0)]
        if args.listfiles or args.verbose:
            if (args.packages == "all") or (pkg_name.decode("ANSI") in args.packages):
                print(filename.decode("ANSI"))
        filesha256 = file_entries[i+0x40:i+0x60]
        pka_index.setdefault(filesha256,[[],{}])[0].append(pkg_name)
        pka_index[filesha256][1]['filename'] = filename
num_comp_entries = unpack('L',f.read(4))[0]
comp_entries = f.read(num_comp_entries * 0x34)

#parse compression entries and add to pka_index
for comp_entry in range(num_comp_entries):
    i = comp_entry * 0x34
    filesha256 = comp_entries[i:i+0x20]
    block_offset = unpack('Q',comp_entries[i+0x20:i+0x28])[0]
    block_size = unpack('L',comp_entries[i+0x28:i+0x2C])[0]
    unpacked_length=unpack('L',comp_entries[i+0x2C:i+0x30])[0]
    comp_type =unpack('L',comp_entries[i+0x30:i+0x34])[0]
    pka_index[filesha256].append([block_offset,block_size,unpacked_length,comp_type])

#extraction, it would also probably be useful to split the package archive back into pkg files for space reasons.
if not (args.listpackages or args.listfiles):
    for x in pka_index:
        for pkg_name in pka_index[x][0]:
            if (args.packages == "all") or (pkg_name.decode("ANSI") in args.packages):
                if args.verbose: print("Extracting file: " + pka_index[x][1]['filename'].decode("ANSI") + " into " + pkg_name.decode("ANSI") + "\\" + pka_index[x][1]['filename'].decode("ANSI")) 
                os.makedirs(pkg_name,exist_ok=True)
                f.seek(pka_index[x][2][0])
                with open(pkg_name.decode("ANSI") + "\\" + pka_index[x][1]['filename'].decode("ANSI"),"wb") as o:
                    o.write(decompress(f.read(pka_index[x][2][1]),uncompressed_size=pka_index[x][2][2]))
"@
#==============================================================================================================================================================================================
#  IMPORTED CODE: ADVANCED RICHTEXTBOX - ALLOWS SETTING TEXT ALIGNMENT (LEFT, RIGHT, CENTER, JUSTIFY)
#==============================================================================================================================================================================================
#  Normal rich textboxes do not allow justifying the text. This custom version does.
#  Source: https://github.com/ehsanrashid/Extensions/blob/master/System.Windows/Forms/AdvRichTextBox.cs
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
using System;
using System.Windows.Forms;
using System.Runtime.InteropServices;
public class AdvRichTextBox : RichTextBox
{
  public void BeginUpdate()
  {
    ++updating;
    if ( updating > 1 ) return;
    oldEventMask = SendMessage( new HandleRef( this, Handle ), EM_SETEVENTMASK, 0, 0 );
    SendMessage( new HandleRef( this, Handle ), WM_SETREDRAW, 0, 0 );
  }
  public void EndUpdate()
  {
    --updating;
    if ( updating > 0 ) return;
    SendMessage( new HandleRef( this, Handle ), WM_SETREDRAW, 1, 0 );
    SendMessage( new HandleRef( this, Handle ), EM_SETEVENTMASK, 0, oldEventMask );
  }
  public new TextAlign SelectionAlignment
  {
    get
    {
      PARAFORMAT fmt = new PARAFORMAT();
      fmt.cbSize = Marshal.SizeOf( fmt );
      SendMessage( new HandleRef( this, Handle ), EM_GETPARAFORMAT, SCF_SELECTION, ref fmt );
      if ( ( fmt.dwMask & PFM_ALIGNMENT ) == 0 )
        return TextAlign.Left;
        return ( TextAlign )fmt.wAlignment;
    }
    set
    {
      PARAFORMAT fmt = new PARAFORMAT();
      fmt.cbSize = Marshal.SizeOf( fmt );
      fmt.dwMask = PFM_ALIGNMENT;
      fmt.wAlignment = ( short )value;
      SendMessage( new HandleRef( this, Handle ), EM_SETPARAFORMAT, SCF_SELECTION, ref fmt );
    }
  }
  protected override void OnHandleCreated( EventArgs e )
  {
    base.OnHandleCreated( e );
    SendMessage( new HandleRef( this, Handle ), EM_SETTYPOGRAPHYOPTIONS, TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY );
  }
  private int updating = 0;
  private int oldEventMask = 0;
  private const int EM_SETEVENTMASK = 1073;
  private const int EM_GETPARAFORMAT = 1085;
  private const int EM_SETPARAFORMAT = 1095;
  private const int EM_SETTYPOGRAPHYOPTIONS = 1226;
  private const int WM_SETREDRAW = 11;
  private const int TO_ADVANCEDTYPOGRAPHY = 1;
  private const int PFM_ALIGNMENT = 8;
  private const int SCF_SELECTION = 1;
  [StructLayout( LayoutKind.Sequential )]
  private struct PARAFORMAT
  {
    public int cbSize;
    public uint dwMask;
    public short wNumbering;
    public short wReserved;
    public int dxStartIndent;
    public int dxRightIndent;
    public int dxOffset;
    public short wAlignment;
    public short cTabCount;
    [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
    public int[] rgxTabs;
    public int dySpaceBefore;
    public int dySpaceAfter;
    public int dyLineSpacing;
    public short sStyle;
    public byte bLineSpacingRule;
    public byte bOutlineLevel;
    public short wShadingWeight;
    public short wShadingStyle;
    public short wNumberingStart;
    public short wNumberingStyle;
    public short wNumberingTab;
    public short wBorderSpace;
    public short wBorderWidth;
    public short wBorders;
  }
  [DllImport("user32", CharSet = CharSet.Auto )]private static extern int SendMessage( HandleRef hWnd, int msg, int wParam, int lParam);
  [DllImport("user32", CharSet = CharSet.Auto )]private static extern int SendMessage( HandleRef hWnd, int msg, int wParam, ref PARAFORMAT lp);
}
public enum TextAlign { Left = 1, Right = 2, Center = 3, Justify = 4 }
"@
# Add the code as a type definition in C# language so we can make use of it.
$RefAssem = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
Add-Type -TypeDefinition $Source -ReferencedAssemblies $RefAssem -Language 'CSharp'
#==============================================================================================================================================================================================
#  IMPORTED CODE: TRANSPARENT LABEL - CREATES A LABEL WITH NO BACKGROUND COLOR
#==============================================================================================================================================================================================
#  This can be used in conjunction with the advanced rich textbox to make it so the textbox can not be clicked on by making it equal and size and overlapping it.
#  Source: https://stackoverflow.com/a/50334624/7544344
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
using System;
using System.Windows.Forms;
using System.Runtime.InteropServices;
public class TransparentLabel : Label
{
    public void Dummy() {  }
    public TransparentLabel()
    {
        this.SetStyle(ControlStyles.Opaque, true);
        this.SetStyle(ControlStyles.OptimizedDoubleBuffer, false);
    }
    protected override CreateParams CreateParams
    {
        get
        {
            CreateParams parms = base.CreateParams;
            parms.ExStyle |= 0x20;  // Turn on WS_EX_TRANSPARENT
            return parms;
        }
    }
}
"@
# Add the code as a type definition in C# language so we can make use of it.
$RefAssem = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
Add-Type -TypeDefinition $Source -ReferencedAssemblies $RefAssem -Language 'CSharp' | Out-Null
#==============================================================================================================================================================================================
# This is the last time these values are used so null them out.
$Source = $null
$RefAssem = $null
#==============================================================================================================================================================================================
#  DPI ADJUSTMENTS
#==============================================================================================================================================================================================
#  Adjusts a value to scale according to the current DPI. The "$DPIMultiplier" is a global variable calculated on init.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$Source = @"
using System;
using System.Runtime.InteropServices;
public class DPI
{
  [DllImport("user32.dll")]
  public static extern bool SetProcessDPIAware();
  public static void SetProcessAware()
  {
    SetProcessDPIAware();
  }
}
"@
# Add the code as a type definition in C# language so we can make use of it.
$RefAssem = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
Add-Type -TypeDefinition $Source -ReferencedAssemblies $RefAssem -Language 'CSharp' | Out-Null
#==============================================================================================================================================================================================
#  Adjusts a value to scale according to the current DPI. The "$DPIMultiplier" is a global variable calculated on init.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DPISize($Value, $Add=0, $AddX=0, $AddY=0, [switch]$Round=$false)
{
  # Immediately return the value if DPI scaling is disabled.
  if (!$HighDPIEnabled) { return $Value }

  # Get the variable type so we know what to do with it.
  $ValueType = $Value.GetType().ToString()

  # Shorten this massive blob of text with a variable.
  $RMode = [System.MidpointRounding]::AwayFromZero

  # If the value fed was a string, convert it to an integer.
  if ($ValueType -eq "System.String")
  {
    # If there is a period, try to parse it as an integer.
    if (($ValueType -like "*.*") -and ($Value -as [decimal] -is [decimal]))
    {
        $Value = [Convert]::ToDecimal($Value)
        $ValueType = "System.Decimal"
    }  
    # Try to parse it as an integer.
    elseif ($Value -as [int] -is [int])
    {
        $Value = [Convert]::ToInt32($Value)
        $ValueType = "System.Int32"
    }
  }
  # The type of variable will determine the calculation method.
  switch ($ValueType)
  {
    # 16-Bit Integer, Aliases: Int16
    'System.Int16'          { if (!$Round) { $Value = [int16][Math]::Truncate($Value * $DPIMultiplier) } 
                              else         { $Value = [int16][Math]::Round(($Value * $DPIMultiplier), $RMode) }
                              return       ( $Value + $Add + $AddX + $AddY ) }
    # 32-Bit Integer, Aliases: Int, Int32
    'System.Int32'          { if (!$Round) { $Value = [int][Math]::Truncate($Value * $DPIMultiplier) } 
                              else         { $Value = [int][Math]::Round(($Value * $DPIMultiplier), $RMode) }
                              return       ( $Value + $Add + $AddX + $AddY ) }
    # 64-Bit Integer, Aliases: Int64, Long
    'System.Int64'          { if (!$Round) { $Value = [int64][Math]::Truncate($Value * $DPIMultiplier) }
                              else         { $Value = [int64][Math]::Round(($Value * $DPIMultiplier), $RMode) }
                              return       ( $Value + $Add + $AddX + $AddY ) }
    # Single Float, Aliases: Single, Float
    'System.Single'         { if (!$Round) { $Value = [single][Math]::Truncate($Value * $DPIMultiplier) }
                              else         { $Value = [single][Math]::Round(($Value * $DPIMultiplier), $RMode) }
                              return       ( $Value + $Add + $AddX + $AddY ) }
    # Double Float
    'System.Double'         { if (!$Round) { $Value = [double]($Value * $DPIMultiplier) }
                              else         { $Value = [double][Math]::Round(($Value * $DPIMultiplier), $RMode) }
                              return       ( $Value + $Add + $AddX + $AddY ) }
    # Decimal
    'System.Decimal'        { if (!$Round) { $Value = [decimal]($Value * $DPIMultiplier) }
                              else         { $Value = [decimal][Math]::Round(($Value * $DPIMultiplier), $RMode) }
                              return       ( $Value + $Add + $AddX + $AddY ) }
    # Drawing Size (Width, Height)
    'System.Drawing.Size'   { if (!$Round) { $Value = New-Object Drawing.Size([int][Math]::Truncate($Value.Width * $DPIMultiplier), [int][Math]::Truncate($Value.Height * $DPIMultiplier)) }
                              else         { $Value = New-Object Drawing.Size([int][Math]::Round(($Value.Width * $DPIMultiplier), $RMode), [int][Math]::Round(($Value.Height * $DPIMultiplier), $RMode)) }
                              return       ( New-Object Drawing.Size(($Value.Width + $Add + $AddX), ($Value.Height + $Add + $AddY)) ) }
    # Drawing Point (X, Y)
    'System.Drawing.Point'  { if (!$Round) { $Value = New-Object Drawing.Point([int][Math]::Truncate($Value.X * $DPIMultiplier), [int][Math]::Truncate($Value.Y * $DPIMultiplier)) }
                              else         { $Value = New-Object Drawing.Point([int][Math]::Round(($Value.X * $DPIMultiplier), $RMode), [int][Math]::Round(($Value.Y * $DPIMultiplier), $RMode)) }
                              return       ( New-Object Drawing.Point(($Value.X + $Add + $AddX), ($Value.Y + $Add + $AddY)) ) }
  }
}
#==============================================================================================================================================================================================
#  PROGRAM PATHS FROM MASTER FOLDER
#==============================================================================================================================================================================================
#  If the user decided to use the "CTT-PS Programs" folder that I offer for download. This updates all programs on boot and when the master folder is updated. Because it only
#  cares about executable names, the folders do not have to have any specific naming scheme or hierarchy. Python is scanned for as well, but it is not included in the package in
#  an "installed" form but rather an installer. Whether or not the user decides to install it here is up to them. The registry scans are still performed if programs are not found.
#==============================================================================================================================================================================================
#  Updates all tool paths from a master path on boot if enabled, and when the master path is updated.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MasterToolsPathUpdate([switch]$UpdateGUI)
{
  # Make sure the box is checked and the path for the tools actually exists.
  if ((!$UseToolsMasterPath) -or (!(TestPath -LiteralPath $ToolsMasterPath))) { return }

  # Create an 2-dimensional array that stores the programs, their executables, and the textboxes that display them.
  $ProgramList = New-Object Collections.Generic.List[string[]]

  # The first string is the variable name, the second string is the executable name, and any strings beyond that are associated textboxes.
  $ProgramList.Add(@( '7ZipPath',       '7z.exe',                             'Options7ZipTextBox'        ))
  $ProgramList.Add(@( 'Compressonator', 'CompressonatorCLI.exe',              'OptionsCompressTextBox'    ))
  $ProgramList.Add(@( 'ECTPath',        'ect*.exe',                           'OptionsECTTextBox'         ))
  $ProgramList.Add(@( 'ESRGANBasePath', 'test.py',                            'OptionsESRGANTextBox'      ))
  $ProgramList.Add(@( 'ImageMagick',    'magick.exe',                         'OptionsImageMagickTextBox' ))
  $ProgramList.Add(@( 'IshiirukaTool',  'TextureEncoder.exe',                 'OptionsIshiirukaTextBox','MaterialIshiirukaTextBox' ))
  $ProgramList.Add(@( 'PhyrePKGTool',   'PKGToolCmd.dll',                     'OptionsPKGToolTextBox','ToCSExtractPKGTextBox','ToCSRepackPKGToolBox' ))
  $ProgramList.Add(@( 'MatMapGenPath',  'generate.py',                        'OptionsMatMapGenTextBox'   ))
  $ProgramList.Add(@( 'OptiPNGPath',    'optipng.exe',                        'OptionsOptiPNGTextBox'     ))
  $ProgramList.Add(@( 'OxiPNGPath',     'oxipng.exe',                         'OptionsOxiPNGTextBox'      ))
  $ProgramList.Add(@( 'PingoPath',      'pingo.exe',                          'OptionsPingoTextBox'       ))
  $ProgramList.Add(@( 'ScalerTestPath', 'ScalerTest*.exe',                    'OptionsScalerTestTextBox'  ))
  $ProgramList.Add(@( 'SFTGANBasePath', 'test_sftgan.py',                     'OptionsSFTGANTextBox'      ))
  $ProgramList.Add(@( 'TexConvTool',    'texconv.exe',                        'OptionsTexConvTextBox'     ))
  $ProgramList.Add(@( 'TexExtractTool', 'DolphinTextureExtraction*tool.exe',  'OptionsExtractTexTextBox','TexExtractProgramTextBox'  ))
  $ProgramList.Add(@( 'Waifu2xPath',    'waifu2x-*-*.exe',                    'OptionsWaifu2xTextBox'     ))
  $ProgramList.Add(@( 'Python',         'python.exe',                         'OptionsPythonTextBox'      ))

  # Get all the executables, python scripts, and the PKG Tool and store them in a list.
  $ExecutableList = EnumerateFiles -LiteralPath $ToolsMasterPath -Filter @('*.py','*.exe','*PKGToolCmd.dll*') -Recurse

  # Loop through the list of compatible programs.
  for ($i = 0 ; $i -lt $ProgramList.Count ; $i++)
  {
    # First lets see if the program path actually exists.
    $PathValue = Get-Variable -Name $ProgramList[$i][0] -ValueOnly

    # If we already have a valid path, no point in trying to forcefully update it.
    if (TestPath -LiteralPath $PathValue) { continue }

    # Search for the tool in the list of executables.
    foreach ($Executable in $ExecutableList)
    {
      # Get the executable as an item to get its name and other stuff.
      $ExecItem = Get-Item -LiteralPath $Executable

      # Check to see if we have a match.
      if ($ExecItem.Name -like $ProgramList[$i][1])
      {
        # How the value is stored depends on the extension.
        switch -wildcard ($ExecItem.Name)
        {
          # Currently only the python scripts need special attention, as SFTGAN is one folder deeper and needs to be cropped.
          '*.exe' { $NewPathValue = $Executable }
          '*.dll' { $NewPathValue = $Executable }
          '*.py'  { $NewPathValue = $ExecItem.DirectoryName.Replace('\pytorch_test','') }
        }
        # Update the path variable with the full path to the tool.
        Set-Variable -Name $ProgramList[$i][0] -Value $NewPathValue -Scope 'Global'

        # If the parameter to update the GUI is set.
        if ($UpdateGUI) 
        {
          # Now we need to loop through the textboxes that need updated.
          for ($x = 2 ; $x -lt $ProgramList[$i].Count ; $x++)
          {
            # Get the textbox using its name as a string.
            $TextBox = Get-Variable -Name $ProgramList[$i][$x] -ValueOnly

            # Update the text with the new value.
            $TextBox.Text = $NewPathValue
          }
        }
        # Some special cases for ESRGAN and SFTGAN that need a quick modification.
        if ($ExecItem.Name -eq 'test.py')        { RevertESRGANChanges }
        if ($ExecItem.Name -eq 'test_sftgan.py') { CleanSFTGANFolder   }

        # Use the first match instead of the last because why not.
        break
      }
    }
  }
  # If the GUI was created and needs updated.
  if ($UpdateGUI)
  {
    # If ImageMagick was updated, also enable the "Start" buttons.
    if (TestPath -LiteralPath $ImageMagick)
    {
      $MainStartButton.Enabled      = $true
      $MainProcessButton.Enabled    = $true
      $TexListStartButton.Enabled   = $true
      $TexListProcessButton.Enabled = $true
    }
    # Repopulate the DDS Tools and Upscale filter lists.
    RefreshDDSLists
    PopulateUpscaleFilterList
    PopulateSuperScalerModels
    PopulateOptimizerList
    Waifu2x_UpdateAppSpecificOptions
  }
}
#==============================================================================================================================================================================================
#  PROGRAM PATHS FROM REGISTRY: IMAGEMAGICK
#==============================================================================================================================================================================================
#  Gets the install path to ImageMagick by pulling it from the registry.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetImageMagickRegistryAttempt([string]$RegSearch)
{
  # Get the path to ImageMagick.
  $ImageMagickAttempt = ((Get-ItemProperty -LiteralPath $RegSearch -Name BinPath -ErrorAction SilentlyContinue).BinPath)

  # If the path was found, return the value.
  if ($ImageMagickAttempt -ne $null) { return $ImageMagickAttempt }

  # If fruit was not yielded, return an empty string.
  return $null
}
#==============================================================================================================================================================================================
#  Attempt to get ImageMagick from the registry. If that fails, check known locations.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetImageMagickInstallPath()
{
  # Just to avoid complications, start with an empty string.
  $global:ImageMagick = $null

  # A few places that ImageMagick may be installed to.
  $RegStrings = New-Object string[] 4
  $RegStrings[0] = 'HKLM:\Software\ImageMagick\Current\'
  $RegStrings[1] = 'HKLM:\Software\Wow6432Node\ImageMagick\Current\'
  $RegStrings[2] = 'HKCU:\Software\ImageMagick\Current\'
  $RegStrings[3] = 'HKCU:\Software\Wow6432Node\ImageMagick\Current\'

  # Loop through each registry entry.
  foreach ($RegEntry in $RegStrings)
  {
    # Get the registry attempt at getting ImageMagick.
    $ImageMagickTestPath = (GetImageMagickRegistryAttempt -RegSearch $RegEntry)

    # Test to see if the path was found.
    if ($ImageMagickTestPath -ne $null)
    {
      # Attempt to set the ImageMagick path via registry entry.
      $global:ImageMagick = $global:ImageMagickBase = $ImageMagickTestPath + '\magick.exe'
    }
    # The path was not found so it is null.
    else
    {
      # Also set the ImageMagick variables to null.
      $global:ImageMagick = $global:ImageMagickBase = $null
    }
    # ImageMagick was found, so lets get out of here.
    if ($ImageMagick -ne $null) { return }
  }
  # If the registry check failed, try some paths that ImageMagick may be installed to.
  $PathStrings = New-Object string[] 3
  $PathStrings[0] = (Get-WmiObject Win32_OperatingSystem).SystemDrive
  $PathStrings[1] = (Get-WmiObject Win32_OperatingSystem).SystemDrive + '\Program Files'
  $PathStrings[2] = (Get-WmiObject Win32_OperatingSystem).SystemDrive + '\Program Files (x86)'

  # Loop through each path in the array.
  foreach ($MagickSearch in Get-ChildItem -LiteralPath $PathStrings) 
  {
    # Only match results that look like "ImageMagick".
    if ($MagickSearch -like '*ImageMagick*')
    {
      # Now that we have an ImageMagick folder, loop through all files in that folder.
      foreach ($File in Get-ChildItem -LiteralPath $MagickSearch.FullName -Recurse -Force)
      {
        # If the main executable is found.
        if ($File.Name -eq 'magick.exe')
        {
          # Set the path to ImageMagick.
          $global:ImageMagick = $global:ImageMagickBase = $File.FullName

          # We have it so end the loop.
          break
        }
      }
    }
    # ImageMagick was found, so end the loop.
    if ($ImageMagick -ne $null) { break }
  }
}
#==============================================================================================================================================================================================
#  PROGRAM PATHS FROM REGISTRY: 7-ZIP
#==============================================================================================================================================================================================
#  Gets the install path to 7-Zip by pulling it from the registry.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Get7ZipRegistryAttempt([string]$RegSearch)
{
  # Get the path to 7-Zip.
  $7ZipAttempt = (Get-ItemProperty -LiteralPath $RegSearch -Name Path -ErrorAction SilentlyContinue).Path

  # If the path was found, return the value.
  if ($7ZipAttempt -ne $null) { return $7ZipAttempt }

  # If fruit was not yielded, return an empty string.
  return $null
}
#==============================================================================================================================================================================================
#  Attempt to get 7-Zip from the registry. If that fails, check known locations.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Get7ZipInstallPath()
{
  # Just to avoid complications, start with an empty string.
  $global:7ZipPath = $null

  # A few places that 7-Zip may be installed to.
  $RegStrings = New-Object string[] 4
  $RegStrings[0] = 'HKLM:\Software\7-Zip'
  $RegStrings[1] = 'HKCU:\Software\7-Zip'
  $RegStrings[2] = 'HKLM:\Software\Wow6432Node\7-Zip'
  $RegStrings[3] = 'HKCU:\Software\Wow6432Node\7-Zip'

  # Loop through each registry entry.
  foreach ($RegEntry in $RegStrings)
  {
    # Attempt to set the 7-Zip path via registry entry.
    $global:7ZipPath = $global:7ZipPathBase = (Get7ZipRegistryAttempt -RegSearch $RegEntry) + '7z.exe'

    # 7-Zip was found, so lets get out of here.
    if ($7ZipPath -ne $null) { return }
  }
  # If the registry check failed, try some paths that 7-Zip may be installed to.
  $PathStrings = New-Object string[] 3
  $PathStrings[0] = (Get-WmiObject Win32_OperatingSystem).SystemDrive
  $PathStrings[1] = (Get-WmiObject Win32_OperatingSystem).SystemDrive + '\Program Files'
  $PathStrings[2] = (Get-WmiObject Win32_OperatingSystem).SystemDrive + '\Program Files (x86)'

  # Loop through each path in the array.
  foreach ($7ZipSearch in Get-ChildItem -LiteralPath $PathStrings) 
  {
    # Only match results that look like "7ZipPath".
    if ($7ZipSearch -like '*7-Zip*')
    {
      # Now that we have an 7-Zip folder, loop through all files in that folder.
      foreach ($File in Get-ChildItem -LiteralPath $7ZipSearch.FullName -Recurse -Force)
      {
        # If the main executable is found.
        if ($File.Name -eq '7z.exe')
        {
          # Set the path to 7-Zip.
          $global:7ZipPath = $global:7ZipPathBase = $File.FullName

          # We have it so end the loop.
          break
        }
      }
    }
    # 7-Zip was found, so end the loop.
    if ($7ZipPath -ne $null) { break }
  }
}
#==============================================================================================================================================================================================
#  PROGRAM PATHS FROM REGISTRY: PYTHON
#==============================================================================================================================================================================================
#  Gets the install path to Python by pulling it from the registry.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPythonRegistryAttempt([string]$RegSearch)
{
  # Support python version 3.9.x.
  $MinimumVersion = 9
  $MaximumVersion = 9

  # Loop through all the supported versions.
  for ($i = $MinimumVersion ; $i -le $MaximumVersion ; $i++)
  {
    # Set up the registry entry path and the current version to search for.
    $RegPath = $RegSearch + $i.ToString() + '\InstallPath'

    # Get the path to Python.
    $PythonAttempt = (Get-ItemProperty -LiteralPath $RegPath -Name ExecutablePath -ErrorAction SilentlyContinue).ExecutablePath

    # If the path was found, end the loop.
    if ($PythonAttempt -ne $null) { return $PythonAttempt }
  }
  # If fruit was not yielded, return an empty string.
  return $null
}
#==============================================================================================================================================================================================
#  Attempt to get Python from the registry. If that fails, check known locations.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPythonInstallPath()
{
  # Just to avoid complications, start with an empty string.
  $global:Python = $null

  # A few places that Python may be installed to.
  $RegStrings = New-Object string[] 4
  $RegStrings[0] = 'HKCU:\Software\Wow6432Node\Python\PythonCore\3.'
  $RegStrings[1] = 'HKLM:\Software\Wow6432Node\Python\PythonCore\3.'
  $RegStrings[2] = 'HKCU:\Software\Python\PythonCore\3.'
  $RegStrings[3] = 'HKLM:\Software\Python\PythonCore\3.'

  # Loop through each registry entry.
  foreach ($RegEntry in $RegStrings)
  {
    # Attempt to set the Python path via registry entry.
    $global:Python = GetPythonRegistryAttempt -RegSearch $RegEntry

    # Python was found, so lets get out of here.
    if ($Python -ne $null) { return }
  }
  # Create a list to check for additional paths, and create a list for paths that actually exist.
  $PyAddList = New-Object Collections.Generic.List[string]
  $PyVarList = New-Object Collections.Generic.List[string]

  # Add all the paths to the temporary list.
  $PyAddList.Add([Environment]::GetFolderPath("LocalApplicationData") + '\Programs')
  $PyAddList.Add((Get-WmiObject Win32_OperatingSystem).SystemDrive)
  $PyAddList.Add((Get-WmiObject Win32_OperatingSystem).SystemDrive + '\Program Files')
  $PyAddList.Add((Get-WmiObject Win32_OperatingSystem).SystemDrive + '\Program Files (x86)')

  # Add the paths to the list if they exist.
  foreach ($PyEntry in $PyAddList) { if (TestPath -LiteralPath $PyEntry) { $PyVarList.Add($PyEntry) } }

  # Loop through each path in the array.
  foreach ($PySearch in Get-ChildItem -LiteralPath $PyVarList) 
  {
    # Only match results that look like "Python".
    if ($PySearch -like '*Python*')
    {
      # Now that we have a python folder, loop through all files in that folder.
      foreach ($File in Get-ChildItem -LiteralPath $PySearch.FullName -Recurse -Force)
      {
        # If the main executable is found.
        if ($File.Name -eq 'python.exe')
        {
          # Set the path to Python.
          $global:Python = $File.FullName

          # We have it so end the loop.
          break
        }
      }
    }
    # Python was found, so end the loop.
    if ($Python -ne $null) { break }
  }
}
#==============================================================================================================================================================================================
#  Types of global variables stored in the script's header.
#==============================================================================================================================================================================================
#  Boolean   : Finding a boolean is as simple as testing for the words "true" or "false".
#  Integer   : Integer is found by testing the value as an integer, and not containing a period (.) or hash tag (#).
#  Decimal   : Like integer test except allowing decimals, it is tested as a decimal and does not contain a hash tag (#).
#  Extension : Technically a string, but simpler to give it its own type. File extensions will always match the global constants defined at the top of this script.
#  String    : If everything else fails, the value is treated as a string. My checks are thorough enough that only strings should be found as strings.
#==============================================================================================================================================================================================
#  Gets a comprehensive list of all global variable names that are in the script's header or the "StoredOptions" file in appdata.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetScriptVarNames([string]$ImportPath)
{
  # Get this script's content. Start at index 1 by adding a dummy value to make things easier (can reference "line 1" directly).
  $Content = @('') + (Get-Content -LiteralPath $ImportPath)

  # Create a list of all the global variables this script currently has in the header.
  $VarList = New-Object Collections.Generic.List[string]

  # Loop through the beginning lines of the script.
  for ($i = 1 ; $i -lt $Content.Count ; $i++)
  {
    # A check to see if we're on a proper variable line. Do not count the script name variable.
    if (($Content[$i] -like '$global:*') -and ($Content[$i] -notlike '*ScriptName*'))
    {
      # Split the line to separate the variable from its value.
      $LineSplit = $Content[$i].Split('=', 2)

      # Now extract the variable name only from the rest of the junk.
      $VarName = $LineSplit[0].Replace('$global:', '').Trim()

      # Add the variable name to the list.
      $VarList.Add($VarName) | Out-Null
    }
    # Save some time if it didn't exist and we reached the end.
    if ($Content[$i] -like '*ENDGLOBALS*') { break }
  }
  # Return the list of variables that this script currently uses. 
  return $VarList
}
#==============================================================================================================================================================================================
#  Gets each line of global variables exactly how they are written in the script or the "StoredOptions" file in appdata.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetScriptVarValues([string]$ImportPath)
{
  # Get this script's content. Start at index 1 by adding a dummy value to make things easier (can reference "line 1" directly).
  $Content = @('') + (Get-Content -LiteralPath $ImportPath)

  # Create a list of all the global variables this script currently has in the header.
  $VarList = New-Object Collections.Generic.List[string]

  # Loop through the beginning lines of the script.
  for ($i = 1 ; $i -lt $Content.Count ; $i++)
  {
    # A check to see if we're on a proper variable line. Do not count the script name variable.
    if (($Content[$i] -like '$global:*') -and ($Content[$i] -notlike '*ScriptName*'))
    {
      # Add the variable name to the list.
      $VarList.Add($Content[$i]) | Out-Null
    }
    # If importing AppData options exit early since it won't have as many lines as the script.
    if ($i -eq $Content.Length) { break }

    # Save some time if it didn't exist and we reached the end.
    if ($Content[$i] -like '*ENDGLOBALS*') { break }
  }
  # Return the list of variables that this script currently uses. 
  return $VarList
}
#==============================================================================================================================================================================================
#  Gets the type of variable grabbed from the script's header by testing its value against certain conditions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetVariableDataType([string]$VarName, [string]$Value)
{
  # Boolean: If the line contains the word "true" or "false".
  if (($Value -like '*true*') -or ($Value -like '*false*')) { return 'Boolean' }

  # Integer: Test the value as an int, but don't allow periods because decimals can pass this check.
  elseif (($Value -ne '') -and ($Value -notlike '*#*') -and ($Value -notlike '*.*') -and ($Value -as [int] -is [int])) { return 'Integer' }

  # Decimal: Decimals are the same as integers, except we allow a period here.
  elseif (($Value -ne '') -and ($Value -notlike '*#*') -and ($Value -notlike '*,*') -and ($Value -as [decimal] -is [decimal])) { return 'Decimal' }

  # Pesky file extensions made me have to think for a bit.
  $ExtensionList = @('$PNG','$DDS','$JPG','$BMP','$TGA','$TIF','$TIFF','$WEBP','$NUL','$ZIP')

  # Extension: Not the cleanest way to get file extension, but effective. 
  foreach ($Extension in $ExtensionList) { if ($Value -like ('*' + $Extension + '*')) { return 'Extension' } }

  # String: If nothing else matches, then its most likely a string.
  return 'String'
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: STORE SINGLE GLOBAL VARIABLE
#==============================================================================================================================================================================================
#  Can store the value of a variable directly to the script immediately rather than wait for the script to update when closed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StoreSingleGlobalVariable([string]$VarName)
{
  # Grab all text from the script file. Start at index 1 rather than 0 to match the line number.
  $Content = @('') + (Get-Content -LiteralPath $ScriptPath)

  # Get what is currently written to the script.
  $ImportValue = ImportSingleGlobalVariable -VarName $VarName
  $ScriptValue = Get-Variable -Name $VarName -ValueOnly

  # If the values match up there is no point in writing it to the script.
  if ($ScriptValue -eq $ImportValue) { return }

  # Loop through the beginning lines of the script.
  for ($i = 1 ; $i -le $Content.Count ; $i++)
  {
    # See if the line contains the variable name.
    if ($Content[$i] -like ('*$global:' + $VarName + '*'))
    {
      # Split the line on the equals sign to separate the variable from its value.
      $LineSplit = $Content[$i].Split('=', 2)

      # Get the value of the variable.
      $LineValue = $LineSplit[1].Replace('"','').Trim()

      # Get the data type of the variable by analyzing the value.
      $DataType = GetVariableDataType -VarName $VarName -Value $LineValue

      # Use the data type to determine the type to cast the variable into.
      switch ($DataType)
      {
        # Assemble the new line to replace the line in the script.
        'Boolean'   { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= $' + $ScriptValue.ToString().ToLower() }
        'Integer'   { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= ' + $ScriptValue.ToString() }
        'Decimal'   { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= ' + (FormatDecimal -Value $ScriptValue.ToString()) }
        'Extension' { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= $' + (ExtensionToText -Extension $ScriptValue) }
        'String'    { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= "' + $ScriptValue + '"' }
      }
      # Make sure there is actually data to write before writing it.
      if ($NewLine -ne '') { $Content[$i] = $NewLine } 
    }
    # Save some time if it didn't exist and we reached the end.
    if ($Content[$i] -like '*ENDGLOBALS*') { break }
  }
  # Create a new array to hold the script, minus the line added at the beginning.
  $NewContent = New-Object object[] ($Content.Length - 1)

  # Copy the array but skip over the dummy line.
  [Array]::Copy($Content, 1, $NewContent, 0, ($Content.Length - 1))

  # Write the script to a temporary file before overwriting the main script.
  $TempOverwrite = $BaseFolder + '\CTT-Updating.temp'

  # Write the changes to the script file.
  Set-Content -LiteralPath $TempOverwrite -Value $NewContent

  # Now overwrite the main script with the newly created one.
  Move-Item -LiteralPath $TempOverwrite -Destination $ScriptPath -Force
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: STORE ALL GLOBAL VARIABLES
#==============================================================================================================================================================================================
#  Writes all variable values to INI file or the script's header when the script is closed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StoreAllGlobalVariables([string]$StorePath)
{
  # Grab all text from the script file. Start at index 1 rather than 0 to match the line number.
  $Content = @('') + (Get-Content -LiteralPath $StorePath)

  # The variable for "EnableStoring" must be updated no matter what. Search through a generic range that covers all versions of this script so far.
  for ($i = 1 ; $i -le $Content.Count ; $i++)
  {
    # See if the line contains the variable name.
    if ($Content[$i] -like '*EnableStoring*')
    {
      # Always store the the variable that says whether or not to store anything else.
      $Content[$i] = '$global:EnableStoring           = $' + $EnableStoring.ToString().ToLower()

      # The value was found so stop looping.
      break
    }
  } 
  # Only store everything else if "EnableStoring" is true.
  if ($EnableStoring)
  {
    # Update the master texture paths if the user wishes to store them.
    if ($StoreInputFolder)  { $global:SavedInputFolder  = $MasterInputPath } else { $global:SavedInputFolder = '' }
    if ($StoreOutputFolder) { $global:SavedOutputFolder = $MasterOutputPath.Replace('\~CTT_Generated','') } else { $global:SavedOutputFolder = '' }

    # Loop through the beginning lines of the script.
    for ($i = 1 ; $i -le $Content.Count ; $i++)
    {
      # A few checks to see if we're on a proper variable line.
      $SkipCheck = New-Object bool[] 4
      $SkipCheck[0] = ($Content[$i] -like '*ScriptName*')         # We don't want to save the script name since it's pointless.
      $SkipCheck[1] = ($Content[$i] -like '*TextureToolData*')    # This variable is only in the script header and not an external ini file.
      $SkipCheck[2] = ($Content[$i] -like '*DisableHighDPIMode*') # This variable is only in the script header and not an external ini file.
      $SkipCheck[3] = ($Content[$i] -notlike '$global:* = *')     # The line must contain a global variable.

      # If any of the above conditions pass then skip this line.
      if (TestBooleanArray -Or -Array $SkipCheck) { continue }

      # Split the line on the equals sign to separate the variable from its value.
      $LineSplit = $Content[$i].Split('=', 2)

      # Now extract the variable name only from the rest of the junk. Use trim to remove trailing white space.
      $VarName = $LineSplit[0].Replace('$global:', '').Trim()

      # Get the value of the variable.
      $LineValue = $LineSplit[1].Replace('"','').Trim()

      # Get the data type of the variable by analyzing the value.
      $DataType = GetVariableDataType -VarName $VarName -Value $LineValue

      # Get the value of the variable.
      $VarValue = Get-Variable -Name $VarName -ValueOnly

      # Debug: Show the variable name being written.
      DebugMessage -Message ($VarName + ' : Updated')

      # Use the data type to determine the type to cast the variable into.
      switch ($DataType)
      {
        # Assemble the new line to replace the line in the script.
        'Boolean'   { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= $' + $VarValue.ToString().ToLower() }
        'Integer'   { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= ' + $VarValue.ToString() }
        'Decimal'   { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= ' + (FormatDecimal -Value $VarValue.ToString()) }
        'Extension' { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= $' + (ExtensionToText -Extension $VarValue) }
        'String'    { $NewLine = '$global:' + (ExtendString -InputString $VarName -Length 24) + '= "' + $VarValue + '"' }
      }
      # Make sure there is actually data to write before writing it.
      if ($NewLine -ne '') { $Content[$i] = $NewLine }
      
      # Save some time if it didn't exist and we reached the end.
      if ($Content[$i] -like '*ENDGLOBALS*') { break }
    }
  }
  # Create a new array to hold the script, minus the line added at the beginning.
  $NewContent = New-Object object[] ($Content.Length - 1)

  # Copy the array but skip over the dummy line.
  [Array]::Copy($Content, 1, $NewContent, 0, ($Content.Length - 1))

  # Write the script to a temporary file before overwriting the main script.
  $TempOverwrite = $BaseFolder + '\CTT-Updating.temp'

  # Write the changes to the script file.
  Set-Content -LiteralPath $TempOverwrite -Value $NewContent

  # Now overwrite the main script with the newly created one.
  Move-Item -LiteralPath $TempOverwrite -Destination $StorePath -Force
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: IMPORT SINGLE GLOBAL VARIABLE
#==============================================================================================================================================================================================
#  A handy little function that can pull whatever value is currently written to the script or the external ini options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImportSingleGlobalVariable([string]$VarName)
{
  # Grab all text from the imported file. Start at index 1 so shit lines up.
  $Content = @('') + (Get-Content -LiteralPath $ScriptPath)

  # Loop through the beginning lines of the script.
  for ($i = 1 ; $i -lt $Content.Count ; $i++)
  {
    # Search for the "TextureToolData" variable.
    if ($Content[$i] -like ('*$global:' + $VarName + '*'))
    {
      # Split the line to separate the variable from its value.
      $LineSplit = $Content[$i].Split('=', 2)

      # Get the value of the variable.
      $LineValue = $LineSplit[1].Replace('"','').Trim()

      # Get the data type of the variable by analyzing the value.
      $DataType = GetVariableDataType -VarName $VarName -Value $LineValue

      # The output variable can be of multiple types. The value returned here depends on the variable retrieved.
      switch ($DataType)
      {
        # Use the data type assigned by the above function to determine the type to cast the variable into.
        'Boolean'   { $FetchedValue = [Convert]::ToBoolean($LineValue.Replace('$','')) }
        'Integer'   { $FetchedValue = [int]$LineValue }
        'Decimal'   { $FetchedValue = [decimal]$LineValue }
        'Extension' { $FetchedValue = '.' + $LineValue.Substring(1,3).ToLower() }
        'String'    { $FetchedValue = $LineValue }
      }
      # Return whatever the value was.
      return $FetchedValue
    }
    # Save some time if it didn't exist and we reached the end.
    if ($Content[$i] -like '*ENDGLOBALS*') { break }
  }
  # Default to null. 
  return $null
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: IMPORT ALL GLOBAL VARIABLES
#==============================================================================================================================================================================================
#  Master import function that imports values from another version of Custom Texture Tool PS.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImportAllGlobalVariables([string]$ImportPath, [switch]$SkipGUI)
{
  # If importing options from AppData on startup, the GUI has not been created yet.
  if (!$SkipGUI)
  {
    # Temporarily disable the GUI.
    $MainDialog.Enabled = $false
    $TexListDialog.Enabled = $false
    $OptionsDialog.Enabled = $false

    # Store the texture list mode. If it changed after importing, the GUI will need to be updated.
    $OldTextureListMode = $TextureListMode
  }
  # Grab all text from the imported file. Start at index 1 so shit lines up.
  $Content = @('') + (Get-Content -LiteralPath $ImportPath)

  # Get a list of all variables the script currently uses.
  $CTTPSVarList = GetScriptVarNames -ImportPath $ScriptPath

  # Loop through the beginning lines of the script.
  for ($i = 1 ; $i -lt $Content.Count ; $i++)
  {
    # A few checks to see if we're on a proper variable line.
    $SkipCheck = New-Object bool[] 2
    $SkipCheck[0] = ($Content[$i] -like '*ScriptName*')   # We don't want to save the script name since it's pointless.
    $SkipCheck[1] = ($Content[$i] -notlike '$global:*')   # The line must contain a global variable.

    # If any of the above conditions pass then skip this line.
    if (TestBooleanArray -Or -Array $SkipCheck) { continue }

    # Split the line to separate the variable from its value.
    $LineSplit = $Content[$i].Split('=', 2)

    # Now extract the variable name only from the rest of the junk.
    $VarName = $LineSplit[0].Replace('$global:', '').Trim()

    # Many old variables no longer exist. Only work with variable names that are still in the script.
    if ($CTTPSVarList -contains $VarName)
    {
      # Get the value of the variable.
      $LineValue = $LineSplit[1].Replace('"','').Trim()

      # Get the data type of the variable by analyzing the value.
      $DataType = GetVariableDataType -VarName $VarName -Value $LineValue

      # The output variable can be of multiple types.
      switch ($DataType)
      {
        # Use the data type assigned by the above function to determine the type to cast the variable into.
        'Boolean'   { $VarValue = [Convert]::ToBoolean($LineValue.Replace('$','')) }
        'Integer'   { $VarValue = [int]$LineValue }
        'Decimal'   { $VarValue = [decimal]$LineValue }
        'Extension' { $VarValue = '.' + $LineValue.Substring(1,3).ToLower() }
        'String'    { $VarValue = $LineValue }
      }
      # Set the variable name to the imported value.
      Set-Variable -Name $VarName -Value $VarValue -Scope 'Global'
    }
    # If importing AppData options exit early since it won't have as many lines as the script.
    if ($i -eq $Content.Length) { break }

    # Save some time if it didn't exist and we reached the end.
    if ($Content[$i] -like '*ENDGLOBALS*') { break }
  }
  # If importing options from AppData on startup, the GUI has not been created yet.
  if (!$SkipGUI)
  {
    # Update everything on the GUI if not importing from AppData on startup.
    RefreshGUI

    # Check to see if the texture list mode has changed.
    if ($OldTextureListMode -ne $TextureListMode)
    {
      # If it has, swap the texture list mode.
      TexList_ToggleVisibility -TexListMode $TextureListMode
    }
    # Show a confirmation dialog after the operation has finished.
    $Title   = 'CTT-PS Import Options'
    $Message = 'All options have been successfully imported!'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 36) -OffsetY (DPISize 18) -Message $Message 

    # Enable the dialogs.
    $MainDialog.Enabled = $true
    $TexListDialog.Enabled = $true
    $OptionsDialog.Enabled = $true
  }
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: SYNC APPDATA VARIABLES WITH SCRIPT VARIABLES
#==============================================================================================================================================================================================
#  Gets a list of all options from the script and imports them into the external ini file. Also prunes options that no longer exist from the ini file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SyncAppDataOptions([string]$ImportFrom, [string]$CopyInto)
{
  # Get a list of the variable names from the script, and get a list of the full variable lines.
  $ImportNameList = GetScriptVarNames -ImportPath $ImportFrom
  $ImportFullList = GetScriptVarValues -ImportPath $ImportFrom

  # If the external list does not exist. 
  if (!(TestPath -LiteralPath $CopyInto))
  {
    # Create the external options by copying the script's global variable header.
    Set-Content -LiteralPath $CopyInto -Value $ImportFullList

    # Nothing more needs to be done so exit now.
    return
  }
  # Create an empty array to store the updated list.
  $NewVarList = New-Object Collections.Generic.List[string]
  
  # Get the names of the variables from the external options file.
  $CopyToNameList = GetScriptVarNames -ImportPath $CopyInto
  $CopyToFullList = GetScriptVarValues -ImportPath $CopyInto

  # Loop through all variable names currently in the script header.
  for ($i = 0 ; $i -lt $ImportNameList.Length ; $i++)
  {
    # Do not sync these options as they do not belong in the external ini.
    $SkipCheck = New-Object bool[] 2
    $SkipCheck[0] = ($ImportNameList[$i] -eq 'TextureToolData')
    $SkipCheck[1] = ($ImportNameList[$i] -eq 'DisableHighDPIMode')

    # If any of the above conditions pass then skip this line.
    if (TestBooleanArray -Or -Array $SkipCheck) { continue }

    # Make sure the AppData options contains the current variable.
    if ($CopyToNameList -contains $ImportNameList[$i])
    {
      # If it does, we need to find where it is in the file since it may not line up with the script's position.
      for ($x = 0 ; $x -lt $CopyToNameList.Length ; $x++)
      {
        # Search for the matching variable name in the list.
        if ($CopyToNameList[$x] -eq $ImportNameList[$i])
        {
          # The length of the name and full list should match so add the current value from the full list.
          $NewVarList.Add($CopyToFullList[$x])

          # Since it was found, end the loop to save time.
          break
        }
      }
    }
    # It does not contain the current variable so add it using the script's var and value.
    else
    {
      # The length of the name and full list should match so add the current value from the full list.
      $NewVarList.Add($ImportFullList[$i])
    }
  }
  # Create the external options by copying the script's global variable header.
  Set-Content -LiteralPath $CopyInto -Value $NewVarList
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: UPDATE ALL GUI VALUES
#==============================================================================================================================================================================================
#  Update all GUI check boxes, combo boxes, text boxes, etc. on the GUI with the current values stored in memory. This is done any time
#  all options are updated at once: either importing options from another CTT-PS, or restoring the default values to all options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RefreshGUI()
{
  # To get the columns back to normal size, disable the event that stores their sizes.
  $BlockColumnResize = $true

  # Main: CTT-PS Options
  $MainCTTPSCombo.SelectedItem          = $CTTPSSelectedMode
  $MainTexListCombo.SelectedItem        = $TextureListMode
  $TexListAScrollCheck.Checked          = $TexListAutoScroll
  $TexListStoreSizeCheck.Checked        = $StoreTexListSizes
  $TexListDialog.Size                   = New-Object Drawing.Size($TexListWidth, $TexListHeight)
  $TexListCatalog.Columns[0].Width      = $TexListColumnSizeA
  $TexListCatalog.Columns[1].Width      = $TexListColumnSizeB
  $TexListCatalog.Columns[2].Width      = $TexListColumnSizeC
  $TexListCatalog.Columns[3].Width      = $TexListColumnSizeD
  $TexListCatalog.Columns[4].Width      = $TexListColumnSizeE
  $TexListCatalog.Columns[5].Width      = $TexListColumnSizeF
  $TexListCatalog.Columns[6].Width      = $TexListColumnSizeG
  $TexListCatalog.Columns[7].Width      = $TexListColumnSizeH
  $TexListCatalog.Columns[8].Width      = $TexListColumnSizeI

  # Now that they have been restored disable this variable.
  $BlockColumnResize = $false

  # Main: Input/Output Paths
  $MainStoreInput.Checked               = $StoreInputFolder
  $MainStoreOutput.Checked              = $StoreOutputFolder

  # Main: DDS Texture Options
  $MainDDSToolCombo.SelectedItem        = $DDSCreatorTool
  $MainDDSFormat.SelectedItem           = $DDSBlkCompress
  $MainDDSFlagRemoval.SelectedItem      = $DDSFlagRemoval
  $MainDDSFallback.SelectedItem         = $DDSFallbackCompress
  $MainDDSDX10Check.Checked             = $DDSForceDX10Header

  # Main: DDS Tool - Compressonator Config
  $CompressGPUEncodeCombo.SelectedItem  = $CompressEncodeWith
  $CompressGPUDecodeCombo.SelectedItem  = $CompressDecodeWith
  $CompressSwizzleCheck.Checked         = $CompressSwizzle
  $CompressNumThreadsNBox.Value         = $CompressNumThreads
  $CompressBC7QualityCombo.SelectedItem = $CompressBC7Quality
  $CompressPerformCheck.Checked         = $CompressNoPerformance

  # Main: DDS Tool - TexConv Config
  $TexConvCompSpeedCombo.SelectedItem   = $TexConvCompSpeed
  $TexConvAlphaCombo.SelectedItem       = $TexConvAlphaType
  $TexConvFlipCombo.SelectedItem        = $TexConvFlipImage
  $TexConvSRGBCheck.Checked             = $TexConvForceSRGB
  $TexConvDisableGPUCheck.Checked       = $TexConvDisableGPU

  # Main: DDS Tool - ImageMagick Config
  $ImageMagickAlphaCheck.Checked        = $MagickAlphaWeight

  # Main: PNG Texture Options
  $MainPNGFlipResult.Checked            = $PNGFlipResult
  $MainPNGPaletted.Checked              = $PNGPalettedImage
  $MainPNGBC7Converter.SelectedItem     = $PNGBC7Converter
  $MainPNGAlphaPixels.Checked           = $PNGSaveAlphaPixels

  # Main: JPG Texture Options
  $MainJPGQualityNumBox.Value           = $JPGQualityValue

  # Main: BMP Texture Options
  $MainBMPLimitColor.Checked            = $BMPLimitColors
  $MainBMPVersionNumBox.Value           = $BMPBitmapVersion

  # Main: TIFF Texture Options
  $MainNoResizeTIFF.Checked             = $TIFFNoResizeMipmap

  # Main: Mipmap Options
  $MainDisableMipmaps.Checked           = $DisableMipmaps
  $MainForceNewMipmaps.Checked          = $ForceNewMipmaps
  $MainTopLevelMipmap.Checked           = $MipmapTopLevelBase
  $MainMaxMipmapToggle.Checked          = $MaxMipmapEnabled
  $MainMaxMipmapNumBox.Value            = $MaxMipmapLevels
  $MainExternalDDSMipmap.Checked        = $ExternalDDSMipmaps
  $MainForceMipmapsAll.Checked          = $ForceCreateMipmaps

  # Main: Process Selected
  $ProcessFastModeCheck.Checked         = $ProcessFastMode
  $ProcessOverwriteCheck.Checked        = $ProcessOverwrite
  $ProcessKeepOriginalCheck.Checked     = $ProcessKeepOriginal
  $ProcessOverrideCheck.Checked         = $ProcessOverride
  $ProcessOverrideTextBox.Text          = $ProcessOverridePath

  # Operation: Create Texture Size Database
  $DatabaseOverwriteCheck.Checked       = $DatabaseOverwrite
  $DatabaseMissingCheck.Checked         = $DatabaseMissing
  $DatabaseMissCopyCheck.Checked        = $DatabaseMissCopy
  $DatabaseNameTextBox.Text             = $DatabaseName
  $DatabaseLocTextBox.Text              = $DatabasePath

  # Operation: Scan Dolphin/Database Textures For Issues
  $ScanRepairCheck.Checked              = $RepairTextures
  $ScanCopyBadTextures.Checked          = $CopyBadTextures
  $ScanHideOKTextures.Checked           = $HideOKTextures
  $ScanIgnoreDuplicates.Checked         = $IgnoreDuplicates
  $ScanAllowNotHD.Checked               = $AllowNotHD
  $ScanScaleFixNumBox.Value             = $ScaleThreshold
  $ScanAspectFixNumBox.Value            = $AspectThreshold
  $ScanUserScaleValues.Checked          = $UserScaleValues
  $ScanAcceptedScalesTextBox.Text       = $AcceptedScales

  # Operation: Convert Textures to Another Format
  $ConvertFormatCombo.SelectedItem      = ExtensionToText -Extension $ConvertFormat
  $ConvertCopyNonTex.Checked            = $CopyNonTextures
  $ConvertEnableSharpen                 = $EnableSharpen
  $ConvertAutoRepair.Checked            = $ConvertRepair
  $ConvertScaleFixNumBox.Value          = $ScaleThreshold
  $ConvertIconSizeTextBox.Text          = $ConvertIconSizes

  # Operation: Rescale Textures With New Scaling Factor
  $RescaleFactorNumBox.Value            = $RescaleFactor
  $RescaleFormatCombo.SelectedItem      = ExtensionToText -Extension $RescaleFormat
  $RescaleCopyNonTex.Checked            = $CopyNonTextures
  $RescaleEnableSharpen                 = $EnableSharpen
  $RescaleCondCombo.SelectedItem        = $RescaleScaling
  $RescaleDolphinDimCheck.Checked       = $RescaleDolphinReal
  $RescaleManualCheck.Checked           = $ManualRescale

  # Operation: Resize Textures With Specific Dimensions
  $ResizeWidthNumBox.Value              = $ResizeWidth
  $ResizeHeightNumBox.Value             = $ResizeHeight
  $ResizeFormatCombo.SelectedItem       = ExtensionToText -Extension $ResizeFormat
  $ResizeCopyNonTex.Checked             = $CopyNonTextures
  $ResizeEnableSharpen                  = $EnableSharpen

  # Operation: Add Identifying Watermark to All Textures
  $WatermarkLengthNumBox.Value          = $WM_Length
  $WatermarkFontSizeNumBox.Value        = $WM_FontSize
  $WatermarkFontColor.BackColor         = $WM_FontColor
  $WatermarkBGColor.BackColor           = $WM_BGColor
  $WatermarkFontCombo.SelectedItem      = $WM_FontFace

  # Operation: Create Materials With Material Map Generator
  $MaterialTileSizeCombo.SelectedItem   = $MatMapTileSize
  $MaterialEdgePixelCombo.SelectedItem  = $MatMapEdgePixels
  $MaterialDisableGPUCheck.Checked      = $MatMapDisableGPU
  $MaterialCreateMapsCheck.Checked      = $MatMapCreateMaps
  $MaterialsFormatCombo.SelectedItem    = ExtensionToText -Extension $IshiirukaFormat

  # Operation: Create Material Maps With Ishiiruka Tool
  $MaterialFormatCombo.SelectedItem     = ExtensionToText -Extension $IshiirukaFormat
  $MaterialInPlaceCheck.Checked         = $InPlaceMaterial
  $MaterialIshiirukaTextBox.Text        = $IshiirukaTool

  # Operation: Optimize PNG Textures With Optimizer Program
  $OptimizeTestsNumBox.Value            = $OptimizeTests
  $OptimizeThreadsNumBox.Value          = $OptimizeThreads
  $OptimizerInPlaceCheck.Checked        = $OptimizeInPlace
  $OptimizerStripMetaDataCheck.Checked  = $OptimizeStripMeta
  $OptimizeStrictLosslessCheck.Checked  = $OptimizeLossless
  $OptimizeReuseColorsCheck.Checked     = $OptimizeReuseColors
  $OptimizerDolphinFixCheck.Checked     = $OptiDolphinCheck

  # Operation: Apply Upscaling Filter to All Textures
  $UpscaleSelection.SelectedItem        = $FilterSelected
  $UpscaleFactorNumBox.Value            = $UpscaleFactor
  $UpscaleSeamlessCombo.SelectedItem    = $SeamlessMethod
  $UpscaleSeamlessPixels.Value          = $SeamlessPixels
  $UpscaleFormatCombo.SelectedItem      = ExtensionToText -Extension $UpscaleFormat
  $UpscaleFactorTarget.Checked          = $UpscaleAsTarget

  # Options: Apply Upscaling Filter - Waifu2x Options
  $OptionsW2XModelCombo.SelectedItem    = Waifu2x_FlipModelName -ModelName $Waifu2xModel
  $OptionsW2XModeCombo.SelectedItem     = Waifu2x_FlipConvertModeName -ModeName $Waifu2xCMode
  $OptionsW2XNoiseNumBox.Value          = $Waifu2xNoise
  $OptionsW2XDisableGPU.Checked         = $Waifu2xDisableGPU
  $OptionsW2XOpenCLBox.Checked          = $Waifu2xOpenCL

  # Options: Apply Upscaling Filter - ESRGAN/SFTGAN Options
  $OptionsESRGANModelCombo.SelectedItem = $ESRGANModel
  $OptionsSFTGANModelCombo.SelectedItem = $SFTGANModel
  $OptionsESRGANNoGPUCheck.Checked      = $ESRGANDisableGPU
  $OptionsSSAlpha.Checked               = $ESRGANSaveAlpha
  $OptionsSSSegments.Checked            = $ESRGANUseSegments
  $OptionsSSMultiplier.SelectedItem     = $ESRGANMaxSegment
  $OptionsSSPixels.Value                = $ESRGANExtraPixels
  $OptionsSSBorder.SelectedItem         = $ESRGANPixelBuffer

  # Operation: Generate New Mipmaps For Dolphin Textures
  $GenNewMipmapsCheck.Checked           = $InPlaceMipmaps

  # Operation: Remove Invalid Mipmaps From Dolphin Textures
  $InvalidHideOKTextures.Checked        = $HideOKTextures

  # Operation: Extract Internal Mipmaps
  $ExtractDDSMipmapCheck.Checked        = $InPlaceExtractDDS

  # Operation: Remove Alpha Channel From Opaque Textures
  $RemoveAlphaHideOK.Checked            = $HideOKTextures

  # Operation: Combine Multiple Textures
  $CombineZeldaButton.Image             = GetZeldaTriforceButton
  $CombineRowsNumBox.Value              = $TextureRows
  $CombineColumnsNumBox.Value           = $TextureCols
  $CombineCTTTexCheck.Checked           = $CTTIncludeTextures
  $CombineRatioXNumBox.Value            = $CombineButtonSizeX
  $CombineRatioYNumBox.Value            = $CombineButtonSizeY
  $CombineNameTextBox.Text              = $CombinedName
  $CombineAutoArrangeCheckBox.Checked   = $CombineAutoArrange
  $CombineZeldaTopLeftCheckBox.Checked  = $UserSpecifyTopLeft
  $CombineZeldaOverlapCheckBox.Checked  = $CombineOverlapEnable
  $CombineOverlapNumBox.Value           = $CombineOverlapValue
  $CombinePixelCropCheckBox.Checked     = $CombinePixelCrop
  $CombinePixelCropTNumBox.Value        = $CombinePixelCropT
  $CombinePixelCropBNumBox.Value        = $CombinePixelCropB
  $CombinePixelCropLNumBox.Value        = $CombinePixelCropL
  $CombinePixelCropRNumBox.Value        = $CombinePixelCropR

  # Operation: Split Combined Multi-Texture
  $SplitZeldaButton.Image               = GetZeldaTriforceButton
  $SplitTextureRowsNumBox.Value         = $TextureRows
  $SplitTextureColsNumBox.Value         = $TextureCols
  $SplitBatchCheck.Checked              = $SplitBatchImages
  $SplitBoundariesCheckBox.Checked      = $SplitDefineBoundary
  $SplitBoundariesWidthNumBox.Value     = $SplitBoundaryWidth
  $SplitBoundariesHeightNumBox.Value    = $SplitBoundaryHeight
  $SplitZeldaOverlapCheckBox.Checked    = $SplitOverlapEnable
  $SplitOverlapNumBox.Value             = $SplitPixelOverlap
  $SplitZeldaResCheckBox.Checked        = $SplitZeldaRestore
  $SplitZeldaRestoreT.Value             = $SplitPixelRestoreT
  $SplitZeldaRestoreB.Value             = $SplitPixelRestoreB
  $SplitZeldaRestoreL.Value             = $SplitPixelRestoreL
  $SplitZeldaRestoreR.Value             = $SplitPixelRestoreR

  # Operation: Add/Remove Arbitrary Mipmap Suffix
  $ArbitraryMipmapRadioAdd.Checked      = ($ArbSuffixChoice -eq 'Add Suffix')
  $ArbitraryMipmapRadioRem.Checked      = ($ArbSuffixChoice -eq 'Remove Suffix')

  # Operation: PNG Alpha Pixel Manipulation
  $AlphaPixelCombo.SelectedIndex        = $AlphaPixelMode
  $AlphaPixelInPlaceCheck.Checked       = $InPlaceAlphaPixel
  $CustomAlphaSearchOn.Checked          = ($AlphaSearch -eq 'No Color Data')
  $CustomAlphaSearchOff.Checked         = ($AlphaSearch -eq 'Allow Color Data')
  $CustomThresholdNumBox.Value          = $AlphaThreshold
  $CustomAlphaRedCheck.Checked          = $BAlphaRed
  $CustomAlphaRedNumBox.Value           = $CAlphaRed
  $CustomAlphaGrnCheck.Checked          = $BAlphaGrn
  $CustomAlphaGrnNumBox.Value           = $CAlphaGrn
  $CustomAlphaBluCheck.Checked          = $BAlphaBlu
  $CustomAlphaBluNumBox.Value           = $CAlphaBlu
  $CustomAlphaAlpCheck.Checked          = $BAlphaAlp
  $CustomAlphaAlpNumBox.Value           = $CAlphaAlp

  # Operation: Separate/Combine Texture RGBA Channels
  $RGBAChannelsCombo.SelectedItem       = $RGBAChannelChoice
  $RGBABackgroundCombo.SelectedItem     = $RGBABackGroundChoice
  $RGBAKeepAlphaCheck.Checked           = $RGBAUtilizeAlpha

  # Operation: Dolphin Resource Pack Manager
  $ResOpCombo.SelectedItem              = $ResourceOperation
  $ResCompressPack.Checked              = $ResourceCompress

  # Operation: Various "Phyre Mode" Options
  $ToCSExtractPKACombo.SelectedItem     = $PhyrePKAType
  $ToCSExtractPKGTextBox.Text           = $PhyrePKGTool
  $ToCSCreateSwizzle.Checked            = $PhyreSwizzle
  $ToCSCreatePrevPath.Checked           = $PhyrePreviousPath
  $ToCSCreatePhyreScan.Checked          = $PhyreOnlyScan
  $ToCSConvertUnswizzle.Checked         = $PhyreSwizzle
  $ToCSConvertHeader.Checked            = $PhyreSaveHeader
  $ToCSConvertDDSMipmaps.Checked        = $PhyreSaveMipmaps
  $ToCSConvertPrevPath.Checked          = $PhyrePreviousPath
  $ToCSDDXT1AlphaDXT5.Checked           = $PhyreDXT1AToDXT5
  $ToCSConvertPhyreScan.Checked         = $PhyreOnlyScan
  $ToCSCreateFormatCombo.SelectedItem   = $PhyreImageFormat
  $ToCSCreateUpdateXML.Checked          = $PhyreXMLUpdate
  $ToCSRepackPrevPath.Checked           = $PhyrePreviousPath

  # Operation: Convert Phyre Extension Setting
  switch ($PhyreExtension)
  {
    '.nul'   { $ToCSCreateExtension.SelectedItem = 'Source' }
    default  { $ToCSCreateExtension.SelectedItem = ExtensionToText -Extension $PhyreExtension }
  }
  # OPeration: Various "Metroid" Mode Options
  $MetroidHighQualityCheckBox.Checked   = $MetroidHighQuality

  # Operation: Extract Textures With TextureExtraction Tool
  $TexExtractProgramTextBox.Text        = $TexExtractTool
  $TexExtractForceCheckBox.Checked      = $ExtractForceUnknown
  $TexExtractRawCheckBox.Checked        = $ExtractRawImages
  $TexExtractRawCheckBox.Checked        = $ExtractCombineRGBA
  $TexExtractCleanCombo.SelectedItem    = $ExtractCleanType
  $TexExtractCleanNumBox.Value          = $ExtractCleanCount
  $TexExtractThreadCheckBox.Checked     = $ExtractTasksEnable
  $TexExtractThreadNumBox.Value         = $ExtractTasksCount
  $TexExtractMipmapCheck.Checked        = $ExtractTexMipmaps
  $TexExtractDolphinCheck.Checked       = $ExtractDolphinMipmap
  $TexExtractArbMipCheck.Checked        = $ExtractArbMipmap

  # Options: Preferences
  $OptionsUpdateRateNumBox.Value        = $DialogUpdateRate
  $OptionsOpSkipExists.Checked          = $AlwaysOverwrite
  $OptionsRecursion.Checked             = $DirectoryRecursion
  $OptionsAutoCleanOutput.Checked       = $AutoCleanOutput
  $OptionsEnableStoring.Checked         = $EnableStoring
  $OptionsAppDataStoring.Checked        = $StoreToAppData
  $OptionsDisableLogFile.Checked        = $CreateLogFile
  $OptionsTopMostDialog.Checked         = $DisableTopMost
  $OptionsShowQuickHelp.Checked         = $ShowQuickHelpIcon
  $OptionsGlobalMinimize.Checked        = $MinimizeSingle
  $OptionsVisualStyleCheckBox.Checked   = $EnableVisualStyle
  $OptionsWebLinkCheckBox.Checked       = $ShowWebLinkIcons
  $OptionsClearTextCheckBox.Checked     = $ClickClearText
  $OptionsShutdownPCCheckBox.Checked    = $AutoShutdownPC

  # Options: Exclusions
  $OptionsExPNGCheck.Checked            = $ExcludePNG
  $OptionsExDDSCheck.Checked            = $ExcludeDDS
  $OptionsExJPGCheck.Checked            = $ExcludeJPG
  $OptionsExTGACheck.Checked            = $ExcludeTGA
  $OptionsExTIFCheck.Checked            = $ExcludeTIF
  $OptionsExIsMipmap.Checked            = $ExcludeIsMipmap
  $OptionsExHasMipmap.Checked           = $ExcludeHasMipmap
  $OptionsExNoAlpha.Checked             = $ExcludeNoAlpha
  $OptionsExHasAlpha.Checked            = $ExcludeHasAlpha
  $OptionsExTransCombo.SelectedItem     = $ExcludeTransparency
  $OptionsExHasMaterials.Checked        = $ExcludeHasMats
  $OptionsExHasMatMaps.Checked          = $ExcludeHasMatMaps
  $OptionsExMinWidth.Value              = $ExcludeMinWidth
  $OptionsExMinHeight.Value             = $ExcludeMinHeight
  $OptionsExMaxWidth.Value              = $ExcludeMaxWidth
  $OptionsExMaxHeight.Value             = $ExcludeMaxHeight

  # Options: Debug
  $OptionsPSConsoleCheckBox.Checked     = $EnableThePSConsole
  $OptionsAutoConsoleCheckBox.Checked   = $DisableAutoConsole
  $OptionsForceBC7CheckBox.Checked      = $ForceShowBC7Format
  $OptionsDDSHeaderCheckBox.Checked     = $UseStockDDSHeaders
  $OptionsDumpIconsCheckBox.Checked     = $DumpCTTPSIconAsPNG
  $OptionsDPIScaleCheckBox.Checked      = $DisableHighDPIMode
  $OptionsNoSaveCheckBox.Checked        = $CloseNoSaveButtons
  $OptionsSplitCombLimitNumBox.Value    = $SplitCombineLimits

  # Options: Tool Paths
  $OptionsMasterToolsCheckBox.Checked   = $UseToolsMasterPath
  $OptionsMasterToolsTextBox.Text       = $ToolsMasterPath
  $OptionsImageMagickTextBox.Text       = $ImageMagick
  $OptionsTexConvTextBox.Text           = $TexConvTool
  $OptionsCompressTextBox.Text          = $Compressonator
  $OptionsIshiirukaTextBox.Text         = $IshiirukaTool
  $OptionsMatMapGenTextBox.Text         = $MatMapGenPath
  $OptionsExtractTexTextBox.Text        = $TexExtractTool
  $OptionsOptiPNGTextBox.Text           = $OptiPNGPath
  $OptionsOxiPNGTextBox.Text            = $OxiPNGPath
  $OptionsPingoTextBox.Text             = $PingoPath
  $OptionsECTTextBox.Text               = $ECTPath
  $OptionsScalerTestTextBox.Text        = $ScalerTestPath
  $OptionsWaifu2xTextBox.Text           = $Waifu2xPath
  $Options7ZipTextBox.Text              = $7ZipPath
  $OptionsPKGToolTextBox.Text           = $PhyrePKGTool
  $OptionsESRGANTextBox.Text            = $ESRGANBasePath
  $OptionsSFTGANTextBox.Text            = $SFTGANBasePath

  # Populate the "DDS Tool" and "DDS Format" lists.
  RefreshDDSLists

  # Populate the list of Optimizer tools.
  PopulateOptimizerList

  # Certain upscale filters may be unlocked now, so repopulate the list.
  PopulateUpscaleFilterList

  # Populate the models lists for ESRGAN and SFTGAN.
  PopulateSuperScalerModels
}
#==============================================================================================================================================================================================
#  UPDATE SCRIPT: RESTORE DEFAULTS
#==============================================================================================================================================================================================
#  Restores the script to factory defaults. Honestly, every configurable program in existence should have this option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RestoreDefaultOptions()
{
  # Set the values for the Yes/No dialog.
  $Title   = 'CTT-PS Restore Defaults'
  $Message = 'Are you sure you wish to restore all default values?'

  # Display a Yes/No dialog to verify resetting to defaults.
  if (ShowYesNoDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 22) -OffsetY (DPISize 18) -Message $Message)
  {
    # Main: CTT-PS Options
    $global:CTTPSSelectedMode       = "Dolphin Mode"
    $global:TexListAutoScroll       = $true
    $global:StoreTexListSizes       = $false
    $global:TexListWidth            = (DPISize 1172)
    $global:TexListHeight           = (DPISize 600)
    $global:TexListColumnSizeA      = 230
    $global:TexListColumnSizeB      = 100
    $global:TexListColumnSizeC      = 100
    $global:TexListColumnSizeD      = 80
    $global:TexListColumnSizeE      = 85
    $global:TexListColumnSizeF      = 85
    $global:TexListColumnSizeG      = 180
    $global:TexListColumnSizeH      = 70
    $global:TexListColumnSizeI      = 210

    # Main: Input/Output Path
    $global:StoreInputFolder       = $false
    $global:StoreOutputFolder      = $false
    $global:SavedInputFolder       = ""
    $global:SavedOutputFolder      = ""

    # Main: DDS Options
    $global:DDSCreatorTool         = "ImageMagick"
    $global:DDSBlkCompress         = "BC1/BC3"
    $global:DDSFallbackCompress    = "BC1/BC3"
    $global:DDSFlagRemoval         = "New & Base"
    $global:DDSForceDX10Header     = $false

    # Main: DDS Tool - Compressonator
    $global:CompressEncodeWith     = "CPU"
    $global:CompressDecodeWith     = "CPU"
    $global:CompressSwizzle        = $false
    $global:CompressNumThreads     = 0
    $global:CompressBC7Quality     = "Auto"
    $global:CompressNoPerformance  = $false

    # Main: DDS Tool - TexConv
    $global:TexConvCompSpeed       = "Standard"
    $global:TexConvAlphaType       = "No Force"
    $global:TexConvFlipImage       = "Disabled"
    $global:TexConvForceSRGB       = $true
    $global:TexConvDisableGPU      = $false

    # Main: DDS Tool - ImageMagick
    $global:MagickAlphaWeight      = $false

    # Main: PNG Options
    $global:PNGFlipResult          = $false
    $global:PNGPalettedImage       = $false
    $global:PNGBC7Converter        = "TexConv"
    $global:PNGSaveAlphaPixels     = $false

    # Main: JPG Options
    $global:JPGQualityValue        = 90
    
    # Main: BMP Options
    $global:BMPLimitColors         = $false
    $global:BMPBitmapVersion       = 4

    # Main: TIFF Options
    $global:TIFFNoResizeMipmap     = $false

    # Main: Mipmap Options
    $global:DisableMipmaps         = $false
    $global:ForceNewMipmaps        = $false
    $global:MipmapTopLevelBase     = $false
    $global:MaxMipmapEnabled       = $false
    $global:MaxMipmapLevels        = 2
    $global:ExternalDDSMipmaps     = $false
    $global:ForceCreateMipmaps     = $false

    # Main: Process Selected
    $global:ProcessFastMode        = $false
    $global:ProcessOverwrite       = $false
    $global:ProcessKeepOriginal    = $false
    $global:ProcessOverride        = $false
    $global:ProcessOverridePath    = ""

    # Operation: Create Texture Size Database
    $global:DatabaseOverwrite      = $false
    $global:DatabaseMissing        = $false
    $global:DatabaseMissCopy       = $false
    $global:DatabaseName           = "TextureSizes.tdb"

    # Operation: Scan Dolphin/Database Textures For Issues
    $global:RepairTextures         = $false
    $global:CopyBadTextures        = $false
    $global:HideOKTextures         = $false
    $global:IgnoreDuplicates       = $false
    $global:AllowNotHD             = $true
    $global:ScaleThreshold         = 0.65
    $global:AspectThreshold        = 0.05
    $global:UserScaleValues        = $false
    $global:AcceptedScales         = ""

    # Operation: Shared between Convert/Rescale/Resize
    $global:CopyNonTextures        = $true
    $global:EnableSharpen          = $true

    # Operation: Convert Textures to Another Format
    $global:ConvertFormat          = $PNG
    $global:ConvertRepair          = $false
    $global:ConvertIconSizes       = "16,24,32,48,64,128,256"

    # Operation: Rescale Textures With New Scaling Factor
    $global:RescaleFactor          = 4.00
    $global:RescaleFormat          = $PNG
    $global:RescaleScaling         = "Always"
    $global:RescaleDolphinReal     = $false
    $global:ManualRescale          = $false

    # Operation: Resize Textures With Specific Dimensions
    $global:ResizeWidth            = 128
    $global:ResizeHeight           = 128
    $global:ResizeFormat           = $PNG

    # Operation: Add Identifying Watermark to All Textures
    $global:WM_Length              = 0
    $global:WM_FontSize            = 8
    $global:WM_FontColor           = "#FF0000"
    $global:WM_BGColor             = "#00FF00"
    $global:WM_FontFace            = "Courier-New-Bold"

    # Operation: Create Materials With Material Map Generator
    $global:MatMapTileSize         = "512x512"
    $global:MatMapEdgePixels       = "None"
    $global:MatMapDisableGPU       = $false
    $global:MatMapCreateMaps       = $false

    # Operation: Create Material Maps With Ishiiruka Tool
    $global:IshiirukaFormat        = $PNG
    $global:InPlaceMaterial        = $false

    # Operation: Optimize PNG Textures With Optimizer Program
    $global:OptimizeTests          = 3
    $global:OptimizeThreads        = 1
    $global:OptimizeStripMeta      = $false
    $global:OptimizeLossless       = $false
    $global:OptimizeReuseColors    = $false
    $global:OptimizeInPlace        = $false
    $global:OptiDolphinCheck       = $true

    # Operation: Apply Upscaling Filter to All Textures
    $global:FilterSelected         = "Point"
    $global:UpscaleFactor          = 4
    $global:SeamlessMethod         = "Disable"
    $global:SeamlessPixels         = 24
    $global:UpscaleFormat          = $PNG
    $global:UpscaleAsTarget        = $false
    $global:Waifu2xModel           = "anime_style_art_rgb"
    $global:Waifu2xCMode           = "noise_scale"
    $global:Waifu2xNoise           = 2
    $global:Waifu2xDisableGPU      = $false
    $global:Waifu2xOpenCL          = $false
    $global:ESRGANModel            = "RRDB_ESRGAN_x4"
    $global:SFTGANModel            = "SFTGAN_torch"
    $global:ESRGANDisableGPU       = $false
    $global:ESRGANSaveAlpha        = $false
    $global:ESRGANUseSegments      = $false
    $global:ESRGANMaxSegment       = "256x256"
    $global:ESRGANExtraPixels      = 24
    $global:ESRGANPixelBuffer      = "Standard"

    # Operations - Generate New Mipmaps For Dolphin Textures 
    $global:InPlaceMipmaps         = $false

    # Operations - Extract Internal Mipmaps
    $global:InPlaceExtractDDS      = $false

    # Operation: Combine Multiple Textures
    $global:TextureRows            = 2
    $global:TextureCols            = 2
    $global:CTTIncludeTextures     = $false
    $global:CombineButtonSizeX     = 100
    $global:CombineButtonSizeY     = 100
    $global:CombinedName           = "CombinedTexture"
    $global:CombineFontColor       = "#000000"
    $global:CombineTileColor       = "#00FF00"
    $global:CombineAutoArrange     = $false
    $global:UserSpecifyTopLeft     = $false
    $global:CombineOverlapEnable   = $false
    $global:CombineOverlapValue    = 0
    $global:CombinePixelCrop       = $false
    $global:CombinePixelCropT      = 0
    $global:CombinePixelCropB      = 0
    $global:CombinePixelCropL      = 0
    $global:CombinePixelCropR      = 0

    # Operation: Split Combined Multi-Texture
    $global:SplitBatchImages       = $false
    $global:SplitDefineBoundary    = $false
    $global:SplitBoundaryWidth     = 0
    $global:SplitBoundaryHeight    = 0
    $global:SplitOverlapEnable     = $false
    $global:SplitPixelOverlap      = 0
    $global:SplitZeldaRestore      = $false
    $global:SplitPixelRestoreT     = 0
    $global:SplitPixelRestoreB     = 0
    $global:SplitPixelRestoreL     = 0
    $global:SplitPixelRestoreR     = 0

    # Operation: Add/Remove Arbitrary Mipmap Suffix
    $global:ArbSuffixChoice        = "Add Suffix"

    # Operation: PNG Alpha Pixel Manipulation
    $global:AlphaPixelMode         = 0
    $global:InPlaceAlphaPixel      = $false
    $global:AlphaSearch            = "No Color Data"
    $global:AlphaThreshold         = 0
    $global:BAlphaRed              = $true
    $global:CAlphaRed              = 0
    $global:BAlphaGrn              = $true
    $global:CAlphaGrn              = 0
    $global:BAlphaBlu              = $true
    $global:CAlphaBlu              = 0
    $global:BAlphaAlp              = $true
    $global:CAlphaAlp              = 0

    # Operation: Separate/Combine Texture RGBA Channels
    $global:RGBAChannelChoice      = "Split into Channels"
    $global:RGBABackGroundChoice   = "Black"
    $global:RGBAUtilizeAlpha       = $false

    # Operation: Dolphin Resource Pack Manager
    $global:ResourceOperation      = "Create a Resource Pack"
    $global:ResourceCompress       = $false

    # Operation: Various "Phyre Mode" Options
    $global:PhyrePKAType           = "All Possible Files"
    $global:PhyreSwizzle           = $true
    $global:PhyreSaveHeader        = $true
    $global:PhyreSaveMipmaps       = $false
    $global:PhyrePreviousPath      = $true
    $global:PhyreOnlyScan          = $false
    $global:PhyreExtension         = $NUL
    $global:PhyreImageFormat       = "Source"
    $global:PhyreXMLUpdate         = $true
    $global:PhyreDXT1AToDXT5       = $false

    # Operation: Various "Metroid Prime Mode" Options
    $global:MetroidHighQuality     = $false

    # Operation: Extract Textures With TextureExtraction Tool
    $global:ExtractForceUnknown    = $false
    $global:ExtractRawImages       = $false
    $global:ExtractCombineRGBA     = $false
    $global:ExtractCleanType       = "Default"
    $global:ExtractCleanCount      = 7
    $global:ExtractTasksEnable     = $false
    $global:ExtractTasksCount      = 4
    $global:ExtractTexMipmaps      = $false
    $global:ExtractDolphinMipmap   = $true
    $global:ExtractArbMipmap       = $true

    # Options: Preferences
    $global:EnableStoring          = $true
    $global:StoreToAppData         = $true
    $global:CreateLogFile          = $true
    $global:DirectoryRecursion     = $true
    $global:AlwaysOverwrite        = $true
    $global:AutoCleanOutput        = $true
    $global:DialogUpdateRate       = 25
    $global:DisableTopMost         = $true
    $global:MinimizeSingle         = $true
    $global:EnableVisualStyle      = $true
    $global:ShowQuickHelpIcon      = $true
    $global:ShowWebLinkIcons       = $true
    $global:ClickClearText         = $true
    $global:AutoShutdownPC         = $false

    # Options: Exclusions
    $global:ExcludePNG             = $true
    $global:ExcludeDDS             = $true
    $global:ExcludeJPG             = $true
    $global:ExcludeTGA             = $true
    $global:ExcludeTIF             = $true
    $global:ExcludeIsMipmap        = $true
    $global:ExcludeHasMipmap       = $true
    $global:ExcludeNoAlpha         = $true
    $global:ExcludeHasAlpha        = $true
    $global:ExcludeHasMats         = $true
    $global:ExcludeHasMatMaps      = $true
    $global:ExcludeTransparency    = "Allow All (Fastest)"
    $global:ExcludeMinWidth        = 0
    $global:ExcludeMinHeight       = 0
    $global:ExcludeMaxWidth        = 0
    $global:ExcludeMaxHeight       = 0

    # Options: Debug
    $global:EnableThePSConsole     = $false
    $global:DisableAutoConsole     = $false
    $global:ForceShowBC7Format     = $false
    $global:UseStockDDSHeaders     = $false
    $global:DumpCTTPSIconAsPNG     = $false
    $global:CloseNoSaveButtons     = $false
    $global:SplitCombineLimits     = 120

    # Update everything on the GUI.
    RefreshGUI
  }
}
#==============================================================================================================================================================================================
#  LOG FILE: CREATE AND WRITE TO THE LOG FILE
#==============================================================================================================================================================================================
#  Used in the "TexList_Init", this function creates the log file if it is not disabled, or it's not a ToCS PKG File option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateLog()
{
  # If the user disabled creating the log file then do not create it. Also block it for "Phyre Mode" PKG operations.
  $LogChecks = New-Object bool[] 4
  $LogChecks[0] = ($CreateLogFile)                          # The user must have the option to create the log enabled.
  $LogChecks[1] = ($MasterOperation -ne 'ExtractPKAFiles')  # Logs are not updated for Phyre Mode PKG options.
  $LogChecks[2] = ($MasterOperation -ne 'ExtractPKGFiles')  # Logs are not updated for Phyre Mode PKG options.
  $LogChecks[3] = ($MasterOperation -ne 'PackIntoPKGFile')  # Logs are not updated for Phyre Mode PKG options.

  # Make sure all conditions pass to update the log file.
  if (TestBooleanArray -And -Array $LogChecks)
  {
    # If a log file already exists, remove it before starting to add data to it.
    RemovePath -LiteralPath $LogFile

    # Log the intro stuff. Print the currently selected operation to the log file.
    Add-Content -LiteralPath $LogFile -Value '========================================================================================================================================================================================================================================================================='
    Add-Content -LiteralPath $LogFile -Value 'Custom Texture Tool PS - Operation Log '
    Add-Content -LiteralPath $LogFile -Value '========================================================================================================================================================================================================================================================================='
    Add-Content -LiteralPath $LogFile -Value ('Operation Selected : ' + $StoredOperation)

    # Keeps track of any sub-options that were enabled.
    $EnabledOptions = ''

    # Log selected options. Certain operations have specific options we only want to show when they are enabled.
    switch ($MasterOperation)
    {
      # "Scan Dolphin/Database Textures For Issues" has quite a few specific options not found elsewhere.
      'ScanAllTextures' 
      {
        if ($CopyBadTextures)    { $EnabledOptions += 'Copy Bad Textures, ' }
        if ($RepairTextures)     { $EnabledOptions += 'Attempt Repairs, ' }
        if ($HideOKTextures)     { $EnabledOptions += 'Hide OK Textures, ' }
        if ($IgnoreDuplicates)   { $EnabledOptions += 'Ignore Duplicates, ' }
        if ($AllowNotHD)         { $EnabledOptions += 'Allow Not-HD Textures, ' }
      }
      # "Convert Textures to Another Format" can auto-repair textures and copy non-texture files.
      'ConvertTextures' 
      {
        if ($ConvertRepair)      { $EnabledOptions += 'Auto-Repair Dimensions, ' }
        if ($CopyNonTextures)    { $EnabledOptions += 'Copy Non-Textures, ' }
        if ($EnableSharpen)      { $EnabledOptions += 'Enable Sharpening, ' }
      }
      # "Rescale Textures With New Scaling Factor" has manual rescale and copy non-texture files.
      'RescaleTextures' 
      {
        if ($ManualRescale)      { $EnabledOptions += 'Manual Rescale, ' }
        if ($CopyNonTextures)    { $EnabledOptions += 'Copy Non-Textures, ' }
        if ($EnableSharpen)      { $EnabledOptions += 'Enable Sharpening, ' }
      }
      # "Resize Textures With Specific Dimensions" only has copy non-texture files.
      'ResolutionScale' 
      {
        if ($CopyNonTextures)    { $EnabledOptions += 'Copy Non-Textures, ' }
        if ($EnableSharpen)      { $EnabledOptions += 'Enable Sharpening, ' }
      }
    }
    # Always log these options as they are always available.
    if ($DDSForceDX10Header) { $EnabledOptions += 'DX10 Header, ' }
    if ($TexConvForceSRGB)   { $EnabledOptions += 'TexConv: Force sRGB, ' }
    if ($TexConvDisableGPU)  { $EnabledOptions += 'TexConv: Disable GPU, ' }
    if ($TIFFNoResizeMipmap) { $EnabledOptions += 'Do Not Resize TIFF Layers, ' }
    if ($PNGFlipResult)      { $EnabledOptions += 'Flip PNG Result, ' }
    if ($PNGPalettedImage)   { $EnabledOptions += 'PNG Paletted, ' }
    if ($PNGSaveAlphaPixels) { $EnabledOptions += 'PNG Keep Fully Transparent Pixels, ' }

    # If mipmap generation is disabled, only display this single mipmap option.
    if ($DisableMipmaps)
    {
      $EnabledOptions += 'Disable Mipmap Generation, '
    }
    # If mipmap generation is not disabled, show the state of other mipmap options.
    else
    {
      if ($ForceCreateMipmaps) { $EnabledOptions += 'Force Create Mipmaps, ' }
      if ($ForceNewMipmaps)    { $EnabledOptions += 'Force New Mipmaps, ' }
      if ($MipmapTopLevelBase) { $EnabledOptions += 'Mipmaps From Top Level, ' }
      if ($ExternalDDSMipmaps) { $EnabledOptions += 'External Mipmaps, ' }
    }
    # If there isn't any options enabled, no point in trying to log them.
    if ($EnabledOptions -ne '')
    {
      # The last logged option will leave behind a trailing comma so trim it.
      $EnabledOptions = $EnabledOptions.TrimEnd(', ')

      # Print all enabled options in the log file.
      Add-Content -LiteralPath $LogFile -Value ('Enabled Sub-Options: ' + $EnabledOptions)
    }
  }
}
#==============================================================================================================================================================================================
#  LOG FILE: UPDATE THE LOG FILE
#==============================================================================================================================================================================================
#  Used in the "TexList_UpdateTexture", this updates the log with texture information after processing a texture during the MasterLoop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateLog([hashtable]$TextureInfo)
{
  # The conditions to update the log are confusing so store them in an array.
  $LogChecks = New-Object bool[] 6
  $LogChecks[0] = ($CreateLogFile)                                    # The log file must have been created.
  $LogChecks[1] = ($MasterOperation -ne 'ExtractPKAFiles')            # Logs are not updated for Phyre Mode PKG options.
  $LogChecks[2] = ($MasterOperation -ne 'ExtractPKGFiles')            # Logs are not updated for Phyre Mode PKG options.
  $LogChecks[3] = ($MasterOperation -ne 'PackIntoPKGFile')            # Logs are not updated for Phyre Mode PKG options.
  $LogChecks[4] = ($MasterOperation -ne 'SplitMultiImage')            # Do not update the log when splitting textures.
  $LogChecks[5] = (($TexListStatus -ne 'OK') -or (!$HideOKTextures))  # Only log textures with "OK" status if the user did not hide them.

  # Make sure all conditions pass to update the log file.
  if (TestBooleanArray -And -Array $LogChecks)
  {
    # If the path has changed since the last texture, then log the new path for the next texture.
    if ($TextureInfo.Path -ne $PreviousPath)
    {
      Add-Content -LiteralPath $LogFile -Value '========================================================================================================================================================================================================================================================================='
      Add-Content -LiteralPath $LogFile -Value ('Path: ' + $TextureInfo.Path)
      Add-Content -LiteralPath $LogFile -Value ''
    }
    # Format text for log files using the custom "ExtendString" function.
    $LogTextureName = ExtendString -InputString $TextureInfo.FullName -Length 70

    # For Dolphin textures, show the old values along with the custom texture values.
    if (($TextureInfo.Dolphin) -or ($TextureInfo.DBTexture))
    {
      $LogDimensions  = ExtendString -InputString ($TextureInfo.Width.ToString() + 'x' + $TextureInfo.Height.ToString() + ' (' + $TextureInfo.OldWidth.ToString() + 'x' + $TextureInfo.OldHeight.ToString() +')') -Length 24
      $LogScaleFactor = ExtendString -InputString $TextureInfo.FullScale -Length 14
      $LogAspectRatio = ExtendString -InputString ($TextureInfo.Aspect.ToString() + ':1 (' + ($TextureInfo.OldAspect.ToString() + ':1)')) -Length 15
    }
    # For non-Dolphin textures, the original dimensions, scaling factor, and aspect ratio is unknown.
    else
    {
      $LogDimensions  = ExtendString -InputString ($TextureInfo.Width.ToString() + 'x' + $TextureInfo.Height.ToString()) -Length 24
      $LogScaleFactor = ExtendString -InputString 'Unknown' -Length 14
      $LogAspectRatio = ExtendString -InputString ($TextureInfo.Aspect.ToString() + ':1') -Length 15
    }
    # If the "message" var contains something, include it in the log. If it doesn't, just print the "status" var.
    if ($TexListMessage -ne '') { $LogStatusMessage = $TexListStatus + ' : ' + $TexListMessage } else { $LogStatusMessage = $TexListStatus }

    # Add the texture to the log file, along with various information about the texture.
    Add-Content -LiteralPath $LogFile -Value ($LogTextureName + ' [Dimensions] ' + $LogDimensions + ' [Scale] ' + $LogScaleFactor + ' [Aspect] ' + $LogAspectRatio + ' [Status] ' + $LogStatusMessage)

    # Store the current path so when the next texture is analyzed, it is known whether or not the path changed so the log can be updated accordingly.
    $global:PreviousPath = $TextureInfo.Path
  }
}
#==============================================================================================================================================================================================
#  LOG FILE: FINAL UPDATE
#==============================================================================================================================================================================================
#  Used in "TexList_UpdateFinal". When the MasterLoop is finished, updates the log file one last time.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateLogFinal()
{
  # Exit now if the log file is not going to be created.
  if ((!$CreateLogFile) -or ($MasterOperation -eq 'ExtractPKAFiles') -or ($MasterOperation -eq 'ExtractPKGFiles') -or ($MasterOperation -eq 'PackIntoPKGFile')) { return }

  # Log a bar for the hell of it.
  Add-Content -LiteralPath $LogFile -Value '========================================================================================================================================================================================================================================================================='

  # Log selected options. Certain operations have specific options we only want to show when they are enabled.
  switch -wildcard ($MasterOperation)
  {
    # "Scan Dolphin/Datbase Textures For Issues" has quite a few specific options not found elsewhere.
    "ScanAllTextures"
    {
      # If there were issues, show the number of issues that were counted.
      if ($CountIssues -gt 0) { Add-Content -LiteralPath $LogFile -Value ('Total Texture Issues   : ' + $CountIssues) }

      # If there were no issues, report that. 
      else { Add-Content -LiteralPath $LogFile -Value 'No texture issues were detected!' }

      # If the user attempted to repair textures.
      if ($RepairTextures)
      {
        # Add a blank space between the final texture and end reports.
        TexList_AddString -TexEntry ''

        # If textures were copied, report the number that were copied.
        if ($CountCopied -gt 0)
        {
          # Display the total textures copied.
          Add-Content -LiteralPath $LogFile -Value ('Total Textures Copied  : ' + $CountCopied)
          TexList_AddString -TexEntry ('Total Textures Copied: ' + $CountCopied)
        }
        # If textures were repaired, report the number that were repaired.
        if ($CountRepaired -gt 0)
        {
          # Display the total textures repaired.
          Add-Content -LiteralPath $LogFile -Value ('Total Textures Repaired: ' + $CountRepaired)
          TexList_AddString -TexEntry ('Total Textures Repaired: ' + $CountRepaired)
        }
      }
    }
    # "Optimize PNG Textures With Optimizer Program" reports the number of textures optimized and how much storage was recovered.
    "*Optimiz*"
    {
      # Report the total number of textures optimized.
      Add-Content -LiteralPath $LogFile -Value ('Total Textures Optimized     : ' + $CountOptimized)
      TexList_AddString -TexEntry ''
      TexList_AddString -TexEntry ('Total Optimized: ' + $CountOptimized)

      # If the Total Reduction is greater than 1 MB.
      if ($OptimizedBytes -ge 1048576) { $LogEntry = (B2MB -Bytes $OptimizedBytes).ToString() + ' MB' }

      # If the Total Reduction is greater than 1 KB.
      elseif ($OptimizedBytes -ge 1024) { $LogEntry = (B2KB -Bytes $OptimizedBytes).ToString() + ' KB' }

      # The Total Reduction didn't even break 1 KB so report in Bytes.
      else { $LogEntry = $OptimizedBytes.ToString() + ' Bytes' }

      # Update the log and texture list with the amount of space recovered.
      Add-Content -LiteralPath $LogFile -Value ('Total Reduction With Optimizer : ' + $LogEntry )
      TexList_AddString -TexEntry ('Total Reduction: ' + $LogEntry)
    }
    # "Generate New Mipmaps For Dolphin Textures" just reports the number of mipmap textures that needed mipmaps.
    "GenerateMipmaps"
    {
      # Report the number of textures that had mipmaps missing.
      if ($CountMipmapped -gt 0)
      {
        # Add the total amount of textures mipmapped to the log and texture list.
        Add-Content -LiteralPath $LogFile -Value ('Total Textures Mipmapped: ' + $CountMipmapped)
        TexList_AddString -TexEntry ''
        TexList_AddString -TexEntry ('Total Textures Mipmapped: ' + $CountMipmapped)
      }
      # Report that nothing needed done.
      else
      {
        # Add that no textures required mipmaps to the log and texture list.
        Add-Content -LiteralPath $LogFile -Value 'No textures required mipmaps!'
        TexList_AddString -TexEntry ''
        TexList_AddString -TexEntry 'No textures required mipmaps!'
      }
    }
    # "Remove Invalid Mipmaps From Dolphin Textures" just reports the number of invalid mipmaps removed.
    "RemoveBadMipmap"
    {
      # Report the number of textures that had mipmaps removed.
      if ($CountInvalidMips -gt 0)
      {
        # Add the total number of textures that had mipmap removes to the log and texture list.
        Add-Content -LiteralPath $LogFile -Value ('Total Invalid Mipmap Textures: ' + $CountInvalidMips)
        TexList_AddString -TexEntry ''
        TexList_AddString -TexEntry ('Total Invalid Mipmap Textures: ' + $CountInvalidMips)
      }
      # Report that nothing needed done.
      else
      {
        # Show that no textures had mipmap issues.
        Add-Content -LiteralPath $LogFile -Value 'No textures with invalid mipmaps were found!'
        TexList_AddString -TexEntry ''
        TexList_AddString -TexEntry 'No textures with invalid mipmaps were found!'
      }
    }
    # "Remove Alpha Channel From Opaque Textures" just reports the number of textures with alpha channels removed.
    "AlphaChannelFix"
    {
      # Report the number of textures that had alpha channel removed.
      if ($CountSlicedAlpha -gt 0)
      {
        # Show the number of textures that had alpha channels removed.
        Add-Content -LiteralPath $LogFile -Value ('Total Alpha Channels Removed: ' + $CountSlicedAlpha)
        TexList_AddString -TexEntry ''
        TexList_AddString -TexEntry ('Total Alpha Channels Removed: ' + $CountSlicedAlpha)
      }
      # Report that nothing needed done.
      else
      {
        # Show that no alpha channels had to be removed.
        Add-Content -LiteralPath $LogFile -Value 'No textures with an unnecessary alpha channel were found!'
        TexList_AddString -TexEntry ''
        TexList_AddString -TexEntry 'No textures with an unnecessary alpha channel were found!'
      }
    }
  }
  # Create one last dividing bar.
  Add-Content -LiteralPath $LogFile -Value '========================================================================================================================================================================================================================================================================='
}
#==============================================================================================================================================================================================
#  TEMPORARILY OVERRIDE MASTER PATHS
#==============================================================================================================================================================================================
#  When the temporary master paths are no longer needed, this will restore them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MasterPaths_Restore()
{
  # Do not try to restore the paths if the flag hasn't been set.
  if (!$PathsNeedRestore) { return }

  # Make sure a path has actually been saved.
  if ($MasterInputSave -ne '')
  {
    # Restore the input path.
    $global:MasterInputPath = $MasterInputSave
    $global:MasterInputSave = ''
  }
  # Make sure a path has actually been saved.
  if ($MasterOutputSave -ne '')
  {
    # Restore the output path.
    $global:MasterOutputPath = $MasterOutputSave
    $global:MasterOutputSave = ''
  }
  # The paths no longer need to be restored.
  $global:PathsNeedRestore = $false
}
#==============================================================================================================================================================================================
#  Some options temporarily overwrite the master paths. This function creates a backup of whichever was replaced.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MasterPaths_Override([string]$InputPath='', [string]$OutputPath='')
{
  # Attempt to restore the paths before overriding just in case.
  MasterPaths_Restore

  # Make sure the path exists.
  if (TestPath -LiteralPath $InputPath)
  {
    # Back up the master path so it can be restored and overwrite it.
    $global:MasterInputSave = $MasterInputPath
    $global:MasterInputPath = $InputPath
  }
  # See if the output path was defined.
  if ($OutputPath -ne '')
  {
    # The output path won't exist until it's needed, so don't test for it.
    $global:MasterOutputSave = $MasterOutputPath
    $global:MasterOutputPath = $OutputPath
  }
  # Track that the paths will need to be restored.
  $global:PathsNeedRestore = $true
}
#==============================================================================================================================================================================================
#  STRING MANIPULATION FUNCTIONS
#==============================================================================================================================================================================================
#  Counts the number of characters in a string and extends it with empty spaces to the input amount.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtendString([string]$InputString, [int]$Length)
{
  # Count the number of characters in the input string.
  $Count = ($InputString | Measure-Object -Character).Characters

  # Check the number of characters against the desired amount.
  if ($Count -lt $Length)
  {
    # If the string is to be lengthened, find out by how much.
    $AddLength = $Length - $Count

    # Loop until the string matches the desired number of characters.
    for ($i = 1 ; $i -le $AddLength ; $i++)
    {
      # Add an empty space to the end of the string.
      $InputString += ' '
    }
  }
  # Return the modified string.
  return $InputString
}
#==============================================================================================================================================================================================
#  Takes an integer and converts it to a string and also appends a 0 to the front of the string if the integer is less than 10.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function IntToStringDoubleDigit([int]$Value)
{
  # Check if the input number is less than 10.
  if ($Value -lt 10)
  {
    # If it is, append a 0 and return as a string.
    return ('0' + $Value.ToString())
  }
  # Otherwise just return the integer as a string.
  return $Value.ToString()
}
#==============================================================================================================================================================================================
#  Forces any numeric value into a string with a whole number and two decimal places (examples: .2848 = 0.28 ; 134.0235 = 134.02 ; 2 = 2.00)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FormatDecimal([string]$Value)
{
  # Some countries use commas instead of periods for decimals.
  if ($Value -like '*,*')
  {
    # If a comma is found, replace it with a period.
    $Value = $Value.Replace(',','.')
  }
  # Now split on the period. This will be used to fix any values with a leading 0 (such as 01.25) or a missing 0 (such as .25).
  $PeriodSplit = $Value.Split('.', 2)

  # Powershell trickery: convert the integer part of the string into an actual integer, then back into a string. This will remove any leading 0s, or make it 0 if a number was not found.
  $IntValue = ([int]$PeriodSplit[0]).ToString()
  $DecValue = $PeriodSplit[1]

  # How the decimal value will be formatted depends on the number of characters available in the decimal value.
  $DecimalPlaces = (($DecValue | Measure-Object -Character).Characters).ToString()

  # A switch works well here because the range is 0-2, anything beyond, and nothing negative.
  switch ($DecimalPlaces)
  {
    '0'     { $FixedValue = $IntValue + '.00' }                           # If a decimal value was not provided, append two 0s.
    '1'     { $FixedValue = $IntValue + '.' + $DecValue + '0' }           # If there is only a single digit, then append a single zero.
    '2'     { $FixedValue = $IntValue + '.' + $DecValue }                 # If there are exactly 2 characters, just use the current value.
    default { $FixedValue = $IntValue + '.' + $DecValue.Substring(0,2) }  # If the decimal has more than 2 characters, keep only the first 2 characters.
  }
  # Return the new value.
  return $FixedValue
}
#==============================================================================================================================================================================================
#  Takes a file extension (.png/.dds/.jpg) and returns it as a capitalized word (PNG/DDS/JPG/TGA/TIFF).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtensionToText([string]$Extension)
{
  # Trim the period and force the string to uppercase.
  return $Extension.TrimStart('.').ToUpper()
}
#==============================================================================================================================================================================================
#  Extracts the file extension from a file and returns either the file or the extension.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractExtension([string]$FilePath, [switch]$ReturnFile)
{
  # Split the input based on periods.
  $GetExtension = $FilePath.Split('.')

  # Get the position of the extension.
  $Pos = $GetExtension.Count - 1

  # Get the last value in the stack which holds the extension.
  $SetExtension = ('.' + $GetExtension[$Pos])

  # If returning only the file with the extension cropped.
  if ($ReturnFile) { return $FilePath.Replace($SetExtension, '') }

  # If returning only the extension with the file cropped.
  return $SetExtension
}
#==============================================================================================================================================================================================
#  Takes a path, checks to see if it has a backslash at the end of it, and if it does, remove it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PathTruncateSlash([string]$Path)
{
  # Get the length of the path minus the last character.
  $PathLength = $Path.Length - 1

  # Don't allow a final backslash in the path since it will be added manually.
  if ($Path.Substring($PathLength, 1) -eq '\')
  {
     # If a slash was found, keep everything but the slash.
    return $Path.Substring(0, ($Path.Length - 1))
  }
  # If the path does not have a backslash, just return the path.
  return $Path
}
#==============================================================================================================================================================================================
#  Checks a string for illegal characters, removes them, then returns the string.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveIllegalCharacters([string]$Value)
{
  # Create an array that contains all illegal characters.
  $IllegalArray = @('<', '>', ':', '"', "'", '/', '\', '|', '?', '*')

  # Loop through the array of illegal characters.
  foreach ($IllegalChar in $IllegalArray)
  {
    # Check the value against the current character and replace if exists.
    $Value = $Value.Replace($IllegalChar,'')
  }
  # Return the modified string.
  return $Value
}
#==============================================================================================================================================================================================
#  Searches a string for regex special characters and adds an escape character to them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function InjectRegexEscapeChar([string]$InputString, [string[]]$Characters)
{
  # Declare and set the new string in case the character array is empty.
  $NewString = $InputString

  # Loop through each character in the array.
  foreach ($Char in $Characters)
  {
    # If the string does not contain the character skip this character.
    if ($NewString -notlike ("*" + $Char + "*")) { continue }
  
    # Add the escape sequence before the character.
    $Escaped = ('\' + $Char)

    # Find the character in the string and replace it with the escaped sequence.
    $NewString = $NewString.Replace($Char, $Escaped)
  }
  # Return the string with all characters excaped.
  return $NewString
}
#==============================================================================================================================================================================================
#  MISCELLANEOUS GLOBAL FUNCTIONS
#==============================================================================================================================================================================================
#  Simple functions to quickly convert bytes to other measurements. Returns two decimal places (ex: 1.23, 4.48, 3.10, 2.00)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function B2KB([Int64]$Bytes) { return [decimal](FormatDecimal -Value ($Bytes / 1024))  }
function B2MB([Int64]$Bytes) { return [decimal](FormatDecimal -Value ($Bytes / 1024 / 1024)) }
#==============================================================================================================================================================================================
#  Calls the .NET Framework hashing function to calculate a MD5, SHA1, SHA256, SHA512 from a file, byte array, or memory stream.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CalculateHash([string]$FilePath='',[byte[]]$ByteArray=$null,[IO.MemoryStream]$Stream=$null,[string]$Algorithm)
{
  # If calculating from a file.
  if ($FilePath -ne '')
  {
    # The hashing function can handle files directly.
    return (Get-FileHash -LiteralPath $FilePath -Algorithm $Algorithm).Hash
  }
  # If calculating from a byte array.
  elseif ($ByteArray -ne $null)
  {
    # The array must be converted to a memory stream.
    $ByteStream = [IO.MemoryStream]::New($ByteArray)

    # Feed that into the hashing function.
    return (Get-FileHash -InputStream $ByteStream -Algorithm $Algorithm).Hash
  }
  # Maybe in some situations the stream is more ready than the byte array.
  elseif ($Stream -ne $null)
  {
    # No need for conversions, stick it right on in there. Nice.
    return (Get-FileHash -InputStream $Stream -Algorithm $Algorithm).Hash
  }
  # Soemthing went wrong or something.
  return ''
}
#==============================================================================================================================================================================================
#  Creates a handly little hashtable which stores RGBA values.
#==============================================================================================================================================================================================
function ColorRGBA([int]$R, [int]$G, [int]$B, [int]$A)
{
  # Create a hashtable.
  $Colors = @{}

  # Give each color a value.
  $Colors.R = $R
  $Colors.G = $G
  $Colors.B = $B
  $Colors.A = $A

  # Return the hashtable.
  return $Colors
}
#==============================================================================================================================================================================================
#  Interpolate two RGBA colors (hashtable above). The "Distance" should be a decimal % to determine the distance between both points.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function InterpolateColors([hashtable]$StartColor, [hashtable]$EndColor, [decimal]$Distance)
{
  # Get the multiplier by multiplying the distance which is % in decimal value.
  $Multiplier = ($Distance * 100)

  # Calculate what a 1% change in color would be.
  $Interval_R = ($EndColor.R - $StartColor.R) / 100
  $Interval_G = ($EndColor.G - $StartColor.G) / 100
  $Interval_B = ($EndColor.B - $StartColor.B) / 100
  $Interval_A = ($EndColor.A - $StartColor.A) / 100

  # Get the new color by adding it to the amount of change.
  $RValue = $StartColor.R + ($Interval_R * $Multiplier)
  $GValue = $StartColor.G + ($Interval_G * $Multiplier)
  $BValue = $StartColor.B + ($Interval_B * $Multiplier)
  $AValue = $StartColor.A + ($Interval_A * $Multiplier)

  # Round the nearest to the next highest whole (2.1 rounds to 3) but only if the value is currently below 255 so 
  # it can't go beyond that. If it is beyond that somehow (which should never happen), as a safeguard, force 255.
  if ($RValue -lt 255) { $RFinal = [Math]::Ceiling($RValue) } else { $RFinal = 255 }
  if ($GValue -lt 255) { $GFinal = [Math]::Ceiling($GValue) } else { $GFinal = 255 }
  if ($BValue -lt 255) { $BFinal = [Math]::Ceiling($BValue) } else { $BFinal = 255 }
  if ($AValue -lt 255) { $AFinal = [Math]::Ceiling($AValue) } else { $AFinal = 255 }

  # Return the color in an RGBA hashtable.
  return ColorRGBA -R $RFinal -G $GFinal -B $BFinal -A $AFinal
}
#==============================================================================================================================================================================================
#  Takes a path (usually from a textbox) and gets the location of the file/folder to use as a start path for when selecting a file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetFileStartPath([string]$StartPath)
{
  # See if the path provided exists.
  if (($StartPath -ne '') -and (TestPath -LiteralPath $StartPath))
  {
    # Get the file that has been fed to the function.
    $StartItem = Get-Item -LiteralPath $StartPath

    # If the input is a folder, then just return that.
    if ($StartItem.PSIsContainer) { return $StartPath }

    # If the input is a file, get the path the file is in.
    return $StartItem.DirectoryName
  }
  # If all else fails, start in the script path.
  return $BaseFolder
}
#==============================================================================================================================================================================================
#  Converts bytes in big endian ordering to little endian and vice versa.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FlipEndian([string]$ByteChain)
{
  # The string to store the new byte order in.
  $NewByteOrder = ''

  # An uneven number of values will not bode well.
  if (($ByteChain.Length % 2) -ne 0)
  {
    # Add a 0 to the start of the byte chain.
    $ByteChain = '0' + $ByteChain
  }
  # Loop through all values by two, starting at the end.
  for ($i=0; $i -lt $ByteChain.Length; $i+=2)
  {
    # Write the bytes in reverse, starting with the last two.
    $Position = ($ByteChain.Length - $i - 2)

    # Store the values in a new string in the correct order.
    $NewByteOrder += $ByteChain.Substring($Position, 2)
  }
  # Return the new byte order.
  return $NewByteOrder
}
#==============================================================================================================================================================================================
#  Tests all boolean values in an array. AND: All values must be "true" to return true. OR: Only a single value needs to be "true" to return true.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TestBooleanArray([switch]$And = $false, [switch]$Or = $false, [bool[]]$Array)
{
  # In "And" all checks must pass. In "Or", only a single check needs to pass.
  if ($And)    { foreach ($Check in $Array) { if (!$Check) { return $false } } return $true }
  elseif ($Or) { foreach ($Check in $Array) { if ($Check) { return $true } } return $false }
}
#==============================================================================================================================================================================================
#  Takes a generic list that contains bitmaps and disposes of them. Used in "Process Selected" and "Basic Image Viewer" for example.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DisposeBitmapList($BitmapList)
{
  # Take the front exit if there is no data to work with.
  if ($BitmapList -eq $null) { return }

  # Loop through the list of bitmap images.
  foreach ($Bitmap in $BitmapList)
  {
    # The bitmap itself can also be null so make sure that isn't the case.
    if ($Bitmap -ne $null)
    {
      # Make sure this is actually a bitmap and that the "No Preview" image is not being disposed.
      if (($Bitmap.GetType() -eq [Drawing.Bitmap]) -and ($Bitmap -ne $Image_NoPreview))
      {
        # If the checks pass then dispose the bitmap.
        $Bitmap.Dispose()
        $Bitmap = $null
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Always rounds a number to the next highest value (example: 2.01 will round up to 3).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RoundUp([decimal]$Value)
{
  return [Math]::Round([Math]::Ceiling(($Value * 100) / 100), [System.MidpointRounding]::ToZero)
}
#==============================================================================================================================================================================================
#  DEBUG: SHOW MESSAGE ON PS CONSOLE
#==============================================================================================================================================================================================
#  Writes a message to the PowerShell Window, but only if it's enabled for debugging. The use of the "Write-Host" is actually slower than a boolean check, so only write messages when the 
#  PowerShell window is open. This should prevent a (theoretically small) performance drop when the console isn't in use. The "FollowUp" argument reduces calls to this function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DebugMessage([string]$Message, [string]$MessageColor='White', [string]$FollowUp='', [string]$FollowUpColor='White', [switch]$SameLine)
{
  # Do it all in a single line just because. No point in wasting space like this comment is.
  if ($EnableThePSConsole)
  {
    # Print something to the PS console.
    Write-Host $Message -ForegroundColor $MessageColor -NoNewLine:$SameLine

    # See if a second message is included.
    if ($FollowUp -ne '')
    {
      # Print that to the PS console as well.
      Write-Host $FollowUp -ForegroundColor $FollowUpColor
    } 
  }
}
#==============================================================================================================================================================================================
#  DEBUG: SHOW ALL KEYS IN HASH TABLE AND THEIR VALUES
#==============================================================================================================================================================================================
#  Sometimes I just want to read out everything currently in a hashtable. This can do just that.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PrintHashTableValues([hashtable]$HashTable)
{
  # Some intro text blah blah blah.
  Write-Host ''
  Write-Host 'Displaying contents of hashtable.'
  Write-Host ''

  # Loop through all the keys in the hashtable.
  foreach ($Key in $HashTable.Keys)
  {
    # Write the name of the key and it's current value.
    Write-Host ((ExtendString -InputString $Key -Length 16) + ' : ' + $HashTable.$Key)
  }
  # One last line to keep things separate.
  Write-Host ''
}
#==============================================================================================================================================================================================
#  DEBUG: DISPLAY BYTE ARRAY IN "HEX EDITOR MODE"
#==============================================================================================================================================================================================
#  Takes a byte array and prints all values to the PowerShell console in the same style as a hex editor.
#  This function will never be used in a release version of this script. It is only used by me to debug image headers and the like.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PrintHexArray([byte[]]$ByteArray)
{
  # Initial Values
  $Offset = $Loop  = 0
  $String = $Extra = ''

  # Create a header for shits and giggles.
  Write-Host ' ------------------------------------------------------------------------------'
  Write-Host ' Offset      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F'
  Write-Host ' ------------------------------------------------------------------------------'

  # Loop through each value in the byte array.
  foreach ($Value in $ByteArray)
  {
    # Convert the value to a hex value.
    $Character = ('{0:X}' -f $Value)

    # Make sure it's at least 2 digits long for alignment.
    if ($Character.Length -lt 2) { $Character = '0' + $Character }

    # Update the string with the current characters.
    $String += ($Character + ' ')

    # Add the character to the "Extra" string if it's a valid ASCII format.
    # If it's a value that makes PowerShell freak out, just make it a period.
    if (($Value -gt 32) -and ($Value -lt 126)) { $Extra += [char][byte]$Value } else { $Extra += '.' }

    # If we haven't stored at least 16 digits, just keep adding up for now.
    if ($Loop -lt 15) { $Loop++ }

    # If 16 digits have been reached.
    else
    {
      # Write the line of values.
      Write-Host ((' ' + '{0:X8}' -f $Offset) + ' :: ' + $String + '  ' + $Extra)

      # Reset the values and start counting again.
      $String = $Extra = ''
      $Loop = 0
      $Offset += 16
    }
  }
  # If there are any leftovers, write it out.
  if ($String -ne '')
  {
    $FinalString = ((' ' + '{0:X8}' -f $Offset) + ' :: ' + $String)
    Write-Host ((ExtendString -InputString $FinalString -Length 61) + '  ' + $Extra)
  }
}
#==============================================================================================================================================================================================
#  DEBUG: DISPLAY METROID IMAGE HASH BYTE ARRAY
#==============================================================================================================================================================================================
#  Takes a byte array that represents a Metroid Prime 2 font texture broken down into true/false nodes based on color (see function "GetMetroidImageData").
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PrintMetroidByteArray([byte[]]$ByteArray)
{
  # Start with an empty string.
  $String = ''

  # Show some stuff.
  Write-Host ' ------------------------------------------------------------------------------'
  Write-Host (' ' + $Texture.Name)
  Write-Host ' ------------------------------------------------------------------------------'
  Write-Host ''

  # Loop through the bytes.
  foreach ($Value in $ByteArray)
  {
    # Add the character to the string.
    $String += ($Value.ToString() + ',')

    # If we haven't hit max keep incrementing.
    if ($Loop -lt 93) { $Loop++ }
    
    # When max is hit then show the string.
    else
    {
      Write-Host ('  ' + $String)
      $String = ''
      $Loop = 0
      $Offset += 94
    }
  }
  # If there's any leftovers then show it and remove the last comma.
  if ($String -ne '') { Write-Host ( ('  ' + $String).TrimEnd(',') ) }
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: ASYNCHRONOUS JOB LOOP
#==============================================================================================================================================================================================
#  The "Job Loop" is a function that runs an external program in a separate PowerShell instance, effectively mimicking "multi-threading". Almost all external programs are ran through the
#  job loop, and the script will hang out here until the program is finished or the user cancels the operation. If the user pauses it, the script will instead jump to the "Pause Loop" after
#  the current job loop is finished. While the script is stuck in the job loop, the program is running in another instance, and the GUI will accept input. A third thread can be simulated by
#  forcing "[Application]::DoEvents" every loop iteration which updates the GUI. The GUI is updated every iteration of "$DialogUpdateRate" which is defined by the user. The
#  lower the value specified, the faster the loop runs which takes more CPU power, but the GUI will appear much smoother.
#==============================================================================================================================================================================================
#  If ESRGAN or SFTGAN runs out of VRAM, store it in a variable so it can be reported to the user. This MUST be done during the job loop to get feedback from the separate PowerShell instance.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SuperScalerOutOfVRAM($JobFeedback)
{
  # Check to see if the current filter is ESRGAN or SFTGAN.
  if (($FilterSelected -eq 'ESRGAN') -or ($FilterSelected -eq 'SFTGAN'))
  {
    # Check to see if it ran out of VRAM.
    if ($JobFeedback -like '*CUDA out of memory*')
    {
      # Store this variable so we can get an accurate error message.
      $global:OutOfVRAM = $true
    }
  }
}
#==============================================================================================================================================================================================
#  I was hoping this would show the download progress. Unfortunately, it does not. But it does show that it's actually downloading.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowPyTorchDownload($JobFeedback)
{
  # Simply write whatever Python sent to the console.
  Write-Host $JobFeedback
}
#==============================================================================================================================================================================================
#  Locks the script into a state of "access denied" until the program is done doing its thing.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunJobLoop([string]$Name, [switch]$Silent=$false)
{
  # Get the status of the job before going into the loop.
  $JobStatus = (Get-Job -Name $Name -ErrorAction 'SilentlyContinue').State

  # Hang out here while the application is running.
  while ($JobStatus -ne 'Completed')
  {
    # Wait for the selected time before the next loop iteration.
    Start-Sleep -m $DialogUpdateRate

    # Get the status of the job before going into the next iteration.
    $CurrentJob = Get-Job -Name $Name -ErrorAction 'SilentlyContinue'

    # Break early if the job no longer exists.
    if ($CurrentJob -eq $null) { break }

    # Check to see if the user paused the MasterLoop.
    if (($PauseMasterLoop) -or ($CancelMasterLoop))
    {
      # Disable these controls until the job is finished.
      $TexListStartButton.Enabled = $false
      $TexListCancelButton.Enabled = $false
      $TexListHelpButton.Enabled = $false
      $TexListAScrollCheck.Enabled = $false
      $TexListStoreSizeCheck.Enabled = $false
      $TexListWaitLabel.Visible = $true

      # Update the operation to display something is happening and the user must wait for it to finish.
      TexList_UpdateStatus -Status 'Operation' -Value 'Waiting...' -FontColor ([Drawing.ColorTranslator]::FromHtml('#FF8000'))
    }
    # Display that we're in the job loop.
    if (!$Silent) { DebugMessage -Message '<< Job Loop Iteration >>' }

    # Get anything that the job output.
    $JobFeedback = Receive-Job -Name $Name

    # If the job has anything useful to report.
    if ($JobFeedback)
    {
      # Some jobs can have additional tasks.
      switch ($MasterOperation)
      {
        # Apply Upscaling Filter to All Textures
        'UpscaleTextures'  { SuperScalerOutOfVRAM -JobFeedback $JobFeedback }

        # Create Materials With Material Map Generator
        'CreateMaterials'  { ShowPyTorchDownload -JobFeedback $JobFeedback }
      }
    }
    # Get the status of the job before going into the next iteration.
    $JobStatus = $CurrentJob.State

    # Call DoEvents so the dialog doesn't hang.
    [Windows.Forms.Application]::DoEvents()
  }
}
#==============================================================================================================================================================================================
#  Starts the job loop which halts everything until the current program is finished.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StartJobLoop([string]$Name, [string]$Program = '', [switch]$Silent=$false)
{
  # Debug:Let me know the job loop started.
  if (!$Silent) { DebugMessage -Message ('--- Job Loop Started (' + $Program + ')') }

  # Trap the script in a loop until the program is finished.
  RunJobLoop -Name $Name -Silent:$Silent

  # If the loop was paused or canceled, restore all controls now.
  if (($PauseMasterLoop) -or ($CancelMasterLoop))
  {
    # Bring back the controls if they were disabled.
    $TexListStartButton.Enabled     = $true
    $TexListCancelButton.Enabled    = $true
    $TexListHelpButton.Enabled      = $true
    $TexListAScrollCheck.Enabled    = $true
    $TexListStoreSizeCheck.Enabled  = $true
    $TexListWaitLabel.Visible       = $false
  }
  # If the menu is paused, then start the pause loop.
  if ($PauseMasterLoop)
  {
    # Now hang out here until the user unpauses the script.
    TexList_PauseLoopInProgress
  }
  # Now that the job is finished, clean it up.
  Stop-Job -Name $Name -ErrorAction 'SilentlyContinue'
  Remove-Job -Name $Name -ErrorAction 'SilentlyContinue'

  # Debug:Let me know the job loop ended.
  if (!$Silent) { DebugMessage -Message '--- Job Loop Ended' }
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: IMAGEMAGICK
#==============================================================================================================================================================================================
#  Calls forth ImageMagick to convert an image. All arguments passed to ImageMagick come in a string array.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-Convert([string]$ImageFile, [string[]]$Arguments, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to ImageMagick needs to be copied over.
    Param ([string]$ImageMagick, [string]$ImageFile, [string[]]$Arguments, [string]$OutputFile)

    # Create the image.
    & $ImageMagick -quiet $ImageFile $Arguments $OutputFile | Out-Null
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $ImageMagick,$ImageFile,$Arguments,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'ImageMagick - Convert'
}
#==============================================================================================================================================================================================
#  Calls ImageMagick identify to get characteristics from the image. Can not be threaded due to reliance on return value.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-Identify([string]$ImageFile, [string[]]$Arguments)
{
  # Here a symbolic link to "identify" can be used.
  return (& $ImageMagick 'identify' $Arguments $ImageFile)
}
#==============================================================================================================================================================================================
#  Calls ImageMagick identify to specifically check for an alpha channel.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-IdentifyGray([string]$ImageFile)
{
  # Grab the colorspace from the image.
  $ChannelCheck = Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%[colorspace]')

  # If it's "Gray" or "GrayA" then it's gray.
  return ($ChannelCheck -like 'Gray*')
}
#==============================================================================================================================================================================================
#  Calls ImageMagick to test if an image is transparent.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-IndentifyTransparency([string]$ImageFile)
{
  # ImageMagick is so much better 
  return ((Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%[opaque]')) -eq 'False')
}
#==============================================================================================================================================================================================
#  Calls ImageMagick identify to specifically check for an alpha channel.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-IdentifyAlpha([string]$ImageFile)
{
  # Grab the channel format from the image.
  $ChannelCheck = Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%[channels]')

  # Set up a series of checks in an array to determine if the texture has the required materials.
  $AlphaChecks = New-Object bool[] 5

  # Go through and store the result of each check into the array.
  $AlphaChecks[0]  = ($ChannelCheck -like '*rgba')
  $AlphaChecks[1]  = ($ChannelCheck -eq 'graya')

  # If any condition passes return true.
  if (TestBooleanArray -Or -Array $AlphaChecks) { return $true }

  # If the query doesn't match the above checks it does not have alpha.
  return $false
}
#==============================================================================================================================================================================================
#  Calls ImageMagick montage to combine a collection of images in a separate thread.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-Montage([string[]]$Collection, [string[]]$Arguments, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to ImageMagick needs to be copied over.
    Param ([string]$ImageMagick, [string[]]$Arguments, [string[]]$Collection, [string]$OutputFile)

    # Create the image.
    & $ImageMagick 'montage' -quiet $Arguments $Collection $OutputFile
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $ImageMagick,$Arguments,$Collection,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'ImageMagick - Montage'
}
#==============================================================================================================================================================================================
#  Applies an upscaling filter with ImageMagick in a separate thread. Requires the PNG color type to be manually set (or pulled from the hash table).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Magick-Upscaler([string]$ImageFile, [string]$Factor, [string]$OutputFile, [string]$Filter)
{
  # ImageMagick takes the size in the form of a percentage so calculate that now.
  $NewScale = ([int]$Factor * 100).ToString() + '%'

  # Build a list of arguments to feed into ImageMagick.
  $Arguments = New-Object Collections.Generic.List[string]
  $Arguments.Add('-filter')         | Out-Null
  $Arguments.Add($Filter.ToLower()) | Out-Null
  $Arguments.Add('-resize')         | Out-Null
  $Arguments.Add($NewScale)         | Out-Null

  # If the output extension is PNG then force color type 6 (RGBA).
  if ((ExtractExtension -FilePath $OutputFile) -eq $PNG)
  {
    $Arguments.Add('-define')          | Out-Null
    $Arguments.Add('png:color-type=6') | Out-Null
  }
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to ImageMagick needs to be copied over.
    Param ([string]$ImageMagick, [string]$ImageFile, [string[]]$Arguments, [string]$OutputFile)

    # Create the image.
    & $ImageMagick -quiet $ImageFile $Arguments $OutputFile
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $ImageMagick,$ImageFile,$Arguments,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'ImageMagick - Upscale Filter'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: AMD COMPRESSONATOR
#==============================================================================================================================================================================================
#  Calls AMD CompressonatorCLI.exe to create a DDS texture in a separate thread.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CompressonatorCLI([string]$ImageFile, [string[]]$Arguments, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to Compressonator needs to be copied over.
    Param ([string]$Compressonator, [string]$ImageFile, [string[]]$Arguments, [string]$OutputFile)

    # Run Compressonator in a new thread.
    & $Compressonator $Arguments $ImageFile $OutputFile
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Compressonator,$ImageFile,$Arguments,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Compressonator'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: MICROSOFT TEXCONV
#==============================================================================================================================================================================================
#  Calls Microsoft texconv.exe to create a DDS texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunTexConvTool([string]$ImageFile, [string[]]$Arguments, [string]$OutputFile)
{
  # Get the base name of the input texture and its extension.
  $TexImageName = (Get-Item -LiteralPath $ImageFile).BaseName
  $TexExtension = ExtractExtension -FilePath $OutputFile
  $ArgExtension = ExtensionToText -Extension $TexExtension

  # Create a temporary path to create the image. The created image will be renamed and moved later.
  $TexConvPath = CreatePath -LiteralPath ($TempFolder + '\TexConvTemp')
  $TexConvFile = $TexConvPath + '\' + $TexImageName + $TexExtension

  # Add the always overwrite "-y" command, and the filetype using the extension.
  $Arguments = @('-y', '-ft', $ArgExtension) + $Arguments

  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to TexConvTool needs to be copied over.
    Param ([string]$TexConvTool, [string]$ImageFile, [string[]]$Arguments, [string]$TexConvPath, [string]$TexExtension)

    # Create the texture with TexConvTool.
    & $TexConvTool $ImageFile $Arguments -o $TexConvPath

    # For some reason TexConv outputs as (.tif) instead of (.tiff) so that needs to be fixed.
    foreach ($Image in Get-ChildItem -LiteralPath $TexConvPath -Force)
    {
      # Check to see if the image is a TIF image.
      if (($Image.Extension -eq '.tif') -and ($TexExtension -eq '.tiff'))
      {
        # Set the path to the new name for the image.
        $NewImage = $Image.DirectoryName + '\' + $Image.BaseName + '.tiff'

        # Rename the image using the move item function.
        Move-Item -LiteralPath $Image.FullName -Destination $NewImage -Force
      }
    }
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $TexConvTool,$ImageFile,$Arguments,$TexConvPath,$TexExtension

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Direct-X TexConv'

  # Test to see if the image was created.
  if (TestPath -LiteralPath $TexConvFile)
  {
    # There is a strange bug when converting to PNG that makes it lighter.
    if ($TexExtension -eq $PNG)
    {
      # TexConv has issues with BC7 images being too light. The pixel data is valid however, so this work around grabs the raw pixel
      # data and rewrites the image using Microsoft .NET bitmap functions. Not sure why it works, but it does so hooray?!
      WritePixelDataToImage -PixelData (GetRawImageData -ImageFile $TexConvFile) -OutputFile $TexConvFile
    }
    # Force move/rename the file after it was created to the output path.
    Move-Item -LiteralPath $TexConvFile -Destination $OutputFile -Force
  }
  # We no longer need this so send it to the netherworld.
  RemovePath -LiteralPath $TexConvPath
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: MATERIAL MAP GENERATOR
#==============================================================================================================================================================================================
#  Runs the material map generator script using python.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GenerateMaterials([string[]]$Arguments)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to Waifu2x needs to be copied over.
    Param ([string]$Python, [string]$MatMapGenPath, [string[]]$Arguments)

    # The python script will look for external files so move to it's home folder.
    Push-Location -LiteralPath $MatMapGenPath

    # Run the script through python.
    & $Python 'generate.py' $Arguments

    # Return to wherever we were.
    Pop-Location
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Python,$MatMapGenPath,$Arguments

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Material Map Generator'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: ISHIIRUKA TOOL
#==============================================================================================================================================================================================
#  Calls Ishiiruka Tool to create material map textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Ishiiruka-Tool([string]$ImageFile, [string[]]$Arguments, [string]$OutputPath)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to IshiirukaTool needs to be copied over.
    Param ([string]$IshiirukaTool, [string]$ImageFile, [string]$OutputPath, [string[]]$Arguments)

    # Run IshiirukaTool in a new thread.
    & $IshiirukaTool $ImageFile $OutputPath $Arguments | Out-Null
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $IshiirukaTool,$ImageFile,$OutputPath,$Arguments

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Ishiiruka Tool'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: DOLPHIN TEXTUREEXTRACTION TOOL
#==============================================================================================================================================================================================
#  Runs the Dolphin TextureExtraction Tool which extracts images and converts them into dolphin textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TextureExtractionTool([string]$Operation, [string]$InputPath, [string]$OutputPath, [string[]]$Commands)
{
  # A block of code is needed to pass to the job.
  $TexExtractScript = {

    # Everything that is passed to Waifu2x needs to be copied over.
    Param ( [string]$TexExtractTool, [string]$Operation, [string]$InputPath, [string]$OutputPath, [string[]]$Commands )

    # Run Dolphin TextureExtraction Tool in a new thread.
    & $TexExtractTool $Operation $InputPath $OutputPath $Commands
  }
  if ($Operation -eq "extract")
  {
    # Start the job to create the image.
    $Job = Start-Job -Name 'TexExtract' -Scriptblock $TexExtractScript -ArgumentList $TexExtractTool,$Operation,$InputPath,$OutputPath,$Commands
    
    # Lock certain elements of the script into a loop while the job runs.
    TexExtractLoop -Name 'TexExtract' -Program 'Dolphin TextureExtraction Tool'
  }
  elseif ($Operation -eq "finalize")
  {
    # Start the job to create the image.
    $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $TexExtractScript -ArgumentList $TexExtractTool,$Operation,$InputPath,$OutputPath,$Commands
    
    # Lock certain elements of the script into a loop while the job runs.
    StartJobLoop -Name 'ThreadedScript' -Program 'Dolphin TextureExtraction Tool'
  }
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: PNG OPTIMIZER: OPTIPNG / OXIPNG / PINGO / EFFICIENT COMPRESSION TOOL
##==============================================================================================================================================================================================
#  Optimizes a texture with OptiPNG or OxiPNG.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunPNGOptimizer([string[]]$Arguments)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to OptiPNG needs to be copied over.
    Param ([string]$OptimizerPath, [Collections.Generic.List[string]]$ArgumentList)

    # OxiPNG requires double dashes and can use multiple threads. 
    & $OptimizerPath $ArgumentList 2>&1>$null
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $OptimizerPath,$Arguments

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'PNG Optimizer'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: xBRZ SCALER TEST
#==============================================================================================================================================================================================
#  Calls xBRZ ScalerTest.exe to upscale a texture by the Upscale Factor.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function xBRZ-Upscale([string]$ImageFile, [string]$Factor, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to ScalerTest needs to be copied over.
    Param ([string]$ScalerTestPath, [string]$xBRZLevel, [string]$ImageFile, [string]$OutputFile)

    # Run ScalerTest in a new thread.
    & $ScalerTestPath $xBRZLevel $ImageFile $OutputFile | Out-Null
  }
  # Set the strength for xBRZ in the way ScalerTest expects to see it.
  $xBRZLevel = ('-' + $Factor + 'xBRZ')

  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $ScalerTestPath,$xBRZLevel,$ImageFile,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'xBRZ ScalerTest'
}
#==============================================================================================================================================================================================
#  The function called by the upscaler program. xBRZ can only handle a factor of 6x upscale, but this function will fake a 16x max.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function xBRZ-ScalerTest([string]$ImageFile, [string]$Factor, [string]$OutputFile)
{
  # xBRZ has a max of 6x upscale. So we gotta pull off some crazy shit to give off the illusion that it's 16x.
  if ([int]$Factor -gt 6)
  {
    # Create a temporary path to upscale files.
    $TempUpscalePath = CreatePath -LiteralPath ($TempFolder + '\xBRZTemp')

    # Create a path to the first temporary image.
    $TempUpscaleFileA = $TempUpscalePath + '\Upscale1.png'

    # First step is to upscale using the maximum factor of 6x.
    xBRZ-Upscale -ImageFile $ImageFile -Factor '6' -OutputFile $TempUpscaleFileA

    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }

    # One more upscale is needed. If the factor is 12 or less, only 2x is need. If it's 13 or greater, we will need 3x to meet the demand.
    if ([int]$Factor -gt 12) { $NewFactor = 3 } else { $NewFactor = 2 }

    # Create a path to the second temporary image.
    $TempUpscaleFileB = $TempUpscalePath + '\Upscale2.png'

    # Second step is to upscale using the minimum value to hit our target upscale.
    xBRZ-Upscale -ImageFile $TempUpscaleFileA -Factor $NewFactor -OutputFile $TempUpscaleFileB

    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }

    # Get various properties of the image.
    $OldImageInfo = CreateTextureInfo -ImageFile $ImageFile
    $NewImageInfo = CreateTextureInfo -ImageFile $TempUpscaleFileB

    # Calculated upscale.
    $NewWidth  = $OldImageInfo.Width * [int]$Factor
    $NewHeight = $OldImageInfo.Height * [int]$Factor

    # If the dimensions have changed, the image will need to be rescaled.
    if (($NewImageInfo.Width -ne $NewWidth) -and ($NewImageInfo.Height -ne $NewHeight))
    {
      # We'll need ImageMagick compatible dimensions.
      $Dimensions = $NewWidth.ToString() + 'x' + $NewHeight.ToString() + '!'

      # Resize the image with ImageMagick.
      Magick-Convert -ImageFile $TempUpscaleFileB -Arguments @('-resize', $Dimensions) -OutputFile $OutputFile
    }
    # Just send the result to the output path.
    else
    {
      # Send the final result to the output path and rename the temporary file.
      Move-Item -LiteralPath $TempUpscaleFileB -Destination $OutputFile -Force
    }
    # The usual cleanup.
    RemovePath -LiteralPath $TempUpscalePath
  }
  # If the upscale factor is 6 or less.
  else
  {
    # We can just directly use the upscale factor without doing any fancy stuff.
    xBRZ-Upscale -ImageFile $ImageFile -Factor $Factor -OutputFile $OutputFile
  }
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: WAIFU2X CAFFE OR WAIFU2X CPP
#==============================================================================================================================================================================================
#  Waifu2x programs have a lot of arguments. This function builds a competent list for them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function BuildWaifu2xArgumentList([string]$Factor)
{
  # Get the name of the current waifu2x application.
  $Waifu2xApp = (Get-Item -LiteralPath $Waifu2xPath).Name

  # The latest iterations of Waifu2x-CPP by DeadSix27 updated parameters to use dashes instead of underscores.
  switch -wildcard ($Waifu2xApp)
  {
    # Caffe wants underscores.
    '*caffe*' {
                # Set up the arguments with underscores.
                $Waifu2xCMode = $Waifu2xCMode.ToLower()
                $NoiseLevel = '--noise_level'
                $ScaleRatio = '--scale_ratio'
              }
    # CPP wants dashes.
    '*conve*' {
                # CPP does not support auto scaling.
                if ($Waifu2xCMode -eq 'auto_scale')
                {
                  # Replace it with standard denoise and scaling.
                  $Waifu2xCMode = 'noise_scale'
                }
                # Under normal circumstances.
                else
                {
                  # Use the value set but replace the underscores with dashes.
                  $Waifu2xCMode = $Waifu2xCMode.ToLower().Replace('_','-')
                }
                # Set up the arguments with dashes.
                $NoiseLevel = '--noise-level'
                $ScaleRatio = '--scale-ratio'
              }
  }
  # Build an argument list to feed to the program.
  $Waifu2xArgList = [Collections.Generic.List[string]]@('-m', $Waifu2xCMode)

  # Add arguments based on the mode set. I could do this better but fuck it this is readable.
  switch -wildcard ($Waifu2xCMode)
  {
    # For scale, only the "scale_ratio" argument is required.
    'scale'       {
                    $Waifu2xArgList.Add($ScaleRatio)    | Out-Null
                    $Waifu2xArgList.Add($Factor)        | Out-Null
                  }
    # For noise, only the "noise_level" argument is required.
    'noise'       {
                    $Waifu2xArgList.Add($NoiseLevel)    | Out-Null
                    $Waifu2xArgList.Add($Waifu2xNoise)  | Out-Null
                  }
    # Both arguments are added when its "noise_scale".
    'noise*scale' {
                    $Waifu2xArgList.Add($NoiseLevel)    | Out-Null
                    $Waifu2xArgList.Add($Waifu2xNoise)  | Out-Null
                    $Waifu2xArgList.Add($ScaleRatio)    | Out-Null
                    $Waifu2xArgList.Add($Factor)        | Out-Null
                  }
    # Omit the noise reduction when set to auto_scale.
    'auto*scale' {
                    $Waifu2xArgList.Add($ScaleRatio)    | Out-Null
                    $Waifu2xArgList.Add($Factor)        | Out-Null
                  }
  }
  # This is where the programs diverge on what commands they want.
  switch -wildcard ($Waifu2xApp)
  {
    # Waifu2x Caffe has the exclusive model.
    '*caffe*' {
                # The waifu2x-caffe version of disable GPU is to enable the CPU.
                if ($Waifu2xDisableGPU)
                {
                  $Waifu2xArgList.Add('--process')  | Out-Null
                  $Waifu2xArgList.Add('cpu')      | Out-Null
                }
                # Waifu2x-caffe allows changing the model. Specify the model now.
                $Waifu2xArgList.Add('--model_dir')  | Out-Null
                $Waifu2xArgList.Add('models\' + $Waifu2xModel) | Out-Null
              }
    # Waifu2x-CPP has the exclusive OpenCL.
    '*conve*' {
                # Waifu2x-cpp just straight up has a disable GPU command.
                if ($Waifu2xDisableGPU)
                {
                  $Waifu2xArgList.Add('--disable-gpu')  | Out-Null 
                }
                # The use of OpenCL in waifu2x-cpp which is not available in caffe.
                if ($Waifu2xOpenCL)
                {
                  $Waifu2xArgList.Add('--force-OpenCL') | Out-Null 
                }
              }
  }
  # Return the argument list.
  return $Waifu2xArgList
}
#==============================================================================================================================================================================================
#  Calls Waifu2x to upscale a texture by the Upscale Factor.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Waifu2x-Upscale([string]$ImageFile, [string]$Factor, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to Waifu2x needs to be copied over.
    Param ( [string]$Waifu2xPath, [string]$ImageFile, [string[]]$Arguments, [string]$OutputFile )

    # Get the Waifu2x directory because CPP needs to run from here.
    $WaifuDir = (Get-Item -LiteralPath $Waifu2xPath).DirectoryName

    # Waifu2x-CPP only wants to run from its install location, and Waif2x-Caffe needs to be here to grab the model, so push to the containing folder.
    Push-Location -LiteralPath $WaifuDir

    # Run Waifu2x in a new thread. All of these variables that serve as arguments are set with the GUI (see function "GUI_Start_UpscaleFilterTextures").
    & $Waifu2xPath -i $ImageFile $Arguments -o $OutputFile

    # Return to the previous directory.
    Pop-Location
  }
  # Get the list of arguments to feed to waifu2x.
  $Arguments = BuildWaifu2xArgumentList -Factor $Factor

  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Waifu2xPath,$ImageFile,$Arguments,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Waifu2x'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: ESRGAN
#==============================================================================================================================================================================================
#  Runs the ESRGAN filter using python.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Execute-ESRGAN([string]$ImageFile, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to Waifu2x needs to be copied over.
    Param ( [string]$Python, [string]$ImageFile, [string]$ESRGANBasePath, [string]$ESRGANModel, [string]$OutputFile )

    # Get the image as an item.
    $ImageItem = Get-Item -LiteralPath $ImageFile

    # Create a copy of the image in ESRGAN's folder.
    $ImageInput = $ESRGANBasePath + '\LR\' + $ImageItem.Name

    # This is the image that ESRGAN will upscale.
    Copy-Item -LiteralPath $ImageFile -Destination $ImageInput -Force

    # Jump to the ESRGAN folder for the relative paths.
    Push-Location -LiteralPath $ESRGANBasePath

    # Set the path to the model.
    $ModelPath = ('models\' + $ESRGANModel + '.pth')

    # Run ESRGAN using the specified model path.
    & $Python 'test.py' $ModelPath 2>&1>$null

    # If ESRGAN had any errors, output them so they can be gathered with "Receive-Job " later on.
    Write-Output $Error[0]

    # Remove the image that was used for the input.
    Remove-Item -LiteralPath $ImageInput -Force | Out-Null

    # Create a link to the new texture.
    $ImageOutput = $ESRGANBasePath + '\results\' + $ImageItem.BaseName + '_rlt.png'

    # Check to see if the image was created.
    if (Test-Path -LiteralPath $ImageOutput -ErrorAction 'SilentlyContinue')
    {
      # Move the result to the destination path.
      Move-Item -LiteralPath $ImageOutput -Destination $OutputFile
    }
  }
  # Remove the "LR" folder in case there is junk, then recreate it.
  RemovePath -LiteralPath ($ESRGANBasePath + '\LR')
  CreatePath -LiteralPath ($ESRGANBasePath + '\LR') -NoReturn

  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Python,$ImageFile,$ESRGANBasePath,$ESRGANModel,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'ESRGAN'
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: SFTGAN
#==============================================================================================================================================================================================
#  Runs the SFTGAN filter using python.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Execute-SFTGAN([string]$ImageFile, [string]$OutputFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to Waifu2x needs to be copied over.
    Param ( [string]$Python, [string]$ImageFile, [string]$SFTGANBasePath, [string]$OutputFile )

    # Get the image as an item.
    $ImageItem = Get-Item -LiteralPath $ImageFile

    # Create a copy of the image in SFTGAN's folder.
    $ImageInput = $SFTGANBasePath + '\data\samples\' + $ImageItem.Name

    # This is the image that SFTGAN will upscale.
    Copy-Item -LiteralPath $ImageFile -Destination $ImageInput -Force

    # Jump to the STFGAN folder for the relative paths.
    Push-Location -LiteralPath ($SFTGANBasePath + '\pytorch_test')

    # Run SFTGAN segmentation test and capture any errors. 
    & $Python 'test_segmentation.py' 2>&1>$null

    # If SFTGAN had any errors, output them so they can be gathered with "Receive-Job " later on.
    Write-Output $Error[0]

    # Run SFTGAN filter test and capture any errors. 
    & $Python 'test_sftgan.py' 2>&1>$null

    # If SFTGAN had any errors, output them so they can be gathered with "Receive-Job " later on.
    Write-Output $Error[0]

    # Remove the image that was used for the input.
    Remove-Item -LiteralPath $ImageInput -Force | Out-Null

    # Create a link to the new texture.
    $ImageOutput = $SFTGANBasePath + '\data\samples_result\' + $ImageItem.BaseName + '_rlt.png'

    # Check to see if the image was created.
    if (Test-Path -LiteralPath $ImageOutput -ErrorAction 'SilentlyContinue')
    {
      # Move the result to the destination path.
      Move-Item -LiteralPath $ImageOutput -Destination $OutputFile
    }
  }
  # Remove the "samples" folder in case there is junk, then recreate it.
  RemovePath -LiteralPath ($SFTGANBasePath + '\data\samples')
  CreatePath -LiteralPath ($SFTGANBasePath + '\data\samples') -NoReturn

  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Python,$ImageFile,$SFTGANBasePath,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'SFTGAN'

  # SFTGAN leaves behind a lot of garbage. Remove it all.
  RemovePath -LiteralPath ($SFTGANBasePath + '\data\samples_byteimg')
  RemovePath -LiteralPath ($SFTGANBasePath + '\data\samples_colorimg')
  RemovePath -LiteralPath ($SFTGANBasePath + '\data\samples_result')
  RemovePath -LiteralPath ($SFTGANBasePath + '\data\samples_segprob')
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: ZIP COMPRESSION / 7-ZIP
#==============================================================================================================================================================================================
#  Creates a zip file from a folder. If the zip file exists, it instead adds files to the existing zip file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ZipFileArchive([string]$Content, [string]$ZipFileName)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed to 7-zip needs to be copied over.
    Param ([string]$7ZipPath,[string]$Content,[string]$7zCLevel,[string]$ZipFileName)

    # Jump to the location of the files.
    Push-Location -LiteralPath $Content

    # Run 7-zip in a new thread.
    & $7ZipPath 'a' '-tzip' $7zCLevel '-xr!thumbs.db' $ZipFileName
  }
  # If compression is enabled set it to max.
  if ($ResourceCompress) { $7zCLevel  = '-mx=9' } else { $7zCLevel  = '-mx=0' }

  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $7ZipPath,$Content,$7zCLevel,$ZipFileName

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program '7-Zip'
}
#==============================================================================================================================================================================================
#  Extracts all files from a zip archive to the destination.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ZipExtractArchive([string]$ZipFilePath, [string]$OutputPath)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed through needs to be copied over.
    Param ([string]$ZipFilePath,[string]$OutputPath)

    # This is a new instance of PowerShell so load the compression assembly.
    Add-Type -AssemblyName 'System.IO.Compression.FileSystem'

    # Open and read the zip file.
    $ZipArchive = [IO.Compression.ZipFile]::OpenRead($ZipFilePath)

    # Extract the entire ZIP to the destination folder.
    [IO.Compression.ZipFileExtensions]::ExtractToDirectory($ZipArchive, $OutputPath)

    # Doubt this is necessary but to hell with it.
    $ZipArchive.Dispose()
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $ZipFilePath,$OutputPath

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'ZIP: Extract Archive'
}
#==============================================================================================================================================================================================
#  Extracts a file from a zip archive by name to the destination.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ZipExtractFile([string]$ZipFilePath, [string]$ExtractFile, [string]$OutputPath)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed through needs to be copied over.
    Param ([string]$ZipFilePath,[string]$ExtractFile,[string]$OutputFile)

    # This is a new instance of PowerShell so load the compression assembly.
    Add-Type -AssemblyName 'System.IO.Compression.FileSystem'

    # Open and read the zip file.
    $ZipArchive = [IO.Compression.ZipFile]::OpenRead($ZipFilePath)

    # Get the entry in the zip file.
    $ZipEntry = $ZipArchive.GetEntry($ExtractFile)

    # Extract the file to the location.
    [IO.Compression.ZipFileExtensions]::ExtractToFile($ZipEntry, $OutputFile)

    # Doubt this is necessary but to hell with it.
    $ZipArchive.Dispose()
  }
  # Get the path to where the file will be extracted.
  $OutputFile = $OutputPath + '\' + $ExtractFile

  # If the output file already exists, overwrite it.
  RemovePath -LiteralPath $OutputFile

  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $ZipFilePath,$ExtractFile,$OutputFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'ZIP: Extract File'

  # Return the path to the file for ease of use.
  return $OutputFile
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: PYTHON
#==============================================================================================================================================================================================
#  Runs a python script in another thread so it doesn't freeze the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunPythonScript([string]$Script, [string[]]$Arguments, [string]$OutputPath)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed through needs to be copied over.
    Param ([string]$Python, [string]$Script, [string[]]$Arguments, [string]$OutputPath)

    # Set the location to the output folder so the script extracts the contents here.
    Push-Location -LiteralPath $OutputPath

    # Run the python script.
    & $Python $Script $Arguments

    # Probably not necessary since it's the end of the instance, but old habits die hard.
    Pop-Location
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Python,$Script,$Arguments,$OutputPath

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Python Script'
}
#==============================================================================================================================================================================================
#  Updates "pip" to the latest version.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PythonUpdatePip()
{
  # Updates "pip" to the latest version.
  & $Python '-m' 'pip' 'install' '--upgrade' 'pip' '--no-warn-script-location'
}
#==============================================================================================================================================================================================
#  Gets a list of all python modules.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PythonGetModules()
{
  # Updates "pip" to the latest version.
  return (& $Python '-m' 'pip' 'list')
}
#==============================================================================================================================================================================================
#  Installs a specific version of PyTorch, which is subject to change in future versions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PythonInstallTorch()
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed through needs to be copied over.
    Param ([string]$Python)

    # Updates "pip" to the latest version.
    & $Python '-m' 'pip' 'install' 'torch==1.10.1+cu113' 'torchvision==0.11.2+cu113' 'torchaudio===0.10.1+cu113' '-f' 'https://download.pytorch.org/whl/cu113/torch_stable.html'
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $Python

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'Python - Install Torch' -Silent
}
#==============================================================================================================================================================================================
#  Checks to see if a specific Python module is installed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PythonCheckModule([string]$Module)
{
  # Python will force the PS console black, so make it black now for consistency.
  if ($EnableThePSConsole) { $Host.UI.RawUI.BackgroundColor = 'Black' }

  # Debug: Show me some debug messages if the console is enabled.
  DebugMessage -Message '-----------------------------------------------------------------------------'
  DebugMessage -Message (' Notice: Python Module "' + $Module + '" Check')
  DebugMessage -Message '-----------------------------------------------------------------------------'

  # Get a list of all modules installed.
  $InstallList = PythonGetModules

  # Loop through all entries in the list and see if the module is in the list.
  foreach ($ListEntry in $InstallList)
  {
    # The text to match the module.
    $ModuleMatch = '*' + $Module + '*'
    
    # Try to match the module name.
    if ($ListEntry -like $ModuleMatch) 
    {
      # Debug: Notify me that it was found.
      DebugMessage -Message 'This module is installed!'
      DebugMessage -Message '-----------------------------------------------------------------------------'

      # If we found a match then exit now.
      return $true
    }
  }
  # Debug: Notify me that it wasn't found.
  DebugMessage -Message 'This module is not installed!'
  DebugMessage -Message '-----------------------------------------------------------------------------'

  # The module was not found.
  return $false
}
#==============================================================================================================================================================================================
#  Downloads and installs the desired Python module.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PythonInstallModules([string[]]$Modules, [switch]$SkipError)
{
  # Python will force the PS console black, so make it black now for consistency.
  if ($EnableThePSConsole) { $Host.UI.RawUI.BackgroundColor = 'Black' }

  # Debug: Show me some debug messages if the console is enabled.
  DebugMessage -Message '-----------------------------------------------------------------------------'
  DebugMessage -Message (' Notice: Python Module "' + $Modules + '" Install')
  DebugMessage -Message '-----------------------------------------------------------------------------'

  # Test to see if the user has an internet connection by checking a connection to google.
  if (!(Test-Connection "google.com" -Quiet))
  {
    # Allows skipping the error message in case I want to put one somewhere else.
    if (!$SkipError)
    {
      # If an internet connection was not found, then alert the user.
      $Title   = 'CTT-PS Error: Not Online'
      $Message = 'An internet connection is required to download/update required Python files. These files are required to run this operation, so excution has been cancelled.'
      ShowOKDialog -Title $Title -SizeX (DPISize 290) -SizeY (DPISize 40) -OffsetX (DPISize 8) -OffsetY (DPISize 6) -Message $Message

      # Debug: Show that there is no internet connection.
      DebugMessage -Message ' An internet connection was not detected!'
      DebugMessage -Message '-----------------------------------------------------------------------------'
    }
    # Can't do much without internet so get out of here.
    return $false
  }
  # Update pip because why not.
  PythonUpdatePip

  # If we got here, it's not installed so install the python module.
  & $Python '-m' 'pip' 'install' $Modules '--no-warn-script-location'

  # Debug: Notify me that it wasn't found.
  DebugMessage -Message ' The module should now be installed!'
  DebugMessage -Message '-----------------------------------------------------------------------------'

  # All I can do is assume it installed correctly.
  return $true
}
#==============================================================================================================================================================================================
#  EXTERNAL TOOLS: TRAILS OF COLD STEEL PKG TOOLS
#==============================================================================================================================================================================================
#  Extracts or repacks a Trails of Cold Steel PKG file using the "Kiseki PKG Tool" by Sewer56 or "PKG Tool" by thesupersonic16.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunPKGTool([string]$PKGFile)
{
  # A block of code is needed to pass to the job.
  $ThreadedScript = {

    # Everything that is passed through needs to be copied over.
    Param ([string]$PhyrePKGTool,[string]$PKGFile)

    # The PKG Tool by Sewer56.
    if ($PhyrePKGTool -like '*.dll')
    {
      # This PKG Tool uses .NET Core to work.
      & 'dotnet' $PhyrePKGTool $PKGFile 2>&1>$null
    }
    # The PKG Tool by thesupersonic16.
    else
    {
      # This PKG Tool can be straight up ran.
      & $PhyrePKGTool $PKGFile
    }
  }
  # Start the job to create the image.
  $Job = Start-Job -Name 'ThreadedScript' -Scriptblock $ThreadedScript -ArgumentList $PhyrePKGTool,$PKGFile

  # Lock certain elements of the script into a loop while the job runs.
  StartJobLoop -Name 'ThreadedScript' -Program 'PKG Tool'
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: TEXTURE VALIDATION
#==============================================================================================================================================================================================
#  Checks for the tilde character in the path and allows bypassing it under certain conditions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateTilde([string]$InputPath)
{
  # Check to see if the tilde character is in the path.
  if ($InputPath -like '*~*')
  {
    # Depending on the operation, when a tilde passes can change.
    switch -wildcard ($MasterOperation)
    {
      # Calculate Textures VRAM Requirement
      'CalculatingVRAM' { $BypassTilde = (TestPath -LiteralPath $VRAMPackPath) }

      # Convert Phyre Textures to PNG Textures
      'ConvertPhyrePNG' { $BypassTilde = $PhyrePreviousPath }

      # Create Phyre Textures From PNG/Phyre
      'CreateFromPhyre' { $BypassTilde = $PhyrePreviousPath }

      # Repack Folders/Textures Into PKG Files
      'PackIntoPKGFile' { $BypassTilde = $PhyrePreviousPath }
    }
    # If the tilde was not bypassed.
    if (!$BypassTilde)
    {
      # Debug:Show a debug message saying the texture was skipped.
      DebugMessage -Message '-- Tilde character "~" found in path. Skipping texture.'

      # In this situation, we skip the texture.
      return $false
    }
  }
  # There is no tilde or it was bypassed.
  return $true
}
#==============================================================================================================================================================================================
#  Allows files to pass that are not textures when certain operations are selected.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateNonTexture($InputItem)
{
  # Splitting textures has a special mode to batch (.ctt) files.
  if (($MasterOperation -eq 'SplitMultiImage') -and ($SplitBatchImages))
  {
    # Verify that it has the correct extension.
    return ($InputItem.Extension -eq $CTT)
  }
  # The Phyre Mode options present a bunch of new file types to verify. Also verify them if using the Basic Image Viewer.
  elseif ($CTTPSSelectedMode -eq 'Phyre Mode')
  {
    # Depending on the operation, allow certain files to pass.
    switch ($MasterOperation)
    {
      # Extract Trails of Cold Steel PKA Files
      'ExtractPKAFiles'
      {
        # Check to see if it has the (.pka) extension.
        return ($InputItem.Extension -eq $PKA)
      }  
      # Extract Trails of Cold Steel PKG Files
      'ExtractPKGFiles'
      {
        # Check to see if it has the (.pkg) extension.
        return ($InputItem.Extension -eq $PKG)
      }
      # Convert Phyre Textures to PNG Textures
      'ConvertPhyrePNG'
      {
        # Here we want (.phyre) and (.header) files.
        if ($InputItem.Extension -eq '.header') { return $true }

        # If it's a phyre file, also make sure it's a phyre image.
        if ($InputItem.Extension -eq '.phyre')
        {
          # Create an array of accepted phyre image types.
          $PhyreTypes = @($PNG,$DDS,$BMP)

          # Get the last four characters of the phyre image.
          $PhyreExt = $InputItem.BaseName.Substring(($InputItem.BaseName.Length -4), 4)

          # If it's a phyre image then we're off to the races.
          return ($PhyreTypes -contains $PhyreExt)
        }
      }
      # Repack Folders/Textures Into PKG Files
      'PackIntoPKGFile'
      {
        # In this rare instance we only want folder paths.
        if (TestPath -LiteralPath $InputItem.FullName -PathType 'Container')
        {
          # The folder path must contain the file the asset XML file.
          $AssetPath = $InputItem.FullName + '\asset_D3D11.xml'

          # Return whether or not that file exists in the path.
          return (TestPath -LiteralPath $AssetPath)
        }
      }
    }
  }
  # If nothing above passed the tests, then test the file as a texture.
  return $false
}
#==============================================================================================================================================================================================
#  Tests if the input is actually a file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateImageFile([string]$ImageFile)
{
  # Make sure the path is actually a file.
  if (TestPath -LiteralPath $ImageFile -PathType 'Container')
  {
    # This is not an image it's actually a folder.
    return $false
  }
  # It's really an image.
  return $true
}
#==============================================================================================================================================================================================
#  Tests the extension of the texture to see if it is PNG, DDS, or JPG.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateExtension([string]$Extension)
{
  # The supported extensions depends on the selected mode.
  $ExtCheck = @($PNG,$DDS,$JPG,$BMP,$TGA,$TIF,$TIFF,$WEBP,$ICO)

  # An ugly workaround to force validation of any file when input extension is wildcard.
  if (($MasterOperation -eq "ExecutableBatch") -and ($CLIInputExtensionsBox.Text -eq ".*"))
  {
    return $true
  }
  # Make sure the texture has a valid extension.
  if ($ExtCheck -contains $Extension)
  {
    # Yay a valid image file.
    return $true
  }
  # It's not an image or it has no extension.
  return $false
}
#==============================================================================================================================================================================================
#  Checks to see if the texture has a valid file name + extension.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateTextureName([string]$ImageName)
{
  # See if the name contains a mipmap identifier.
  if ($ImageName -like '*_mip*')
  {
    # The texture is a mipmap so fail validation.
    return $false
  }
  # Check to see if it is a Dolphin texture.
  if ($ImageName -like 'tex1_*')
  {
    # Create an array with every type of material.
    $MaterialList = @('*.bump*','*.spec*','*.nrm*','*.lum*','*.mat*')

    # Loop through each type of material.
    foreach ($Material in $MaterialList)
    {
      # Check to see if the image contains the material.
      if ($ImageName -like $Material)
      {
        # Do not validate materials or material maps.
        return $false
      }
    }
    # The file name and extension passes all validity checks.
    return $true
  }
  # Check to see if it is Venomalia's "combined RGBA" texture.
  if ($ImageName -like 'RGBA_*x*_*')
  {
    # Validate the texture if in Dolphin Mode.
    return ($CTTPSSelectedMode -eq "Dolphin Mode")
  }
  # If it's not a Dolphin texture and it's not Dolphin Mode always pass the texture.
  return ($CTTPSSelectedMode -ne "Dolphin Mode")
}
#==============================================================================================================================================================================================
#  DDS Headers are mostly standardized, but it's not uncommon for different compression programs to get a few flags wrong. This function will search for any issues found in a DDS header 
#  and attempt to repair them. Uses several of the repair functions found above this one. One such issue is Compressonator sets the DDPF_ALPHAPIXELS flag in the pixel format header which 
#  makes the image unreadable by TexConv. This function removes that flag when the image is read. It also fixes an issue with Ishiiruka DDS color textures which also sets a flag in the 
#  pixel format header. This flag is DDPF_RGB which makes the image unreadable by almost all programs so it is also removed. More info can be found below. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateDDSHeader([string]$ImageFile)
{
  # Get the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # Get the first 8 bytes of the image from the byte array.
  $HeaderBytes = [BitConverter]::ToString($ByteArray[0..7])

  # Bad headers will generate powershell warnings. The user does not need to know this info, and neither do I, so hide it.
  $ErrorActionPreference = 'silentlycontinue'

  # Validate the header bytes.
  if (!($HeaderBytes -eq '44-44-53-20-7C-00-00-00')) { return $false }

  # Store the value of these bytes. If they are different at the end, rewrite the texture.
  $OldByte28 = $ByteArray[28]
  $OldByte80 = $ByteArray[80]

  # The DDS header from bytes 85-88 should hold the FOURCC value to identify the compression format or if it has a DX10 header.
  # DXT1: 44-58-54-31, DXT3: 44-58-54-31, DXT5: 44-58-54-35, DX10: 44-58-31-30
  $FourCC = GetDDSFourCC -ByteArray $ByteArray

  #=============================================================================
  # MIPMAP REPAIR
  #=============================================================================
  # If the mipmap flag is 0, set it to 1. The top level counts as a mipmap.
  if ($ByteArray[28] -eq 0) { $ByteArray[28] = 1 }

  # Some broken textures have the mipmap flag set, but don't actually contain mipmaps. So let's try to fix this now.
  $ImageInfo = CreateTextureInfo -ImageFile $ImageFile -Extended

  # If working with a DX10 texture, the header is 144 bytes. For DX9 textures, it's 128 bytes.
  if ($ImageInfo.DDSFourCC -eq 'DX10') { $HeaderSize = 148 } else { $HeaderSize = 128 }

  # Calculate the texture size without mipmaps.
  $ByteCount = GetDDSByteCount -Format $ImageInfo.Format -Width $ImageInfo.Width -Height $ImageInfo.Height -HeaderLength $HeaderSize

  # If the mipmap flag is greater than 1, and the calculated size does not match the actual size, it does NOT have mipmaps.
  if (($ByteArray[28] -gt 1) -and ($ByteArray.Length -eq $ByteCount)) { $ByteArray[28] = 1 }

  #=============================================================================
  # REPAIR OTHER KNOWN HEADER ISSUES
  #=============================================================================
  # Fix any known issues with D3D9 DXT textures.
  if ($FourCC -like 'DXT*')
  {
    # Get the RGB flags set at Byte[80].
    $DDPF_RGB = [int]([BitConverter]::ToString($ByteArray[80]).Substring(0,1))

    # Remove the DDPF_RGB flag since it is not used in an uncompressed texture.
    if ($DDPF_RGB -eq 4) { $ByteArray[80] = $ByteArray[80] - 64 }

    # Get the alpha pixel format flags set at Byte[80].
    $DDPF_Alpha = [int]([BitConverter]::ToString($ByteArray[80]).Substring(1,1))

    # Fix it if it's greater than 5. DXT textures should not have uncompressed data.
    if ($DDPF_Alpha -gt 5) { $ByteArray[80] = $ByteArray[80] - ($DDPF_Alpha - 5) }
  }
  # Verify that the DX10 type is known.
  elseif ($FourCC -like 'DX10')
  {
    # Get the value found at byte 128 (this holds the block compression type).
    $DX10BCFlag = [Convert]::ToInt32([BitConverter]::ToString($ByteArray[128]), 16)

    # Get the block compression type from a compiled list.
    $BlockCompression = GetDX10BlockCompression -DXGI_FORMAT $DX10BCFlag

    # See if the compression type is unknown.
    if ($BlockCompression -eq 'Unknown')
    {
      # Alert the user this is an unsupported type.
      TexList_SetTextureStatus -Status 'File' -Message 'DDS block compression type not supported by this script!'

      # Fail the texture since this script won't know wtf to do with it.
      return $false
    }
  }
  # If the header changed at all, rewrite the texture with changes. 
  if (($ByteArray[28] -ne $OldByte28) -or ($ByteArray[80] -ne $OldByte80))
  {  
    # Overwrite the old file with the corrected header.
    [IO.File]::WriteAllBytes($ImageFile, $ByteArray)
  }
  # All conditions pass so the header is good.
  return $true
}
#==============================================================================================================================================================================================
#  Tests if a TGA header is valid by checking several values.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateTGAHeader([string]$ImageFile)
{
  # Get the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # Create an array to store the checks in.
  $ValidateTGA = New-Object bool[] 3

  # Type of colour map (0=none, 1=has palette)
  $ValidateTGA[0] = (($ByteArray[1] -eq 0) -or ($ByteArray[1] -eq 1))

  # Type of image (0=none,1=indexed,2=rgb,3=grey,+8=rle packed)
  $ValidateTGA[1] = (($ByteArray[2] -in 0..3) -or ($ByteArray[2] -in 9..11))  

  # Image bits per pixel (8,16,24,32).
  $ValidateTGA[2] = (($ByteArray[16] -eq 8) -or ($ByteArray[16] -eq 16) -or ($ByteArray[16] -eq 24) -or ($ByteArray[16] -eq 32))  

  # Test to see if all of these conditions match. I could check more stuff but this should be sufficient.
  if (TestBooleanArray -And -Array $ValidateTGA)
  {
    # All conditions pass so the header is good.
    return $true
  }
  # The header failed a check so it's bad.
  return $false
}
#==============================================================================================================================================================================================
#  Tests an image for validity by reading the first few bytes of the header. DDS textures have their headers fully analyzed and repaired using the function above this one.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateImageHeader([string]$ImageFile)
{
  # An ugly workaround to force validation of any file when input extension is wildcard.
  if (($MasterOperation -eq "ExecutableBatch") -and ($CLIInputExtensionsBox.Text -eq ".*"))
  {
    return $true
  }
  # Get the image as an item to get properties from it.
  $ImageItem = Get-Item -LiteralPath $ImageFile

  # Get the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # Each file type will have a different set of bytes to compare to.
  switch ($ImageItem.Extension)
  {
    # PNG we'll just check the first 8 bytes. If they are good, assume the rest of the image is too.
    $PNG  {
            # Get the first 8 bytes of the image from the byte array.
            $HeaderBytes = [BitConverter]::ToString($ByteArray[0..7])

            # Validate the first 8 bytes of the PNG header.
            if ($HeaderBytes -eq '89-50-4E-47-0D-0A-1A-0A') { return $true }
          }
    # A lot can be wrong with a DDS header, so verify it further and apply any fixes.
    $DDS  {
            # It's rather complex so perform everything in its own function.
            return (ValidateDDSHeader -ImageFile $ImageFile)
          }
    # JPG is forced true for now until I come up with a solution (which I may never care to).
    $JPG  { return $true }

    # BMP is forced true for now until I come up with a solution (which I may never care to).
    $BMP  { return $true }

    # TIF images have either 4D-4D "MM" (Motorola byte order / big-endian) or 49-49 "II" (Intel byte order / little-endian) in the first two bytes.
    $TIF  {
            # Get the first 2 bytes of the image from the byte array.
            $HeaderBytes = [BitConverter]::ToString($ByteArray[0..1])

            # Validate the first 2 bytes of the header.
            if (($HeaderBytes -eq '4D-4D') -or ($HeaderBytes -eq '49-49')) { return $true }
          }
    # TIFF images are the same as TIF so just do the same checks.
    $TIFF {
            # Get the first 2 bytes of the image from the byte array.
            $HeaderBytes = [BitConverter]::ToString($ByteArray[0..1])

            # Validate the first 2 bytes of the header.
            if (($HeaderBytes -eq '4D-4D') -or ($HeaderBytes -eq '49-49')) { return $true }
          }
    # WEBP images are forced true for now until I come up with a solution (which I may never care to).
    $WEBP { return $true }

    # TGA headers are rather simple, but checking the values requires more space than I want to use here.
    $TGA  {
            # Validate the TGA header using a special function to check certain values.
            return (ValidateTGAHeader -ImageFile $ImageFile)
          }

    # Icons are forced true for now until I come up with a solution (which I may never care to).
    $ICO  { return $true }
  }
  # The texture header is corrupt so copy it. But don't copy it when calculating VRAM for textures.
  if (!($MasterOperation -eq 'CalculatingVRAM'))
  {
    # Get the relative path to the iamge.
    $Relative = GetRelativePath -TexturePath $ImageItem.DirectoryName -Basic

    # Copy corrupt texture to the output path.
    $CorruptPath = CreatePath -LiteralPath ($MasterOutputPath + '\CorruptTextures' + $Relative)
    Copy-Item -LiteralPath $ImageFile -Destination $CorruptPath -Force
  }
  # Debug:Show me that the texture is corrupted.
  DebugMessage -Message '-- Texture Corrupted'

  # Return false to report back that the image is invalid.
  return $false
}
#==============================================================================================================================================================================================
#  Tests if a path/file is a valid texture when creating the Texture Hash Table, using partial data from the Texture Hash Table.
#  I don't really like multiple conditions with the same return, I'd rather check all conditions at once. But this way allows it to fail early so it's faster.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Create this list now so it isn't created every single texture. This is a list of operations where validation should pass for "not textures". Splitting images allows 
# passing the (.ctt) files generated when combining textures. The rest are "Phyre Mode" options that pass (.pka .pkg .phyre .header) files and images.
$global:NonTextureOps = @('SplitMultiImage','ExtractPKAFiles', 'ExtractPKGFiles', 'PackIntoPKGFile', 'ConvertPhyrePNG')

# And here is the function.
function ValidateFile($InputItem)
{
  # If we can't get the path then what can we do with it.
  if (TestPath -LiteralPath $InputItem.FullName)
  {
    # Get the attributes of the file.
    $Attributes = [IO.FileInfo]::New($InputItem.FullName).Attributes

    # Do not try to work with hidden files as it fails.
    if ($Attributes -like '*Hidden*') { DebugMessage -Message '-- Hidden files are not processed.' ; return $false }
  }
  # If somehow there's no file then fail validation.
  else { return $false }

  # Debug: Let me know a texture is about to be processed.
  DebugMessage -Message '- Validation Start for file:' -FollowUp $InputItem.FullName

  # Certain operations require a different kind of validation.
  if ($NonTextureOps -contains $MasterOperation)
  {
    # The first step is to check for the tilde character.
    if (!(ValidateTilde -InputPath $InputItem.FullName))     { DebugMessage -Message '--- 1/2: Validate Tilde Fail'        ; return $false } ; DebugMessage -Message '--- 1/2: Tilde Character Validated'

    # Try to validate files that are not textures.
    if (!(ValidateNonTexture -InputItem $InputItem))         { DebugMessage -Message '--- 2/2: Validate Non-Texture Fail' ; return $false } ; DebugMessage -Message '--- 2/2: Non-Texture Validated'

    # Try to validate files that are not textures.
    return $true
  }
  # The first step is to check for the tilde character.
  if (!(ValidateTilde -InputPath $InputItem.FullName))       { DebugMessage -Message '-- 1/5: Validate Tilde Fail'        ; return $false } ; DebugMessage -Message '--- 1/5: Tilde Character Validated'

  # Make sure the texture has a valid extension.
  if (!(ValidateImageFile -ImageFile $InputItem.FullName))   { DebugMessage -Message '-- 2/5: Validate File Fail'         ; return $false } ; DebugMessage -Message '--- 2/5: Texture File Validated'

  # Make sure the texture has a valid extension.
  if (!(ValidateExtension -Extension $InputItem.Extension))  { DebugMessage -Message '-- 3/5: Validate Extension Fail'    ; return $false } ; DebugMessage -Message '--- 3/5: Texture Extension Validated'

  # Validate the name of the texture.
  if (!(ValidateTextureName -ImageName $InputItem.Name))     { DebugMessage -Message '-- 4/5: Validate Name Fail'         ; return $false } ; DebugMessage -Message '--- 4/5: Texture FileName Validated'

  # Validate the image header.
  if (!(ValidateImageHeader -ImageFile $InputItem.FullName)) { DebugMessage -Message '-- 5/5: Validate Header Fail'       ; return $false } ; DebugMessage -Message '--- 5/5: Texture Header Validated'

  # If we made it this far it's a valid texture.
  return $true
}
#==============================================================================================================================================================================================
#  DOCUMENTATION: TEXTURE HASH TABLE
#==============================================================================================================================================================================================
#  When a texture is ran through the main loop, a global hash table is created for the current texture called "$Texture". Many of this script's functions rely on this global hash table 
#  and are designed around having its data readily available. Each iteration of the loop creates a new hash table for the current texture and discards the data from the last one.
#  Eventually this hash table and all supporting functions was rewritten to be more dynamic, in that it can be created for any image file at any time.
#  Below is a list of all information that can be retrieved when a hash table for the current texture has been created.
#==============================================================================================================================================================================================
#  $Texture.Name                 - string    -  The name of the texture without the extension.
#  $Texture.FullName             - string    -  The name of the texture with the file extension.
#  $Texture.Extension            - string    -  The file extension of the texture file.
#  $Texture.Path                 - string    -  The path to where the texture is currently located, minus the texture name.
#  $Texture.PathName             - string    -  The full path to the texture including the texture name without the file extension.
#  $Texture.FullPath             - string    -  The full path to the texture including the texture name with the file extension.
#  $Texture.Relative             - string    -  The relative path to the texture, which is the Path minus the MasterInputPath (location of the script).
#  $Texture.Dolphin              - boolean   -  Stores true or false whether or not the texture is in Dolphin's texture format (starts with "tex1").
#  $Texture.DBTexture            - boolean   -  Stores true or false whether or not the texture is found in a texture size database ($DatabaseName).
#  $Texture.Height               - integer   -  The height of the custom texture.
#  $Texture.Aspect               - decimal   -  The aspect of the custom texture (Width/Height)
#  $Texture.OldWidth             - integer   -  The width of the original texture.
#  $Texture.OldHeight            - integer   -  The height of the original texture.
#  $Texture.OldAspect            - decimal   -  The aspect of the original texture (OldWidth/OldHeight)
#  $Texture.OldDimensions        - string    -  The full dimensions of the original texture in the form of (OldWidth x OldHeight).
#  $Texture.ScaleWidth           - decimal   -  The width scale of the custom texture (Width/OldWidth).
#  $Texture.ScaleHeight          - decimal   -  The height scale of the custom texture (Height/OldHeight).
#  $Texture.FullScale            - string    -  The full scale of the texture in the form of "ScaleWidth x ScaleHeight" (but no spaces in between).
#  $Texture.IsIcon               - boolean   -  Stores true or false of whether or not the texture is an icon file.
#  $Texture.IsMipmap             - boolean   -  Stores true or false of whether or not the texture is a Mipmap texture.
#  $Texture.ArbMips              - boolean   -  Stores true or false of whether or not the texture contains the arbitrary mipmap flag.
#  $Texture.HasMatMap            - boolean   -  Stores true or false of whether or not the texture has a supplied material map (nrm) texture.
#  $Texture.MatMap               - string    -  The full path to the texture's supplied material map.
#  $Texture.HasMats              - boolean   -  Stores true or false of whether or not the texture has supplied materials (bump/spec/lum/nrm) textures.
#  $Texture.PNGColorType         - string    -  If the texture is to be converted to PNG, stores the type of PNG (0, 2, 4, or 6).
#  $Texture.PNGColorSpace        - string    -  If the texture is to be converted to PNG, stores the color space (Gray, GrayA, RGB, or RGBA).
#  $Texture.PNGBitDepth          - string    -  If the texture is to be converted to PNG, stores the bit depth (8, 16, 24, or 32).
#  $Texture.DDSCompression       - string    -  If the texture is to be converted to DDS, stores the compression type: BC1, BC3, ARGB8, RGBA8, BC7.
#==============================================================================================================================================================================================
#  The function "GetImageInfo" found below can get just some basic info about the image.
#==============================================================================================================================================================================================
#  $Texture.Format               - string    -  The file type: PNG,JPG,TIF,TIFF,TGA,WEBP. Stores the compression type for DDS: BC1,BC2,BC3,BC4,BC5,BC6,BC7,RGB8,RGBA8,ARGB8,L8,A8,LA8
#  $Texture.Size                 - integer   -  The size of the image in Bytes.
#  $Texture.Width                - integer   -  The width of the image.
#  $Texture.Height               - integer   -  The height of the image.
#  $Texture.Dimensions           - string    -  The full dimensions of the image (ex: 128x128).
#  $Texture.Mipmaps              - integer   -  The number of mipmaps, internal (DDS/TIFF) or external (PNG/JPG/TGA)
#  $Texture.Gray                 - boolean   -  True/False the image is a grayscale texture.
#  $Texture.Alpha                - boolean   -  True/False the image contains an alpha channel.
#  $Texture.DDSFourCC            - string    -  DDS Only. The FourCC value found in a DDS header. Empty string for other image formats.
#  $Texture.DDSRGB               - string    -  DDS Only. Keeps track of whether or not the texture has SRGB colorspace.
#==============================================================================================================================================================================================
#  TEXTURE CREATION: TEXTURE HASH TABLE - HELPER FUNCTIONS
#==============================================================================================================================================================================================
#  The relative path to the texture. Think of it as the location of the texture with the entire "Master Input Path" removed from it.
#  For example, if the input path is "C:\Textures", and a texture is in "C:\Textures\Skies", the relative path is "\Skies".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetRelativePath([string]$TexturePath, [switch]$Basic=$false)
{
  # Setting the "relative" path is a bit tricky when using process selected menu.
  if (($ProcessSelected) -and (!$Basic))
  {
    # When adding textures, an array of potential "MasterPaths" should have been created.
    foreach ($MasterPath in $ProcessMasterPaths)
    {
      # Debug: I'm sick of this stupid function breaking, so do some extensive debugging info for awhile.
      DebugMessage -Message ' '
      DebugMessage -Message 'Process Selected: Relative Path'  -FollowUp ' '
      DebugMessage -Message ('MasterPath   : ' + $MasterPath)   -FollowUp ('TexturePath  : ' + $TexturePath)
      DebugMessage -Message ('MasterPath   = TexturePath = ' + ($TexturePath -like ($MasterPath + '*')))

      # Get the path as an item so its easy to get the folder name.
      $MasterItem = Get-Item -LiteralPath $MasterPath

      # If the texture is not part of the current master path then move on to the next one.
      if ($TexturePath -notlike ($MasterPath + '*')) { continue }

      # Use this term to count how many times the folder name appears in the path.
      $SplitString = '\\' + $MasterItem.Name

      # Count the number of instances the folder name appears. (ex: "C:\Test\Folder\Test", the double "Test" will cause problems).
      $CountInstances = ($MasterPath -split $SplitString).Count - 1

      # Debug: More debugging info because fuck this function and Process Selected.
      DebugMessage -Message ('Split Term   : ' + $SplitString)    -FollowUp ('Path Split   : ' + $MasterPath)
      DebugMessage -Message ('Instances    : ' + $CountInstances) -FollowUp ('Greater >1   : ' + ($CountInstances -gt 1))

      # If there is more than one instance of the folder name, a work-around is needed.
      if ($CountInstances -gt 1)
      {
        # Set up the term to attempt to match the name of the last folder in the path.
        $SearchTerm = '\' + $MasterItem.Name

        # A Substring of the master path is used to get the last folder. Set the position by using the difference in length between the master path and search term.
        $DiffPos = $MasterPath.Length - $SearchTerm.Length

        # Set the term to attempt to match by pulling an equal amount of characters from the end of the path string.
        $MatchTerm = $MasterPath.Substring($DiffPos, $SearchTerm.Length)
  
        # Debug: More debugging info because fuck this function and Process Selected.
        DebugMessage -Message ('Search Term  : ' + $SearchTerm)        -FollowUp ('Match Term   : ' + $MatchTerm)
        DebugMessage -Message ('MasterLength : ' + $MasterPath.Length) -FollowUp ('SearchLength : ' + $SearchTerm.Length)
        DebugMessage -Message ('Diff Position: ' + $DiffPos + ' (MasterLength - SearchLength)')
        DebugMessage -Message ('SearchTerm   = MatchTerm = ' + ($SearchTerm -eq $MatchTerm))

        # See if the texture path contains the current master path.
        if ($SearchTerm -eq $MatchTerm)
        {
          # Show me which relative path method was used.
          DebugMessage -Message ' ' -FollowUp 'Relative Method: Process Selected - Handle Multiple Folders With Similar Name'

          # Set up the final string before replacing 
          $FinalString = $MasterPath.Substring(0, $DiffPos)

          # Replace just the master path to get the relative path.
          return $TexturePath.Replace($FinalString,'')
        }
      }
      # Add a forward slash to the path so matching the end is easier.
      $MasterPath = $MasterPath + '\'

      # Now wrap the folder name in slashes so we get a perfect match.
      $ReplaceTerm = '\' + $MasterItem.Name + '\'

      # Trim the folder name from the master path.
      $ReplacePath = $MasterPath.Replace($ReplaceTerm,'')

      # Debug: And even more garbage clogging up my function.
      DebugMessage -Message ('New Master   : ' + $MasterPath)   -FollowUp ('ReplaceTerm  : ' + $ReplaceTerm)
      DebugMessage -Message ('ReplacePath  : ' + $ReplacePath)  -FollowUp ('Texture      = ReplacePath = ' + ($TexturePath -like ('*' + $ReplacePath + '*')))

      # See if the texture path contains the current master path.
      if ($TexturePath -like ('*' + $ReplacePath + '*'))
      {
        # Show me which relative path method was used.
        DebugMessage -Message ' ' -FollowUp 'Relative Method: Process Selected - Trim Folder From Master / Trim Master From Texture'

        # Replace just the master path to get the relative path.
        return $TexturePath.Replace($ReplacePath,'')
      }
    }
    # Show me which relative path method was used.
    DebugMessage -Message ' ' -FollowUp 'Relative Method: FAILED! Shit is probably going to break now.'
  }
  # Combined RGBA textures that were split require special handling.
  if ($TexturePath -like ("*Temp\SplitRGBA*"))
  {
    # Set the path to remove to create a relative path.
    $TempRGBAPath = $TempFolder + '\SplitRGBA'

    # Return the new relative path to the texture.
    return $TexturePath.Replace($TempRGBAPath,'')
  }
  # The texture will always be found in the master input path so this always works.
  return $TexturePath.Replace($MasterInputPath,'')
}
#==============================================================================================================================================================================================
#  Get various information about material maps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMaterialMapInfo([hashtable]$TextureInfo)
{
  # Create and store the values using a hash table.
  $MatMapData = @{}

  # Set the path to the material map. This is set even if the material does not exist.
  $MatMapData.MatMap = ($TextureInfo.PathName + '.mat' + $TextureInfo.Extension)

  # Try to find a material map with ".mat" extension.
  $MatMapData.HasMatMap = (TestPath -LiteralPath $MatMapData.MatMap)

  # Set up a series of checks in an array to determine if the texture has the required materials.
  $HasMaterialsChecks = New-Object bool[] 4

  # Go through and store the result of each check into the array.
  $HasMaterialsChecks[0] = ($TextureInfo.Extension -eq $PNG)
  $HasMaterialsChecks[1] = (TestPath -LiteralPath ($TextureInfo.PathName + '.bump' + $PNG))
  $HasMaterialsChecks[2] = (TestPath -LiteralPath ($TextureInfo.PathName + '.spec' + $PNG))
  $HasMaterialsChecks[3] = (TestPath -LiteralPath ($TextureInfo.PathName + '.nrm'  + $PNG))

  # If all conditions pass return true.
  $MatMapData.HasMats = (TestBooleanArray -And -Array $HasMaterialsChecks)

  # Return the material map data.
  return $MatMapData
}
#==============================================================================================================================================================================================
#  Calculates the aspect ratio of a texture using the width and height.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CalculateAspectRatio([int]$Width, [int]$Height)
{
  # First calculate the aspect difference.
  $Aspect = ($Width / $Height).ToString()

  # Some countries use commas instead of periods for decimals.
  if ($Aspect -like '*,*')
  {
    # If a comma is found, replace it with a period.
    $Aspect = $Aspect.Replace(',','.')
  }
  # Now split on the period.
  $PeriodSplit = $Aspect.Split('.', 2)

  # Powershell trickery: convert the integer part of the string into an actual integer, then back into a string. This will remove any leading 0s, or make it 0 if a number was not found.
  $IntValue = ([int]$PeriodSplit[0]).ToString()
  $DecValue = $PeriodSplit[1]

  # How the decimal value will be formatted depends on the number of characters available in the decimal value.
  $DecimalPlaces = (($DecValue | Measure-Object -Character).Characters).ToString()

  # A switch works well here because the range is 0-1, anything beyond, and nothing negative.
  switch ($DecimalPlaces)
  {
    '0'     { $AspectRatio = $IntValue }
    '1'     { $AspectRatio = $IntValue + '.' + $DecValue }
    default { $AspectRatio = $IntValue + '.' + $DecValue.Substring(0,2) }
  }
  # Return the new value.
  return [decimal]$AspectRatio
}
#==============================================================================================================================================================================================
#  If a texture has alpha, chooses BC3 compression. Otherwise chooses BC1 compression.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DXTGetTypeByAlpha([bool]$Alpha)
{
  # Selectively choose BC3 for textures with an alpha channel.
  if ($Alpha) { return 'BC3' }

  # And BC1 for opaque textures. 
  return 'BC1'
}
#==============================================================================================================================================================================================
#  If a texture path does not have a flag, get the fallback compression type.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetFallbackCompression([bool]$Alpha)
{
  # Selectively choose BC1 for opaque textures, and BC3 for textures with an alpha channel.
  if ($DDSFallbackCompress -eq 'BC1/BC3')
  {
    return (DXTGetTypeByAlpha -Alpha $Alpha)
  }
  # We can just return the value if it's BC3, BC7, or ARGB8.
  return $DDSFallbackCompress
}
#==============================================================================================================================================================================================
#  A list of all DDS flags that this script can use. This array is also used further down in the flag removal functions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$global:DDSFlagArray = @('_BCX','_BC1','_BC2','_BC3','_BC4','_BC5','_BC6','_BC7','_ARGB8','_RGBA8','_L8','_A8','_LA8')
#==============================================================================================================================================================================================
#  If a texture or folder contains a compression flag when *Search Flags* is enabled, find the flag value.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FindCompressionFlag([string]$ImageFile, [bool]$Alpha)
{
  # BCX gets its own special little function.
  if ($ImageFile -like '*_BCX*')
  {
    # Get the type that will be created (DXT1 or DXT5).
    return DXTGetTypeByAlpha -Alpha $Alpha
  }
  # Loop through all flags in an attempt to find one in the texture path.
  foreach ($Flag in $DDSFlagArray)
  {
    # Create a wildcard version of the flag with the underscore.
    $FlagWild = '*' + $Flag + '*'

    # Compare the path to the wildcard flag.
    if ($ImageFile -like $FlagWild)
    {
      # If a flag was found, grab the hash(es) from the texture.
      $Hash = (Get-Item -LiteralPath $ImageFile).Name.Split('_')

      # Set the new flag value.
      $NewFlag = $Flag.Replace('_', '')

      # Special care needs to be taken with Dolphin textures.
      if ($Hash[0] -eq 'tex1')
      {
        # Compare the flag to the hashes to make sure a hash didn't set off a false positive.
        $HashCheckA = '_' + $Hash[2]
        $HashCheckB = '_' + $Hash[3]
        $HashCheckC = '_' + $Hash[4]

        # Make sure the flag was not triggered by the texture hashes.
        if (($HashCheckA -notlike $FlagWild) -and ($HashCheckB -notlike $FlagWild) -and ($HashCheckC -notlike $FlagWild))
        {
          # Return the flag that was found.
          return $NewFlag
        }
      }
      # It's not a Dolphin texture so the flag can just be returned.
      else
      {
        # Return the flag that was found.
        return $NewFlag
      }
    }
  }
  # The texture path did not have a flag, so use the fallback compression set.
  return GetFallbackCompression -Alpha $Alpha
}
#==============================================================================================================================================================================================
#  If the user selected *Passthrough* as the DDS compression type, then find the compression type of the input texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPassthroughCompression([string]$ImageFormat, [string]$Extension, [bool]$Alpha)
{
  # Passthrough will only work if the input texture is a DDS texture.
  if ($Extension -eq $DDS)
  {
    # Fortunately this is already known via TextureInfo, so just return it.
    return $ImageFormat
  }
  # If the input texture is not a DDS texture, use the fallback compression.
  return GetFallbackCompression -Alpha $Alpha
}
#==============================================================================================================================================================================================
#  If a texture is to be converted to DDS, this sets the type of block compression. The compression can be forced using the "*Search Flags*" option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSBlockCompressionType([hashtable]$TextureInfo)
{
  # The variable "$DDSBlkCompress" references the item that is selected from the GUI labelled "DDS Compression".
  switch ($DDSBlkCompress)
  {
    # Selectively choose BC1 for opaque textures, and BC3 for textures with an alpha channel.
    'BC1/BC3'        { return DXTGetTypeByAlpha -Alpha $TextureInfo.Alpha }

    # If the user wants to define textures individually, find the format to convert the texture.
    '*Search Flags*' { return FindCompressionFlag -ImageFile $TextureInfo.FullPath -Alpha $TextureInfo.Alpha }

    # If the user wants to define textures individually, find the format to convert the texture.
    '*Passthrough*'  { return GetPassthroughCompression -ImageFormat $TextureInfo.Format -Extension $TextureInfo.Extension -Alpha $TextureInfo.Alpha }

    # We can just return the value if it's BC3, BC7, or ARGB8.
    default          { return $DDSBlkCompress }
  }
}
#==============================================================================================================================================================================================
#  Returns the PNG color type, color space, and bit depth so ImageMagick knows what type of PNG image to create. This is not exactly
#  the current properties of the image (though it may be accurate or close), but rather what the new image will be created as.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPNGInfo([hashtable]$TextureInfo)
{
  # Force 32-bit RGBA if the input is an icon file.
  if ($TextureInfo.IsIcon) { return @{ 'ColorType' = '6' ; 'ColorSpace' = 'RGBA'  ; 'BitDepth' = '32' } }

  # Check to see if it is a grayscale texture.
  if ($TextureInfo.Gray)
  {
    # Check to see if that grayscale texture has an alpha channel.
    switch ($TextureInfo.Alpha)
    {
      $true   { return @{ 'ColorType' = '4' ; 'ColorSpace' = 'GrayA' ; 'BitDepth' = '16' } }
      $false  { return @{ 'ColorType' = '0' ; 'ColorSpace' = 'Gray'  ; 'BitDepth' = '8'  } }
    }
  }
  # The texture contains colors. Lots of pretty colors.
  switch ($TextureInfo.Alpha)
  {
    $true   { return @{ 'ColorType' = '6' ; 'ColorSpace' = 'RGBA'  ; 'BitDepth' = '32' } }
    $false  { return @{ 'ColorType' = '2' ; 'ColorSpace' = 'RGB'   ; 'BitDepth' = '24' } }
  }
}
#==============================================================================================================================================================================================
#  Gets several properties from the image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetImageInfo([string]$ImageFile)
{
  # Create a hash table that will be added to the ImageInfo hash table.
  $ImageInfo = @{}
  $ImageItem = Get-Item -LiteralPath $ImageFile
  $ImageInfo.Size = $ImageItem.Length

  # Read the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # Store that the texture is in "X" format.
  $ImageInfo.Format = ExtensionToText -Extension $ImageItem.Extension

  #----------------------------------------------------------------------------
  # When it comes to PNG it's nice and straightforward.
  #----------------------------------------------------------------------------
  if ($ImageInfo.Format -eq 'PNG')
  {
    # Convert the hex value to decimal.
    $ImageInfo.Width  = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[16..19])).Replace('-','')),16)
    $ImageInfo.Height = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[20..23])).Replace('-','')),16)

    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($ImageInfo.Width, $ImageInfo.Height))

    # Count the number of external mipmaps.
    $ImageInfo.Mipmaps = CountExternalMipmaps -ImageFile $ImageFile -Levels $MipmapLevels

    # Read the color type from the header.
    $ColorType = [BitConverter]::ToString($ByteArray[25])

    # First check to see if the texture is grayscale.
    switch($ColorType)
    {
      # PNG types 0 (no alpha) and 4 (alpha) are grayscale formats.
      '00'    { $ImageInfo.Gray  = $true  ; $ImageInfo.Alpha = $false  }
      '02'    { $ImageInfo.Gray  = $false ; $ImageInfo.Alpha = $false  }
      '03'    { $ImageInfo.Gray  = $false ; $ImageInfo.Alpha = Magick-IdentifyAlpha -ImageFile $ImageFile   }
      '04'    { $ImageInfo.Gray  = $true  ; $ImageInfo.Alpha = $true  }
      '06'    { $ImageInfo.Gray  = $false ; $ImageInfo.Alpha = $true  }
      default { $ImageInfo.Gray  = $false ; $ImageInfo.Alpha = $false  }
    }
    # Since this is not a DDS texture, store a blank string.
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  #----------------------------------------------------------------------------
  # And the JPG format is not so straight forward so let's just cheat and use .NET which is a bit slower.
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -eq 'JPG')
  {
    # Get the image as a bitmap.
    $BitmapJPG = New-Object Drawing.Bitmap $ImageFile

    # Get the dimensions.
    $ImageInfo.Width  = $BitmapJPG.Width
    $ImageInfo.Height = $BitmapJPG.Height

    # Remove hook to the image.
    $BitmapJPG.Dispose()

    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($ImageInfo.Width, $ImageInfo.Height))

    # Count the number of external mipmaps.
    $ImageInfo.Mipmaps = CountExternalMipmaps -ImageFile $ImageFile -Levels $MipmapLevels

    # Test for grayscale but force alpha to false since JPG does not contain grayscale.
    $ImageInfo.Gray  = Magick-IdentifyGray -ImageFile $ImageFile 
    $ImageInfo.Alpha = $false

    # Since this is not a DDS texture, store a blank string.
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  #----------------------------------------------------------------------------
  # Then we come to DDS which is truly a nightmare in every way since its just a container for many image formats.
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -eq 'DDS')
  {
    # Convert the hex value to decimal. 
    $ImageInfo.Width   = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[19..16])).Replace('-','')),16)
    $ImageInfo.Height  = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[15..12])).Replace('-','')),16)

    # Read the number of mipmaps from the header. Subtract 1 to exclude the top level.
    $ImageInfo.Mipmaps = [Convert]::ToInt32(([BitConverter]::ToString($ByteArray[28])),16) - 1

    # Store the flag that is set in the FourCC field.
    $ImageInfo.DDSFourCC = GetDDSFourCC -ByteArray $ByteArray

    # Getting the image format is different depending on the value found in the FourCC flag.
    switch -wildcard ($ImageInfo.DDSFourCC)
    {
      # Check for DXTC textures and translate them to DX10 equivalents. 
      DXT1 { $ImageInfo.Format = 'BC1' }
      DXT2 { $ImageInfo.Format = 'BC2' }
      DXT3 { $ImageInfo.Format = 'BC2' }
      DXT4 { $ImageInfo.Format = 'BC3' }
      DXT5 { $ImageInfo.Format = 'BC3' }

      # Check for BC4 textures. The FourCC value could be any one of these.
      ATI1 { $ImageInfo.Format = 'BC4' }
      BC4U { $ImageInfo.Format = 'BC4' }
      BC4S { $ImageInfo.Format = 'BC4' }

      # Check for BC5 textures. The FourCC value could be any one of these.
      ATI2 { $ImageInfo.Format = 'BC5' }
      BC5U { $ImageInfo.Format = 'BC5' }
      BC5S { $ImageInfo.Format = 'BC5' }

      # Check for a DX10 header file.
      'DX10'
      {
        # Get the value found at byte 128 (this holds the block compression type).
        $DX10BCFlagHex = [BitConverter]::ToString($ByteArray[128])

        # Convert the hex value to decimal so it matches a value found from this chart:
        # https://msdn.microsoft.com/en-us/library/windows/desktop/bb173059(v=vs.85).aspx
        $DX10BCFlag = [Convert]::ToInt32($DX10BCFlagHex,16)

        # Get the block compression type from a compiled list.
        $ImageFormat = GetDX10BlockCompression -DXGI_FORMAT $DX10BCFlag

        # If it is sRGB the format will contain an "_S" flag.
        $ImageInfo.DDSSRGB = ($ImageFormat -like "*_S")

        # Set the block compression without the flag.
        $ImageInfo.Format = $ImageFormat.Replace("_S","")
      }
      # If there is no FourCC value, its an uncompressed DX9 DDS so get the color space (RGB, RGBA, ARGB, L8, A8, LA8).
      default 
      {
        $ImageInfo.Format = GetDX9UncompressedFormat -ImageFile $ImageFile
        $ImageInfo.DDSSRGB = $false
      }
    }
    # If the FourCC value is DXT1/DXT3/DXT5, test the image for grayscale and alpha.
    if ($ImageInfo.DDSFourCC -like 'DXT*')
    {
      # Check the image to see if it is grayscale and/or has an alpha channel.
      $ImageInfo.Gray  = Magick-IdentifyGray -ImageFile $ImageFile 
      $ImageInfo.Alpha = Magick-IdentifyAlpha -ImageFile $ImageFile 
    }
    # For all other DDS textures (BC7, ARGB8, RGBA8, etc.) force gray off and alpha on.
    else
    {
      # Force these values to avoid errors. Ishiiruka textures do not make use of them (yet?).
      $ImageInfo.Gray  = $false
      $ImageInfo.Alpha = $true
    }
  }
  #----------------------------------------------------------------------------
  # The bitmap format is pretty simple to work with. Use ImageMagick for gray and alpha for convenience.
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -eq 'BMP')
  {
    # Convert the hex value to decimal.
    $ImageInfo.Width  = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[19..18])).Replace('-','')),16)
    $ImageInfo.Height = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[23..22])).Replace('-','')),16)

    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($ImageInfo.Width, $ImageInfo.Height))

    # Count the number of external mipmaps.
    $ImageInfo.Mipmaps = CountExternalMipmaps -ImageFile $ImageFile -Levels $MipmapLevels

    # Check for grayscale and alpha channel.
    $ImageInfo.Gray  = Magick-IdentifyGray -ImageFile $ImageFile 
    $ImageInfo.Alpha = Magick-IdentifyAlpha -ImageFile $ImageFile 

    # Since this is not a DDS texture, store a blank string.
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  #----------------------------------------------------------------------------
  # The truevision targa format is a weird one. I never planned to support it, but here we are.
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -eq 'TGA')
  {
    # Convert the hex value to decimal. 
    $ImageInfo.Width  = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[13..12])).Replace('-','')),16)
    $ImageInfo.Height = [Convert]::ToInt32((([BitConverter]::ToString($ByteArray[15..14])).Replace('-','')),16)

    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($ImageInfo.Width, $ImageInfo.Height))

    # Count the number of external mipmaps.
    $ImageInfo.Mipmaps = CountExternalMipmaps -ImageFile $ImageFile -Levels $MipmapLevels

    # Get the color type to test for gray. (0=none,1=indexed,2=rgb,3=grey,+8=rle packed)
    $ColorType = [BitConverter]::ToString($ByteArray[2])

    # First check to see if the texture is grayscale.
    switch ($ColorType)
    {
      # A value of '03' is grayscale and a value of '0B' is grayscale +rle packed.
      '03'    { $ImageInfo.Gray  = $true }
      '0B'    { $ImageInfo.Gray  = $true }
      default { $ImageInfo.Gray  = $false }
    }
    # Check the image to see if it has an alpha channel.
    $ImageInfo.Alpha = Magick-IdentifyAlpha -ImageFile $ImageFile 

    # Since this is not a DDS texture, store a blank string.
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  #----------------------------------------------------------------------------
  # And I definitely didn't expect to support tif/tiff until a user told me it existed.
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -like 'TIF*')
  {
    # Get the image as an object.
    $DrawImage = [Drawing.Image]::FromFile($ImageFile)

    # Get the dimensions.
    $ImageInfo.Width  = $DrawImage.Width
    $ImageInfo.Height = $DrawImage.Height

    # Count the number of frames in the image.
    $ImageFrames = $DrawImage.GetFrameCount([System.Drawing.Imaging.FrameDimension]::Page)

    # Remove hook to the image.
    $DrawImage.Dispose()

    # See if this file has multiple images in the stack.
    if ($ImageFrames -gt 1)
    {
      # Set the number of mipmaps to the number of frames (minus the first image).
      $ImageInfo.Mipmaps = $ImageFrames - 1
    }
    # It's a single image TIFF file.
    else
    {
      # Calculate the number of mipmap levels the texture should have.
      $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($ImageInfo.Width, $ImageInfo.Height))

      # Attempt to count the number of external mipmaps.
      $ImageInfo.Mipmaps = CountExternalMipmaps -ImageFile $ImageFile -Levels $MipmapLevels
    }
    # Check the image to see if it is grayscale and/or has an alpha channel.
    $ImageInfo.Gray  = Magick-IdentifyGray  -ImageFile $ImageFile 
    $ImageInfo.Alpha = Magick-IdentifyAlpha -ImageFile $ImageFile 

    # Since this is not a DDS texture, store a blank string.
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  #----------------------------------------------------------------------------
  # And... really? Support for icons?
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -eq 'ICO')
  {
    # Icons can have multiple images, so break the images into its parts.
    $WIndex = Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%w %s\n')
    $HIndex = Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%h %s\n')

    # The largest image needs to be found.
    $WidthStore = 0
    $HeightStore = 0

    # Loop through all images found in the icon.
    for ($i = 0 ; $i -lt $WIndex.Count ; $i++)
    {
      # Split the dimension from the index, For example, ImageMagick reports
      # index 1 as "256 1", index 2 as "128 2", index 3 as "64 3", etc..
      $WSplit = $WIndex[$i].Split()
      $WCheck = [int]$WSplit[0]

      # Check to see if the dimension is greater than the stored dimension.
      if ($WCheck -gt $WidthStore) { $WidthStore = $WCheck }
    }
    # Loop through all images found in the icon.
    for ($i = 0 ; $i -lt $HIndex.Count ; $i++)
    {
      # Split the dimension from the index.
      $HSplit = $HIndex[$i].Split()
      $HCheck = [int]$HSplit[0]

      # Check to see if the dimension is greater than the stored dimension.
      if ($HCheck -gt $HeightStore) { $HeightStore = $HCheck }
    }
    # Set the dimensions.
    $ImageInfo.Width  = $WidthStore
    $ImageInfo.Height = $HeightStore

    # Set the rest of the stuff to.. something.
    $ImageInfo.Mipmaps   = 0
    $ImageInfo.Gray      = $false
    $ImageInfo.Alpha     = $true
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  #----------------------------------------------------------------------------
  # And now sigh... webp support...
  #----------------------------------------------------------------------------
  elseif ($ImageInfo.Format -eq 'WEBP')
  {
    # Use ImageMagick to retrieve the dimensions.
    $ImageInfo.Width  = [int](Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%w'))
    $ImageInfo.Height = [int](Magick-Identify -ImageFile $ImageFile -Arguments @('-format','%h'))

    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($ImageInfo.Width, $ImageInfo.Height))

    # Attempt to count the number of external mipmaps.
    $ImageInfo.Mipmaps = CountExternalMipmaps -ImageFile $ImageFile -Levels $MipmapLevels

    # Check the image to see if it is grayscale and/or has an alpha channel.
    $ImageInfo.Gray  = Magick-IdentifyGray  -ImageFile $ImageFile 
    $ImageInfo.Alpha = Magick-IdentifyAlpha -ImageFile $ImageFile 

    # Since this is not a DDS texture, store a blank string.
    $ImageInfo.DDSFourCC = ''
    $ImageInfo.DDSSRGB   = $false
  }
  # Also store the entire dimensions.
  $ImageInfo.Dimensions = $ImageInfo.Width.ToString() + 'x' + $ImageInfo.Height.ToString()
  
  # Return the hash table to add to the ImageInfo hash table.
  return $ImageInfo
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: TEXTURE HASH TABLE
#==============================================================================================================================================================================================
#  Creates a hash table that contains a ton of information about an image file. A global hashtable named "$Texture" is created on each iteration of the
#  master loop, but texture info can be created at any time for just about any image file to get all the useful properties it contains.
#==============================================================================================================================================================================================
function CreateTextureInfo([string]$ImageFile, [switch]$Extended, [switch]$Silent)
{
  # Initialize the texture hash table.
  $TextureInfo = @{}

  # Get the file path as an item so properties can be extracted.
  $FileInfo = Get-Item -LiteralPath $ImageFile

  # Let's get down to business.
  $TextureInfo.Path       = [string]$FileInfo.Directory
  $TextureInfo.Folder     = [System.IO.Path]::GetFileName($TextureInfo.Path)
  $TextureInfo.Name       = $FileInfo.BaseName
  $TextureInfo.FullName   = $FileInfo.Name
  $TextureInfo.Extension  = $FileInfo.Extension
  $TextureInfo.PathName   = $TextureInfo.Path + '\' + $TextureInfo.Name
  $TextureInfo.FullPath   = $TextureInfo.Path + '\' + $TextureInfo.FullName
  $TextureInfo.Relative   = GetRelativePath -TexturePath $TextureInfo.Path
  $TextureInfo.IsIcon     = ($TextureInfo.Extension -eq $ICO)
  $TextureInfo.IsMipmap   = ($TextureInfo.Name -like '*_m_*')
  $TextureInfo.ArbMips    = ($TextureInfo.Name -like '*_arb*')
  $TextureInfo.RGBA       = ($TextureInfo.FullName -like 'RGBA_*x*_*.png')
  $TextureInfo.SplitRGBA  = ($TextureInfo.Path -like ("*Temp\SplitRGBA*"))
  $TextureInfo.Dolphin    = ($TextureInfo.Name -like 'tex1_*')
  $TextureInfo.DBTexture  = $false

  # Here we set up Width, Height, Mipmaps, Alpha, Gray, DDSFourCC, and DDSSRGB.
  $ImageInfo = GetImageInfo -ImageFile $TextureInfo.FullPath

  # All the work is done in the function above so just grab the data.
  $TextureInfo.Width      = $ImageInfo.Width
  $TextureInfo.Height     = $ImageInfo.Height
  $TextureInfo.Dimensions = $ImageInfo.Dimensions
  $TextureInfo.Mipmaps    = $ImageInfo.Mipmaps
  $TextureInfo.Size       = $ImageInfo.Size
  $TextureInfo.Format     = $ImageInfo.Format
  $TextureInfo.Gray       = $ImageInfo.Gray
  $TextureInfo.Alpha      = $ImageInfo.Alpha
  $TextureInfo.DDSFourCC  = $ImageInfo.DDSFourCC
  $TextureInfo.DDSSRGB    = $ImageInfo.DDSSRGB

  # Now the aspect ratio can be calculated from the dimensions.
  $TextureInfo.Aspect     = CalculateAspectRatio -Width $TextureInfo.Width -Height $TextureInfo.Height

  # Get even more information when this switch is set.
  if ($Extended)
  {
    # Get all the various material map information from a hash table.
    $MatMapInfo = GetMaterialMapInfo -TextureInfo $TextureInfo

    # Blah blah blah something something comment.
    $TextureInfo.HasMats    = $MatMapInfo.HasMats
    $TextureInfo.HasMatMap  = $MatMapInfo.HasMatMap
    $TextureInfo.MatMap     = $MatMapInfo.MatMap

    # If it's a Dolphin texture (meaning the name starts with "tex1_"), the original dimensions can be retrieved from the name.
    if ($TextureInfo.Dolphin)
    {
      # Split the texture name by underscores "_" then split the dimensions on the "x".
      $SplitBase = $TextureInfo.Name.Split('_')
      $SplitDims = $SplitBase[1].Split('x')

      # Set up the original texture properties.
      $TextureInfo.OldWidth      = [Convert]::ToInt32($SplitDims[0])
      $TextureInfo.OldHeight     = [Convert]::ToInt32($SplitDims[1])
      $TextureInfo.OldDimensions = $TextureInfo.OldWidth.ToString() + 'x' + $TextureInfo.OldHeight.ToString()
      $TextureInfo.OldAspect     = CalculateAspectRatio -Width $TextureInfo.OldWidth -Height $TextureInfo.OldHeight
    }
    # Check to see if a database file exists.
    elseif (($CTTPSSelectedMode -eq "Database Mode") -and (TestPath -LiteralPath $DatabaseFile))
    {
      # Workaround: Textures with "$" in their name throw off regex. So an escape character needs to be injected.
      $RegexTexture = InjectRegexEscapeChar -InputString $TextureInfo.Name -Characters @('$')

      # See if there is a match in the database.
      $Match = ($TexDatabase -match ("\b" + $RegexTexture + "\b*"))

      # The database contains the texture name
      if ($Match)
      {
        # Get the index of the entry.
        $DBIndex = $TexDatabase.IndexOf($Match)

        # Split the texture dimensions on the "x".
        $SplitBase = $TexDatabase[$DBIndex].Split(';')
        $SplitDims = $SplitBase[1].Split('x')

        # We can't exactly flag it as a "Dolphin" texture, but we do want to allow it to use some functions created specifically for Dolphin textures.
        $TextureInfo.DBTexture     = $true

        # Set the original dimensions based on what is in the database.
        $TextureInfo.OldWidth      = [Convert]::ToInt32($SplitDims[0])
        $TextureInfo.OldHeight     = [Convert]::ToInt32($SplitDims[1])
        $TextureInfo.OldDimensions = $SplitBase[1]
        $TextureInfo.OldAspect     = CalculateAspectRatio -Width $TextureInfo.OldWidth -Height $TextureInfo.OldHeight
      }
      # If the database does not contain the texture name.
      else
      {
        # Set the "original" dimensions to the texture's "current" dimensions.
        $TextureInfo.OldWidth      = $TextureInfo.Width
        $TextureInfo.OldHeight     = $TextureInfo.Height
        $TextureInfo.OldDimensions = $TextureInfo.Dimensions
        $TextureInfo.OldAspect     = $TextureInfo.Aspect
      }
    }
    # If not a Dolphin texture and no database exists then the original dimensions can't be retrieved.
    else
    {
      # Set the "original" dimensions to the texture's "current" dimensions.
      $TextureInfo.OldWidth      = $TextureInfo.Width
      $TextureInfo.OldHeight     = $TextureInfo.Height
      $TextureInfo.OldDimensions = $TextureInfo.Dimensions
      $TextureInfo.OldAspect     = $TextureInfo.Aspect
    }
    # Calculate the custom texture scaling compared to the original texture.
    $TextureInfo.ScaleWidth  = [decimal](FormatDecimal -Value ($TextureInfo.Width/$TextureInfo.OldWidth))
    $TextureInfo.ScaleHeight = [decimal](FormatDecimal -Value ($TextureInfo.Height/$TextureInfo.OldHeight))
    $TextureInfo.FullScale   = $TextureInfo.ScaleWidth.ToString() + 'x' + $TextureInfo.ScaleHeight.ToString()

    # Get info about the texture as if it were a PNG image.
    $PNGData = GetPNGInfo -TextureInfo $TextureInfo

    # Copy all PNG info into the texture hash table.
    $TextureInfo.PNGColorType  = $PNGData.ColorType
    $TextureInfo.PNGColorSpace = $PNGData.ColorSpace
    $TextureInfo.PNGBitDepth   = $PNGData.BitDepth

    # Set the compression format for DDS textures.
    $TextureInfo.DDSCompression = GetDDSBlockCompressionType -TextureInfo $TextureInfo
  }
  # Debug: Maybe I don't want these messages even when troubleshooting.
  if (!$Silent)
  {
    # Debug: Let me know a texture is about to be processed.
    DebugMessage -Message '' -FollowUp '- TextureInfo created for file:'
    DebugMessage -Message $ImageFile -FollowUp ' '
  }
  # Return the texture data so it can be set to a global and used basically everywhere in the script.
  return $TextureInfo
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MISCELLANEOUS MIPMAP FUNCTIONS
#==============================================================================================================================================================================================
#  Calculates how many Mipmap levels a texture should have based on the input dimension.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CalculateMipmapLevels([int]$Dimension)
{
  # Continue to divide the width or height by 2 until 1 (or lower) is hit.
  while($Dimension -gt 1)
  {
    # Perform the calculation as a decimal to remain as accurate as possible.
    $HalvedDimension = [decimal]($Dimension / 2)

    # Divide the dimension in half, and fix the decimal for other regions.
    $NewDimension = FormatDecimal -Value $HalvedDimension

    # Split the value so the decimal can be dropped (and not rounded).
    $NewDimensionSplit = $NewDimension.ToString().Split('.',2)

    # Keep only the integer value for the next iteration.
    $Dimension = [int]$NewDimensionSplit[0]

    # Increment the number of levels.
    $Levels ++
  }
  # Return the number of levels calculated.
  return $Levels
}
#==============================================================================================================================================================================================
#  Loop to calculate a single dimension of a Mipmap based on the Mipmap's current level.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CalculateMipmapDimension([int]$Level, [int]$Dimension)
{
  # Continue the loop until the loop iteration reaches the Mipmap level.
  for ($i=1; $i -le $Level; $i++)
  {
    # Make sure the dimension is not less than or equal to 1. Less than 1 shouldn't ever happen, but just in case.
    if ($Dimension -gt 1)
    {
      # Perform the calculation as a decimal to remain as accurate as possible.
      $HalvedDimension = [decimal]($Dimension / 2)

      # Divide the dimension in half, and fix the decimal for other regions.
      $NewDimension = FormatDecimal -Value $HalvedDimension

      # Split the value so the decimal can be dropped (and not rounded).
      $NewDimensionSplit = $NewDimension.ToString().Split('.',2)

      # Keep only the integer value for the next iteration.
      $Dimension = [int]$NewDimensionSplit[0]
    }
  }
  # Return the calculated dimension.
  return $Dimension
}
#==============================================================================================================================================================================================
#  Counts the number of external mipmaps accompanying the base texture. Does not include the top level (0) in the count.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CountExternalMipmaps([string]$ImageFile, [int]$Levels)
{
  # Default to no mipmaps.
  $MipmapLevels = 0

  # Get the image as an object and get the path it is located in.
  $ImageItem = Get-Item -LiteralPath $ImageFile

  # Create the names of the mipmap levels.
  for ($i = 1 ; $i -le $Levels ; $i++)
  {
    # Add a workaround when counting material map mipmaps.
    if ($ImageItem.BaseName -like "*.mat")
    {
      # Generate the possible name of the mipmap.
      $MipmapCheck = $ImageItem.DirectoryName + '\' + $ImageItem.BaseName.Replace(".mat","") + "_mip" + $i.ToString() + ".mat" + $ImageItem.Extension
    }
    else
    {
      # Generate the possible name of the mipmap.
      $MipmapCheck = $ImageItem.DirectoryName + '\' + $ImageItem.BaseName + "_mip" + $i.ToString() + $ImageItem.Extension
    }
    # Check to see if it exists.
    if (TestPath -LiteralPath $MipmapCheck)
    {
      # Increment the counter if it does.
      $MipmapLevels++
    }
  }
  # Return the number of mipmaps found.
  return $MipmapLevels
}

#==============================================================================================================================================================================================
#  Counts the number of internal mipmaps within a DDS texture. Does not include the top level (0) in the count.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CountInternalMipmaps([string]$ImageFile)
{
  # Default to no mipmaps.
  $MipmapLevels = 0

  # Get the extension of the input image.
  $Extension = (Get-Item -LiteralPath $ImageFile).Extension

  # DDS: Get the mipmap count from the header.
  if ($Extension -eq $DDS)
  {
    # Create a byte array from the image.
    $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

    # Read the number of mipmap levels from the byte array.
    $MipmapString = [BitConverter]::ToString($ByteArray[28])

    # Convert the string to an integer and subtract 1 to compensate for the top level.
    $MipmapLevels = [Convert]::ToInt32($MipmapString) - 1
  }
  # TIFF: Get the file as a drawing image.
  elseif ($Extension -like ($TIF + "*"))
  {
    # Load the image as a drawing image.
    $DrawImage = [Drawing.Image]::FromFile($ImageFile)

    # Count the number of frames in the image.
    $MipmapLevels = $DrawImage.GetFrameCount([Drawing.Imaging.FrameDimension]::Page) - 1

    # Remove the hook to the image.
    $DrawImage.Dispose()
  }
  # Move it along people, nothing to see here.
  return $MipmapLevels
}
#==============================================================================================================================================================================================
#  Searches for custom mipmaps provided by the user and finds where the mipmap chain ends. If a mipmap is missing from the chain, the previous mipmap is detected as the "final mipmap". 
#  For example, if mip1, mip2, mip3, mip5, mip6, and mip7 exist (mip4 is missing), then mip3 will be set as the last mipmap in the chain and mip5+ will be ignored.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetFinalMipmapLevel([hashtable]$MipmapInfo)
{
  # Stores the index of the last mipmap in the chain if the user provided custom mipmaps.
  $FinalLevel = 0

  # A loop to search for the last available mipmap in the chain. 
  for ($i = 1; $i -le $MipmapInfo.Levels; $i++)
  {
    # Check to see if the current mipmap exists.
    if ($MipmapInfo.Exists[$i])
    {
      # If it does, set the current mipmap's index as the final mipmap in the chain.
      $FinalLevel = $i
    }
    # The mipmap did not exist.
    else
    {
      # End the loop to preserve the final mipmap found in the chain.
      break
    }
  }
  return $FinalLevel
}
#==============================================================================================================================================================================================
#  DOCUMENTATION: MIPMAP HASH TABLE
#==============================================================================================================================================================================================
#  Creates Mipmap information based on the input dimensions and the texture currently stored in the global hash table.
#  Only the name/path information is pulled from the texture hash table, the rest of the information is dynamically created from the input dimensions.
#
#  The number of mipmaps [#] in the array is determined by the number of $Mipmap.Levels.
#
#  $Mipmap.Levels             - integer -  The number of levels calculated from the input dimensions. Also defines the size of the Mipmap array.
# *$Mipmap.Name[#]            - string  -  The name of the Mipmap without the extension. 
# *$Mipmap.FullName[#]        - string  -  The name of the Mipmap with the file extension.
# *$Mipmap.FullPath[#]        - string  -  The full path to the Mipmap including the Mipmap + file extension.
#  $Mipmap.Width[#]           - string  -  The calculated width of the Mipmap based on the input dimensions.
#  $Mipmap.Height[#]          - string  -  The calculated height of the Mipmap based on the input dimensions.
#  $Mipmap.Dimensions[#]      - string  -  The calculated full dimensions of the Mipmap in the form of Width x Height.
# *$Mipmap.Exists[#]          - boolean -  Notifies whether or not the mipmap actually exists. 
# *$Mipmap.RealWidth[#]       - string  -  The actual width of the Mipmap if it exists.
# *$Mipmap.RealHeight[#]      - string  -  The actual height of the Mipmap if it exists.
# *$Mipmap.RealDimensions[#]  - string  -  The actual full dimensions of the Mipmap in the form of Width x Height.
#
#  * This data is created based on the current texture hash table. All other information is derived from the input dimensions.
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MIPMAP HASH TABLE
#==============================================================================================================================================================================================
#  The input width and height allows manipulating the number of mipmap levels the hash table will calculate, rather than grab the dimensions of the texture currently stored
#  in the texture hash table. This allows calculating a mipmap hash table for a resized texture before it is actually resized. All mipmap references will have their dimensions
#  calculated from the input width and height, but their real dimensions and whether or not they exist are also included in the hash table for reference.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMipmapInfo([hashtable]$TextureInfo, [int]$Width, [int]$Height, [int]$ForcedLevels=0)
{
  # Initialize the Mipmap hash table.
  $MipmapInfo = @{}

  # The max number of levels are not forced when the value is zero.
  if ($ForcedLevels -eq 0)
  {
    # Store how many Mipmap levels the texture should have based on the largest dimension.
    $MipmapInfo.Levels = CalculateMipmapLevels -Dimension ([Math]::Max($Width, $Height))
  }
  # Allow forcing the number of levels (occasionally needed for TIF/TIFF images).
  else
  {
    # Set the number of levels to the amount forced. Needed when TIF/TIFF mipmaps are not to be treated like mipmaps.
    $MipmapInfo.Levels = $ForcedLevels
  }
  # Initialize an array to store information about each individual Mipmap. ArraySize must be (+1) to start with index[1] instead of [0].
  $ArraySize = ($MipmapInfo.Levels + 1)
  $MipmapInfo.Name           = New-Object string[] $ArraySize
  $MipmapInfo.FullName       = New-Object string[] $ArraySize
  $MipmapInfo.FullPath       = New-Object string[] $ArraySize
  $MipmapInfo.Width          = New-Object int[]    $ArraySize
  $MipmapInfo.Height         = New-Object int[]    $ArraySize
  $MipmapInfo.Dimensions     = New-Object string[] $ArraySize
  $MipmapInfo.Exists         = New-Object bool[]   $ArraySize
  $MipmapInfo.RealWidth      = New-Object int[]    $ArraySize
  $MipmapInfo.RealHeight     = New-Object int[]    $ArraySize
  $MipmapInfo.RealDimensions = New-Object string[] $ArraySize

  # Set some information for the top level mipmap.
  $MipmapInfo.Name[0]           = $TextureInfo.Name
  $MipmapInfo.FullName[0]       = $TextureInfo.FullName
  $MipmapInfo.FullPath[0]       = $TextureInfo.FullPath
  $MipmapInfo.Width[0]          = $TextureInfo.Width
  $MipmapInfo.Height[0]         = $TextureInfo.Height
  $MipmapInfo.Dimensions[0]     = $TextureInfo.Dimensions
  $MipmapInfo.Exists[0]         = $true
  $MipmapInfo.RealWidth[0]      = $TextureInfo.Width
  $MipmapInfo.RealHeight[0]     = $TextureInfo.Height
  $MipmapInfo.RealDimensions[0] = $TextureInfo.Dimensions

  # Store information about each Mipmap. Start with index [1] instead of [0] since it holds the base texture (top level).
  # Example: "mipmap.Variable[3]" will reference properties of "tex1_128x128_m_e3487d3b2a9d3e11_14_mip3"
  for ($i = 1; $i -le $MipmapInfo.Levels; $i++)
  {
    # If the texture name has a mipmap flag to specify the number of mipmaps, remove it when checking for mipmaps.
    if ($TextureInfo.Name -match '_mm(.{1})')
    {
      $MipmapInfo.Name[$i]     = $TextureInfo.Name.Replace($Matches[0], '') + '_mip' + $i
      $MipmapInfo.FullName[$i] = $TextureInfo.Name.Replace($Matches[0], '') + '_mip' + $i + $TextureInfo.Extension
      $MipmapInfo.FullPath[$i] = $TextureInfo.PathName.Replace($Matches[0], '') + '_mip' + $i + $TextureInfo.Extension
    }
    # If it doesn't have a mipmap flag, just use the texture name when searching for mipmaps.
    else
    {
      $MipmapInfo.Name[$i]     = $TextureInfo.Name + '_mip' + $i
      $MipmapInfo.FullName[$i] = $TextureInfo.Name + '_mip' + $i + $TextureInfo.Extension
      $MipmapInfo.FullPath[$i] = $TextureInfo.PathName + '_mip' + $i + $TextureInfo.Extension
    }
    # Also get the width, height, and dimensions.
    $MipmapInfo.Width[$i]      = CalculateMipmapDimension -Level $i -Dimension $Width
    $MipmapInfo.Height[$i]     = CalculateMipmapDimension -Level $i -Dimension $Height
    $MipmapInfo.Dimensions[$i] = $MipmapInfo.Width[$i].ToString() + 'x' + $MipmapInfo.Height[$i].ToString()

    # Store whether or not the mipmap actually exists.
    $MipmapInfo.Exists[$i] = TestPath -LiteralPath $MipmapInfo.FullPath[$i]

    # Check to see if the Mipmap exists.
    if ($MipmapInfo.Exists[$i])
    {
      # Get the dimensions of the texture as a hash table.
      $ImageInfo = GetImageInfo -ImageFile $MipmapInfo.FullPath[$i]

      # Get the dimensions of the Mipmap file.
      $MipmapInfo.RealWidth[$i]      = $ImageInfo.Width
      $MipmapInfo.RealHeight[$i]     = $ImageInfo.Height
      $MipmapInfo.RealDimensions[$i] = $ImageInfo.Dimensions
    }
  }
  # Return the Mipmap data so it can be set to a variable.
  return $MipmapInfo
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MIPMAP HASH TABLE - GETTING THE PROPER MIPMAP HASH TABLE
#==============================================================================================================================================================================================
#  Extends the functionality of "CreateMipmapInfo". The priority for the created hash table goes to a DDS texture with internal mipmaps. The internal mipmaps are extracted and stored in a 
#  temporary folder. These mipmaps must be manually cleaned up when no longer needed (use the destroy function)! If no internal mipmaps exist, then create mipmap info from the base texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMipmapInfoPlus([hashtable]$TextureInfo, [int]$Width, [int]$Height, [int]$ForcedLevels=0)
{
  # Get the number of internal mipmaps.
  $MipmapLevels = CountInternalMipmaps -ImageFile $TextureInfo.FullPath

  # Check to see if there are actually any internal mipmaps to be found.
  if ($MipmapLevels -gt 0)
  {
    # Create a folder to extract internal Mipmaps to.
    $NewTexPath = CreatePath -LiteralPath ($TempFolder + '\MipmapInfoPlus')
    $NewTexFile = $NewTexPath + '\' + $TextureInfo.FullName

    # Run the function associated with the extension.
    switch -wildcard ($TextureInfo.Extension)
    {
      # Extract all internal Mipmaps.
      '.dds'  { ExtractInternalDDSMipmaps -ImageFile $TextureInfo.FullPath -OutputPath $NewTexPath }
      '.tif*' { ExtractInternalTIFMipmaps -ImageFile $TextureInfo.FullPath -OutputPath $NewTexPath }
    }
    # Mipmaps were found so create an entirely new texture hash table based on the temporary texture + mipmaps.
    $NewTexInfo = CreateTextureInfo -ImageFile $NewTexFile -Extended

    # Create a mipmap hash table based on the temporary texture.
    return (CreateMipmapInfo -TextureInfo $NewTexInfo -Width $Width -Height $Height -ForcedLevels $ForcedLevels)
  }
  # If it's not a DDS texture or it did not have mipmaps, simply create a hash table from the current texture.
  return (CreateMipmapInfo -TextureInfo $TextureInfo -Width $Width -Height $Height -ForcedLevels $ForcedLevels)
}
#==============================================================================================================================================================================================
#  Cleans out any temporary DDS mipmaps that were extracted with the above function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DestroyMipmapInfoPlus()
{
  # It's easier to remember to call the above function name than this line.
  RemovePath -LiteralPath ($TempFolder + '\MipmapInfoPlus')
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MIPMAP BASE FINDER
#==============================================================================================================================================================================================
#  Find which texture to use as the mipmap base image whenever a texture containing mipmaps is created.
#  
#  Uses a little trick to increase the generation speed of mipmaps. If the previous mipmap exists, then use that as a base. If new mipmaps are not being 
#  forced from the top level, always use the previously generated mipmap. If the top level is forced, at least one mipmap needs to be created from it before
#  generating future mipmaps from newly generated mipmaps. This is rather confusing to understand just looking at it, so explanation time. When forcing new
#  mipmaps from the top level, we only need to force at least 1 from the top level, then we can just keep generating from each previously generated mipmap.
#  The final known level (+1) can be used as a marker to know when the last mipmap was created from the top level. It's easier to understand with an example.
#  
#  Index = 3, Final = 3. The mipmap exists, so the new mipmap will be generated from the final existing mipmap in the texture pack.
#  Index = 4, Final = 3. Index 4 is equal to 4 (Final+1), the check fails, so generate from the top level. 
#  Index = 5, Final = 3. Index 5 is greater than 4 (Final+1), the check passes, so use the previous mipmap created from the top level.
#  
#  Arguments List:
#  - MipmapInfo      : Hash table containing the texture's mipmap information. Create with "CreateMipmapInfo" or "CreateMipmapInfoPlus".
#  - Index           : The current mipmap index. GetMipmapBaseImage should be called in an integer loop that loops through all levels.
#  - GenPath         : Path to where the mipmap will be created.
#  - ImageFallback   : Image path to fallback on if mipmaps are not created from the previous mipmap (should be the top level / base image).
#  - OutputExtension : Image format, should be ".png" or ".dds". I think ".jpg" should also work.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMipmapBaseImage([hashtable]$MipmapInfo, [int]$Index, [string]$GenPath, [string]$ImageFallback, [string]$OutputExtension)
{
  # Find the last mipmap level in the chain.
  $FinalLevel = GetFinalMipmapLevel -MipmapInfo $MipmapInfo

  # Debug:Show a message to display some information about which mipmap is being returned.
  DebugMessage -Message '' -FollowUp ('Mipmap Base Image (' + $Index + ')')

  # Check to see if new mipmaps were not forced, which generates all mipmaps from the top level.
  if (!$ForceNewMipmaps)
  {
    # See if the mipmap exists in the texture pack.
    if ($MipmapInfo.Exists[$Index])
    {
      # Debug:Show that the existing mipmap is used.
      DebugMessage -Message '- Using the matching existing mipmap' -FollowUp ('- ' + $MipmapInfo.FullPath[$Index])

      # If it exists, use it as the mipmap base.
      return $MipmapInfo.FullPath[$Index]
    }
    # PNG will always generate a new mipmap from the last generated mipmap unless forced to generate from the top level. But for DDS images, it's actually
    # faster to just use the final existing mipmap, especially if the final mipmap is a PNG file. This prevents having to convert the same texture twice.
    elseif (($OutputExtension -eq $DDS) -and (!$MipmapTopLevelBase) -and ($FinalLevel -gt 0))
    {
      # Debug:Show that the final existing mipmap level is used.
      DebugMessage -Message '- Using final existing mipmap level' -FollowUp ('- ' + $MipmapInfo.FullPath[$FinalLevel])

      # Generate remaining missing mipmaps from the final level that was found.
      return $MipmapInfo.FullPath[$FinalLevel]
    }
  }
  # Do not even go this route until were on at least mipmap level 2 so at least a single mipmap is generated from the top level. This path allows generating
  # from the previously generated mipmap. This is the default behavior for PNG files, and this path is only hit for DDS files when the pack has not supplied
  # any mipmap levels (meaning, FinalLevel = 0). In other words, this route will never be hit for DDS textures if the user supplied any number of mipmaps.
  if ($Index -ge 2)
  {
    # Always use the last created mipmap if not forcing from the top level. If forcing from the top level, the top level must have already been used at least
    # once. We can know this if the index is at least 2 levels above the "final" mipmap. Example: index = 4, final = 2, final test = 2 + 1 = 3, and 4 is greater
    # than 3. In this example, we know this path was not taken for level 3 and it was generated from the top level (or rather, the fallback image).
    if ((!$MipmapTopLevelBase) -or (($MipmapTopLevelBase) -and ($Index -gt ($FinalLevel + 1))))
    {
      # Get the path to the previously created mipmap.
      $GetFallbackItem = Get-Item -LiteralPath $ImageFallback
      $PreviousMipPath = $GenPath + '\' + $GetFallbackItem.BaseName + '_mip' + ($Index - 1).ToString() + $OutputExtension

      # Just to be safe, test for the mipmap, even though it should most definitely exist.
      if (TestPath -LiteralPath $PreviousMipPath)
      {
        # Debug:Show that the previously generated mipmap level is used.
        DebugMessage -Message '- Using previously generated mipmap level' -FollowUp ('- ' + $PreviousMipPath)

        # It exists, so use the previous mipmap to generate this one.
        return $PreviousMipPath
      }
    }
  }
  # Debug:Show that the top image is going to be used.
  DebugMessage -Message '- Using largest/base image (aka: top mipmap level)' -FollowUp ('- ' + $ImageFallback)

  # None of the many conditions passed, so return what I presume is the top level.
  return $ImageFallback
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: GET CORRECT MIPMAP LEVELS
#==============================================================================================================================================================================================
#  Several options are available to manipulate the number of mipmaps a texture will be generated with. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetCorrectMipmapLevels([string]$TextureName, [int]$MaxLevels)
{
  # If the texture has a flag for mipmap levels.
  if ($TextureName -match '_mm(.{1})')
  {
    # Make sure the number specified does not exceed the amount of mipmaps needed.
    if ([int]$Matches[1] -le $MaxLevels) { return [int]$Matches[1] }
  }
  # If the texture has a flag for mipmap levels.
  if ($TextureName -like '*_mm')
  {
    # When there is no number accompanying the "_mm" flag, just return the max levels.
    return $MaxLevels
  }
  # This option allows forcing the number of mipmaps to generate.
  if ($MaxMipmapEnabled)
  {
    # Make sure the number specified does not exceed the amount of mipmaps needed.
    if ([int]$MaxMipmapLevels -le $MaxLevels) { return [int]$MaxMipmapLevels }
  }
  # Use the amount that was fed to the parameter.
  return $MaxLevels
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: CREATE MIPMAPS CHECK
#==============================================================================================================================================================================================
#  All texture creation functions use this to check whether or not to create mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMipmapCheck([hashtable]$TextureInfo)
{
  # If mipmaps are disabled then don't create them.
  if ($DisableMipmaps) { return $false }

  # If it's a dolphin mipmap texture, it's already true.
  if (($TextureInfo.Dolphin) -and ($TextureInfo.IsMipmap)) { return $true }

  # Set up the series of checks to see if mipmaps will be created.
  $CreateMipmapChecks = New-Object bool[] 3
  $CreateMipmapChecks[0] = ($ForceCreateMipmaps)
  $CreateMipmapChecks[1] = ($TextureInfo.Mipmaps -gt 0)
  $CreateMipmapChecks[2] = ($TextureInfo.Name -like '*_mm*')

  # Return whether or not to create mipmaps in a variable to be tested.
  return (TestBooleanArray -Or -Array $CreateMipmapChecks)
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: GET THE CORRECT MIPMAP DIMENSIONS FOR TEXTURES (TIF >> PNG or ANYTHING >> TIF/TIFF)
#==============================================================================================================================================================================================
#  This is mostly a hack for TIF/TIFF images but is also used in PNG. If the condition parameter passes (usually $TIFFNoResizeMipmap + whatever else), calculate the amount of change in the 
#  dimensions of the first texture in the stack, then apply that factor to the mipmap dimensions (lower levels). This allows creating TIFF images without forcing them to progressively
#  smaller images like typical mipmaps, but still allows them to be resized based on the scaling factor that the dimensions of the top level is created at.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetModMipmapDimension([bool]$Condition, [int]$MRealDimension, [int]$MCalcDimension, [int]$TRealDimension, [int]$TSetDimension)
{
  # Check if the option to not resize TIFF mipmaps is enabled (+whatever else was fed into the parameter).
  if ($Condition)
  {
    # Check to see if the internal image does not match the resolution of the top layer.
    if ($MRealDimension -ne $TSetDimension)
    {
      # Calcuate the new scaling factor for the mipmap by dividing the size set by the calling function and it's actual size.
      $ChangeFactor = $TSetDimension / $TRealDimension

      # Use this factor to find the new dimension of the mipmap.
      $NewDimension = [int]($ChangeFactor * $MRealDimension)

      # Set the size of the mipmap to newly calculated size.
      return $NewDimension
    }
    # Set the size of the mipmap to its actual size.
    return $TRealDimension
  }
  # Set the size of the mipmap to the size set in MipmapInfo.
  return $MCalcDimension
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: PNG/JPG
#==============================================================================================================================================================================================
#
#                        
#                                   
#                           
#                                       
#                             
#
#==============================================================================================================================================================================================
#  TEXTURE CREATION: PNG RAW IMAGE DATA HASH TABLE
#==============================================================================================================================================================================================
#  Creates a hash table containing the raw RGB/RGBA bytes of an image, the number of channels, if it has an alpha channel, and the width and height.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  Bytes        = Byte Array - The raw RGB/RGBA data. Optional with SkipBytes. 
#  Width        = Integer    - Self explanatory.
#  Height       = Integer    - Self explanatory.
#  Stride       = Integer    - Self explanatory.
#  Dimensions   = String     - The dimensions as "Width x Height" with no spaces.
#  Channels     = Integer    - Number of channels (RGB = 3, RGBA = 4). 
#  AlphaChannel = Boolean    - Alpha channel exists? Does not determine if transparent pixels exist. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetRawImageData([string]$ImageFile, [bool]$SkipBytes = $false)
{
  # Create a hash table so multiple values can be returned.
  $RawData = @{}

  # Get the image as a Bitmap.
  $BitMap = New-Object Drawing.Bitmap($ImageFile)

  # For the sake of convenience down the road, also store the width and height into the hash table.
  $RawData.Width  = $BitMap.Width
  $RawData.Height = $BitMap.Height
  $RawData.Dimensions = $RawData.Width.ToString() + 'x' + $RawData.Height.ToString()

  # To get the number of channels, we can get the color depth and shift the binary value right. 
  $RawData.Channels = [Math]::Floor([Drawing.Image]::GetPixelFormatSize($BitMap.PixelFormat) * [Math]::Pow(2,-3))

  # Use bitwise AND to check to see if the image has an alpha channel. 
  $RawData.AlphaChannel = (($BitMap.PixelFormat.value__ -band [Drawing.Imaging.PixelFormat]::Alpha) -ne 0)

  # Skip storing the image bytes if they are not needed.
  if (!$SkipBytes)
  {
    # Convert the bitmap into BitmapData and grab all the pixel bytes.
    $Rect    = New-Object Drawing.Rectangle(0, 0, $BitMap.Width, $BitMap.Height)
    $BmpData = [Drawing.Imaging.BitmapData]$BitMap.LockBits($Rect, [Drawing.Imaging.ImageLockMode]::ReadWrite, $BitMap.PixelFormat)

    # Store the stride of the image.
    $RawData.Stride = $BmpData.Stride

    # Create a Byte array to hold the image info.
    $RawData.Bytes = New-Object Byte[] ($BmpData.Height * $BmpData.Stride)

    # Copy all Bytes from the image into the Byte array.
    [Runtime.InteropServices.Marshal]::Copy($BmpData.Scan0, $RawData.Bytes, 0, $RawData.Bytes.Length)

    # Unlock the pixel bits so we can dispose the bitmap.
    $BitMap.UnlockBits($BmpData)
  }
  # Now that we're done with the image, dispose of the Bitmap so it doesn't get locked.
  $BitMap.Dispose()

  # Return the data.
  return $RawData
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: WRITE RAW RGBA DATA TO IMAGE
#==============================================================================================================================================================================================
#  Takes a hash table containing a byte array that holds raw RGBA values and creates a PNG file. The proper hash table can be created with "GetRawImageData".
#==============================================================================================================================================================================================
#  The "PixelData" hashtable parameter requires the following values:
#  - PixelData.Bytes
#  - PixelData.Width
#  - PixelData.Height
#  - PixelData.Channels
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function WritePixelDataToImage([hashtable]$PixelData, [string]$OutputFile)
{
  # The pixel format is dependent on the number of channels the image is using.
  switch ($PixelData.Channels)
  {
    # Create a 24-bit image with 3 channels, and 32-bit image with 4 channels.
    '3'     { $BitMap = New-Object Drawing.Bitmap($PixelData.Width, $PixelData.Height, [Drawing.Imaging.PixelFormat]::Format24bppRgb) }
    '4'     { $BitMap = New-Object Drawing.Bitmap($PixelData.Width, $PixelData.Height, [Drawing.Imaging.PixelFormat]::Format32bppArgb) }
    default { return }
  }
  # Create a BitmapData and Lock all pixels to be written .
  $Rect    = New-Object Drawing.Rectangle(0, 0, $PixelData.Width, $PixelData.Height)
  $BmpData = [Drawing.Imaging.BitmapData]$BitMap.LockBits($Rect, [Drawing.Imaging.ImageLockMode]::ReadWrite, $BitMap.PixelFormat)

  # Copy the data from the byte array into BitmapData.Scan0.
  [Runtime.InteropServices.Marshal]::Copy($PixelData.Bytes, 0, $BmpData.Scan0, $PixelData.Bytes.Length)

  # Save the image to a file.
  $BitMap.Save($OutputFile)

  # Unlock the pixels and dispose the bitmap.
  $BitMap.UnlockBits($BmpData)
  $BitMap.Dispose()
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: IMAGE SHARPENING CALCULATION
#==============================================================================================================================================================================================
#  When texture sizes change with ImageMagick, a sharpening filter is applied so the resulting texture doesn't look like trash.
#  The amount of sharpening is determined by the % of difference between both width and height, which is then averaged out.
#  For example, the new texture is 38% smaller than the texture it is being created from, so a value of 0x0.38 strength is fed to ImageMagick.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CalculateSharpenStrength([int]$BaseWidth, [int]$BaseHeight, [int]$ModWidth, [int]$ModHeight)
{
  # If sharpening is disabled, return this value which disables it.
  if (!$EnableSharpen) { return '0x0' }

  # Calculate the percentage of difference between the smallest and largest dimensions.
  [decimal]$CalcWidth  = [Math]::Min($BaseWidth, $ModWidth) / [Math]::Max($BaseWidth, $ModWidth)
  [decimal]$CalcHeight = [Math]::Min($BaseHeight, $ModHeight) / [Math]::Max($BaseHeight, $ModHeight)

  # Subtract 1 from average of the two values previously found (which reverses the %, for example 60% becomes 40%).
  $Strength = FormatDecimal -Value (1 - (($CalcWidth + $CalcHeight) / 2))

  # Cap the strength at 0.60 or else the image may look "over sharpened".
  if ([decimal]$Strength -gt 0.60) { $Strength = '0.60' }

  # Return the average as the amount of sharpening.
  return '0x' + $Strength
}
#==============================================================================================================================================================================================
#  ImageMagick is used as the main backbone for PNG images, but it can not work with DX10 DDS textures (like BC7). This means creating PNG from DX10 DDS textures must be done with another 
#  program, this will be either TexConv or Compressonator. The program that is ran first is decided by an option from the "Additional Options" menu. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTexture_Alternate([string]$ImageFile, [string]$OutputFile, [switch]$NoReturn)
{
  # A block of code that can run TexConv or Compressonator depending on what was selected.
  $PNGSpecial = {

    # Set up the parameters for the script block. We need the program, input image, and output name.
    Param ([string]$PreferredProgram,[string]$ImageFile,[string]$OutputFile)

    # Tracks whether TexConv or Compressonator was used to create the image. Stores null if the program fails.
    $TexToolUsed = $null

    # Make sure TexConv is installed and that it was selected.
    if (($PreferredProgram -eq 'TexConv') -and (TestPath -LiteralPath $TexConvTool))
    {
      # Create the image using TexConv.
      RunTexConvTool -ImageFile $ImageFile -Arguments @('-srgb') -OutputFile $OutputFile

      # If the image exists, store that TexConv created the file.
      if (TestPath -LiteralPath $OutputFile) { $TexToolUsed = "TexConv" }
    }
    # Make sure Compressonator is installed and that it was selected.
    elseif (($PreferredProgram -eq 'Compressonator') -and (TestPath -LiteralPath $Compressonator))
    {
      # Build a list of arguments to feed into Compressonator.
      $CompArguments = New-Object Collections.Generic.List[string]

      # Check to see if the value was set to CPU.
      if ($CompressDecodeWith -ne 'CPU')
      {
        # Enabled GPU decoding with the API that the user selected.
        $CompArguments.Add('-UseGPUDecompress') | Out-Null
        $CompArguments.Add('-DecodeWith') | Out-Null
        $CompArguments.Add($CompressDecodeWith) | Out-Null
      }
      # Always add the command to hide progress.
      $CompArguments.Add('-noprogress') | Out-Null

      # Create the PNG image using Compressonator.
      CompressonatorCLI -ImageFile $ImageFile -Arguments $CompArguments -OutputFile $OutputFile

      # If the image exists, store that Compressonator created the file.
      if (TestPath -LiteralPath $OutputFile) { $TexToolUsed = "Compressonator" }
    }
    # Return whatever it is set to now.
    return $TexToolUsed
  }
  # First attempt to use the program set by the user, then attempt to use the alternate program.
  if ($PNGBC7Converter -eq 'TexConv') { $AlternateProgram = 'Compressonator' } else { $AlternateProgram = 'TexConv' }

  # Attempt to create the texture with the preferred program.
  $TexToolUsed = Invoke-Command -Scriptblock $PNGSpecial -ArgumentList $PNGBC7Converter,$ImageFile,$OutputFile ; if ($CancelMasterLoop) { return }

  # Check to see if it was successfully created.
  if ($TexToolUsed -eq $null)
  {
    # If it was not, then try again using the other program.
    $TexToolUsed = Invoke-Command -Scriptblock $PNGSpecial -ArgumentList $AlternateProgram,$ImageFile,$OutputFile ; if ($CancelMasterLoop) { return }
  }
  # If Compressonator was used to convert the image, we might not need to do more than just move it.
  if (!$NoReturn) { return $TexToolUsed }
}
#==============================================================================================================================================================================================
#  When a PNG texture is to be created, it MUST be created. This function attempts to use every program possible to generate the image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTexture_SuperConvert([string]$ImageFile, [string]$ColorType, [Collections.Generic.List[string]]$Arguments, [string]$OutputFile)
{
  # Create the PNG image with ImageMagick.
  Magick-Convert -ImageFile $ImageFile -Arguments $Arguments -OutputFile $OutputFile

  # Test to see if ImageMagick failed to create the first image.
  if (!(TestPath -LiteralPath $OutputFile))
  {
    # I'm not even going to bother trying to make this work for icons.
    if ($TextureInfo.IsIcon) { return }

    # Try to remove forcing the color type. Some images do not like this, and it's better to create the wrong type rather than no image at all.
    $Arguments.Remove('-define')
    $Arguments.Remove($ColorType)

    # Try using ImageMagick again now that color type is not being forced.
    Magick-Convert -ImageFile $ImageFile -Arguments $Arguments -OutputFile $OutputFile

    # If the image still wasn't created, attempt to use TexConv and Compressonator.
    if (!(TestPath -LiteralPath $OutputFile)) { CreatePNGTexture_Alternate -ImageFile $ImageFile -OutputFile $OutputFile -NoReturn }
  }
}
#==============================================================================================================================================================================================
#  Creates a PNG image when converting from DDS BC7/ARGB/RGBA using TexConv or Compressonator. If the image does not meet certain criteria, it will serve as a temporary image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTextureSingle_PrepareDDSFile([switch]$GetData)
{
  # This function was originally designed to work with only the PNG conversion function, but it's now used for BMP images too. When called from 
  # the PNG function, this function inherits several variables. When called from the BMP function, those variables need to be filled with data.
  if ($GetData)
  {
    # The ImageFile and OutputFile variables should be inherited from any function. Use it to get the name and other properties.
    $ImageItem = Get-Item -LiteralPath $ImageFile
    $ImageName = $ImageItem.BaseName
    $ImageInfo = CreateTextureInfo -ImageFile $ImageFile

    # Going to need the width, height, and format too.
    $Width  = $ImageInfo.Width
    $Height = $ImageInfo.Height
    $Format = $ImageInfo.Extension
  }
  # Create a temporary folder that will hold the new image.
  $TImagePath = CreatePath -LiteralPath ($TempFolder + '\DDS2PNG')
  $TImageFile = $TImagePath + '\' + $ImageName + $PNG

  # Create the temporary image. The function will return whether TexConv or Compressonator was used to generate the image. If the value is null, both programs failed.
  $TexToolUsed = CreatePNGTexture_Alternate -ImageFile $ImageFile -OutputFile $TImageFile

  # Now that we have a temporary PNG, decide if it needs further work done with ImageMagick.
  $Regenerate = New-Object bool[] 5
  $Regenerate[0] = ($TexToolUsed -ne $null)          # Indirectly tests if image exists. If TexConv or Compressonator successfully created the image, this will contain the program name.
  $Regenerate[1] = (!$FlipTexture)                   # If the paramter to flip the texture is set, the temporary image must be regenerated with ImageMagick to flip the texture.
  $Regenerate[2] = ($Width -eq $ImageInfo.Width)     # Regenerate the texture if the width doesn't match the output width.
  $Regenerate[3] = ($Height -eq $ImageInfo.Height)   # Regenerate the texture if the height doesn't match the output height.
  $Regenerate[4] = ($Format -eq $PNG)                # Regenerate the texture if the output format is not PNG.

  # If all conditions pass, the image does not need to be regenerated.
  if (TestBooleanArray -And -Array $Regenerate)
  {
    # Move the image to the destination.
    Move-Item -LiteralPath $TImageFile -Destination $OutputFile -Force

    # The image is finished so return an empty string to signal that we're done.
    return ''
  }
  # The show must go on. Set the image path to the newly created temporary PNG image.
  return $TImageFile
}
#==============================================================================================================================================================================================
#  ImageMagick loses some alpha data when converting TGA images and fails for some images. So try to use TexConv first, as it seems to have much better TGA support.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTextureSingle_PrepareTGAFile()
{
  # TexConv must exist if it's going to be used.
  if (TestPath -LiteralPath $TexConvTool)
  {
    # Create a path to the output file.
    $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $Format

    # Set up the arguments to feed to TexConv.
    $ArgumentList = [Collections.Generic.List[string]]@('-w', $Width, '-h', $Height, '-srgb')

    # Create the image using TexConv.
    RunTexConvTool -ImageFile $ImageFile -Arguments $ArgumentList -OutputFile $OutputFile

    # Add a workaround for ICO files. The image needs to be returned because it is created in a temporary folder and not the final output path.
    if (($MasterOperation -eq 'ConvertTextures') -and ($ConvertFormat -eq $ICO)) { return $OutputFile }

    # If the image was created in the output path, then we are done.
    if (TestPath -LiteralPath $OutputFile) { return '' }
  }
  # TexConv failed to create the image so use ImageMagick as a backup.
  return $ImageFile
}
#==============================================================================================================================================================================================
#  This has been abstracted from the function below so its easier to read and doesn't bloat the below function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPNGImageMagickArguments([hashtable]$TextureInfo, [string]$Dimensions, [string]$ColorType, [string]$Format, [string]$Sharpen)
{
  # Build a list of arguments to feed into ImageMagick.
  $Arguments = New-Object Collections.Generic.List[string]

  # If the image is to be created as a paletted image (indexed).
  if ($PNGPalettedImage)
  {
    # When the colorspace is RGBA, we need to reserve 1 color for transparency.
    if (($TextureInfo.PNGColorSpace -eq 'RGBA') -or ($TextureInfo.PNGColorSpace -eq 'GrayA'))
    {
      $Arguments.Add('-type')   | Out-Null
      $Arguments.Add('PaletteMatte') | Out-Null
      $Arguments.Add('-colors')   | Out-Null
      $Arguments.Add('255') | Out-Null
    }
    # When it's RGB or anything else, we can use all colors.
    else
    {
      $Arguments.Add('-colors')   | Out-Null
      $Arguments.Add('256') | Out-Null
      $Arguments.Add('-unique-colors') | Out-Null
      $Arguments.Add('-type')   | Out-Null
      $Arguments.Add('Palette') | Out-Null
    }
    # The commands to resize the image. Replicated below for non-paletted images.
    $Arguments.Add('-resize')   | Out-Null
    $Arguments.Add($Dimensions) | Out-Null
  }
  # This path handles all "normal" use cases.
  else
  {
    # If the texture has an alpha channel, separate it to prevent ImageMagick from removing color data from fully transparent pixels.
    if (($TextureInfo.PNGColorSpace -eq 'RGBA') -and ($PNGSaveAlphaPixels))
    {
      $Arguments.Add('-channel')  | Out-Null
      $Arguments.Add('RGBA')      | Out-Null
      $Arguments.Add('-separate') | Out-Null
    }
    # Define the color type when creating a PNG texture.
    if ($Format -eq $PNG)
    {
      $Arguments.Add('-define')   | Out-Null
      $Arguments.Add($ColorType) | Out-Null
    }
    # Allow setting the quality of JPG images.
    elseif ($Format -eq $JPG)
    {
      $Arguments.Add('-quality')   | Out-Null
      $Arguments.Add($JPGQualityValue.ToString()) | Out-Null
    }
    # All formats will use these parameters.
    $Arguments.Add('-resize')   | Out-Null
    $Arguments.Add($Dimensions) | Out-Null
    $Arguments.Add('-sharpen')  | Out-Null
    $Arguments.Add($Sharpen) | Out-Null    
    

    # This has to be added if the alpha channel was split from the image.
    if (($TextureInfo.PNGColorSpace -eq 'RGBA') -and ($PNGSaveAlphaPixels))
    {
      $Arguments.Add('-combine') | Out-Null 
    }
  }
  # If the user (or me) wanted to flip the texture. This is an easy means to swizzle/unswizzle the pixels.
  if ($FlipTexture) { $Arguments.Add('-flip') | Out-Null }

  # Return the arguments to the main function.
  return $Arguments
}
#==============================================================================================================================================================================================
#  This function creates a single texture or a mipmap when called from the create PNG mipmap function.
#  In most cases, "CreateTexture" should be used instead of using this function directly. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTextureSingle([hashtable]$TextureInfo, [string]$ImageFile, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath, [bool]$FlipTexture = $false, [string]$ForcedName = '')
{
  # Check to see if the image's name has been forced.
  if ($ForcedName -ne '') { $ImageName = $ForcedName } else { $ImageName = (Get-Item -LiteralPath $ImageFile).BaseName } 

  # Set the full path to the output file using whatever name was decided above.
  $OutputFile = $OutputPath + '\' + $ImageName + $Format

  # Get the dimensions of the image that is being fed to the function.
  $ImageInfo = CreateTextureInfo -ImageFile $ImageFile

  # Some input images may require just a bit more love before it can be passed off to ImageMagick.
  switch ($ImageInfo.Extension)
  {
    # Certain types of DDS formats are not supported by ImageMagick.
    $DDS  {
            # Create a list of all the DDS formats that that ImageMagick can not handle.
            $DDSFormats = [Collections.Generic.List[string]]@('BC4','BC5','BC6','BC7','L8','A8','LA8','A1R5G5B5','A4R4G4B4')

            # When the input texture is a DDS, check for a variety for formats that ImageMagick will fail with.
            if (($DDSFormats -contains $ImageInfo.Format) -or ($ImageInfo.DDSFourCC -eq 'DX10'))
            {
              # Sets the path to the newly created temporary PNG image or an empty string if it does not need to be recreated.
              $ImageFile = CreatePNGTextureSingle_PrepareDDSFile
            }
          }
    # ImageMagick can not handle all TGA images, so pass it off to TexConv.
    $TGA  {
            # Attempt to create the TGA file with TexConv. If it was created, the image path will be empty.
            $ImageFile = CreatePNGTextureSingle_PrepareTGAFile
          }
  }
  # Check to see if the image file does not need to be recreated for any reason.
  if ($ImageFile -eq '')
  {
    # If a temporary DDS image was generated, it is no longer needed so remove it.
    RemovePath -LiteralPath ($TempFolder + '\DDS2PNG')
    RemovePath -LiteralPath ($TempFolder + '\TGA2PNG')
    return
  }
  # Assemble ImageMagick ready parameters for the dimensions, the PNG color type, and the sharpening strength.
  $Dimensions = $Width.ToString() + 'x' + $Height.ToString() + '!'
  $PColorType = 'png:color-type=' + $TextureInfo.PNGColorType
  $Sharpening = CalculateSharpenStrength -BaseWidth $ImageInfo.Width -BaseHeight $ImageInfo.Height -ModWidth $Width -ModHeight $Height
  $Arguments  = GetPNGImageMagickArguments -TextureInfo $TextureInfo -Dimensions $Dimensions -ColorType $PColorType -Format $Format -Sharpen $Sharpening

  # Create the PNG image using the super convert function, which tries multiple programs to generate the image starting with ImageMagick.
  CreatePNGTexture_SuperConvert -ImageFile $ImageFile -ColorType $PColorType -Arguments $Arguments -OutputFile $OutputFile ; if ($CancelMasterLoop) { return }

  # Clean up any feces that this function left behind.
  RemovePath -LiteralPath ($TempFolder + '\DDS2PNG')
  RemovePath -LiteralPath ($TempFolder + '\TGA2PNG')
}
#==============================================================================================================================================================================================
#  Sub-function of "CreatePNGTexture" to create mipmaps for PNG or JPG textures. This is available as a stand-alone function so other parts
#  of the script (such as applying upscaling filters) can make use of it without having to go through the entire "CreateTexture" process.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTextureMipmaps([hashtable]$TextureInfo, [string]$ImageFile, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath, [bool]$FlipTexture = $false)
{
  # Condition to check if the input image is a TIF/TIFF image and that internal images should not be treated like "mipmaps".
  $TIFFCondition = (($TextureInfo.Extension -like ($TIF + '*')) -and ($TIFFNoResizeMipmap))

  # This gets confusing fast, and was a bitch to get working correct since I didn't originally plan for this in my code. 
  # The idea is not to treat internal images as mipmaps where each one is created at half the resolution.
  switch ($TIFFCondition)
  {
    # In this situation, all TIF/TIFF internal images are always used. So count the number of internal images, and force that for the mipmap info or some levels may not have data created for them.
    $true   {
              $MipmapLevels = CountInternalMipmaps -ImageFile $TextureInfo.FullPath
              $MipmapInfo   = CreateMipmapInfoPlus -TextureInfo $TextureInfo -Width $Width -Height $Height -ForcedLevels $MipmapLevels
            }
    # Here the mipmap info is generated, and the number of levels used are calculated based on the input dimensions then verified in the "get correct" function.
    $false  {
              $MipmapInfo   = CreateMipmapInfoPlus -TextureInfo $TextureInfo -Width $Width -Height $Height
              $MipmapLevels = GetCorrectMipmapLevels -TextureName $TextureInfo.Name -MaxLevels $MipmapInfo.Levels
            }
  }
  # First create the top level.
  CreatePNGTextureSingle -TextureInfo $TextureInfo -ImageFile $MipmapInfo.FullPath[0] -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath -FlipTexture $FlipTexture ; if ($CancelMasterLoop) { return }

  # Set the path to the created texture to use as a fallback when getting the mipmap base image.
  $FallbackImage = $OutputPath + '\' + $MipmapInfo.Name[0] + $Format

  # Loop through all levels.
  for ($i=1; $i -le $MipmapLevels; $i++)
  {
    # Get the image that will be used as the new mipmap.
    $MipmapBasePath = GetMipmapBaseImage -MipmapInfo $MipmapInfo -Index $i -GenPath $OutputPath -ImageFallback $FallbackImage -OutputExtension $PNG
    $MipmapBaseName = (Get-Item -LiteralPath $MipmapBasePath).BaseName

    # If the TIF/TIFF condition passes, set the dimensions of the mipmap using the image based on whether or not its a TIFF image.
    $MipmapWidth  = GetModMipmapDimension -Condition $TIFFCondition -MRealDimension $MipmapInfo.RealWidth[$i]  -MCalcDimension $MipmapInfo.Width[$i]  -TRealDimension $TextureInfo.Width  -TSetDimension $Width  
    $MipmapHeight = GetModMipmapDimension -Condition $TIFFCondition -MRealDimension $MipmapInfo.RealHeight[$i] -MCalcDimension $MipmapInfo.Height[$i] -TRealDimension $TextureInfo.Height -TSetDimension $Height 

    # Generate the new Mipmap.
    CreatePNGTextureSingle -TextureInfo $TextureInfo -ImageFile $MipmapBasePath -Width $MipmapWidth -Height $MipmapHeight -Format $Format -OutputPath $OutputPath -FlipTexture $FlipTexture -ForcedName $MipmapInfo.Name[$i] ; if ($CancelMasterLoop) { return }
  }
  # Destroy the folder with internal mipmaps if it exists.
  DestroyMipmapInfoPlus
}
#==============================================================================================================================================================================================
#  Creates a PNG or JPG texture and handles creating external mipmaps for that texture.
#  In most cases, "CreateTexture" should be used instead of using this function directly. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGTexture([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath, [bool]$FlipTexture = $false)
{
  # Check to see if it is not a mipmap texture.
  if (!(CreateMipmapCheck -TextureInfo $TextureInfo))
  {
    # Create the image using the input parameters.
    CreatePNGTextureSingle -TextureInfo $TextureInfo -ImageFile $TextureInfo.FullPath -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath -FlipTexture $FlipTexture
  }
  # This texture is a mipmap texture.
  else
  {
    # If it is, then generate Mipmaps.
    CreatePNGTextureMipmaps -TextureInfo $TextureInfo -ImageFile $TextureInfo.FullPath -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath -FlipTexture $FlipTexture
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: BMP
#==============================================================================================================================================================================================
#
#          
#               
#         
#              
#          
#
#==============================================================================================================================================================================================
#  While bitmap is supported, it is still very limited in what texture formats can be converted to it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateBMPTexture([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Start with the image passed in texture info.
  $ImageInfo = CreateTextureInfo -ImageFile $TextureInfo.FullPath
  $ImageFile = $TextureInfo.FullPath

  # Set the full path to the output file using whatever name was decided above.
  $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $Format

  # Some input images may require just a bit more love before it can be passed off to ImageMagick.
  switch ($ImageInfo.Extension)
  {
    # Certain types of DDS formats are not supported by ImageMagick.
    $DDS  {
            # Create a list of all the DDS formats that that ImageMagick can not handle.
            $DDSFormats = [Collections.Generic.List[string]]@('BC4','BC5','BC6','BC7','L8','A8','LA8')

            # When the input texture is a DDS, check for a variety for formats that ImageMagick will fail with.
            if (($DDSFormats -contains $ImageInfo.Format) -or ($ImageInfo.DDSFourCC -eq 'DX10'))
            {
              # Sets the path to the newly created temporary PNG image or an empty string if it does not need to be recreated.
              $ImageFile = CreatePNGTextureSingle_PrepareDDSFile -GetData
            }
          }
    # ImageMagick can not handle all TGA images, so pass it off to TexConv.
    $TGA  {
            # Attempt to create the TGA file with TexConv. If it was created, the image path will be empty.
            $ImageFile = CreatePNGTextureSingle_PrepareTGAFile -GetData
          }
  }
  # Check to see if the image file does not need to be recreated for any reason.
  if ($ImageFile -eq '')
  {
    # If a temporary DDS image was generated, it is no longer needed so remove it.
    RemovePath -LiteralPath ($TempFolder + '\DDS2PNG')
    RemovePath -LiteralPath ($TempFolder + '\TGA2PNG')
    return
  }
  # Assemble the dimensions for ImageMagick.
  $Dimensions = $Width.ToString() + 'x' + $Height.ToString() + '!'

  # Build a list of arguments to feed into ImageMagick.
  $Arguments = New-Object Collections.Generic.List[string]
  $Arguments.Add('-resize')         | Out-Null
  $Arguments.Add($Dimensions)       | Out-Null 

  # Check to see if the user wants to limit the image to 256 colors.
  if ($BMPLimitColors)
  {
    # When the colorspace is RGBA, we need to reserve 1 color for transparency.
    if (($TextureInfo.PNGColorSpace -eq 'RGBA') -or ($TextureInfo.PNGColorSpace -eq 'GrayA'))
    {
      $Arguments.Add('-type')   | Out-Null
      $Arguments.Add('PaletteMatte') | Out-Null
      $Arguments.Add('-colors')   | Out-Null
      $Arguments.Add('255') | Out-Null
    }
    # When it's RGB or anything else, we can use all colors.
    else
    {
      $Arguments.Add('-type') | Out-Null 
      $Arguments.Add('Palette') | Out-Null 
      $Arguments.Add('-colors') | Out-Null 
      $Arguments.Add('256')     | Out-Null
    }
  }
  # Get the version of the bitmap set.
  $BMPVersion = 'bmp:format=bmp' + $BMPBitmapVersion.ToString()

  # Add the type of bitmap the user wants.
  $Arguments.Add('-define')         | Out-Null
  $Arguments.Add($BMPVersion) | Out-Null

  # Create the bitmap image using ImageMagick.
  Magick-Convert -ImageFile $ImageFile -Arguments $Arguments -OutputFile $OutputFile
}
#==============================================================================================================================================================================================
#  IMAGE CREATION: ICON
#==============================================================================================================================================================================================
#
#       
#                   
#                   
#                   
#       
#
#==============================================================================================================================================================================================
#  Creates an icon file using the sizes specified in the textbox on the "Convert Textures" menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateIconImages([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # If for some reason the string is empty, then don't try to run any code.
  if ($ConvertIconSizes -eq "") { return }

  # Convert the string array into an integer array.
  $IconSizesInt = $ConvertIconSizes.Split(',') | % { Invoke-Expression -Command $_ }

  # Sort the array from least to greatest, then reverse the order.
  [Array]::Sort($IconSizesInt)
  [Array]::Reverse($IconSizesInt)

  # Create a path to store the temporary images.
  $TempIcons = CreatePath -LiteralPath ($TempFolder + '\TempIcons')

  # Store each image into a collection.
  $IconCollection = New-Object Collections.Generic.List[string]

  # Loop through the available icon sizes.
  foreach ($IconSize in $IconSizesInt)
  {
    # Do not allow a size of zero, and not allow icons to exceed 256x256 in size.
    if (($IconSize -gt 0) -or ($IconSize -le 256))
    {
      # Set the full path to the new image.
      $NewIconImageName = $TextureInfo.Name + '_' + $IconSize.ToString()
      $NewIconImagePath = $TempIcons + '\' + $NewIconImageName + $PNG

      # Create the new image that will serve as the current dimensions of the icon.
      CreatePNGTextureSingle -TextureInfo $TextureInfo -ImageFile $TextureInfo.FullPath -Width $IconSize -Height $IconSize -Format $PNG -OutputPath $TempIcons -ForcedName $NewIconImageName

      # Add the image to the collection.
      $IconCollection.Add($NewIconImagePath)
    }
  }
  # Set the output path for the new icon.
  $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $ICO

  # Create the icon in the output path.
  Magick-Convert -Arguments $IconCollection -OutputFile $OutputFile

  # Peform some cleanup.
  RemovePath -LiteralPath $TempIcons
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: TGA
#==============================================================================================================================================================================================
#
#       
#                     
#              
#                   
#               
#
#==============================================================================================================================================================================================
#  Creates multiple TGA images at progressively smaller resolutions to simulate mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTGATextureMipmap([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Create a path to the output file.
  $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $Format

  # Create a mipmap hash table.
  $MipmapInfo = CreateMipmapInfoPlus -TextureInfo $TextureInfo -Width $Width -Height $Height

  # Get the number of mipmaps the texture should be created with.
  $MipmapLevels = GetCorrectMipmapLevels -TextureName $TextureInfo.Name -MaxLevels $MipmapInfo.Levels

  # Create a path to the top level.
  $BaseLevel = $OutputPath + '\' + $TextureInfo.Name + $Format

  # Set up the arguments to feed to TexConv.
  $ArgumentList = [Collections.Generic.List[string]]@('-w', $Width, '-h', $Height, '-srgb')

  # Create the top level using TexConv.
  RunTexConvTool -ImageFile $MipmapInfo.FullPath[0] -Arguments $ArgumentList -OutputFile $BaseLevel

  # Loop through all levels.
  for ($i=1; $i -le $MipmapLevels; $i++)
  {
    # Get the image that will be used as the new mipmap, and the name of the base image that was retrieved. If it matches the name of the previous mipmap, a potentially flipped PNG version was already created.
    $MipmapImage  = GetMipmapBaseImage -MipmapInfo $MipmapInfo -Index $i -GenPath $OutputPath -ImageFallback $TextureInfo.FullPath -OutputExtension $Format
    $MipmapOutput = $OutputPath + '\' + $TextureInfo.Name + '_mip' + $i + $Format

    # Set up the arguments to feed to TexConv.
    $ArgumentList = [Collections.Generic.List[string]]@('-w', $MipmapInfo.Width[$i], '-h', $MipmapInfo.Height[$i], '-srgb')

    # Create the mipmap using TexConv.
    RunTexConvTool -ImageFile $MipmapImage -Arguments $ArgumentList -OutputFile $MipmapOutput
  }
  # Cleanup time.
  DestroyMipmapInfoPlus
}
#==============================================================================================================================================================================================
#  Creates a single TGA texture without mipmaps included.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTGATextureSingle([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Create a path to the output file.
  $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $Format

  # Set up the arguments to feed to TexConv.
  $ArgumentList = [Collections.Generic.List[string]]@('-w', $Width, '-h', $Height, '-srgb')

  # Create the image using TexConv.
  RunTexConvTool -ImageFile $TextureInfo.FullPath -Arguments $ArgumentList -OutputFile $OutputFile
}
#==============================================================================================================================================================================================
#  Creates a TGA texture with or without mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTGATexture([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Check to see if it is not a mipmap texture.
  if (!(CreateMipmapCheck -TextureInfo $TextureInfo))
  {
    # Create the image using the input parameters.
    CreateTGATextureSingle -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath
  }
  # This texture is a mipmap texture.
  else
  {
    # If it is, then generate Mipmaps.
    CreateTGATextureMipmap -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: TIF/TIFF
#==============================================================================================================================================================================================
#
#           
#                         
#                
#                   
#                   
#
#==============================================================================================================================================================================================
#  TEXTURE CREATION: EXTRACT LAYERS FROM MULTI-IMAGE TIF/TIFF
#==============================================================================================================================================================================================
#  Extracts all images within a TIF/TIFF file into separate TIF/TIFF files.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractInternalTIFMipmaps([string]$ImageFile, [string]$OutputPath)
{
  # Get data of the texture, and get the name of the image.
  $TexInfo = CreateTextureInfo -ImageFile $ImageFile

  # Create the path to where mipmaps will be extracted, and create the path to the base image.
  $ExtractPath = CreatePath -LiteralPath ($TempFolder + '\ExtractedTIFFMipmaps')
  $ExtractFile = $ExtractPath + '\' + $TexInfo.FullName

  # There is no point in doing anything if it doesn't even have mipmaps. Simply copy the texture because I'm sure the function that called this one will be looking for it.
  if ($TexInfo.Mipmaps -eq 0) { Copy-Item -LiteralPath $ImageFile -Destination $ExtractFile -Force ; return }

  # Load the image as a drawing image.
  $DrawImage = [Drawing.Image]::FromFile($ImageFile)

  # Count the number of frames in the image.
  $ImageFrames = $DrawImage.GetFrameCount([Drawing.Imaging.FrameDimension]::Page)

  # Loop through all frames.
  for ($i = 1 ; $i -le $ImageFrames ; $i++)
  {
    # Set the active frame to the current level.
    $DrawImage.SelectActiveFrame([Drawing.Imaging.FrameDimension]::Page, $i)

    # Create a path for the image. Distinguish top level from lower levels.
    switch($i)
    {
      # Append the "mip" suffix for any other layers.
      '0'     { $ExtractFile = $ExtractPath + '\' + $TexInfo.FullName }
      default { $ExtractFile = $ExtractPath + '\' + $TexInfo.Name + '_mip' + ($i - 1).ToString() + $TexInfo.Extension }
    }
    # Save the image to the destination.
    $DrawImage.Save($ExtractFile)
  }
  # Remove the hook to the image.
  $DrawImage.Dispose()

  # The final phase: loop through all mipmaps in the temporary path.
  foreach ($LoopImage in EnumerateFiles -LiteralPath $ExtractPath)
  {
    # Move all mipmaps to the output path.
    Move-Item -LiteralPath $LoopImage -Destination $OutputPath -Force
  }
  # Cleanup the temp folder.
  RemovePath -LiteralPath $ExtractPath
}
#==============================================================================================================================================================================================
#  Combines an array of TIF/TIFF files into a single TIF/TIFF file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTIFImages([string[]]$ImageArray, [string]$OutputFile)
{
  # Loop through all the available image converter types.
  foreach ($ImageEncoder in [Drawing.Imaging.ImageCodecInfo]::GetImageEncoders())
  {
    # Get the codec for tiff files.
    if ($ImageEncoder.MimeType -eq 'image/tiff') { $CodecInfo = $ImageEncoder }
  }
  # Use the save encoder and create the parameters.
  $Encoder = [Drawing.Imaging.Encoder]::SaveFlag
  $EncodeParams = New-Object Drawing.Imaging.EncoderParameters(1)

  # Set the encoder parameter to multi-frame image.
  $EncodeParams.Param[0] = New-Object Drawing.Imaging.EncoderParameter($Encoder, [long][Drawing.Imaging.EncoderValue]::MultiFrame)
  $FinalImage = [Drawing.Image]::FromFile($ImageArray[0])
  $FinalImage.Save($OutputFile, $CodecInfo, $EncodeParams)

  # Loop through all images fed to this function.
  for ($Frame = 0; $Frame -lt $ImageArray.Length; $Frame++)
  {
    # Set the encoder paramter to save the intermediate frames.
    $EncodeParams.Param[0] = New-Object Drawing.Imaging.EncoderParameter($Encoder, [long][Drawing.Imaging.EncoderValue]::FrameDimensionPage)
    $TempImage = [Drawing.Image]::FromFile($ImageArray[$Frame])
    $FinalImage.SaveAdd($TempImage, $EncodeParams)
    $TempImage.Dispose()
  }
  # Flush and cleanup.
  $EncodeParams.Param[0] = New-Object Drawing.Imaging.EncoderParameter($Encoder, [long][Drawing.Imaging.EncoderValue]::Flush) 
  $FinalImage.SaveAdd($EncodeParams)
  $FinalImage.Dispose()
}
#==============================================================================================================================================================================================
#  Creates a TIF/TIFF image with no additional layers.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTIFTextureSingle([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Create a path to the output file.
  $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $Format

  # Set up the arguments to feed to TexConv.
  $ArgumentList = [Collections.Generic.List[string]]@('-w', $Width, '-h', $Height, '-srgb')

  # Create the image using TexConv.
  RunTexConvTool -ImageFile $TextureInfo.FullPath -Arguments $ArgumentList -OutputFile $OutputFile
}
#==============================================================================================================================================================================================
#  Combines an array of TIF/TIFF files into a single TIF/TIFF file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTIFTextureMipmap([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # This gets confusing fast, and was a bitch to get working correct since I didn't originally plan for this in my code. 
  # The idea is not to treat internal images as mipmaps where each one is created at half the resolution.
  switch ($TIFFNoResizeMipmap)
  {
    # In this situation, all TIF/TIFF internal images are always used. So count the number of internal images, and force that for the mipmap info or some levels may not have data created for them.
    $true   {
              $MipmapLevels = CountInternalMipmaps -ImageFile $TextureInfo.FullPath
              $MipmapInfo   = CreateMipmapInfoPlus -TextureInfo $TextureInfo -Width $Width -Height $Height -ForcedLevels $MipmapLevels
            }
            
    # Here the mipmap info is generated, and the number of levels used are calculated based on the input dimensions then verified in the "get correct" function.
    $false  {
              $MipmapInfo   = CreateMipmapInfoPlus -TextureInfo $TextureInfo -Width $Width -Height $Height
              $MipmapLevels = GetCorrectMipmapLevels -TextureName $TextureInfo.Name -MaxLevels $MipmapInfo.Levels
            }
  }
  # Create a temporary path to create the mipmaps.
  $TempMipmapPath = CreatePath -LiteralPath ($TempFolder + '\NewMipmaps')

  # Create a path to the top level.
  $BaseLevel = $TempMipmapPath + '\' + $TextureInfo.Name + $Format

  # Set up the arguments to feed to TexConv.
  $ArgumentList = [Collections.Generic.List[string]]@('-w', $Width, '-h', $Height, '-srgb')

  # Create the top level using TexConv.
  RunTexConvTool -ImageFile $MipmapInfo.FullPath[0] -Arguments $ArgumentList -OutputFile $BaseLevel

  # Holds a list of the base texture and all mipmaps.
  $TIFFArray = New-Object string[] ($MipmapLevels + 1)

  # Store the base image into the TIFF array.
  $TIFFArray[0] = $BaseLevel

  # Loop through all levels.
  for ($i=1; $i -le $MipmapLevels; $i++)
  {
    # Get the image that will be used as the new mipmap, and the name of the base image that was retrieved. If it matches the name of the previous mipmap, a potentially flipped PNG version was already created.
    $MipmapImage  = GetMipmapBaseImage -MipmapInfo $MipmapInfo -Index $i -GenPath $TempMipmapPath -ImageFallback $TextureInfo.FullPath -OutputExtension $Format
    $MipmapOutput = $TempMipmapPath + '\' + $TextureInfo.Name + '_mip' + $i + $Format

    # If the TIF/TIFF condition passes, set the dimensions of the mipmap using the image based on whether or not its a TIFF image.
    $TIFFMipWidth  = GetModMipmapDimension -Condition $TIFFNoResizeMipmap -MRealDimension $MipmapInfo.RealWidth[$i]  -MCalcDimension $MipmapInfo.Width[$i]  -TRealDimension $TextureInfo.Width  -TSetDimension $Width  
    $TIFFMipHeight = GetModMipmapDimension -Condition $TIFFNoResizeMipmap -MRealDimension $MipmapInfo.RealHeight[$i] -MCalcDimension $MipmapInfo.Height[$i] -TRealDimension $TextureInfo.Height -TSetDimension $Height 

    # Set up the arguments to feed to TexConv.
    $ArgumentList = [Collections.Generic.List[string]]@('-w', $TIFFMipWidth, '-h', $TIFFMipHeight, '-srgb')

    # Create the mipmap using TexConv.
    RunTexConvTool -ImageFile $MipmapImage -Arguments $ArgumentList -OutputFile $MipmapOutput

    # Store the mipmap into the TIF/TIFF array.
    $TIFFArray[$i] = $MipmapOutput
  }
  # Create the mipmaps externally from the image.
  if ($ExternalDDSMipmaps)
  {
    # Loop through all images in the array.
    foreach ($Image in $TIFFArray)
    {
      # Move them to the destination folder.
      Move-Item -LiteralPath $Image -Destination $OutputPath -Force
    }
  }
  # Combine all images into a single TIF/TIFF file.
  else
  {
    # Create a path to the output file.
    $CombinedFile = $OutputPath + '\' + $TextureInfo.Name + $Format

    # Combine the TIF/TIFF files into a single image.
    CombineTIFImages -ImageArray $TIFFArray -OutputFile $CombinedFile
  }
  # Cleanup time.
  RemovePath -LiteralPath $TempMipmapPath

  # The PLUS version of mipmap info leaves garbage around.
  DestroyMipmapInfoPlus
}
#==============================================================================================================================================================================================
#  The main function to create a TIF/TIFF image which selects whether or not to create mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTIFTexture([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Check to see if it is not a mipmap texture.
  if (!(CreateMipmapCheck -TextureInfo $TextureInfo))
  {
    # Create the image using the input parameters.
    CreateTIFTextureSingle -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath
  }
  # This texture is a mipmap texture.
  else
  {
    # If it is, then generate Mipmaps.
    CreateTIFTextureMipmap -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS
#==============================================================================================================================================================================================
#
#        
#              
#              
#                   
#        
#
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GET UNCOMPRESSED FORMATS
#==============================================================================================================================================================================================
#  Gets the type of DX9 uncompressed DDS texture (RGB8, RGBA8, ARGB8, L8, A8, or LA8).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDX9UncompressedFormat([string]$ImageFile)
{
  # Read the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # To get the channel order, grab the data in the bitmask sections.
  $PF = $ByteArray[80..83]      # 50-54 | Pixel Format Flags
  $BP = $ByteArray[88..91]      # 58-5B | Bits Per Pixel
  $RB = $ByteArray[92..95]      # 5C-5F | Red bit mask.
  $GB = $ByteArray[96..99]      # 60-63 | Green bit mask.
  $BB = $ByteArray[100..103]    # 64-67 | Blue bit mask.
  $AB = $ByteArray[104..107]    # 68-6B | Alpha bit mask.

  # Using all the values above, assemble them all into a byte array.
  [byte[]]$CheckBytes  = @( $PF[0], $PF[1], $PF[2], $PF[3], $BP[0], $BP[1], $BP[2], $BP[3], `
                            $RB[0], $RB[1], $RB[2], $RB[3], $GB[0], $GB[1], $GB[2], $GB[3], `
                            $BB[0], $BB[1], $BB[2], $BB[3], $AB[0], $AB[1], $AB[2], $AB[3]  )

  # Assemble byte arrays representing the flags to check.
  [byte[]]$RGB8_Bytes  = @(   64,    0,    0,    0,   24,    0,    0,    0, `
                             255,    0,    0,    0,    0,  255,    0,    0, `
                               0,    0,  255,    0,    0,    0,    0,    0  )
  [byte[]]$RGBA8_Bytes = @(   65,    0,    0,    0,   32,    0,    0,    0, `
                             255,    0,    0,    0,    0,  255,    0,    0, `
                               0,    0,  255,    0,    0,    0,    0,  255  )
  [byte[]]$ARGB8_Bytes = @(   65,    0,    0,    0,   32,    0,    0,    0, `
                               0,    0,  255,    0,    0,  255,    0,    0, `
                             255,    0,    0,    0,    0,    0,    0,  255  )
  [byte[]]$L8_Bytes    = @(    0,    0,    2,    0,    8,    0,    0,    0, `
                             255,    0,    0,    0,    0,    0,    0,    0, `
                               0,    0,    0,    0,    0,    0,    0,    0  )
  [byte[]]$A8_Bytes    = @(    2,    0,    0,    0,    8,    0,    0,    0, `
                               0,    0,    0,    0,    0,    0,    0,    0, `
                               0,    0,    0,    0,  255,    0,    0,    0  )
  [byte[]]$LA8_Bytes   = @(    1,    0,    2,    0,   16,    0,    0,    0, `
                             255,    0,    0,    0,    0,    0,    0,    0, `
                               0,    0,    0,    0,    0,  255,    0,    0  )
  [byte[]]$A1R5G5B5    = @(   65,    0,    0,    0,   16,    0,    0,    0, `
                               0,  124,    0,    0,  224,   03,    0,    0, `
                              31,    0,    0,    0,    0,  128,    0,    0  )                 
  [byte[]]$A4R4G4B4    = @(   65,    0,    0,    0,   16,    0,    0,    0, `
                               0,   15,    0,    0,  240,    0,    0,    0, `
                              15,    0,    0,    0,    0,  240,    0,    0  )                 

  # Compare them to the one above until a match is found.
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $RGB8_Bytes))  { return 'RGB8'     }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $RGBA8_Bytes)) { return 'RGBA8'    }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $ARGB8_Bytes)) { return 'ARGB8'    }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $L8_Bytes))    { return 'L8'       }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $A8_Bytes))    { return 'A8'       }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $LA8_Bytes))   { return 'LA8'      }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $A1R5G5B5))    { return 'A1R5G5B5' }
  if ([System.Linq.Enumerable]::SequenceEqual($CheckBytes, $A4R4G4B4))    { return 'A4R4G4B4' }

  # The image type isn't compatible with this script or it has a bad header.
  return 'Unknown'
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GET FOURCC VALUE
#==============================================================================================================================================================================================
#  Gets the FourCC value from the header of a DDS image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSFourCC([byte[]]$ByteArray = $null, [string]$ImageFile = "")
{
  # An image file was not defined.
  if ($ByteArray -eq $null)
  {
    # Read the image as a byte array.
    $ByteArray = [IO.File]::ReadAllBytes($ImageFile)
  }
  # Convert the hex values to a string and join them together.
  $FourCC = [BitConverter]::ToString($ByteArray[84..87])
  $FourCC = [string]::Join('', ($FourCC.Split('-') | foreach { [char][byte]([Convert]::ToInt16($_, 16)) }))

  # Return the FourCC value.
  return $FourCC
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GET DXGI BLOCK COMPRESSION
#==============================================================================================================================================================================================
#  Gets the block compression type of a texture with a DX10 header by reading the DXGI_FORMAT flag.
#  Reference: https://msdn.microsoft.com/en-us/library/windows/desktop/bb173059(v=vs.85).aspx
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDX10BlockCompression([int]$DXGI_FORMAT)
{
  # Return the basic compression type. Only "SRGB" types are are distinguished from the rest with "_S" flag.
  switch ($DXGI_FORMAT)
  {
    # This only covers a small spectrum of DDS formats, but these are the ones I'm most concerned with.
    27 { return 'RGBA8'   }  # DXGI_FORMAT_R8G8B8A8_TYPELESS
    28 { return 'RGBA8'   }  # DXGI_FORMAT_R8G8B8A8_UNORM
    29 { return 'RGBA8_S' }  # DXGI_FORMAT_R8G8B8A8_UNORM_SRGB
    30 { return 'RGBA8'   }  # DXGI_FORMAT_R8G8B8A8_UINT
    31 { return 'RGBA8'   }  # DXGI_FORMAT_R8G8B8A8_SNORM
    32 { return 'RGBA8'   }  # DXGI_FORMAT_R8G8B8A8_SINT
    70 { return 'BC1'     }  # DXGI_FORMAT_BC1_TYPELESS
    71 { return 'BC1'     }  # DXGI_FORMAT_BC1_UNORM
    72 { return 'BC1_S'   }  # DXGI_FORMAT_BC1_UNORM_SRGB
    73 { return 'BC2'     }  # DXGI_FORMAT_BC2_TYPELESS
    74 { return 'BC2'     }  # DXGI_FORMAT_BC2_UNORM
    75 { return 'BC2_S'   }  # DXGI_FORMAT_BC2_UNORM_SRGB
    76 { return 'BC3'     }  # DXGI_FORMAT_BC3_TYPELESS
    77 { return 'BC3'     }  # DXGI_FORMAT_BC3_UNORM
    78 { return 'BC3_S'   }  # DXGI_FORMAT_BC3_UNORM_SRGB
    79 { return 'BC4'     }  # DXGI_FORMAT_BC4_TYPELESS
    80 { return 'BC4'     }  # DXGI_FORMAT_BC4_UNORM
    81 { return 'BC4_S'   }  # DXGI_FORMAT_BC4_SNORM
    82 { return 'BC5'     }  # DXGI_FORMAT_BC5_TYPELESS
    83 { return 'BC5'     }  # DXGI_FORMAT_BC5_UNORM
    84 { return 'BC5_S'   }  # DXGI_FORMAT_BC5_SNORM
    87 { return 'ARGB8'   }  # DXGI_FORMAT_B8G8R8A8_UNORM
    90 { return 'ARGB8'   }  # DXGI_FORMAT_B8G8R8A8_TYPELESS
    91 { return 'ARGB8_S' }  # DXGI_FORMAT_B8G8R8A8_UNORM_SRGB
    94 { return 'BC6'     }  # DXGI_FORMAT_BC6H_TYPELESS
    95 { return 'BC6'     }  # DXGI_FORMAT_BC6H_UF16
    96 { return 'BC6_S'   }  # DXGI_FORMAT_BC6H_SF16
    97 { return 'BC7'     }  # DXGI_FORMAT_BC7_TYPELESS
    98 { return 'BC7'     }  # DXGI_FORMAT_BC7_UNORM
    99 { return 'BC7_S'   }  # DXGI_FORMAT_BC7_UNORM_SRGB

    # The texture format is not known.
    default { return 'Unknown - DXGI: ' + $DXGI_FORMAT.ToString() }
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS DIMENSION CALCULATIONS
#==============================================================================================================================================================================================
#  To use, set "DDSMultFour" as a hashtable variable. This tests if the input dimensions are a multiple of four, and returns a hash table that
#  supplies the corrected Width and Height and the combined dimensions. Data is retrieved with "Var.Width" "Var.Height" or "Var.Dimensions".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DDSMultFour([int]$Width, [int]$Height)
{
  # Create and store the values using a hash table.
  $DDSData = @{}

  # Calculate the nearest multiple of 4 for width and height.
  $DDSData.Width  = $Width + 4 - 1 - (($Width + 4 - 1) % 4)
  $DDSData.Height = $Height + 4 - 1 - (($Height + 4 - 1) % 4)

  # Store the combined width and height into a string separated by an "x".
  $DDSData.Dimensions = $DDSData.Width.ToString() + 'x' + $DDSData.Height.ToString()

  # Return the hash table data.
  return $DDSData
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS HEADER CREATION
#==============================================================================================================================================================================================
#  Used when computing the pitch.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSBlockSize([string]$Format)
{
  # The format of the texture. Accepts both variants of DXTn/BC1-3.
  switch ($Format)
  {
    # Return the size of a compressed block, or bits per pixel if uncompressed.
    'BC1'      { return 8  }
    'DXT1'     { return 8  }
    'BC2'      { return 16 }
    'DXT2'     { return 16 }
    'DXT3'     { return 16 }
    'BC3'      { return 16 }
    'DXT4'     { return 16 }
    'DXT5'     { return 16 }
    'BC4'      { return 8  }
    'BC5'      { return 16 }
    'BC6'      { return 16 }
    'BC7'      { return 16 }
    'RGB8'     { return 24 }
    'ARGB8'    { return 32 }
    'RGBA8'    { return 32 }
    'L8'       { return 8  }
    'A8'       { return 8  }
    'LA8'      { return 16 }
    'A1R5G5B5' { return 16 }
    'A4R4G4B4' { return 16 }
  }
}
#==============================================================================================================================================================================================
#  Gets the DX10 specific header flags from an image file. Used to pass this data to the header generation function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDX10HeaderInfo([string]$ImageFile)
{
  # Read the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # Return the values in a hash table.
  $DX10Info = @{}

  # These are the only four bytes I'm concerned with.
  $DX10Info.DXGI   = $ByteArray[128]
  $DX10Info.ResDim = $ByteArray[132]
  $DX10Info.Array  = $ByteArray[140]
  $DX10Info.MiscF2 = $ByteArray[144]

  # Return the hash table.
  return $DX10Info
}
#==============================================================================================================================================================================================
#  The list of DXGI formats that this script creates.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDX10DXGIFormat([string]$Format)
{
  # If the user wants to create textures with SRGB flag set.
  if ($TexConvForceSRGB)
  {
    switch ($Format)
    {
      'BC1'   { return 72 } # DXGI_FORMAT_BC1_UNORM_SRGB
      'DXT1'  { return 72 } # DXGI_FORMAT_BC1_UNORM_SRGB
      'BC2'   { return 75 } # DXGI_FORMAT_BC2_UNORM_SRGB
      'DXT2'  { return 75 } # DXGI_FORMAT_BC2_UNORM_SRGB
      'DXT3'  { return 75 } # DXGI_FORMAT_BC2_UNORM_SRGB
      'BC3'   { return 78 } # DXGI_FORMAT_BC3_UNORM_SRGB
      'DXT4'  { return 78 } # DXGI_FORMAT_BC3_UNORM_SRGB
      'DXT5'  { return 78 } # DXGI_FORMAT_BC3_UNORM_SRGB
      'BC4'   { return 81 } # DXGI_FORMAT_BC4_SNORM
      'BC5'   { return 84 } # DXGI_FORMAT_BC5_SNORM
      'BC6'   { return 96 } # DXGI_FORMAT_BC6H_SF16
      'BC7'   { return 98 } # DXGI_FORMAT_BC7_UNORM_SRGB
      'ARGB8' { return 91 } # DXGI_FORMAT_B8G8R8A8_UNORM_SRGB
      'RGBA8' { return 29 } # DXGI_FORMAT_R8G8B8A8_UNORM_SRGB
    }
  }
  # Return standard texture types.
  else
  {
    switch ($Format)
    {
      'BC1'   { return 71 } # DXGI_FORMAT_BC1_UNORM
      'DXT1'  { return 71 } # DXGI_FORMAT_BC1_UNORM
      'BC2'   { return 74 } # DXGI_FORMAT_BC2_UNORM
      'DXT2'  { return 74 } # DXGI_FORMAT_BC2_UNORM
      'DXT3'  { return 74 } # DXGI_FORMAT_BC2_UNORM
      'BC3'   { return 77 } # DXGI_FORMAT_BC3_UNORM
      'DXT4'  { return 77 } # DXGI_FORMAT_BC3_UNORM
      'DXT5'  { return 77 } # DXGI_FORMAT_BC3_UNORM
      'BC4'   { return 80 } # DXGI_FORMAT_BC4_UNORM
      'BC5'   { return 83 } # DXGI_FORMAT_BC5_UNORM
      'BC6'   { return 95 } # DXGI_FORMAT_BC6H_UF16
      'BC7'   { return 98 } # DXGI_FORMAT_BC7_UNORM
      'ARGB8' { return 87 } # DXGI_FORMAT_B8G8R8A8_UNORM
      'RGBA8' { return 28 } # DXGI_FORMAT_R8G8B8A8_UNORM
    }
  }
}
#==============================================================================================================================================================================================
#  Since I have no good ways to test a DDS image for transparency, set a generic safe value for the "miscFlags2" alpha bit depending on the image format. It's possible
#  that some formats will set a "0" when there is no alpha but is capable of alpha, but I have not encountered any issue when setting the flag to 1 in these cases.
#
#  0 - DDS_ALPHA_MODE_UNKNOWN       - Alpha channel content is unknown. This is the value for legacy files, which typically is assumed to be 'straight' alpha.
#  1 - DDS_ALPHA_MODE_STRAIGHT      - Any alpha channel content is presumed to use straight alpha.
#  2 - DDS_ALPHA_MODE_PREMULTIPLIED - Any alpha channel content is using premultiplied alpha. The only legacy file formats that indicate this information are 'DX2' and 'DX4'.
#  3 - DDS_ALPHA_MODE_OPAQUE        - Any alpha channel content is all set to fully opaque.
#  4 - DDS_ALPHA_MODE_CUSTOM        - Any alpha channel content is being used as a 4th channel and is not intended to represent transparency (straight or premultiplied).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDX10TransparencyByte([string]$Format)
{
  # I could really go for a Dominos pizza right about now.
  switch ($Format)
  {
    # BC1 gets opaque. BC4-6 I think unknown should suffice. Everything else gets straght alpha.
    'BC1'   { return 3 }
    'DXT1'  { return 3 }
    'BC2'   { return 1 }
    'DXT2'  { return 1 }
    'DXT3'  { return 1 }
    'BC3'   { return 1 }
    'DXT4'  { return 1 }
    'DXT5'  { return 1 }
    'BC4'   { return 0 }
    'BC5'   { return 0 }
    'BC6'   { return 0 }
    'BC7'   { return 1 }
    'ARGB8' { return 1 }
    'RGBA8' { return 1 }
  }
}
#==============================================================================================================================================================================================
#  Computes the pitch for a DDS texture header.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSPitchBytes([string]$ImageFormat, [int]$Width, [int]$Height, [int]$BlockSize)
{
  # We need an empty byte array.
  $ByteArray = New-Object Byte[] 4

  # Create a list of all formats that don't store the pitch.
  $NoPitchBytesList = @('A1R5G5B5','A4R4G4B4')

  # If the image format is this type.
  if ($NoPitchBytesList -notcontains $ImageFormat)
  {
    # Create a list of all the uncompressed DDS formats.
    $DDSFormatList = @('RGB8','RGBA8','ARGB8','L8','A8','LA8')

    # If the input texture is one of the above formats, or it has a DX10 header, use Compressonator or ImageMagick.
    $Uncompressed = ($DDSFormatList -contains $ImageFormat)

    # Pitch is computed differently for uncompressed textures.
    if ($Uncompressed)
    {
      # For uncompressed we use the bits per pixel for BlockSize.
      [int]$Pitch = ($Width * $BlockSize) / 8
    }
    # The texture is using block compression.
    else
    {
      # Here we use the block size for BlockSize (woah).
      [int]$Pitch = [Math]::Max(1,($Width / 4)) * [Math]::Max(1,($Height / 4)) * $BlockSize
    }
    # DDS is little endian, so swap the byte order. Convert the value to hex and pad it to 8 digits. 
    $Bytes = (FlipEndian -ByteChain ('{0:X8}' -f $Pitch)).ToCharArray()

    # Store all bytes into the byte array so they can be accessed easier.
    $ByteArray[0] = '{0:D}' -f ('0x' + $Bytes[0] + $Bytes[1])
    $ByteArray[1] = '{0:D}' -f ('0x' + $Bytes[2] + $Bytes[3])
    $ByteArray[2] = '{0:D}' -f ('0x' + $Bytes[4] + $Bytes[5])
    $ByteArray[3] = '{0:D}' -f ('0x' + $Bytes[6] + $Bytes[7])
  }
  # Return the byte array.
  return $ByteArray
}
#==============================================================================================================================================================================================
#  Gets the dimension bytes for a DDS header.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSDimensionBytes([int]$Dimension)
{
  # Convert the value to hex and flip the endianess.
  $Bytes = (FlipEndian -ByteChain ('{0:X8}' -f $Dimension)).ToCharArray()

  # Store all bytes into a byte array so they can be accessed easier.
  $ByteArray = New-Object Byte[] 4
  $ByteArray[0] = '{0:D}' -f ('0x' + $Bytes[0] + $Bytes[1])
  $ByteArray[1] = '{0:D}' -f ('0x' + $Bytes[2] + $Bytes[3])
  $ByteArray[2] = '{0:D}' -f ('0x' + $Bytes[4] + $Bytes[5])
  $ByteArray[3] = '{0:D}' -f ('0x' + $Bytes[6] + $Bytes[7])

  # Return the byte array.
  return $ByteArray
}
#==============================================================================================================================================================================================
#  Generates a header for a DDS file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GenerateDDSHeader([string]$ImageFormat, [string]$FourCC = '', [int]$Width, [int]$Height, [int]$MipmapLevels, [hashtable]$DX10Info = $null)
{
  # Create a list of all the uncompressed DDS formats.
  $UncompressedList = @('RGB8','RGBA8','ARGB8','L8','A8','LA8','A1R5G5B5','A4R4G4B4')

  # This just keeps track of which types are uncompressed so we know to treat them differently.
  $Uncompressed = ($UncompressedList -contains $ImageFormat)

  # Create a special list of uncompressed formats that are treated slightly differently in some places.
  $SUncompressedList = @('A1R5G5B5','A4R4G4B4')

  # Keeps track of uncompressed formats that are treated slightly differently than most uncompressed formats.
  $SUncompressed = ($SUncompressedList -contains $ImageFormat)

  # The block size is referenced multiple times so just find it once.
  $DDSBlockSize = GetDDSBlockSize -Format $ImageFormat

  #============================================================================================================================================================================================
  # Setting the main flags of the header.
  #============================================================================================================================================================================================
  # Store the values in a byte array so they are easy to plug into the header.
  $X = New-Object Byte[] 4

  # DDSD_Caps,[01 00 00 00] DDSD_Height [02 00 00 00], and DDSD_Width [04 00 00 00] will always be set.
  $X[0] = 7

  # If it's a standard uncompressed texture, add DDSD_Pitch [08 00 00 00] to the flag
  if (($Uncompressed) -and (!$SUncompressed))
  {
    $X[0] += 8 
  }
  # DDSD_PixelFormat [00 10 00 00] is required in every header, so always add it.
  $X[1] = 16

  # DDSD_MipmapCount [00 00 02 00] should always be included, so set it by default.
  $X[2] = 2

  # If it's a compressed texture, DDSD_LinearSize [00 00 08 00] will be provided.
  if (!$Uncompressed) { $X[2] += 8}

  #============================================================================================================================================================================================
  # Getting the width and height for the header.
  #============================================================================================================================================================================================
  # These handy functions I created will return a byte array with the correct bytes.
  $W = GetDDSDimensionBytes -Dimension $Width
  $H = GetDDSDimensionBytes -Dimension $Height

  #============================================================================================================================================================================================
  # Getting the pitch for the header.
  #============================================================================================================================================================================================
  # I also created a function to calculate the pitch. I'm not sure if it's 100% correct, but the results match every DDS I threw at it.
  $P = GetDDSPitchBytes -ImageFormat $ImageFormat -Width $Width -Height $Height -BlockSize $DDSBlockSize

  #============================================================================================================================================================================================
  # Getting the depth for the header.
  #============================================================================================================================================================================================
  # Bytes bytes and more bytes.
  $D = New-Object Byte[] 4

  # For the mass majority of DDS add +1 to depth.
  if (!$SUncompressed)
  {
    $D[0] = 1
  }
  #============================================================================================================================================================================================
  # Getting the mipmaps for the header.
  #============================================================================================================================================================================================
  # I doubt a texture will ever have even close to 255 mipmaps, so only fill in the first value.
  $M = New-Object Byte[] 4

  # Mipmaps are stored in the first byte. All other values will default to 0.
  $M[0] = $MipmapLevels

  #============================================================================================================================================================================================
  # Setting up the pixel format header.
  #============================================================================================================================================================================================
  # More bytes. Byte, bite... I'm hungry.
  $Y = New-Object Byte[] 4

  # D3D9 compressed textures and all DX10+ textures always have the DDPF_FourCC [04 00 00 00] flag set.
  if ((!$Uncompressed) -or ($FourCC -eq 'DX10'))
  {
    $Y[0] = 4
  }
  # D3D9 uncompressed textures have all kinds of different flags in the pixel format header.
  elseif (($FourCC -ne 'DX10') -and ($Uncompressed))
  {
    switch ($ImageFormat)
    {
      'RGB8'      { $Y[0] = 64 }            # DDPF_RGB [40 00 00 00]
      'RGBA8'     { $Y[0] = 65 }            # DDPF_RGB [40 00 00 00] and DDPF_ALPHAPIXELS [01 00 00 00]
      'ARGB8'     { $Y[0] = 65 }            # DDPF_RGB [40 00 00 00] and DDPF_ALPHAPIXELS [01 00 00 00]
      'L8'        { $Y[2] = 2  }            # DDPF_LUMINANCE [00 00 02 00]
      'A8'        { $Y[0] = 2  }            # DDPF_ALPHA [02 00 00 00]
      'LA8'       { $Y[0] = 1 ; $Y[2] = 2 } # DDPF_ALPHAPIXELS [01 00 00 00] and DDPF_LUMINANCE [00 00 02 00]
      'A1R5G5B5'  { $Y[0] = 65 }            # DDPF_RGB [40 00 00 00] and DDPF_ALPHAPIXELS [01 00 00 00]
      'A4R4G4B4'  { $Y[0] = 65 }            # DDPF_RGB [40 00 00 00] and DDPF_ALPHAPIXELS [01 00 00 00]
    }
  }
  #============================================================================================================================================================================================
  # Setting up the FourCC field.
  #============================================================================================================================================================================================
  $F = New-Object Byte[] 4

  # DX10 textures will always have the FourCC field. DX9 textures will only have it for compressed textures.
  if (($FourCC -eq 'DX10') -or (!$Uncompressed))
  {
    $ASCIIBytes = $FourCC.ToCharArray()
    $F[0] = [byte][char]$ASCIIBytes[0]
    $F[1] = [byte][char]$ASCIIBytes[1]
    $F[2] = [byte][char]$ASCIIBytes[2]
    $F[3] = [byte][char]$ASCIIBytes[3]
  }
  #============================================================================================================================================================================================
  # Setting up the RGB BitCount and BitMask sections for D3D9 uncompressed DDS textures.
  #============================================================================================================================================================================================
  $C = New-Object Byte[] 4
  $R = New-Object Byte[] 4
  $G = New-Object Byte[] 4
  $B = New-Object Byte[] 4
  $A = New-Object Byte[] 4

  # Only D3D9 uncompressed textures make use of these fields that I know of.
  if (($FourCC -ne 'DX10') -and ($Uncompressed))
  {
    # Get the RGB BitCount flag which equals the bits per pixel.
    $C[0] = $DDSBlockSize

    # Set up the bit mask fields depending on the type of uncompressed texture.
    switch ($ImageFormat)
    {
      'RGB8'      { $R[2] = 255 ; $G[1] = 255 ; $B[0] = 255 }
      'RGBA8'     { $R[0] = 255 ; $G[1] = 255 ; $B[2] = 255 ; $A[3] = 255 }
      'ARGB8'     { $R[2] = 255 ; $G[1] = 255 ; $B[0] = 255 ; $A[3] = 255 }
      'L8'        { $R[0] = 255 }
      'A8'        { $A[0] = 255 }
      'LA8'       { $R[0] = 255 ; $A[1] = 255 }
      'A1R5G5B5'  { $R[1] = 124 ; $G[0] = 224 ; $G[1] = 3  ; $B[0] = 31 ; $A[1] = 128 }
      'A4R4G4B4'  { $R[1] = 15  ; $G[0] = 240 ; $B[0] = 15 ; $A[1] = 240 }
    }
  }
  #============================================================================================================================================================================================
  # Setting up the dwCaps1 flags for the header.
  #============================================================================================================================================================================================
  $I = New-Object Byte[] 4

  # The DDSCaps_Texure [00 10 00 00] flag is required in every texture.
  $I[1] = 16

  # If there are mipmaps, set both the DDSCaps_Mipmap [00 00 40 00] and DDSCaps_Complex [08 00 00 00] flags.
  if ($MipmapLevels -gt 1)
  {
    $I[0] = 8
    $I[2] = 64
  }
  # I honestly have no idea what this flag is, but it is present in some of the stranger uncompressed textures.
  if ($SUncompressed)
  {
    $I[0] += 2
  }
  #============================================================================================================================================================================================
  # Assemble the header using all the data collected.
  #============================================================================================================================================================================================
  [byte[]]$HeaderArray = @(

       68,    68,    83,    32,   124,     0,     0,     0, $X[0], $X[1], $X[2], $X[3], $H[0], $H[1], $H[2], $H[3],  #- 0x00
    $W[0], $W[1], $W[2], $W[3], $P[0], $P[1], $P[2], $P[3], $D[0], $D[1], $D[2], $D[3], $M[0], $M[1], $M[2], $M[3],  #- 0x10
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,  #- 0x20
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,  #- 0x30
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,    32,     0,     0,     0,  #- 0x40
    $Y[0], $Y[1], $Y[2], $Y[3], $F[0], $F[1], $F[2], $F[3], $C[0], $C[1], $C[2], $C[3], $R[0], $R[1], $R[2], $R[3],  #- 0x50
    $G[0], $G[1], $G[2], $G[3], $B[0], $B[1], $B[2], $B[3], $A[0], $A[1], $A[2], $A[3], $I[0], $I[1], $I[2], $I[3],  #- 0x60
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0)  #- 0x70

  #============================================================================================================================================================================================
  # If its a DX10 texture, add 20 more bytes to the header.
  #============================================================================================================================================================================================
  if ($FourCC -eq 'DX10')
  {
    # Zero out the initial values.
    $Z = New-Object Byte[] 4  # DXGI_Format
    $S = New-Object Byte[] 4  # D3D10_RESOURCE_DIMENSION
    $E = New-Object Byte[] 4  # Array Size
    $L = New-Object Byte[] 4  # Misc Flags 2

    # Get the DXGI value of the current image format.
    $DXGIFormat = GetDX10DXGIFormat -Format $ImageFormat

    # If the DX10 header values were retrieved from the previous texture, then copy them over.
    if ($DX10Info -ne $null)
    {
      # Check to see if the format was passed through.
      switch ($DDSBlkCompress -eq '*Passthrough*')
      {
        # If the DXGI format was set to pass through, copy that. If it wasn't, get it from the retexture.
        $true  { $Z[0] = $DX10Info.DXGI }
        $false { $Z[0] = $DXGIFormat }
      }
      $S[0] = $DX10Info.ResDim
      $E[0] = $DX10Info.Array
      $L[0] = $DX10Info.MiscF2
    }
    # Otherwise, attempt to fill these in using what information we know.
    else
    {
      $Z[0] = $DXGIFormat
      $S[0] = 3
      $E[0] = 1
      $L[0] = GetDX10TransparencyByte -Format $ImageFormat
    }
    # Create the DX10 extended array which will be added to the header.
    [byte[]]$ExtendArray = @(

      $Z[0], $Z[1], $Z[2], $Z[3], $S[0], $S[1], $S[2], $S[3],     0,     0,     0,     0, $E[0], $E[1], $E[2], $E[3],  #- 0x80
      $L[0], $L[1], $L[2], $L[3])                                                                                      #- 0x90

    # Store all bytes in a new array.
    $DX10Array = New-Object Byte[] 148

    # Copy the header and extended array into the new array.
    [Array]::Copy($HeaderArray, 0, $DX10Array, 0, 128)
    [Array]::Copy($ExtendArray, 0, $DX10Array, 128, 20)

    # Set the header array to the new array.
    $HeaderArray = $DX10Array
  }
  # Return the newly created header bytes.
  return ,$HeaderArray
}
#==============================================================================================================================================================================================
#  Gets the pixel bytes of a DDS image and stores them in a byte array. Does not include the header.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSImagePixelData([string]$ImageFile)
{
  # Read the image as a byte array.
  $ByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # DX9 textures have a 128 byte header.
  $HeaderLength = 128

  # DX10 textures have a 148 byte array.
  if ((GetDDSFourCC -ByteArray $ByteArray) -eq 'DX10') { $HeaderLength = 148 }

  # Find the number of pixel byte values we are actually copying.
  $PixelLength = $ByteArray.Length - $HeaderLength

  # Store all bytes in a new array.
  $PixelArray = New-Object Byte[] $PixelLength

  # Copy all pixel bytes from the input image byte array ($ByteArray) into the new pixel array. 
  # Start with the byte just past the header, and copy the rest of the entire image which is all pixel data.
  [Array]::Copy($ByteArray, $HeaderLength, $PixelArray, 0, $PixelLength)

  # Return the image pixel data.
  return ,$PixelArray
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: EXTRACT DDS INTERNAL MIPMAPS
#==============================================================================================================================================================================================
#  Calculates the number of bytes that a DDS texture will be made up of depending on the format, width, height, and length of the header.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDDSByteCount([string]$Format, [int]$Width, [int]$Height, [int]$HeaderLength)
{
  # To calculate the total size of each image in bytes (the base texture and each mipmap), the number of pixels can be used as a reference. For DXT3, DXT5, and BC7, we can generally 
  # assume that each pixel is equal to 1 byte. The catch is that DDS is made up of compressed blocks of 4x4=16 pixels. This means each block must be at least 16 bytes, even if a block
  # has less than 16 pixels of data. So, rounding up each dimension to the nearest multiple of four before multiplying the dimensions will give us the correct number of bytes.
  $MultFour = DDSMultFour -Width $Width -Height $Height

  # So now its time to actually calculate the number of bytes using all we know from above. For DXT3/DXT5/BC7, it's known that the dimensions rounded up to the nearest multiple of four
  # and multiplied together will give the exact number of bytes relating to pixel data. BC1 textures require exactly half to represent a 4x4 block, so 16 pixels will be represented in
  # 8 bytes. The formula is the same, except the product of the rounded up dimensions needs to be divided in half. After the pixels have been calculated, all thats left is to add in the
  # size of the header. The header is 128 bytes for DDS textures with a D3D9 header, the FourCC flag will read DXT1/DXT3/DXT5. The header is 148 bytes for DDS textures with a DX10 header,
  # the FourCC flag will read DX10. DXT1/DXT3/DXT5 textures can have a DX10 header, and while rare, is a possibility. All BC7 textures will have a DX10 148 byte header.
  switch ($Format)
  {
    # Some of the most common formats.
    'BC1'   { return ($MultFour.Width * $MultFour.Height / 2 + $HeaderLength) }
    'DXT1'  { return ($MultFour.Width * $MultFour.Height / 2 + $HeaderLength) }
    'BC2'   { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'DXT3'  { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'BC3'   { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'DXT5'  { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'BC4'   { return ($MultFour.Width * $MultFour.Height / 2 + $HeaderLength) }
    'BC5'   { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'BC6'   { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'BC7'   { return ($MultFour.Width * $MultFour.Height + $HeaderLength) }
    'RGB8'  { return ($Width * $Height * 3 + $HeaderLength) }
    'RGBA8' { return ($Width * $Height * 4 + $HeaderLength) }
    'ARGB8' { return ($Width * $Height * 4 + $HeaderLength) }
    'L8'    { return ($Width * $Height + $HeaderLength) }
    'A8'    { return ($Width * $Height + $HeaderLength) }
    'LA8'   { return ($Width * $Height * 2 + $HeaderLength) }

    # And now for some of the more uncommon formats.
    'A1R5G5B5'   { return ($Width * $Height * 2 + $HeaderLength) }
    'A4R4G4B4'   { return ($Width * $Height * 2 + $HeaderLength) }
  }
}
#==============================================================================================================================================================================================
#  Extracts all internal mipmaps from a DDS texture into the output path. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractInternalDDSMipmaps([string]$ImageFile, [string]$OutputPath)
{
  # Get data of the texture, and get the name of the image.
  $TexInfo = CreateTextureInfo -ImageFile $ImageFile -Extended

  # Create the path to where mipmaps will be extracted, and create the path to the base image.
  $ExtractPath = CreatePath -LiteralPath ($TempFolder + '\ExtractedDDSMipmaps')
  $ExtractFile = $ExtractPath + '\' + $TexInfo.Name + $DDS

  # There is no point in doing anything if it doesn't even have mipmaps. Simply copy the texture because I'm sure the function that called this one will be looking for it.
  if ($TexInfo.Mipmaps -eq 0) { Copy-Item -LiteralPath $ImageFile -Destination $ExtractFile -Force ; return }

  # Check to see if the DX10 header was forced.
  switch ($DDSForceDX10Header)
  {
    # If it was, use it. If not, use whatever the image is currently using.
    $true   { $FourCC = 'DX10'  }
    $false  { $FourCC = $TexInfo.DDSFourCC }
  }
  # Generate a new header for the DDS file.
  $HeaderArray = GenerateDDSHeader -ImageFormat $TexInfo.Format -FourCC $FourCC -Width $TexInfo.Width -Height $TexInfo.Height -MipmapLevels 1

  # Get the pixel bytes from the image.
  $PixelArray = GetDDSImagePixelData -ImageFile $ImageFile

  # Calculate the number of bytes that the texture will be made up of.
  $ByteCount = GetDDSByteCount -Format $TexInfo.Format -Width $TexInfo.Width -Height $TexInfo.Height -HeaderLength $HeaderArray.Length

  # The collection of bytes (header + pixel) to represent the new base texture (top mipmap level).
  $NewImageBytes = New-Object Byte[] $ByteCount

  # Copy the generated header and pixel data of the top level (base texture) from the image into the new array. 
  [Array]::Copy($HeaderArray, 0, $NewImageBytes, 0, $HeaderArray.Length)
  [Array]::Copy($PixelArray, 0, $NewImageBytes, $HeaderArray.Length, ($ByteCount - $HeaderArray.Length))

  # Write the texture file. The new byte array should contain the new header, and the pixel data of the first image.
  [IO.File]::WriteAllBytes($ExtractFile, $NewImageBytes) ; if ($CancelMasterLoop) { return }

  # So there are textures with a mipmap count, but don't really have mipmaps.
  $TestByteArray = [IO.File]::ReadAllBytes($ImageFile)

  # If the size of the image matches the byte count, then this texture does not really have mipmaps.
  if ($TestByteArray.Length -eq $ByteCount) { return }

  # Get the offset of the first mipmap within the pixel data.
  $MipmapOffset = $ByteCount - $HeaderArray.Length

  # Now the same shit must be done for every mipmap.
  for ($i=1; $i -le $TexInfo.Mipmaps; $i++)
  {
    # Calculate the dimensions of the mipmap.
    $MipWidth  = CalculateMipmapDimension -Level $i -Dimension $TexInfo.Width
    $MipHeight = CalculateMipmapDimension -Level $i -Dimension $TexInfo.Height

    # Generate a new header for the DDS file.
    $HeaderArray = GenerateDDSHeader -ImageFormat $TexInfo.Format -FourCC $FourCC -Width $MipWidth -Height $MipHeight -MipmapLevels 1

    # Calculate the number of bytes that the texture will be made up of.
    $MipByteCount = GetDDSByteCount -Format $TexInfo.Format -Width $MipWidth -Height $MipHeight -HeaderLength $HeaderArray.Length

    # A temporary byte array.
    $NewMipmapBytes = New-Object Byte[] $MipByteCount

    # Copy the generated header and the pixel data of the mipmap from the input image into the new array. The mipmap offset finally comes in handy.
    [Array]::Copy($HeaderArray, 0, $NewMipmapBytes, 0, $HeaderArray.Length)
    [Array]::Copy($PixelArray, $MipmapOffset, $NewMipmapBytes, $HeaderArray.Length, ($MipByteCount - $HeaderArray.Length))

    # The full name to the extracted mipmap.
    $MipmapFile = $ExtractPath + '\' + $TexInfo.Name + '_mip' + $i + $DDS

    # Write the mipmap file.
    [IO.File]::WriteAllBytes($MipmapFile, $NewMipmapBytes) ; if ($CancelMasterLoop) { return }

    # Update the mipmap offset. Subtract the header size to make up for the header bytes that were added in.
    $MipmapOffset += ($MipByteCount - $HeaderArray.Length)
  }
  # The final phase: loop through all mipmaps in the temporary path.
  foreach ($LoopImage in EnumerateFiles -LiteralPath $ExtractPath)
  {
    # Move all mipmaps to the output path.
    Move-Item -LiteralPath $LoopImage -Destination $OutputPath -Force
  }
  # Cleanup the temp folder.
  RemovePath -LiteralPath $ExtractPath
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GENERATION TOOLS - COMPRESSONATOR
#==============================================================================================================================================================================================
#  Compressonator can create arguably the highest quality images for any DDS format, but it is not without its fair share of issues. It can not work with textures that are already in
#  a DDS format, and it can not resize images. In these cases, a temporary PNG is generated with another tool (so no quality is lost). It also fails to create smaller images at times,
#  and I'm not quite sure why that happens. In this case, the script is smart enough to fall back to another tool to attempt to create any images Compressonator fails to create.
#==============================================================================================================================================================================================
#  Compressonator BC7 image quality can exceed all other programs, but the quality level set must be within reason as it greatly increases the time it takes to create the texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Compressonator_GetQualityLevels([hashtable]$TextureInfo, [int]$Width, [int]$Height)
{
  # Set up the default arguments.
  $Args = @{}
  $Args.Quality = '0.01'
  $Args.Perform = '1.00'

  # Adjust the quality based on what the user set the value to.
  switch ($CompressBC7Quality)
  {
    'Low/Fast'  { $Args.Quality = '0.01' ; $Args.Perform = '1.00' }
    'Medium'    { $Args.Quality = '0.15' ; $Args.Perform = '0.75' }
    'High'      { $Args.Quality = '0.30' ; $Args.Perform = '0.60' }
    'Very High' { $Args.Quality = '0.45' ; $Args.Perform = '0.45' }
    '*Ultra'    { $Args.Quality = '0.60' ; $Args.Perform = '0.30' }
    '*Extreme'  { $Args.Quality = '1.00' ; $Args.Perform = '0.00' }
    'Auto'      {
                  # Get the largest dimension or the soon-to-be converted texture.
                  $Dimension = [Math]::Max($Width, $Height)

                  # If the texture does not have alpha, or it's a mipmap texture, set lower overall qualities.
                  if ((!$TextureInfo.Alpha) -or ($TextureInfo.IsMipmap))
                  {
                    switch ($Dimension)
                    {
                      {$_ -le 64}   { $Args.Quality = '1.00' ; $Args.Perform = '1.00' ; return $Args }
                      {$_ -le 128}  { $Args.Quality = '0.50' ; $Args.Perform = '1.00' ; return $Args }
                      {$_ -le 256}  { $Args.Quality = '0.20' ; $Args.Perform = '1.00' ; return $Args }
                      {$_ -le 512}  { $Args.Quality = '0.10' ; $Args.Perform = '1.00' ; return $Args }
                      {$_ -le 768}  { $Args.Quality = '0.08' ; $Args.Perform = '1.00' ; return $Args }
                      {$_ -le 1024} { $Args.Quality = '0.05' ; $Args.Perform = '1.00' ; return $Args }
                      {$_ -le 2048} { $Args.Quality = '0.02' ; $Args.Perform = '1.00' ; return $Args }
                      default       { $Args.Quality = '0.01' ; $Args.Perform = '1.00' ; return $Args }
                    }
                  }
                  # If the texture has alpha and it's not a mipmap, set higher overall qualities.
                  else
                  {
                    switch ($Dimension)
                    {
                      {$_ -le 64}   { $Args.Quality = '1.00' ; $Args.Perform = '0.00' ; return $Args }
                      {$_ -le 128}  { $Args.Quality = '0.50' ; $Args.Perform = '0.00' ; return $Args }
                      {$_ -le 256}  { $Args.Quality = '0.40' ; $Args.Perform = '0.00' ; return $Args }
                      {$_ -le 512}  { $Args.Quality = '0.24' ; $Args.Perform = '0.00' ; return $Args }
                      {$_ -le 768}  { $Args.Quality = '0.20' ; $Args.Perform = '0.00' ; return $Args }
                      {$_ -le 1024} { $Args.Quality = '0.15' ; $Args.Perform = '0.25' ; return $Args }
                      {$_ -le 2048} { $Args.Quality = '0.10' ; $Args.Perform = '0.50' ; return $Args }
                      default       { $Args.Quality = '0.05' ; $Args.Perform = '1.00' ; return $Args }
                    }
                  }
                }
  }
  # Give us what we want.
  return $Args
}
#==============================================================================================================================================================================================
#  Compressonator can not handle some images as they are, so prepare them before sending them to Compressonator.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Compressonator_PrepareTexture([string]$ImageFile, [int]$Width, [int]$Height)
{
  # Grab the dimensions and extension of the image. Compressonator can not resize images so it must be done with another tool first.
  $ImageInfo = GetImageInfo -ImageFile $ImageFile

  # If the dimensions are simply off by the nearest multiple of four then we don't need to regenerate the image. Compressonator will scale it up a few pixels.
  $MultFour = DDSMultFour -Width $ImageInfo.Width -Height $ImageInfo.Height

  # Set up a series of checks to see if a temporary image needs to be generated.
  $TempCompressImage = New-Object bool[] 2
  $TempCompressImage[0] = ($Width -ne $MultFour.Width)     # The output width is different than the input width.
  $TempCompressImage[1] = ($Height -ne $MultFour.Height)   # The output height is different than the input height.

  # If any of the conditions pass then generate a temporary image.
  if (TestBooleanArray -Or -Array $TempCompressImage)
  {
    # Create a path to generate a temporary texture.
    $TempCompressPath = CreatePath -LiteralPath ($TempFolder + '\Compressonator')

    # Create the resized image as a PNG file.
    CreatePNGTextureSingle -TextureInfo $TextureInfo -ImageFile $ImageFile -Width $Width -Height $Height -Format $PNG -OutputPath $TempCompressPath -ForcedName $OutputName

    # Set the image to the temporary texture.
    $ImageFile = $TempCompressPath + '\' + $OutputName + $PNG
  }
  # Return whatever the image is now.
  return $ImageFile
}
#==============================================================================================================================================================================================
#  The main function to create a texture using Compressonator.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DDSTool_Compressonator([hashtable]$TextureInfo, [string]$ImageFile, [int]$Width, [int]$Height, [string]$OutputFile)
{
  # If the formats above are found, then exit now.
  if ((!(TestPath -LiteralPath $Compressonator)) -or (($TextureInfo.Extension -ne $PNG) -and ($TextureInfo.Extension -ne $JPG))) { return }

  # Resize the image if the current dimensions and the new dimensions do not line up. If the dimensions are only off by the nearest multiple of four, then
  # the image is not resized as Compressonator will automatically scale it up to the nearest multiple of four. This can save some time to not create a new image.
  $ImageFile = Compressonator_PrepareTexture -ImageFile $ImageFile -Width $Width -Height $Height

  # Set the compresion flag based on the type of DDS compression set.
  switch ($TextureInfo.DDSCompression)
  {
    # Compressonator can handle quite a few types of DDS textures.
    'BC1'   { $DDSType = 'BC1'  }
    'DXT1'  { $DDSType = 'BC1'  }
    'BC2'   { $DDSType = 'BC2'  }
    'DXT2'  { $DDSType = 'BC2'  }
    'DXT3'  { $DDSType = 'BC2'  }
    'BC3'   { $DDSType = 'BC3'  }
    'DXT4'  { $DDSType = 'BC3'  }
    'DXT5'  { $DDSType = 'BC3'  }
    'BC4'   { $DDSType = 'BC4'  }
    'BC5'   { $DDSType = 'BC5'  }
    'BC6'   { $DDSType = 'BC6H' }
    'BC7'   { $DDSType = 'BC7'  }
    'ARGB8' { $DDSType = 'ARGB_8888' }
  }
  # Build a list of default arguments to feed into Compressonator.
  $ArgumentList = [Collections.Generic.List[string]]@()

  # Add the swizzle command if the user enabled it.
  if ($CompressSwizzle) { $ArgumentList.Add('-doswizzle') }

  # Encoding will not work with uncompressed textures.
  if ($TextureInfo.DDSCompression -ne 'ARGB8')
  {
    # Set the encoder to what is selected.
    $ArgumentList.Add('-EncodeWith') | Out-Null
    $ArgumentList.Add($CompressEncodeWith) | Out-Null
  }
  # Set the type of texture to create (ARGB8, BC1, BC2, etc..)
  $ArgumentList.Add('-fd') | Out-Null
  $ArgumentList.Add($DDSType) | Out-Null

  # Mipmaps are taken care of in a different function. Also hide progress from command line.
  $ArgumentList.Add('-nomipmap') | Out-Null

  # Check to see if encoding with the CPU or HPC.
  if (($CompressEncodeWith -eq 'CPU') -or ($CompressEncodeWith -eq 'HPC'))
  {
    # Set the number of the threads if the user increased it above zero.
    if ($CompressNumThreads -gt 0)
    {
      # Set the number of threads entered by the user.
      $ArgumentList.Add('-NumThreads')
      $ArgumentList.Add($CompressNumThreads.ToString())
    }
    # Use the number of physical cores present in the system.
    else
    {
      # Set the number to the number of physical cores.
      $ArgumentList.Add('-NumThreads')
      $ArgumentList.Add($PhysicalCores)
    }
  }
  # If the compression type is set to BC1.
  if ($DDSType -eq 'BC1')
  {
    # Check to see if the texture has transparent pixels.
    if (Magick-IndentifyTransparency -ImageFile $ImageFile)
    {
      # Allow using 1-bit Alpha for DXT1 textures.
      $ArgumentList.Add('-DXT1UseAlpha')
      $ArgumentList.Add('1')
    }
  }
  # If the compression type is set to BC7 adjust the level of quality.
  elseif ($DDSType -eq 'BC7')
  {
    # Get the quality and performance levels to use when creating the texture.
    $Args = Compressonator_GetQualityLevels -TextureInfo $TextureInfo -Width $Width -Height $Height

    # Add the quality and performance arguments.
    $ArgumentList.Add('-Quality') | Out-Null
    $ArgumentList.Add($Args.Quality) | Out-Null

    # If the "-Performance" commmand is not disabled.
    if (!$CompressNoPerformance)
    {
      # Add the command to the list.
      $ArgumentList.Add('-Performance') | Out-Null
      $ArgumentList.Add($Args.Perform) | Out-Null
    }
  }
  # Check for a DX9 texture.
  elseif (@('BC1','BC2','BC3') -contains $DDSType)
  {
    # Use the lowest speed for the best possible quality.
    $ArgumentList.Add('-CompressionSpeed') | Out-Null
    $ArgumentList.Add('0') | Out-Null
  }
  # Create the image using Compressonator.
  CompressonatorCLI -ImageFile $ImageFile -Arguments $ArgumentList -OutputFile $OutputFile

  # We no longer need this so send it to the netherworld if it was created.
  RemovePath -LiteralPath ($TempFolder + '\Compressonator')
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GENERATION TOOLS - TEXCONV
#==============================================================================================================================================================================================
#  TexConv is a double edged sword in that it is really fast, convert anything to anything, and even resize images on the fly. But it also creates lower quality textures than
#  Compressonator. It is the only program that can convert BC7 textures to other formats, so it is used even in the Compressonator function if the input texture is a BC7 image. 
#  It does not have many bugs that I'm aware of, but it can fail to read some images. I created a small hacky work-around for this situation using ImageMagick.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DDSTool_TexConv([hashtable]$TextureInfo, [string]$ImageFile, [int]$Width, [int]$Height, [string]$OutputFile)
{
  # The path to TexConv must be correct or else it can't be used!
  if (!(TestPath -LiteralPath $TexConvTool)) { return }

  # Set the compression flag based on the type of DDS compression set.
  switch ($TextureInfo.DDSCompression)
  {
    # TexConv can handle every type of DDS texture.
    'BC1'   { $DDSType = 'BC1_UNORM' }
    'DXT1'  { $DDSType = 'BC1_UNORM' }
    'BC2'   { $DDSType = 'BC2_UNORM' }
    'DXT2'  { $DDSType = 'BC2_UNORM' }
    'DXT3'  { $DDSType = 'BC2_UNORM' }
    'BC3'   { $DDSType = 'BC3_UNORM' }
    'DXT4'  { $DDSType = 'BC3_UNORM' }
    'DXT5'  { $DDSType = 'BC3_UNORM' }
    'BC4'   { $DDSType = 'BC4_UNORM' }
    'BC5'   { $DDSType = 'BC5_UNORM' }
    'BC6'   { $DDSType = 'BC6H_UF16' }
    'BC7'   { $DDSType = 'BC7_UNORM' }
    'ARGB8' { $DDSType = 'B8G8R8A8_UNORM' }
    'RGBA8' { $DDSType = 'R8G8B8A8_UNORM' }
    'L8'    { $DDSType = 'R8_UNORM' }
    'A8'    { $DDSType = 'A8_UNORM' }
    'LA8'   { $DDSType = 'R8G8_UNORM' }
  }
  # Build a list of default arguments to feed into TexConv.
  $ArgumentList = [Collections.Generic.List[string]]@('-f', $DDSType, '-w', $Width, '-h', $Height, '-m', '1')

  # Check to see if we're creating DDS BC7 textures.
  if ($TextureInfo.DDSCompression -eq 'BC7')
  {
    # If the compression type was altered add the flag.
    switch ($TexConvCompSpeed)
    {
      # Standard doesn't have a flag so only add for quick and max.
      'Quick'   { $ArgumentList.Add('-bcquick') }
      'Maximum' { $ArgumentList.Add('-bcmax')   }
    }
  }
  # Check to see if an alpha type was forced.
  switch ($TexConvAlphaType)
  {
    # Set the appropriate flag.
    'Straight'      { $ArgumentList.Add('-alpha')   }
    'Premultiplied' { $ArgumentList.Add('-pmalpha') }
  }
  # Check to see if the user wants to flip the image.
  switch ($TexConvFlipImage)
  {
    # Add one or the other or both or none.
    'Horizontal'  { $ArgumentList.Add('-hflip') }
    'Vertical'    { $ArgumentList.Add('-vflip') }
    'Both'        { $ArgumentList.Add('-hflip') ; $ArgumentList.Add('-vflip') }
  }
  # The "-srgb" flag forces SRGB, "-dx10" forces a DX10 header, "-nogpu" disables GPU.
  if ($TexConvForceSRGB)   { $ArgumentList.Add('-srgb')  | Out-Null }
  if ($DDSForceDX10Header) { $ArgumentList.Add('-dx10')  | Out-Null }
  if ($TexConvDisableGPU)  { $ArgumentList.Add('-nogpu') | Out-Null }

  # I have no idea if adding this is going to have any repercussions down the road. But, I do know it fixes losing color
  # data in fully transparent pixels. It also seemed to give better results in some places.
  $ArgumentList.Add('-sepalpha') | Out-Null

  # Create the texture using TexConv.
  RunTexConvTool -ImageFile $ImageFile -Arguments $ArgumentList -OutputFile $OutputFile
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GENERATION TOOLS - IMAGEMAGICK
#==============================================================================================================================================================================================
#  ImageMagick is very powerful, but it does not support BC7 images. It also creates very bad quality BC1/BC3 DDS textures and should not be used unless everything else fails.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DDSTool_ImageMagick([hashtable]$TextureInfo, [string]$ImageFile, [int]$Width, [int]$Height, [string]$OutputFile)
{
  # Create a list of all the unsupported DDS formats.
  $Unsupported = @('DXT2','BC2','BC4','BC5','BC6','BC7','ARGB8','RGBA8','L8','A8','LA8')

  # If the formats above are found, then exit now because ImageMagick has no idea what to do with them.
  if (($Unsupported -contains $TextureInfo.Format) -or ($Unsupported -contains $TextureInfo.DDSCompression)) { return }

  # Choose either no compression or the correct block compression.
  switch ($TextureInfo.DDSCompression)
  {
    # ImageMagick can barely do shit with DDS textures.
    'BC1'     { $DDSType = 'dds:compression=dxt1' }
    'DXT1'    { $DDSType = 'dds:compression=dxt1' }
    'BC3'     { $DDSType = 'dds:compression=dxt5' }
    'DXT4'    { $DDSType = 'dds:compression=dxt5' }
    'DXT5'    { $DDSType = 'dds:compression=dxt5' }
  }
  # Set up the dimensions in the way ImageMagick expects them.
  $NewDimensions = $Width.ToString() + 'x' + $Height.ToString() + '!'

  # Build a list of arguments to feed into ImageMagick.
  $ArgumentList = [Collections.Generic.List[string]]@('-define', $DDSType, '-define', 'dds:mipmaps=0', '-resize', $NewDimensions)

  # Create the image using ImageMagick.
  Magick-Convert -ImageFile $ImageFile -Arguments $ArgumentList -OutputFile $OutputFile
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS GENERATION TOOLS - AUTO-SELECT PROPER TOOL / TRY NEXT TOOL IF IMAGE FAILS
#==============================================================================================================================================================================================
#  Runs each tool from a list until the texture is created, prioritizing the tool selected by the user.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDDSOptimalTool([hashtable]$TextureInfo, [string]$ImageFile, [int]$Width, [int]$Height, [string]$OutputPath, [string]$ForcedName = '')
{
  # The output name of the texture can be forced if it is set by the function calling it.
  switch ($ForcedName)
  {
    # Use the texture name. The output name will bleed into any DDS creation functions.
    ''      {
              $OutputName = $TextureInfo.Name 
              $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $DDS
            }
    # Use the forced name. This is basically used for custom mipmaps because we never know which image was actually used as the base image.
    default {
              $OutputName = $ForcedName
              $OutputFile = $OutputPath + '\' + $ForcedName + $DDS
            }
  }
  # Create a list containing all tools to loop through. These names must match the ones from the GUI, and the tool's creation function must use the same name.
  $OldToolList = @('Compressonator', 'TexConv', 'ImageMagick')

  # Create a new list with the selected tool at the top of it.
  $NewToolList = @($DDSCreatorTool)

  # This loop arranges the tools in a list that puts the selected tool at the top.
  foreach ($Tool in $OldToolList)
  {
    # We already have the selected tool at the top of the new list.
    if ($Tool -ne $DDSCreatorTool)
    {
      # Add the current tool to list.
      $NewToolList += $Tool
    }
  }
  # If the output file exists, remove it so it can be recreated.
  RemovePath -LiteralPath $OutputFile

  # Loop through the new list to try to create the image with the selected tool first.
  foreach ($Tool in $NewToolList)
  {
    # Run the tool by calling the function by name. All tool creation functions start with "DDSTool_" followed by the tool's name with no spaces.
    Invoke-Expression -Command ('DDSTool_' + $Tool.Replace(' ','') + ' -TextureInfo $TextureInfo -ImageFile $ImageFile -Width $Width -Height $Height -OutputFile $OutputFile')

    # If the texture was created end the loop. 
    if (TestPath -LiteralPath $OutputFile)
    {
      # Store which DDS tool was used.
      $global:DDSToolUtilized = $Tool

      # Break the loop so it's not created again.
      break
    }
    # If it was not created, the loop will continue and the next tool in the list will be used.
    else
    {
      # Debug: Let me know when a tool fails to create an image.
      DebugMessage -Message ('NOTICE: ' + $Tool + ' failed to create the image!')
    }
  }
  # Return the created file so we can run some analysis on it.
  return $OutputFile
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS TEXTURE WITHOUT MIPMAPS
#==============================================================================================================================================================================================
#  Create a DDS texture with corrected dimensions and no mipmap levels.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDDSImageSingle([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$OutputPath)
{
  # Dolphin crashes when using D3D11 if the dimensions are not a multiple of four.
  $MultFour = DDSMultFour -Width $Width -Height $Height

  # Create the texture with the repaired dimensions.
  $NewTexture = CreateDDSOptimalTool -TextureInfo $TextureInfo -ImageFile $TextureInfo.FullPath -Width $MultFour.Width -Height $MultFour.Height -OutputPath $OutputPath ; if ($CancelMasterLoop) { return }

  # Check if the user did not disable headers created by this script.
  if (!$UseStockDDSHeaders)
  {
    # Define these now, set and use them later.
    $FourCC = ''
    $NewImageFormat = $TextureInfo.DDSCompression
    $DX10Info = $null
  
    # Get the FourCC value of the output texture from the generated program.
    $InitialFourCC = GetDDSFourCC -ImageFile $NewTexture

    # Make sure there is actually something in the FourCC value.
    if ($InitialFourCC -ne '')
    {
      # If creating a DX10 texture, we will need to know the actual block compression type.
      $ByteArray   = [IO.File]::ReadAllBytes($NewTexture)
      $DX10BCFlag  = $ByteArray[128]
      $BlkCompress = GetDX10BlockCompression -DXGI_FORMAT $DX10BCFlag

      # Check if the input texture is a DX10 texture.
      switch ($TextureInfo.DDSFourCC -eq 'DX10')
      {
        # If it is, copy the DX10 header info from the input texture. If it isn't, then copy from the new texture.
        $true   { $DX10Info = GetDX10HeaderInfo -ImageFile $TextureInfo.FullPath }
        $false  { $DX10Info = GetDX10HeaderInfo -ImageFile $NewTexture }
      }
      # Check to see if the DX10 header was forced or the input texture is a DX10 image.
      switch (($DDSForceDX10Header) -or ($TextureInfo.DDSFourCC -eq 'DX10'))
      {
        # If it was, use it. If not, use whatever the image was output with.
        $true   { $FourCC = 'DX10'  }
        $false  { $FourCC = $InitialFourCC }
      }
      # Get the initial size of the header to know where to start copying data from. 
      switch ($InitialFourCC)
      {
        # DX9 headers are 128 bytes in length, and DX10 headers are 148 bytes.
        'DX10'  { $NewImageFormat = $BlkCompress }
        default { $NewImageFormat = $InitialFourCC }
      }
    }
    # Generate a new header for the DDS file and get the pixel data.
    $HeaderArray = GenerateDDSHeader -ImageFormat $NewImageFormat -FourCC $FourCC -Width $MultFour.Width -Height $MultFour.Height -MipmapLevels 1 -DX10Info $DX10Info
    $PixelArray  = GetDDSImagePixelData -ImageFile $NewTexture

    # Store all bytes in a new array.
    $ArraySize  = $HeaderArray.Length + $PixelArray.Length
    $FinalArray = New-Object Byte[] $ArraySize

    # Copy all data from the header array and pixel array into the new array.
    [Array]::Copy($HeaderArray, 0, $FinalArray, 0, $HeaderArray.Length)
    [Array]::Copy($PixelArray, 0, $FinalArray, $HeaderArray.Length, $PixelArray.Length)

    # Write all bytes to create the image.
    [IO.File]::WriteAllBytes($NewTexture, $FinalArray)
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: DDS TEXTURE AND MIPMAP GENERATION
#==============================================================================================================================================================================================
#  Creates a DDS texture with custom internal mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDDSImageMipmap([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$OutputPath)
{
  # Dolphin crashes when using D3D11 if the dimensions are not a multiple of four.
  $MultFour = DDSMultFour -Width $Width -Height $Height

  # Create a new mipmap hash table based on the input width and height.
  $MipmapInfo = CreateMipmapInfoPlus -TextureInfo $TextureInfo -Width $MultFour.Width -Height $MultFour.Height

  # Get the number of mipmaps the texture should be created with.
  $MipmapLevels = GetCorrectMipmapLevels -TextureName $TextureInfo.Name -MaxLevels $MipmapInfo.Levels

  # Create a temporary path to create the mipmaps.
  $TempMipmapPath = CreatePath -LiteralPath ($TempFolder + '\NewMipmaps')

  # First create the top layer.
  $CreatedTexture = CreateDDSOptimalTool -TextureInfo $TextureInfo -ImageFile $MipmapInfo.FullPath[0] -Width $MultFour.Width -Height $MultFour.Height -OutputPath $TempMipmapPath

  # Don't waste time if we don't have to.
  if ($CancelMasterLoop) { return }

  # The path to the temporary top layer.
  $BaseImageFile = $TempMipmapPath + '\'+ $TextureInfo.Name + $DDS

  # Get the FourCC value of the output texture from the generated program.
  $InitialFourCC = GetDDSFourCC -ImageFile $BaseImageFile

  # Check if the input texture is a DX10 texture.
  switch ($TextureInfo.DDSFourCC -eq 'DX10')
  {
    # If it is, copy the DX10 header info from the input texture. If it isn't, then copy from the new texture.
    $true   { $DX10Info = GetDX10HeaderInfo -ImageFile $TextureInfo.FullPath }
    $false  { $DX10Info = GetDX10HeaderInfo -ImageFile $BaseImageFile }
  }
  # Check to see if the DX10 header was forced or the input texture is a DX10 image.
  switch (($DDSForceDX10Header) -or ($TextureInfo.DDSFourCC -eq 'DX10'))
  {
    # If it was, use it. If not, use whatever the image was output with.
    $true   { $FourCC = 'DX10'  }
    $false  { $FourCC = $InitialFourCC }
  }
  # Generate a new header for the DDS file and get the pixel data. Send +1 to mipmap levels since the header counts the top level (base texture).
  $HeaderArray = GenerateDDSHeader -ImageFormat $TextureInfo.DDSCompression -FourCC $FourCC -Width $MultFour.Width -Height $MultFour.Height -MipmapLevels ($MipmapLevels + 1) -DX10Info $DX10Info
  $PixelArray  = GetDDSImagePixelData -ImageFile $BaseImageFile

  # The total size of the new image in bytes. This number is initially calculated from the header size, and the pixel size of the top level (base texture). This number
  # is incremented by the pixel size of each mipmap in the loop below. The initial size of this value is also used to find the offset of the first lower mipmap level.
  $ByteCount = $HeaderArray.Length + $PixelArray.Length

  # All pixel bytes of individual mipmaps need to be stored in arrays so they can be accessed later. Add +1 so we can start with index 1 (index 0 will not be used).
  $MipmapPixelArray = New-Object Object[] ($MipmapLevels + 1)

  # Loop through all mipmap levels.
  for ($i=1; $i -le $MipmapLevels; $i++)
  {
    # Find the image which will be used as a base for the new mipmap.
    $MipmapBaseFile = GetMipmapBaseImage -MipmapInfo $MipmapInfo -Index $i -GenPath $TempMipmapPath -ImageFallback $MipmapInfo.FullPath[0] -OutputExtension $DDS

    # Create the mipmap from whatever image was chosen from the above function.
    $CreatedTexture = CreateDDSOptimalTool -TextureInfo $TextureInfo -ImageFile $MipmapBaseFile -Width $MipmapInfo.Width[$i] -Height $MipmapInfo.Height[$i] -OutputPath $TempMipmapPath -ForcedName $MipmapInfo.Name[$i]

    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }

    # Get the pixel data for the mipmap and store it in a hashtable array.
    $MipmapPixelArray[$i] = GetDDSImagePixelData -ImageFile $CreatedTexture

    # Add the number of bytes that make up the mipmap to the total size of the image.
    $ByteCount += $MipmapPixelArray[$i].Length
  }
  # Create a new byte array to store all the collective data in.
  $ImageByteArray = New-Object byte[] $ByteCount

  # Copy the generated header and the pixel data of the top level (base texture) into the new byte array.
  [Array]::Copy($HeaderArray, 0, $ImageByteArray, 0, $HeaderArray.Length)
  [Array]::Copy($PixelArray, 0, $ImageByteArray, $HeaderArray.Length, $PixelArray.Length)

  # Set the initial offset for the first mipmap.
  $MipmapOffset = $HeaderArray.Length + $PixelArray.Length

  # One more loop through all mipmap levels.
  for ($i=1; $i -le $MipmapLevels; $i++)
  {
    # Copy the pixel data from the top level into the new byte array.
    [Array]::Copy($MipmapPixelArray[$i], 0, $ImageByteArray, $MipmapOffset, $MipmapPixelArray[$i].Length)

    # Set the offset to the start of the group of bytes that make up the next mipmap.
    $MipmapOffset += $MipmapPixelArray[$i].Length
  }
  # The full path to where the new texture will be created.
  $OutputFile = $OutputPath + '\' + $TextureInfo.Name + $DDS

  # Write all data to create the image.
  [IO.File]::WriteAllBytes($OutputFile, $ImageByteArray)

  # Don't waste time if we don't have to.
  if ($CancelMasterLoop) { return }

  # If the user wants external mipmaps extract them from the texture.
  if ($ExternalDDSMipmaps) { ExtractInternalDDSMipmaps -ImageFile $OutputFile -OutputPath $OutputPath }

  # Take out the trash before proceeding.
  RemovePath $TempMipmapPath

  # Destroy the folder with internal mipmaps if it exists.
  DestroyMipmapInfoPlus
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MAIN DDS CREATE FUNCTION
#==============================================================================================================================================================================================
#  Creates a DDS texture with or without mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDDSTexture([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$OutputPath)
{
  # The image does not need mipmaps.
  if (!(CreateMipmapCheck -TextureInfo $TextureInfo))
  {
    # Just create the texture without mipmaps.
    CreateDDSImageSingle -TextureInfo $TextureInfo -Width $Width -Height $Height -OutputPath $OutputPath
  }
  # Check to see if the texture will have mipmaps created for it.
  else
  {
    # Custom mipmaps generates all mipmap levels as individual files and splices them together.
    CreateDDSImageMipmap -TextureInfo $TextureInfo -Width $Width -Height $Height -OutputPath $OutputPath
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MATERIAL MAPS
#==============================================================================================================================================================================================
#
#                          
#                                           
#                                
#                                                 
#                                     
#
#==============================================================================================================================================================================================
#  TEXTURE CREATION: CREATE MATERIAL MAPS FROM MATERIAL TEXTURES
#==============================================================================================================================================================================================
#  Creates a list of arguments to send to Ishiiruka Tool when creating material maps from textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Materials_GetArgumentList([bool]$NoMipmaps, [int]$Width=0, [int]$Height=0, [string]$Format, [switch]$FromMaterial=$false)
{
  # Create a list of arguments to feed into Ishiiruka Tool.
  $ArgumentList = New-Object Collections.Generic.List[string]

  # Do not create mipmaps if it's not a mipmap texture.
  if ($NoMipmaps) { $ArgumentList.Add('-nomipmaps') }

  # If dimensions were specified, add them to the arguments.
  if ($Width -gt 0) { $ArgumentList.Add('-w' + $Width) }
  if ($Height -gt 0) { $ArgumentList.Add('-h' + $Height) }

  # Check if the user wanted to convert textures to DDS.
  if ($Format -eq $DDS)
  {
    # Always add this argument for any type of DDS.
    $ArgumentList.Add('-compress')
  
    # If the output format is set to BC7 then create it as that.
    if ($DDSBlkCompress -eq 'BC7') { $ArgumentList.Add('-usebc7') }
  }
  # If the flag is set to create from an already created material map.
  if ($FromMaterial) { $ArgumentList.Add('-frommaterial') }

  # Send back the argument list to feed into Ishiiruka Tool.
  return $ArgumentList
}
#==============================================================================================================================================================================================
#  Creates temporary materials at a new size if the image is to be resized for any reason.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FromMaterials_ResizeMaterials([Collections.Generic.List[string]]$Materials, [int]$OldWidth, [int]$OldHeight, [int]$NewWidth, [int]$NewHeight, [string]$OutputPath)
{
  # Calculate the amount of sharpening the size has changed and the user has it enabled.
  $SharpenStrength = CalculateSharpenStrength -BaseWidth $OldWidth -BaseHeight $OldHeight -ModWidth $NewWidth -ModHeight $NewHeight

  # Start a new list since we will need to reference them later.
  $NewMaterialList = New-Object Collections.Generic.List[string]

  # Store the new dimensions in a format needed by ImageMagick.
  $NewDimensions = $NewWidth.ToString() + 'x' + $NewHeight.ToString() + '!'

  # Loop through each material in the list.
  foreach ($Material in $Materials)
  {
    # Get the texture as an item to extract properties.
    $MaterialItem = Get-Item -LiteralPath $Material

    # Set the path to where the material will be created.
    $NewMaterialPath = $OutputPath + '\' + $MaterialItem.Name

    # Create the temporary rescaled color map.
    Magick-Convert -ImageFile $Material -Arguments @('-resize', $NewDimensions, '-sharpen', $SharpenStrength, '-define', 'png:color-type=6') -OutputFile $NewMaterialPath

    # Add the rescaled material to the new list.
    $NewMaterialList.Add($NewMaterialPath)
  }
  # Return the new list of materials.
  return $NewMaterialList
}
#==============================================================================================================================================================================================
#  Creates an Ishiiruka material map from bump/spec/lum/nrm textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMaterialMap_FromMaterials([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # This is cosmetic only, but include it so the script outputs the proper text.
  $global:DDSToolUtilized = "Ishiiruka Tool"

  # Create a list of all potential material maps.
  $MaterialList = New-Object Collections.Generic.List[string]
  $MaterialUsed = New-Object Collections.Generic.List[string]

  # Add the main texture to the list.
  $MaterialList.Add($TextureInfo.FullPath)

  # Loop through each type of material.
  foreach ($MaterialType in @('bump','spec','nrm','lum'))
  {
    # Set the path to the material.
    $MaterialPath = $TextureInfo.PathName + '.' + $MaterialType + $PNG

    # Check to see if the material exists. 
    if (TestPath -LiteralPath $MaterialPath)
    {
      # If it does, add the type and material to their proper lists.
      $MaterialUsed.Add($MaterialType)
      $MaterialList.Add($MaterialPath)
    }
  }
  # Assemble a string to show which materials were used on the Texture List.
  $ShowMatsUsed = $MaterialUsed[0]

  # Add the rest of the types to the string adding a forward slash between them.
  for ($i = 1 ; $i -lt $MaterialUsed.Count ; $i ++) { $ShowMatsUsed += '/' + $MaterialUsed[$i] }

  # If new dimensions are specified, the materials must be created with these dimensions.
  if (($Width -ne $TextureInfo.Width) -or ($Height -ne $TextureInfo.Height))
  {
    # Set the path to store temporary rescaled textures.
    $RescaledMaterials = CreatePath -LiteralPath ($TempFolder + '\RescaledMaterials')

    # Resize the materials and store them in an array.
    $MaterialList = FromMaterials_ResizeMaterials -Materials $MaterialList -OldWidth $TextureInfo.Width -OldHeight $TextureInfo.Height -NewWidth $Width -NewHeight $Height -OutputPath $RescaledMaterials
  }
  # Create a temporary path to store the Ishiiruka Tool results, and a final path to store the finalized results.
  $TempMaterials  = CreatePath -LiteralPath ($TempFolder + '\TempMaterials')

  # Check to see if the texture should not have mipmaps.
  $NoMipmaps = ((!$TextureInfo.IsMipmap) -or ($DisableMipmaps) -or (($MaxMipmapEnabled) -and ($MaxMipmapLevels -eq 0)))

  # Get a list of arguments to feed into Ishiiruka Tool.
  $ArgumentList = Materials_GetArgumentList -NoMipmaps $NoMipmaps -Format $Format

  # Create the material map in the output folder. The first texture in the list is the color texture.
  Ishiiruka-Tool -ImageFile $MaterialList[0] -Arguments $ArgumentList -OutputPath $TempMaterials

  # Built a collection of the generated material map and its mipmaps if applicable.
  $MatCollection = EnumerateFiles -LiteralPath $TempMaterials -Filter '*.*'

  # Loop through the material maps.
  foreach ($MaterialMap in $MatCollection)
  {
    # Move the generated material map and its mipmaps to the output path.
    Move-Item -LiteralPath $MaterialMap -Destination $OutputPath -Force
  }
  # Cleanup temporary materials if they exist now that they are no longer needed.
  RemovePath -LiteralPath $RescaledMaterials
  RemovePath -LiteralPath $TempMaterials
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: CREATE MATERIAL MAPS FROM EXISTING MATERIAL MAPS
#==============================================================================================================================================================================================
#  Copy the material map and color texture if the size and output format has not changed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FromMaterialMap_CopyMaterial([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # Get the current dimensions of the material map.
  $ImageInfo = GetImageInfo -ImageFile $TextureInfo.MatMap

  # Ishiiruka Tool does not work with BC7 material maps.
  if ($TextureInfo.Format -eq 'BC7')
  {
    # Copy both the material map and the color texture.
    Copy-Item -LiteralPath $TextureInfo.MatMap -Destination $OutputPath
    Copy-Item -LiteralPath $TextureInfo.FullPath -Destination $OutputPath

    # Report to the texture list that the textures were copied.
    TexList_SetTextureStatus -Status 'Copied' -Message 'BC7 material maps can not be converted.'

    # Exit the function now that the work is already done.
    return $true
  }
  # Check if the format and dimensions line up so the texture can just be copied instead of recreated.
  if (($ImageInfo.Width -eq $Width) -and ($ImageInfo.Height -eq $Height) -and ($TextureInfo.Extension -eq $Format))
  {
    # DDS requires an additional layer of checks since the current format and output format may not match.
    if (($TextureInfo.Extension -eq ".dds") -and ($TextureInfo.Format -ne $TextureInfo.DDSCompression)) { return $false }
  
    # Get the texture, material map, and all of their mipmaps in a single collection.
    foreach ($Image in EnumerateFiles -LiteralPath $TextureInfo.Path -Filter ('*' + $TextureInfo.Name + '*'))
    {
      # Loop through the collection and copy them all to the destination folder.
      Copy-Item -LiteralPath $Image -Destination $OutputPath -Force
    }
    # Report to the texture list that the textures were copied.
    TexList_SetTextureStatus -Status 'Copied' -Message 'Material map copied from existing material map.'

    # Exit the function now that the work is already done.
    return $true
  }
  # The texture was not copied so push onward.
  return $false
}
#==============================================================================================================================================================================================
#  Creates an Ishiiruka material map from an already existing material map.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMaterialMap_FromMaterialMap([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath)
{
  # This is cosmetic only, but include it so the script outputs the proper text.
  $global:DDSToolUtilized = "Ishiiruka Tool"

  # If the material map format or size has not changed, it can simply be copied.
  if (FromMaterialMap_CopyMaterial -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath) { return }

  # Path to store the temp material maps.
  $TempMaterials  = CreatePath -LiteralPath ($TempFolder + '\TempMaterialMap')

  # Check to see if the texture should not have mipmaps.
  $NoMipmaps = ((!$TextureInfo.IsMipmap) -or ($DisableMipmaps) -or (($MaxMipmapEnabled) -and ($MaxMipmapLevels -eq 0)))

  # Get a list of arguments to feed into Ishiiruka Tool.
  $ArgumentList = Materials_GetArgumentList -NoMipmaps $NoMipmaps -Width $Width -Height $Height -Format $Format -FromMaterial

  # Run this copy through Ishiiruka Tool.
  Ishiiruka-Tool -ImageFile $TextureInfo.FullPath -Arguments $ArgumentList -OutputPath $TempMaterials

  # Built a collection of the generated material map and its mipmaps if applicable.
  $MatCollection = EnumerateFiles -LiteralPath $TempMaterials -Filter '*.*'

  # Loop through the material maps.
  foreach ($MaterialMap in $MatCollection)
  {
    # Move the generated material map and its mipmaps to the OutputPath path.
    Move-Item -LiteralPath $MaterialMap -Destination $OutputPath -Force
  }
  # Cleanup temporary materials if they exist now that they are no longer needed.
  RemovePath -LiteralPath $TempMaterials
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MERGED RGBA FILES
#==============================================================================================================================================================================================
#
#                            
#                                                             
#                                       
#                                                          
#                                    
#
#==============================================================================================================================================================================================
#  TEXTURE CREATION: SPLIT MERGED RGBA TEXTURES
#==============================================================================================================================================================================================
#  Uses the TextureExtraction Tool by Venomalia to split merged RGBA textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitMergedRGBA([string]$ImagePath, [string]$OutputPath)
{
  # Set up some commands to pass to TextureExtraction Tool.
  $ExtractCommands = @("-Progress:list","-log","none")

  # Split the RGBA texture into its parts.
  TextureExtractionTool -Operation "finalize" -InputPath $ImagePath -OutputPath $OutputPath -Commands $ExtractCommands
}
#==============================================================================================================================================================================================
#  Found in the MasterLoop, when an RGBA image is encountered it is passed off to here.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DetectAndSplitMergedRGBA()
{
  # If the MasterLoop was cancelled then don't do anything here.
  if ($CancelMasterLoop) { return }

  # Make sure the TextureExtraction Tool is present to handle these textures.
  if (TestPath -LiteralPath $TexExtractTool)
  {
    # Modify the "Wait Label" to show that textures are being split.
    $TexListWaitLabel.Size = DPISize (New-Object Drawing.Size(590, 28))
    $TexListWaitLabel.Text = ' Splitting "RGBA" textures with TextureExtraction Tool...'
    $TexListWaitLabel.Visible = $true
    TexList_CenterWaitLabel
  
    # Create a folder to store RGBA textures.
    $RGBACollection = CreatePath -LiteralPath ($TempFolder + '\SplitRGBA' + $Texture.Relative)

    # Split the name on the underscores.
    $SplitRGBAName = $Texture.Name.Split("_")

    # Get the various properties to assemble texture names.
    $TexSize  = $SplitRGBAName[1]
    $MainHash = $SplitRGBAName[2]
    $SubHashA = $SplitRGBAName[3]
    $SubHashB = $SplitRGBAName[4]
    $Format   = $SplitRGBAName[5]

    # Create the two new texture names from the split name above.
    $TexNameA = $RGBACollection + "\tex1_" + $TexSize + "_" + $MainHash + "_" + $SubHashA + "_" + $Format + $PNG
    $TexNameB = $RGBACollection + "\tex1_" + $TexSize + "_" + $MainHash + "_" + $SubHashB + "_" + $Format + $PNG

    # Split the texture into the parts of its sum.
    SplitMergedRGBA -ImagePath $Texture.FullPath -OutputPath $RGBACollection

    # TextureExtraction Tool likes to steal my window title so take it back.
    $host.UI.RawUI.WindowTitle = 'CTT-PS PowerShell'

    # Add the textures to the list of textures to process.
    if (TestPath -LiteralPath $TexNameA) { $global:ProcessMasterList.Add($TexNameA) }
    if (TestPath -LiteralPath $TexNameB) { $global:ProcessMasterList.Add($TexNameB) }

    # Count the number of RGBA textures split.
    $global:CountRGBASplit++
    
    # Restore the "Wait Label" to it's previous setting.
    $TexListWaitLabel.Size = DPISize (New-Object Drawing.Size(450, 28))
    $TexListWaitLabel.Visible = $false
    $TexListWaitLabel.Text = ' Waiting for the current program to close...'
    TexList_CenterWaitLabel
  }
  # If it's not found, then handle them a different way.
  else
  {
    # Add the texture to the list but without showing properties.
    TexList_AddFileString -FilePath $Texture.FullPath -Status 'Fail' -Message 'Combined-RGBA requires TextureExtraction Tool to split!'
  }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MASTER FUNCTION
#==============================================================================================================================================================================================
#  Tests the format of the input texture, or the format of the output texture for BC7, and checks for TexConv which is required to work with BC7.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateCreateTexture([hashtable]$TextureInfo, [string]$OutputPath)
{
  # Get the full path of the output texture so the length can be measured.
  $FullPath = $OutputPath + '\' + $TextureInfo.FullName

  # Set up the static size lists that will contain the conditions and error messages.
  $ConditionList = New-Object bool[] 8
  $ErrorMessages = New-Object string[] 8

  # Condition 00: The full path to the output file exceeds Windows 260 character limit.
  $ConditionList[0] = ($FullPath.Length -gt 260)
  $ErrorMessages[0] = 'Output path exceeds Windows limit of 260 characters. Texture can not be created!'

  # Condition 01: If attempting to create a TIFF image, TexConv must be installed.
  $ConditionList[1] = ((($Format -eq $TIF) -or ($Format -eq $TIFF)) -and (!(TestPath -LiteralPath $TexConvTool)))
  $ErrorMessages[1] = 'Creating TIFF images requires a valid path set to TexConv!'

  # Condition 02: If attempting to create a TGA image, TexConv must be installed.
  $ConditionList[2] = (($Format -eq $TGA) -and (!(TestPath -LiteralPath $TexConvTool)))
  $ErrorMessages[2] = 'Creating TGA images requires a valid path set to TexConv!'

  # Condition 03: If the format of the input image is TGA format and TexConv is not found, do not create the texture.
  $ConditionList[3] = (($TextureInfo.Format -eq 'TGA') -and (!(TestPath -LiteralPath $TexConvTool)))
  $ErrorMessages[3] = 'Converting TGA images to other formats requires a valid path set to TexConv!'

  # Condition 04: If the format of the input image is BC7 format and TexConv is not found, do not create the texture.
  $ConditionList[4] = (($TextureInfo.Format -eq 'BC7') -and (!(TestPath -LiteralPath $TexConvTool)) -and (!$ForceShowBC7Format))
  $ErrorMessages[4] = 'Converting BC7 images to other formats requires a valid path set to TexConv!'

  # Condition 05: If the output format is set to BC7 format and TexConv is not found, do not create the texture.
  $ConditionList[5] = (($TextureInfo.DDSCompression -eq 'BC7') -and (!(TestPath -LiteralPath $TexConvTool)) -and (!$ForceShowBC7Format))
  $ErrorMessages[5] = 'Creating BC7 images requires a valid path to TexConv!'

  # Condition 06: Check for a valid path to Ishiiruka Tool when dealing with any kind of materials.
  $ConditionList[6] = (($TextureInfo.HasMatMap -or $TextureInfo.HasMats) -and (!(TestPath -LiteralPath $IshiirukaTool)))
  $ErrorMessages[6] = 'Creating material maps requires a valid path to Ishiiruka Tool!'

  # Condition 07: Check to see if it is an icon file, and the operation is set to "Convert".
  $ConditionList[7] = (($TextureInfo.IsIcon) -and ($MasterOperation -ne 'ConvertTextures'))
  $ErrorMessages[7] = 'Converting icon files only works in "Convert Textures to Another Format".'

  # Final: Loop through the static list of conditions.
  for($i = 0 ; $i -lt $ConditionList.Count ; $i++)
  {
    # Test to see if the condition passes.
    if ($ConditionList[$i] -eq $true)
    {
      # Show the error message.
      TexList_SetTextureStatus -Status 'Fail' -Message $ErrorMessages[$i]

      # Fail the texture.
      return $false
    }
  }
  # Create the texture if everything is good.
  return $true
}
#==============================================================================================================================================================================================
#  The master function that links together all the different texture creation functions and automatically chooses the appropriate function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTexture([hashtable]$TextureInfo, [int]$Width, [int]$Height, [string]$Format, [string]$OutputPath, [switch]$NoReturn, [bool]$FlipTexture=$false)
{
  # Icons will falsely come up as failed because the output name is slightly different.
  switch ($TextureInfo.IsIcon)
  {
    # Set the full path to where the new texture will be created to test for its existence after it has been created.
    $true   { $NewTextureFile = $OutputPath + '\' + $TextureInfo.Name + $Format }
    $false  { $NewTextureFile = $OutputPath + '\' + $TextureInfo.Name + $Format }
  }
  # Validate the texture should be created by checking a few things.
  if (!(ValidateCreateTexture -TextureInfo $TextureInfo -OutputPath $OutputPath)) { if (!$NoReturn) { return $false } }

  # The texture has a material map included.
  if ($TextureInfo.HasMatMap)
  {
    # Create a material map texture from the existing material map.
    CreateMaterialMap_FromMaterialMap -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath
  }
  # The texture has material textures included.
  elseif ($TextureInfo.HasMats)
  {
    # Create a material map texture from the materials (bump/spec/nrm/lum).
    CreateMaterialMap_FromMaterials -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath
  }
  # Create the texture based on the extension.
  else
  {
    # Select the create method based on the format.
    switch ($Format)
    {
      $PNG    { CreatePNGTexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath -FlipTexture $FlipTexture }
      $DDS    { CreateDDSTexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -OutputPath $OutputPath }
      $JPG    { CreatePNGTexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath }
      $BMP    { CreateBMPTexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath }
      $TIF    { CreateTIFTexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath }
      $TIFF   { CreateTIFTexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath }
      $TGA    { CreateTGATexture  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath }
      $ICO    { CreateIconImages  -TextureInfo $TextureInfo -Width $Width -Height $Height -Format $Format -OutputPath $OutputPath }
    }
  }
  # Return whether or not the texture was created (unless I don't want it to using "NoReturn" parameter).
  if (!$NoReturn) { return (TestPath -LiteralPath $NewTextureFile) }
}
#==============================================================================================================================================================================================
#  TEXTURE CREATION: MISCELLANEOUS TEXTURE FUNCTIONS
#==============================================================================================================================================================================================
#  Used to copy the current texture, its Mipmaps, and Material Map from the current texture path in the hash table to a destination path.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CopyTexture([string]$OutputPath)
{
  # Copy the texture because of reasons.
  Copy-Item -LiteralPath $Texture.FullPath -Destination $OutputPath -Force

  # If the texture is a Mipmap, look for lower Mipmap levels and copy them too.
  if (($Texture.IsMipmap) -or ($Texture.Mipmaps -gt 0))
  {
    # Attempt to create a Mipmap hash table.
    $Mipmap = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

    # Loop through all lower levels.
    for ($i=1; $i -le $Mipmap.Levels; $i++) 
    {
      # If the Mipmap level exists, copy it.
      if ($Mipmap.Exists[$i])
      {
        Copy-Item -LiteralPath $Mipmap.FullPath[$i] -Destination $OutputPath -Force
      }
    }
  }
  # If the texture has a material map, copy it as well.
  if ($Texture.HasMatMap)
  {
    Copy-Item -LiteralPath $Texture.MatMap -Destination $OutputPath -Force
  }
}
#==============================================================================================================================================================================================
#  Checks the decimal value of the input against ScaleThreshold, and increments the integer if the decimal is greater than ScaleThreshold.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ScaleThresholdCorrection([string]$Value)
{
  # Split the integer from the decimal value.
  $ScaleSplit = (FormatDecimal -Value $Value).Split('.', 2)

  # Store the integer value as an actual integer.
  $IntValue = [int]$ScaleSplit[0]

  # Store the decimal value separately without the integer.
  $DecValue = [decimal]('0.' + $ScaleSplit[1])

  # See if the decimal value is greater than or equal to Scale-Fix Threshold.
  if ($DecValue -ge [decimal]$ScaleThreshold)
  {
    # If it is, increment the scaling integer.
    $IntValue++
  }
  # Return the new integer scale.
  return $IntValue
}
#==============================================================================================================================================================================================
#  OPERATION 00: CREATE TEXTURE SIZE DATABASE
#==============================================================================================================================================================================================
#  A series of reusable checks to create or update the DB log file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateDBMissLog()
{
  # The valid operations to create a database missing log file.
  $LogChecks = New-Object bool[] 5
  $LogChecks[0] = ($MasterOperation -eq 'ScanAllTextures')
  $LogChecks[1] = ($MasterOperation -eq 'ConvertTextures')
  $LogChecks[2] = ($MasterOperation -eq 'RescaleTextures')
  $LogChecks[3] = ($MasterOperation -eq 'ResolutionScale')
  $LogChecks[4] = ($MasterOperation -eq 'UpscaleTextures')

  # Check to see if the log is enabled and that the operation is any of the above.
  $global:ValidDBMissLog = TestBooleanArray -Or -Array $LogChecks
}
#==============================================================================================================================================================================================
#  Creates a log file for missing textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDBMissLog()
{
  # We must be in a specific operation and the option must be checked.
  if ((!$ValidDBMissLog) -and (!$DatabaseMissing)) { return }

  # Set the path to the "missing" log file.
  $global:DBMissingLog = $BaseFolder + "\DatabaseMissing.log"

  # If the missing list already exists then null it out.
  if ($DBMissingList -ne $null) { $global:DBMissingList = $null }

  # If the log already exists, 
  if (TestPath -LiteralPath $DBMissingLog)
  {
    # Load in the values already stored.
    $Content = Get-Content -LiteralPath $DBMissingLog

    # If content exists, then load that.
    if ($Content)
    {
      # Convert it to a generic list.
      [Collections.Generic.List[String]]$global:DBMissingList = $Content

      # Escape now so it isn't overwritten with an empty variable.
      return
    }
  }
  # If the missing list has not yet been created.
  if (!$DBMissingList)
  {
    # Create an array to store the missing textures.
    $global:DBMissingList = New-Object Collections.Generic.List[string]
  }
}
#==============================================================================================================================================================================================
#  Adds a missing texture to the database missing log file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddTextureDBLog($TextureInfo)
{
  # We must be in a specific operation.
  if (!$ValidDBMissLog) { return }

  # Check to see if the texture is missing from the list.
  if ($DBMissingList -notcontains $TextureInfo.Name)
  {
    # If it is, then add it to the list.
    $DBMissingList.Add($TextureInfo.Name)

    # If the user wants to add it to a log file.
    if ($DatabaseMissing)
    {
      # Add it to the log file.
      Add-Content -LiteralPath $DBMissingLog -Value $TextureInfo.Name
    }
    # Check to see if the user wishes to copy it to the output folder.
    if ($DatabaseMissCopy)
    {
      # Set the path to where missing textures will be copied.
      $DBMissPath = CreatePath -LiteralPath ($MasterOutputPath + '\DatabaseMissing' + $TextureInfo.Relative)

      # Copy the texture to the destination.
      Copy-Item -LiteralPath $TextureInfo.FullPath -Destination $DBMissPath
    }
  }
}
#==============================================================================================================================================================================================
#  Loads an existing database file before the main loop starts.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadTextureDatabase()
{
  # Don't use a database if we're not in the correct mode.
  if ($CTTPSSelectedMode -ne "Database Mode") { return }

  # If the database already exists then null it out.
  if ($TexDataBase -ne $null) { $global:TexDataBase = $null }

  # Can't load what doesn't exist.
  if (TestPath -LiteralPath $DatabaseFile)
  {
    # Load the texture database.
    $Content = Get-Content -LiteralPath $DatabaseFile

    # If content exists, then load that.
    if ($Content)
    {
      # Convert it to a generic list.
      [Collections.Generic.List[String]]$global:TexDatabase = $Content

      # Escape now so it isn't overwritten with an empty variable.
      return
    }
  }
  # If the text document was empty but it exists.
  $global:TexDatabase = New-Object Collections.Generic.List[string]
}
#==============================================================================================================================================================================================
#  This is called if the user wants to convert textures to a specific format.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTexSizeDatabase()
{
  # Workaround: Textures with "$" in their name throw off regex. So an escape character needs to be injected.
  $RegexTexture = InjectRegexEscapeChar -InputString $Texture.Name -Characters @('$')

  # See if there is a match in the database.
  $Match = ($TexDatabase -match ("\b" + $RegexTexture + "\b*"))

  # Create a string to add to the database.
  $TextureText = $Texture.Name + ';' + $Texture.Dimensions

  # There was no matching entry.
  if ((!$Match) -and (!$Texture.Dolphin))
  {
    # Load the texture and its dimensions into the hash table.
    $TexDatabase.Add($TextureText) | Out-Null

    # Add the texture and dimensions to the database file.
    Add-Content -LiteralPath $DatabaseFile -Value $TextureText

    # Report the texture has been added to the database file.
    TexList_SetTextureStatus -Status 'Added' -Message ('Texture added to "' + $DatabaseName + '" database.')
  }
  # The user wishes to overwrite the current value in the database.
  elseif ($DatabaseOverwrite)
  {
    # Get the index of the entry.
    $DBIndex = $TexDatabase.IndexOf($Match)

    # Overwrite the entry.
    $TexDatabase[$DBIndex] = $TextureText

    # Update the text file with the new content.
    Set-Content -LiteralPath $DatabaseFile -Value $TexDatabase

    # Report the texture dimensions have been updated in the database.
    TexList_SetTextureStatus -Status 'Updated' -Message ('Texture dimensions updated in "' + $DatabaseName + '" database.')
  }
  # The texture already exists in the database.
  else
  {
    # Report the texture already exists in the database.
    TexList_SetTextureStatus -Status 'Exists' -Message ('Texture already exists in "' + $DatabaseName + '" database.')
  }
}
#==============================================================================================================================================================================================
#  OPERATION 01: SCAN DOLPHIN TEXTURES FOR ISSUES +
#  OPERATION 02: SCAN DATABASE TEXTURES FOR ISSUES - ISSUE DETECTION
#==============================================================================================================================================================================================
#  ISSUE 00: Check to see if it's actually an HD texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_00()
{
  # See if the user wants to detect NotHD textures, and test both the width and height..
  if ((!$Texture.RGBA) -and (!$AllowNotHD) -and (($Texture.ScaleWidth -le 1) -or ($Texture.ScaleHeight -le 1)))
  {
    # Copy NotHD textures to their own folder.
    $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\NotHDTextures' + $Texture.Relative)
    CopyTexture -OutputPath $OutputPath

    # Output that it copied the file.
    $global:IssuesMessage = 'Not HD ; '

    # Track that it had issues.
    $global:TextureIssues += 1
    $global:StatusOfIssue = "Issues"
  }
}
#==============================================================================================================================================================================================
#  ISSUE 01: Check for Dolphin identified duplicates (ones that end with .1, .2, .3, etc.)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_01()
{
  # Only perform this on Dolphin textures.
  if ($Texture.Dolphin)
  {
    # Splits the texture name into 2 parts based on any periods found
    $SplitPeriod = $Texture.Name.Split('.',2)

    # Check to see something exists after the period, and that it is an integer (so it doesn't catch material map textures).
    if (($SplitPeriod[1]) -and ($SplitPeriod[1] -as [int] -is [int]))
    {
      # Copy DolphinDupes to their own folder.
      $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\DolphinDuplicates' + $Texture.Relative)
      CopyTexture -OutputPath $OutputPath

      # Output that it copied the file.
      $global:IssuesMessage += 'Dolphin Dupe ; '
      
      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
  }
}
#==============================================================================================================================================================================================
#  ISSUE 02: Test for Duplicate Texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_02()
{
  # Only run if the user does not want to hide duplicates.
  if (!$IgnoreDuplicates)
  {
    # Find the texture in the "Duplicates" hash table if it exists.
    if ($Duplicates.ContainsKey($Texture.Name))
    {
      # Copy Duplicates to their own folder.
      $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\DuplicateTextures' + $Texture.Relative)
      CopyTexture -OutputPath $OutputPath

      # Get the value of that texture from the hash table (the size of the texture when added).
      $CheckSize = $Duplicates.Get_Item($Texture.Name)

      # If the sizes match, then it's an exact duplicate.
      if ($CheckSize -eq $Texture.Size)
      {
        # Add the issue to the global issues variable.
        $global:IssuesMessage += 'Duplicate ; '
      }
      # If they don't match report that it is different.
      else
      {
        # Add the issue to the global issues variable.
        $global:IssuesMessage += 'Duplicate (Different) ; '
      }
      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
    # If the texture was not in the Duplicates hash table.
    else
    {
      # Add it to the Duplicates hash table by texture name and store the size as its value.
      $Duplicates.Add($Texture.Name, $Texture.Size) | Out-Null
    }
  }
}
#==============================================================================================================================================================================================
#  ISSUE 03: Check to see if there are any missing external Mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_03()
{
  # If it's a DDS texture, we only check for external if it is set as the DDS mipmap type.
  if (($Texture.Extension -eq $DDS) -and (!$ExternalDDSMipmaps)) { return }

  # It must be a mipmap texture. If it's a material map texture, skip it. 
  if (($Texture.IsMipmap) -and (!$Texture.HasMatMap))
  {
    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($Texture.Width, $Texture.Height))

    # Get the number of external mipmaps.
    $MipmapsFound = CountExternalMipmaps -ImageFile $Texture.FullPath -Levels $MipmapLevels

    # Find how many mipmap levels are missing.
    $CountMissing = $MipmapLevels - $MipmapsFound

    # Check to see if there are any missing mipmap levels.
    if ($CountMissing -gt 0)
    {
      # If it's a DDS texture, show a slightly different message.
      if ($Texture.Extension -eq $DDS)
      { 
        $global:IssuesMessage += 'External Mipmaps Missing (x' + $CountMissing + ') ; '
      } 
      # Otherwise show the message for PNG/JPG textures.
      else 
      {
        $global:IssuesMessage += 'Mipmaps Missing (x' + $CountMissing + ') ; '
      }
      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
  }
} 
#==============================================================================================================================================================================================
#  ISSUE 04: Check to see if the texture has material textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_04()
{
  # Reference the "HasMaterials" variable.
  if (($Texture.Dolphin) -and ($Texture.HasMats))
  {
    # Add the issue to the global issues variable.
    $global:IssuesMessage += 'Material Maps Found ; '
    $global:StatusOfIssue = "Notice"
  }
}
#==============================================================================================================================================================================================
#  ISSUE 05: Check to see if the texture name has spaces.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_05()
{
  # Get the name of the texture with no spaces.
  $TextureNoSpace = $Texture.FullName.Replace(" ","")

  # Compare it to the length of the original name. If they don't match, spaced were removed.
  if (($Texture.Dolphin) -and ($Texture.FullName.Length -ne $TextureNoSpace.Length))
  {
    # The path to the new texture name.
    $FixedFullPath = $Texture.Path + '\' + $Texture.FullName.Replace(" ","")

    # Rename without spaces. Move-Item is used for PS v2 users.
    Move-Item -LiteralPath $Texture.FullPath -Destination $FixedFullPath -Force

    # Report to the user that spaces were removed.
    $global:IssuesMessage += 'Spaces in texture name have been removed. ; '
    $global:StatusOfIssue = "Repaired"
  }
}
#==============================================================================================================================================================================================
#  ISSUE 06: PNG/JPG only. Check to see if there are any Mipmaps with bad scaling values.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_06()
{
  # Texture must be a PNG/JPG Mipmap texture.
  if (($Texture.IsMipmap) -and ($Texture.Extension -ne $DDS))
  {
    # For now assume none of the mipmaps have bad dimensions.
    $BadDimensions = 0

    # Create a mipmap hashtable.
    $MipmapInfo = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

    # Loop through all mipmaps.
    for ($i = 1; $i -le $MipmapInfo.Levels; $i++)
    {
      # Compare the calculated dimensions with the real dimensions and count the number that don't match up.
      if ($MipmapInfo.Exists[$i] -and ($MipmapInfo.Dimensions[$i] -ne $MipmapInfo.RealDimensions[$i]))
      {
        # We have a loser, so throw it in the pile.
        $BadDimensions += 1
      }
    }
    # It's pretty obvious what's going on here.
    if ($BadDimensions -gt 0)
    {
      # Add the issue to the global issues variable.
      $global:IssuesMessage += 'Mipmaps Bad Scale (x' + $BadDimensions + ') ; '

      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
  }
}
#==============================================================================================================================================================================================
#  ISSUE 07: PNG/JPG only. Check to see if the integer variables match between scales.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_07()
{
  # Texture must be PNG/JPG and scaling values must not be identical for both width and height.
  if (($Texture.Extension -ne $DDS) -and ($Texture.ScaleWidth -ne $Texture.ScaleHeight))
  {
    # Add the issue to the global issues variable.
    $global:IssuesMessage += 'Width/Height Uneven Upscale Values ; '

    # Track that it had issues.
    $global:TextureIssues += 1
    $global:StatusOfIssue = "Issues"
  }
}
#==============================================================================================================================================================================================
#  ISSUE 08: PNG/JPG only. Check to see if the scale is an integer scale.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_08()
{
  # Texture must be in PNG/JPG format.
  if ($Texture.Extension -ne $DDS)
  {
    # Split the value for both width and height to grab a decimal value if it exists.
    $WidthCheck  = $Texture.ScaleWidth.ToString().Split('.',2)
    $HeightCheck = $Texture.ScaleHeight.ToString().Split('.',2)

    # The value should store double zeros if there is no decimal value.
    if (($WidthCheck[1] -ne '00') -or ($HeightCheck[1] -ne '00'))
    {
      # Add the issue to the global issues variable.
      $global:IssuesMessage += 'Non-Integer Upscale ; '

      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
  }
}
#==============================================================================================================================================================================================
#  ISSUE 09: PNG/JPG only. Check to see if the aspects match between original and custom.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_09()
{
  # Texture must be PNG/JPG and aspect ratios must not be identical between the original and custom texture.
  if (($Texture.Extension -ne $DDS) -and ($Texture.OldAspect -ne $Texture.Aspect))
  {
    # Add the issue to the global issues variable.
    $global:IssuesMessage += 'Wrong Aspect Ratio ; '
    
    # Track that it had issues.
    $global:TextureIssues += 1
    $global:StatusOfIssue = "Issues"
  }
}
#==============================================================================================================================================================================================
#  ISSUE 10: DDS only. Check DDS dimensions against calculated dimensions to see if they are at the nearest multiple of 4.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_10()
{
  # Make sure the textures is in DDS format.
  if ($Texture.Extension -eq $DDS)
  {
    # Set an annoying amount of variables to get the "DDS version" of the dimensions.
    $SplitScaleWidth = $Texture.ScaleWidth.ToString().Split('.',2)

    # Calculate the dimensions using the original texture and the current width scale.
    $CheckWidth = [int]$Texture.OldWidth * [int]$SplitScaleWidth[0]

    # Height scale is not used because if the scales are uneven it would throw off the calculation.
    $CheckHeight = [int]$Texture.OldHeight * [int]$SplitScaleWidth[0]

    # Run the new dimensions through the DDS dimension algorithm to get a hashtable with the "nearest multiple of 4" dimensions.
    $MultFour = DDSMultFour -Width $CheckWidth -Height $CheckHeight

    # If the dimensions end up different than the custom texture, then the custom texture is wrong.
    if ($Texture.Dimensions -ne $MultFour.Dimensions)
    {
      # Add the issue to the global issues variable.
      $global:IssuesMessage += 'Wrong DDS Dimensions ; '

      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
  }
}
#==============================================================================================================================================================================================
#  ISSUE 11: DDS only. Check DDS for missing internal mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_11()
{
  # Texture must be a DDS mipmap texture, it must not be a material map, and the user must not force external mipmaps.
  if (($Texture.IsMipmap) -and (!$Texture.HasMatMap) -and ($Texture.Extension -eq $DDS) -and (!$ExternalDDSMipmaps))
  {
    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($Texture.Width, $Texture.Height))

    # Get the number of internal mipmaps.
    $MipmapsFound = CountInternalMipmaps -ImageFile $Texture.FullPath

    # Find how many mipmap levels are missing.
    $CountMissing = $MipmapLevels - $MipmapsFound

    # The log stuff to report missing mipmaps.
    if ($CountMissing -gt 0)
    {
      # Add the issue to the global issues variable.
      $global:IssuesMessage += 'DDS Internal Mipmaps Missing (x' + $CountMissing + ') ; '

      # Track that it had issues.
      $global:TextureIssues += 1
      $global:StatusOfIssue = "Issues"
    }
  }
}
#==============================================================================================================================================================================================
#  ISSUE 12: User defined scaling values.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_12()
{
  # If "Allow Not-HD textures" is enabled and the scale is 1x then ignore it for this option too.
  if (($AllowNotHD) -and ($Texture.ScaleWidth -eq 1) -and ($Texture.ScaleHeight -eq 1))
  {
    # Run to the hills, run for your life.
    return
  }
  # If this list is empty or if we're not even looking for bad scales then no reason to continue.
  if ((!$UserScaleValues) -or ($AcceptedScales -eq ""))
  {
    # Nowhere to go, nothing to do.
    return
  }
  # Create a decimal array.
  $AcceptedScalesDec = New-Object Collections.Generic.List[decimal]

  # Create an array from the values separated by commas.
  $AcceptedScalesSplit = $AcceptedScales.Split(',')

  # Convert the string array into a decimal array.
  foreach ($StringValue in $AcceptedScalesSplit)
  {
    # Add the "00" to the end of the value.
    $NewValue = $StringValue + ".00"

    # Convert the value to decimal.
    $DecValue = [decimal]$NewValue.Replace(",", ".")

    # Add the new value to the decimal list.
    $AcceptedScalesDec.Add($DecValue)
  }
  # Sort the array from least to greatest, then reverse the order.
  [Array]::Sort($AcceptedScalesDec)

  # Check to see if either the width scale or the height scale is outside of the accepted scaling value.
  if (($AcceptedScalesDec -notcontains $Texture.ScaleWidth) -or ($AcceptedScalesDec -notcontains $Texture.ScaleHeight))
  {
    # Add the issue to the global issues variable.
    $global:IssuesMessage += 'Unaccepted User Scale ; '

    # Track that it had issues.
    $global:TextureIssues += 1
    $global:StatusOfIssue = "Issues"
  }
}
#==============================================================================================================================================================================================
#  ISSUE 13: RGBA texture created by TextureExtraction Tool.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckTextureForIssue_13()
{
  # Educate the user what these are.
  if ($Texture.RGBA)
  {
    # Add the issue to the global issues variable.
    $global:IssuesMessage += 'Note: CTT-PS will automatically split these textures when converting. ; '

    # Track that it had issues.
    $global:StatusOfIssue = "Combined-RGBA"
  }
}
#==============================================================================================================================================================================================
#  OPERATION 01: SCAN DOLPHIN TEXTURES FOR ISSUES +
#  OPERATION 02: SCAN DATABASE TEXTURES FOR ISSUES - TEXTURE REPAIR AND COPY
#==============================================================================================================================================================================================
#  Try to repair the texture and track if it was repaired.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AttemptRepair()
{
  # Find the difference in aspect between the original and custom textures.
  $AspectDifference = [Math]::Abs($Texture.Aspect - $Texture.OldAspect)

  # Keeps track of whether or not the texture was repaired.
  $TextureRepaired = $false

  # Attempt to repair the bad texture if the user wanted to, and the aspect difference is within the aspect fix threshold.
  if (($RepairTextures) -and ($AspectDifference -le [decimal]$AspectThreshold))
  {
    # Find the smallest scale between width and height and see if the integer should be incremented.
    $NewScale = ScaleThresholdCorrection -Value ([Math]::Min($Texture.ScaleWidth, $Texture.ScaleHeight))

    # Use the new scaling value to determine the new dimensions.
    $NewWidth  = ([int]$Texture.OldWidth * $NewScale)
    $NewHeight = ([int]$Texture.OldHeight * $NewScale)

    # Create the repaired folder location if it does not exist.
    $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\RepairedTextures' + $Texture.Relative)

    # The full path to where the new texture will be created.
    $ExistingTexture = $OutputPath + '\' + $Texture.Name + $Extension

    # If the user wants to skip textures that already exist, allow doing this.
    if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $ExistingTexture)) 
    {
      # Report that the texture already exists.
      $global:IssuesMessage += 'Repair Skipped: Texture Already Exists in Output Path ; '
    }
    # The user does not want to skip textures to generate the fixed texture.
    else
    {
      # Create the texture in the repaired folder.
      $TextureRepaired = CreateTexture -TextureInfo $Texture -Width $NewWidth -Height $NewHeight -Format $Texture.Extension -OutputPath $OutputPath

      # If the texture was repaired, report it.
      if ($TextureRepaired)
      {
        # Add to the total number of repaired textures.
        $global:CountRepaired += 1

        # Show that the texture was repaired.
        $global:StatusOfIssue = 'Repair: ' + $TextureIssues.ToString()

        # Update the texture list to say that the texture was copied.
        $global:IssuesMessage += 'Texture repaired: "..\RepairedTextures' + $Texture.Relative + '" ; '
      }
    }
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
  }
  # Return whether or not the texture was repaired.
  return $TextureRepaired
}
#==============================================================================================================================================================================================
#  Copy the broken texture if it wasn't repaired.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CopyBrokenTexture()
{
  # Count the number of textures that were copied.
  $global:CountCopied += 1

  # Create the broken textures folder if it does not exist and copy the broken texture.
  $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\BrokenTextures' + $Texture.Relative)
  CopyTexture -OutputPath $OutputPath

  # Update the texture list to say that the texture was copied.
  $global:IssuesMessage += 'Texture copied to: "..\BrokenTextures' + $Texture.Relative + '" ; '
}
#==============================================================================================================================================================================================
#  OPERATION 01: SCAN DOLPHIN TEXTURES FOR ISSUES +
#  OPERATION 02: SCAN DATABASE TEXTURES FOR ISSUES - MASTER FUNCTION
#==============================================================================================================================================================================================
#  Checks a texture for all issues and reports to logs.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ScanTextureForIssues()
{
  # Keeps track of number of issues and any messages to print.
  $global:TextureIssues = 0
  $global:IssuesMessage = ""
  $global:StatusOfIssue = "OK"
  
  # Check the texture for issues.
  for ($i = 0 ; $i -le 13 ; $i++)
  {
    # Force calling the function by name. Because there are two digits in the name (ex: CheckTextureForIssue_03) the index must be converted to a double digit.
    Invoke-Expression -Command ('CheckTextureForIssue_' + (IntToStringDoubleDigit -Value $i))

    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
  }
  # Create an array of all issues to repair the texture.
  $RepairChecks = New-Object bool[] 6
  $RepairChecks[0] = ($IssuesMessage -like '*Mipmaps Missing*')
  $RepairChecks[1] = ($IssuesMessage -like '*Mipmaps Bad Scale*')
  $RepairChecks[2] = ($IssuesMessage -like '*Width/Height Uneven*')
  $RepairChecks[3] = ($IssuesMessage -like '*Non-Integer Upscale*')
  $RepairChecks[4] = ($IssuesMessage -like '*Wrong Aspect Ratio*')
  $RepairChecks[5] = ($IssuesMessage -like '*Wrong DDS Dimensions*')

  # If the texture had any of the above issues, attempt to repair them.
  if (TestBooleanArray -Or -Array $RepairChecks)
  {
    # Attempt to repair broken texture.
    $TextureRepaired = AttemptRepair
  }
  # Check if the user wants to copy bad textures, but only copy them if they weren't fixed.
  if (!$TextureRepaired -and $CopyBadTextures)
  {
    # Create an array of all issues to copy the texture.
    $CopyChecks = New-Object bool[] 4
    $CopyChecks[0] = (TestBooleanArray -Or -Array $RepairChecks)
    $CopyChecks[1] = ($IssuesMessage -like '*Dolphin Dupe*')
    $CopyChecks[2] = ($IssuesMessage -like '*Duplicate*')
    $CopyChecks[3] = ($IssuesMessage -like '*Unaccepted User Scale*')
  
    # If the texture had any of the above issues, copy them.
    if (TestBooleanArray -Or -Array $CopyChecks)
    {
      # Attempt to copy the broken texture.
      CopyBrokenTexture
    }
  }
  # Now that repairs have been attempted, test one more time.
  if ($StatusOfIssue -eq "Issues")
  {
    # If it's still "Issues" then add how many issue there are.
    $global:StatusOfIssue += ": " + $TextureIssues.ToString()
  }
  # Each issue adds a semicolon and two spaces, so trim this from the final issue.
  $global:IssuesMessage = $IssuesMessage.TrimEnd(' ; ')

  # Set the message to the trimmed version.
  TexList_SetTextureStatus -Status $StatusOfIssue -Message $IssuesMessage

  # Count the total number of textures with issues.
  $global:CountIssues += 1
}
#==============================================================================================================================================================================================
#  CONVERT AND RESCALE SUPPORT FUNCTIONS - REMOVE FLAGS FROM TEXTURE AND FOLDER NAMES
#==============================================================================================================================================================================================
#  If the user chose "*Search Flags*" as the compression type, search for flags on texture names and remove them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveFlagsFromName([hashtable]$TextureInfo, [string]$CreatedPath, [string]$Format)
{
  # Default the "renamed" path to the base texture name. If a mipmap flag was found, this will be overwritten.
  $RemFlagImagePath = $CreatedPath + '\' + $TextureInfo.Name + $Format

  # Try to find a mipmap flag that specifies the number of mipmaps.
  if (($TextureInfo.Name -match '_mm(.{1})') -or ($TextureInfo.Name -like '*_mm'))
  {
    # If a number was specified, "Matches" exists so use it. If no number was used, only "_mm" exists so replace that.
    if ($Matches -ne $null) { $ReplaceText = $Matches[0] } else { $ReplaceText = '_mm' }

    # Rename the image using the name that excludes "_mm#".
    $CreatedImagePath = $CreatedPath + '\' + $TextureInfo.Name + $Format
    $RemFlagImagePath = $CreatedPath + '\' + $TextureInfo.Name.Replace($ReplaceText, '') + $Format
    Move-Item -LiteralPath $CreatedImagePath -Destination $RemFlagImagePath -Force

    # Find any mipmaps in the newly created pack.
    foreach ($Mipmap in EnumerateFiles -LiteralPath $CreatedPath)
    {
      # Get the texture as an item.
      $MipmapItem = Get-Item -LiteralPath $Mipmap

      # Match the name of the mipmap to the texture name. Exclude the mipmap flag from both results.
      $NewMipmapMatch = $MipmapItem.BaseName.Replace($ReplaceText, '')
      $ReplaceMatches = $TextureInfo.Name.Replace($ReplaceText, '') + '*_mip*'

      # Compare the mipmap name to the search name.
      if ($NewMipmapMatch -like $ReplaceMatches)
      {
        # Rename the mipmap to not have the mipmap flag in it.
        $CreatedMipmapPath = $CreatedPath + '\' + $MipmapItem.Name
        $RenamedMipmapPath = $CreatedPath + '\' + $MipmapItem.Name.Replace($ReplaceText, '')
        Move-Item -LiteralPath $CreatedMipmapPath -Destination $RenamedMipmapPath -Force
      }
    }
  }
  # The texture is a DDS image and flags are enabled.
  if (($Format -eq $DDS) -and ($DDSBlkCompress -eq '*Search Flags*'))
  {
    # Try to find a matching flag in the texture name.
    foreach ($Flag in $DDSFlagArray)
    {
      # Create a wildcard version of the flag.
      $FlagWildCard = '*' + $Flag + '*'
      $ExtraCondition = $true

      # Additional checks need to be made for Dolphin textures.
      if ($TextureInfo.Dolphin)
      {
        # If a flag was found, grab the hash(es) from the texture.
        $Hash = $TextureInfo.Name.Split('_')

        # Always check the 3rd and 4th sections for a hash.
        $HashCheckA = (('_' + $Hash[2]) -notlike $FlagWildCard)
        $HashCheckB = (('_' + $Hash[3]) -notlike $FlagWildCard)
        $HashCheckC = $true

        # Standard Dolphin textures only have 5 segments between underscores.
        if ($Hash.Count -gt 5) { $HashCheckC = (('_' + $Hash[4]) -notlike $FlagWildCard) }

        # Check the hashes and make sure they aren't like the flag.
        $ExtraCondition = ($HashCheckA -and $HashCheckB -and $HashCheckC)
      }
      # Compare the texture name to the current flag in the list. Make sure the flag is not actually a hash triggering it.
      if (($TextureInfo.Name -like $FlagWildCard) -and ($ExtraCondition))
      {
        # Only remove flags from the base textures if the flag option allows it.
        if ($DDSFlagRemoval -eq 'New & Base')
        {
          # Rename the base texture found in the pack.
          $RenamedImageBase = $TextureInfo.Path + '\' + $TextureInfo.Name.Replace($Flag, '') + $TextureInfo.Extension
          Move-Item -LiteralPath $TextureInfo.FullPath -Destination $RenamedImageBase -Force
        }
        # The only time to not remove the flag from the newly generated texture is if the flag removal is set to "None".
        if ($DDSFlagRemoval -ne 'None')
        {
          # Rename the new image that was either converted or rescaled.
          $RenamedImagePath = $CreatedPath + '\' + $TextureInfo.Name.Replace($Flag, '') + $Format
          Move-Item -LiteralPath $RemFlagImagePath -Destination $RenamedImagePath -Force
        }
        # The flag must also be removed from any generated mipmaps.
        foreach ($Mipmap in EnumerateFiles -LiteralPath $CreatedPath)
        {
          # Get the image as an item to retrieve the name.
          $MipmapItem = Get-Item -LiteralPath $Mipmap

          # Attempt to match the mipmap name to the texture name without the flag.
          $NameMatch = '*' + $TextureInfo.Name.Replace($Flag, '') + '*_mip*'

          # Check for a match between the two.
          if ($MipmapItem.BaseName -like $NameMatch)
          {
            # Rename the mipmap with the new name.
            $RenamedMipmapPath = $CreatedPath + '\' + $MipmapItem.BaseName.Replace($Flag, '') + $Format
            Move-Item -LiteralPath $Mipmap -Destination $RenamedMipmapPath -Force
          }
        }
        # Report that the flag has been removed from the texture.
        TexList_SetTextureStatus -Message (' ; Flag "' + $Flag.Replace('_','') + '" removed from ' + $TextureInfo.Name.Replace($Flag, '') + $Format + '.')
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Removes flags from folders only if the folder contains a name that is more than just the flag. For example "FolderName_ARGB8" will be renamed "FolderName", but "_ARGB8"
#  will not be detected by this function. This is part one of removing flags. Flags used as complete folder names is handled in the below function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveFlagsFromFolderNames([string]$LoopPath)
{
  # Loop through all folders and sub-folders to attempt to find texture files.
  foreach ($Folder in EnumerateFolders -LiteralPath $LoopPath -Recurse)
  {
    # If the flag was already removed, the folder will no longer exist.
    if (!(TestPath -LiteralPath $Folder)) { continue }
  
    # Get the folder as an item so we can get some simple properties like the name.
    $FolderItem = Get-Item -LiteralPath $Folder

    # A tilde (~) represents a generated directory. Check a condition for both base pack and generated pack.
    $BasePackCondition = (($Folder -notlike '*~*') -and ($DDSFlagRemoval -eq 'New & Base'))
    $ConvPackCondition = (($Folder -like '*~*') -and ($DDSFlagRemoval -ne 'None'))

    # Check if either condition passes for the "base" folders or the "converted" folders.
    if (($BasePackCondition) -or ($ConvPackCondition))
    {
      # Try to find a matching flag in the folder name.
      foreach ($Flag in $DDSFlagArray)
      {
        # See if the folder name contains the flag, but is not named with just a flag and no other characters.
        if (($FolderItem.Name -like ('*' + $Flag + '*')) -and ($FolderItem.Name -ne $Flag))
        {
          # Get the new path to the folder, minus the flag.
          $NewFolderName = $Folder.Replace($FolderItem.Name,'') + $FolderItem.Name.Replace($Flag,'')

          # If the folder does not already exist.
          if (!(TestPath -LiteralPath $NewFolderName))
          { 
            # Rename the folder.
            Move-Item -LiteralPath $Folder -Destination $NewFolderName -Force
          }
          # If the folder exists, then move the contents of the folder.
          else
          {
            # Build a collection of all files and folders.
            $Collection = EnumerateFiles -LiteralPath $Folder -Recurse
            $Collection += EnumerateFolders -LiteralPath $Folder -Recurse

            # Loop through everything found within the folder.
            foreach ($FlagFile in $Collection)
            {
              # Move the item to the folder that already exists.
              Move-Item -LiteralPath $FlagFile -Destination $NewFolderName -Force
            }
            # Remove the folder since the contents are now empty.
            RemovePath -LiteralPath $Folder
          }
        }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Removes folders that are used as flags and shifts the contents of the directory back. For example, "Folder\_ARGB8\SubFolder" becomes "Folder\Subfolder". Paths may contain
#  multiple flags, so this function must handle that. When a flag is removed, the path has changed in the loop, so the first flag must be removed before trying to access the
#  folder. How this is done is hard to explain, and I suck ass at writing complex code like this, or explaining what I'm actually trying to do.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveFolderFlagsShiftDirs([string]$LoopPath)
{
  # Loop through all folders and sub-folders to attempt to find texture files.
  foreach ($Folder in EnumerateFolders -LiteralPath $LoopPath -Recurse)
  {
    # There is some limitations to this method. Two or more paths is impossible to maintain like "C:\Textures\_ARGB8\_BC7".
    if (!(TestPath -LiteralPath $Folder)) { Continue }
  
    # Get the folder as an item so we can get some simple properties like the name.
    $FolderItem = Get-Item -LiteralPath $Folder

    # A tilde (~) represents a generated directory. Check a condition for both base pack and generated pack.
    $BasePackCondition = (($Folder -notlike '*~*') -and ($DDSFlagRemoval -eq 'New & Base'))
    $ConvPackCondition = (($Folder -like '*~*') -and ($DDSFlagRemoval -ne 'None'))

    # Check if either condition passes for the "base" folders or the "converted" folders.
    if (($BasePackCondition) -or ($ConvPackCondition))
    {
      # Try to find a matching flag in the folder name.
      foreach ($Flag in $DDSFlagArray)
      {
        # The folder name is entirely made up of a flag and contains no other text. (Example: _ARGB8)
        if ($FolderItem.Name -eq $Flag)
        {
          # This is where shit gets confusing and took me forever to figure out. Sometimes the path will contain more than one flag. But, one of the flags has
          # already been removed, so the path has changed compared to when the loop started. The loop itself contains an outdated path that needs to be fixed,
          # so we must modify that path to remove the flag. So to start out, track the flags in the path in the order they are found using an array.
          $FlagsFound = New-Object Collections.Generic.List[string]

          # Loop through all folder names to find a flag.
          foreach ($CheckName in $Folder.Split('\'))
          {
            # Loop through all possible flags.
            foreach ($Flag in $DDSFlagArray)
            {
              # Compare the current folder flag name to the current one in the looped list.
              if ($CheckName -eq $Flag)
              {
                # If there is a match, add the flag to the array.
                $FlagsFound.Add($Flag)
              }
            }
          }
          # Store the name of the folder in a separate variable that will be modified to include the final path without previous flags.
          $FinalFolderPath = $Folder

          # So we have the number of flags in the path, but we need to remove them in the correct order from first to last.
          if ($FlagsFound.Count -gt 1)
          {
            # Loop through all flags that came before the current flag.
            for ($i = 0; $i -lt ($FlagsFound.Count - 1); $i++)
            {
              # Remove the previously used flag from the path. Use regex as it allows defining the number of times to remove the flag. We only want to remove the 
              # flag once, even if the user mistakenly used the same flag twice in the same path. Example: "Folder\_ARGB8\SubFolder\_BC7\SubSubFolder\_ARGB8"
              [regex]$ReplaceFlag = ('\\' + $FlagsFound[$i])

              # Update the variable with the new path that doesn't contain the flag.
              $FinalFolderPath = $ReplaceFlag.Replace($FinalFolderPath, '', 1)
            }
          }
          # Build a collection of all files and folders.
          $Collection = EnumerateFiles -LiteralPath $Folder -Recurse
          $Collection += EnumerateFolders -LiteralPath $Folder -Recurse

          # Loop through the folder that only has a flag for a name to try to find sub-folders.
          foreach ($FlagFile in $Collection)
          {
            # Get as an item to retrieve the name.
            $FlagItem = Get-Item -LiteralPath $FlagFile

            # Move the file or folder and all of its contents back one folder.
            $BackFlagPath = $FinalFolderPath.Replace('\' + $FolderItem.Name,'') + '\' + $FlagItem.Name
            Move-Item -LiteralPath $FlagFile -Destination $BackFlagPath -Force
          }
          # Count the number of files in the folder to make sure none remain.
          $Collection = EnumerateFiles -LiteralPath $FinalFolderPath -Recurse
          $Collection += EnumerateFolders -LiteralPath $FinalFolderPath -Recurse

          # If the folder has been completely emptied out.
          if ($Collection.Count -eq 0)
          {
            # Remove the flag folder completely.
            RemovePath -LiteralPath $FinalFolderPath
          }
        }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Master function to run the above loop. Depending on the location of the output folder, it may need to be ran twice.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveFlagsFromFolders()
{
  # Set up the series of checks to remove flags in a variable array.
  $FlagRemoveCheck = New-Object bool[] 3
  $FlagRemoveCheck[0] = (($DDSBlkCompress -eq '*Search Flags*') -and ($MasterOperation -eq 'ConvertTextures') -and ($ConvertFormat -eq $DDS))
  $FlagRemoveCheck[1] = (($DDSBlkCompress -eq '*Search Flags*') -and ($MasterOperation -eq 'RescaleTextures') -and ($RescaleFormat -eq $DDS))
  $FlagRemoveCheck[2] = (($DDSBlkCompress -eq '*Search Flags*') -and ($MasterOperation -eq 'ResolutionScale') -and ($ResizeFormat -eq $DDS))

  # Check if the user defined the output, and are either converting or rescaling DDS textures.
  if (TestBooleanArray -Or -Array $FlagRemoveCheck)
  {
    # First scan for and remove flags in "Input Path". If the output path has not changed, this first loop will do.
    RemoveFlagsFromFolderNames -LoopPath $MasterInputPath
    RemoveFolderFlagsShiftDirs -LoopPath $MasterInputPath

    # See if the "Output Path" is within the Input Path.
    if ($MasterOutputPath -ne ($MasterInputPath + '\~CTT_Generated'))
    {
      # If the output path has changed, run the loop on it as well.
      RemoveFlagsFromFolderNames -LoopPath $MasterOutputPath
      RemoveFolderFlagsShiftDirs -LoopPath $MasterOutputPath
    }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 03: CONVERT TEXTURES TO ANOTHER FORMAT
#==============================================================================================================================================================================================
#  This is called if the user wants to convert textures to a specific format.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ConvertTextureFormat()
{
  # Store converted textures in their own unique directory.
  $ConvertedPath = CreatePath -LiteralPath ($MasterOutputPath + '\ConvertedTextures' + $OutputFormatLabel + $Texture.Relative)

  # The full path to where the new texture will be created.
  $ExistingTexture = $ConvertedPath + '\' + $Texture.Name + $ConvertFormat

  # If the user wants to skip textures that already exist, allow doing this.
  if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $ExistingTexture)) { TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Already Exists in Output Path' ; return }

  # Default the new texture's dimensions to the current dimensions.
  $Width  = $Texture.Width
  $Height = $Texture.Height

  # If the user wishes to auto-repair Dolphin textures, find new dimensions based on the nearest low integer scale.
  if (($ConvertRepair) -and (($Texture.Dolphin) -or ($Texture.DBTexture)) -and (!$Texture.HasMatMap) -and ($ConvertFormat -ne $ICO))
  {
    # Find the smallest scale between width and height and see if the integer should be incremented.
    $NewScale = ScaleThresholdCorrection -Value ([Math]::Min($Texture.ScaleWidth, $Texture.ScaleHeight))

    # Use the new scaling value to determine the new dimensions by multiplying it by the texture's "original" dimensions.
    $Width  = $Texture.OldWidth * $NewScale
    $Height = $Texture.OldHeight * $NewScale
    $Dimensions = $Width.ToString() + 'x' + $Height.ToString()

    # Alert the user that repairs are being done if the calculated dimensions are different than the texture's current dimensions.
    if ($Dimensions -ne $Texture.Dimensions) { TexList_SetTextureStatus -Status 'Repaired' -Message ('Dimensions Repaired to (' + $Dimensions + ') using (' + $NewScale + 'x) Scale ; ') }

    # Otherwise just set the status to "OK" since nothing is being done.
    else { TexList_SetTextureStatus -Status (GetStatus) }
  }
  # Create the converted texture.
  if (CreateTexture -TextureInfo $Texture -Width $Width -Height $Height -Format $ConvertFormat -OutputPath $ConvertedPath -FlipTexture $PNGFlipResult)
  {
    # Change the conversion type into the 3 letter equivalent.
    $FileType = ExtensionToText -Extension $ConvertFormat

    # Each format will have a different output.
    switch ($ConvertFormat)
    {
      # Append some additional info the message before printing it to the texture list.
      $PNG    { $ConvertedText = ' (' + $Texture.PNGBitDepth + '-Bit ' + $Texture.PNGColorSpace + ')' }
      $DDS    { $ConvertedText = ' (' + $Texture.DDSCompression + ') (' + $DDSToolUtilized + ')' }
      default { $ConvertedText = '' }
    }
    # Update the texture on the texture list with the converted message.
    TexList_SetTextureStatus -Status (GetStatus) -Message ('Successfully converted to ' + $FileType + ' format!' + $ConvertedText)

    # Remove flags from the textures.
    RemoveFlagsFromName -TextureInfo $Texture -CreatedPath $ConvertedPath -Format $ConvertFormat

    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $ExistingTexture -NewFormat $ConvertFormat -Width $Width -Height $Height
  }
  # The texture was not successfully converted.
  else
  {
    # Report this error on the texture list.
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
}
#==============================================================================================================================================================================================
#  OPERATION 04: RESCALE TEXTURES WITH NEW SCALING FACTOR
#==============================================================================================================================================================================================
#  Determines the scaling value used based on the value of "Rescale Condition".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Rescale_GetScalingValue([hashtable]$TextureInfo)
{
  # Set up the condition for when a texture should be rescaled based on the user selected value for "Rescale Condition".
  switch ($RescaleScaling)
  {
    # The RescaleFactor is the global variable set by the GUI. The "default" switch should never be hit.
    'Always'    { $RescaleCondition = $true }
    'Upscale'   { $RescaleCondition = (($TextureInfo.ScaleWidth -le [decimal]$RescaleFactor) -and ($TextureInfo.ScaleHeight -le [decimal]$RescaleFactor)) }
    'Downscale' { $RescaleCondition = (($TextureInfo.ScaleWidth -ge [decimal]$RescaleFactor) -and ($TextureInfo.ScaleHeight -ge [decimal]$RescaleFactor)) }
    default     { $RescaleCondition = $false }
  }
  # If the condition passes, rescale the texture using the chosen rescaling factor.
  if ($RescaleCondition) { return $RescaleFactor }

  # If the condition fails, choose the greater of the two scales (between width and height) for the new scaling value.
  # Example: 3.82/4.16, 4 will be used as the new scaling factor. For most cases, this will not actually rescale the texture much unless width and height are uneven.
  return ([Math]::Max($TextureInfo.ScaleWidth, $TextureInfo.ScaleHeight)).ToString().Substring(0,1)
}
#==============================================================================================================================================================================================
#  This is called if the user wants to convert textures to an integer scale.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RescaleTextureInteger()
{
  # Do not allow rescaling icon files.
  if ($Texture.IsIcon) { TexList_SetTextureStatus -Status 'Fail' -Message 'Icon files can not be rescaled.' ; return }

  # Include the format that was forced in the path to the rescaled textures.
  $RescaledPath = CreatePath -LiteralPath ($MasterOutputPath + '\RescaledTextures' + $OutputFormatLabel + $Texture.Relative)

  # The full path to where the new texture will be created.
  $ExistingTexture = $RescaledPath + '\' + $Texture.Name + $RescaleFormat

  # If the user wants to skip textures that already exist, allow doing this.
  if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $ExistingTexture)) { TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Already Exists in Output Path' ; return }

  # Check to see if the user enabled manual rescaling.
  switch ($ManualRescale)
  {
    # If enabled, get the new scale from the menu. If disabled, get the scale based on "Rescale Condition".
    $true   { $NewScale = ManualRescale_ShowDialog -TextureInfo $Texture }
    $false  { $NewScale = Rescale_GetScalingValue -TextureInfo $Texture }
  }
  # Manual Rescale allows entering a value of "0" to skip the texture, so do that if it's found.
  if ([string]$NewScale -eq '0') { TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Manually Skipped' ; return }

  # If the user wants to rescale Dolphin textures as-is using their current dimensions.
  if ((($Texture.Dolphin) -or ($Texture.DBTexture)) -and ($RescaleDolphinReal))
  {
    # Calculate the new dimensions using the real dimensions and the scaling value.
    $Width  = [int]($Texture.Width * $NewScale)
    $Height = [int]($Texture.Height * $NewScale)
  }
  # The default configuration uses the "old dimensions" which are also the current dimensions with non-dolphin textures.
  else
  {
    # Calculate the new dimensions based on the new scaling value.
    $Width  = [int]($Texture.OldWidth * $NewScale)
    $Height = [int]($Texture.OldHeight * $NewScale)
  }
  # Assemble the dimensions into a string for reference.
  $Dimensions = $Width.ToString() + 'x' + $Height.ToString()
  
  # Create the rescaled texture.
  if (CreateTexture -TextureInfo $Texture -Width $Width -Height $Height -Format $RescaleFormat -OutputPath $RescaledPath -FlipTexture $PNGFlipResult)
  {
    # Change the conversion type into the 3 letter equivalent.
    $FileType = ExtensionToText -Extension $RescaleFormat

    # Each format will have a different output.
    switch ($RescaleFormat)
    {
      # Append some additional info the message before printing it to the texture list.
      $PNG    { $RescaledText = ' (' + $Texture.PNGBitDepth + '-Bit ' + $Texture.PNGColorSpace + ')' }
      $DDS    { $RescaledText = ' (' + $Texture.DDSCompression + ') (' + $DDSToolUtilized + ')' }
      default { $RescaledText = '' }
    }
    # Update the texture on the texture list with the rescaled message.
    TexList_SetTextureStatus -Status (GetStatus) -Message ('Successfully Rescaled to: ' + $Dimensions + ' (' + $NewScale + 'x) ' + $FileType + ' format!' + $RescaledText)

    # Remove flags from the textures.
    RemoveFlagsFromName -TextureInfo $Texture -CreatedPath $RescaledPath -Format $RescaleFormat

    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $ExistingTexture -NewFormat $RescaleFormat -Width $Width -Height $Height
  }
  # The texture was not successfully rescaled.
  else
  {
    # Report this error on the texture list.
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
}
#==============================================================================================================================================================================================
#  OPERATION 05: RESIZE TEXTURES WITH SPECIFIC DIMENSIONS
#==============================================================================================================================================================================================
#  This is called if the user wants to resize textures to a specific resolution.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResizeTextureResolution()
{
  # Do not allow rescaling icon files.
  if ($Texture.IsIcon) { TexList_SetTextureStatus -Status 'Fail' -Message 'Icon files can not be rescaled.' ; return }

  # Store converted textures in their own unique directory.
  $ResizedPath = CreatePath -LiteralPath ($MasterOutputPath + '\ResizedTextures' + $OutputFormatLabel + $Texture.Relative)

  # The full path to where the new texture will be created.
  $ExistingTexture = $ResizedPath + '\' + $Texture.Name + $ResizeFormat

  # If the user wants to skip textures that already exist, allow doing this.
  if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $ExistingTexture)) { TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Already Exists in Output Path' ; return }

  # Create the converted texture.
  if (CreateTexture -TextureInfo $Texture -Width $ResizeWidth -Height $ResizeHeight -Format $ResizeFormat -OutputPath $ResizedPath -FlipTexture $PNGFlipResult)
  {
    # Change the conversion type into the 3 letter equivalent.
    $FileType = ExtensionToText -Extension $ResizeFormat

    # Each format will have a different output.
    switch ($ResizeFormat)
    {
      # Append some additional info the message before printing it to the texture list.
      $PNG    { $ResizedText = ' (' + $Texture.PNGBitDepth + '-Bit ' + $Texture.PNGColorSpace + ')' }
      $DDS    { $ResizedText = ' (' + $Texture.DDSCompression + ') (' + $DDSToolUtilized + ')' }
      default { $ResizedText = '' }
    }
    # Update the texture on the texture list with the converted message.
    TexList_SetTextureStatus -Status (GetStatus) -Message ('Successfully resized to ' + $ResizeWidth + 'x' + $ResizeHeight + ' using ' + $FileType + ' format!' + $ResizedText)

    # Remove flags from the textures.
    RemoveFlagsFromName -TextureInfo $Texture -CreatedPath $ResizedPath -Format $ResizeFormat

    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $ExistingTexture -NewFormat $ResizeFormat -Width $ResizeWidth -Height $ResizeHeight
  }
  # The texture was not successfully converted.
  else
  {
    # Report this error on the texture list.
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
}
#==============================================================================================================================================================================================
#  OPERATION 06: ADD IDENTIFYING WATERMARK TO ALL TEXTURES
#==============================================================================================================================================================================================
#  Calculates the new dimensions that will be used for the watermark and caption.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetWatermarkDimensions([int]$Width, [int]$Height)
{
  # Create a hash table to store the calculated dimensions.
  $Calculated = @{}

  # We don't want textures to be less than 256 pixels in width or text may be unreadable, so store the width and height before checks so they can be used if the checks immediately pass.
  $Calculated.Width  = $Width
  $Calculated.Height = $Height

  # Check to see if the texture width is less than 256 pixels.
  if ($Calculated.Width -lt 256)
  {
    # Start with a new scaling factor of 2 which will be incremented by 1 each loop iteration.
    $ScaleFactor = 2

    # If the width failed to be at least 256 pixels, calculate a new width and height that equals/exceeds 256 pixels using the lowest possible integer scale.
    while($Calculated.Width -lt 256)
    {
      # Each iteration increments the scale by 1x. Loop exits when greater than or equal to 256 is reached.
      $Calculated.Width  = $Width * $ScaleFactor
      $Calculated.Height = $Height * $ScaleFactor
      $ScaleFactor ++
    }
  }
  # Return the calculated dimensions.
  return $Calculated
}
#==============================================================================================================================================================================================
#  Creates the base texture that will have the watermark applied to it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateWatermarkTexture([int]$Width, [int]$Height, [string]$OutputPath)
{
  # Set the path for the temporary texture that will serve as the base texture that will have a caption applied to it.
  $TextureFile = $OutputPath + '\tex.png'

  # Store the dimensions in a format needed by ImageMagick when creating images.
  $Dimensions = $Width.ToString() + 'x' + $Height.ToString()

  # Check if the texture is a DDS texture generated with Ishiiruka Tool.
  if (($Texture.HasMatMap) -and ($Texture.Extension -eq $DDS))
  {
    # Attempt to convert it if Ishiiruka Tool is found.
    if (TestPath -LiteralPath $IshiirukaTool)
    {
      # Create a link to the temporary generated texture.
      $IshiirukaFile = $OutputPath + '\' + $Texture.Name + $PNG

      # Resize parameters for Ishiiruka Tool.
      $IshiiWidth  = '-w' + $Width
      $IshiiHeight = '-h' + $Height

      # Create a temporary color texture that is in PNG format.
      Ishiiruka-Tool -ImageFile $Texture.MatMap -Arguments @('-nomipmaps', '-savecolor', $IshiiWidth, $IshiiHeight, '-frommaterial') -OutputPath $OutputPath

      # Rename the file to 'tex.png' for the combination step.
      Move-Item -LiteralPath $IshiirukaFile -Destination $TextureFile -Force
    }
    # Ishiiruka Tool was not found.
    else
    {
      # Instead just create a black texture.
      Magick-Convert -Arguments @('-define', 'png:color-type=6', '-size', $Dimensions, 'xc:#000000') -OutputFile $TextureFile

      # And let the user know why it's a black image.
      TexList_SetTextureStatus -Status 'Issues' -Message 'Ishiiruka Tool not found. Generated texture will be a black image!'
    }
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
  }
  # Check if the texture is in BC7 format.
  elseif ($Texture.Format -eq 'BC7')
  {
    # BC7 textures can only be converted with Compressonator or TexConv.
    if ((TestPath -LiteralPath $Compressonator) -or (TestPath -LiteralPath $TexConvTool))
    {
      # Create a link to the temporary generated texture.
      $ConvertedBC7 = $OutputPath + '\' + $Texture.Name + $PNG

      # Create the image as a PNG file. This function takes care of BC7 textures for us.
      CreatePNGTextureSingle -TextureInfo $Texture -ImageFile $Texture.FullPath -Width $Width -Height $Height -Format $PNG -OutputPath $OutputPath

      # Rename the file to 'tex.png' for the combination step.
      Move-Item -LiteralPath $ConvertedBC7 -Destination $TextureFile -Force
    }
    # TexConv or Compressonator was not found.
    else
    {
      # Instead just create a black texture.
      Magick-Convert -Arguments @('-define', 'png:color-type=6', '-size', $Dimensions, 'xc:#000000') -OutputFile $TextureFile

      # And let the user know why it's a black image.
      TexList_SetTextureStatus -Status 'Issues' -Message 'Converting BC7 textures requires TexConv. Generated texture will be a black image!'
    }
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
  }
  # In every other case, generate the temporary texture from the custom texture.
  else
  {
    # Dimensions in the format that ImageMagick expects.
    $IMDimensions = $Dimensions + '!'

    # Create the temporary texture.
    Magick-Convert -ImageFile $Texture.FullPath -Arguments @('-define', 'png:color-type=6', '-resize', $IMDimensions) -OutputFile $TextureFile
  }
  # Return the path to the texture so it can be set to a variable on creation and referenced.
  return $TextureFile
}
#==============================================================================================================================================================================================
#  Creates the caption that will serve as the texture watermark.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateWatermarkCaption([hashtable]$TextureInfo, [int]$Width, [string]$OutputPath)
{
  # Default the caption text to the texture name.
  $CaptionText = $TextureInfo.Name

  # The "_arb" suffix adds 4 useless characters to the end of the string.
  if ($TextureInfo.ArbMips)
  {
    $CaptionText = $CaptionText.Replace('_arb','')
  }
  # If the value was 0, the user wanted to use the full name.
  if ([int]$WM_Length -eq 0)
  {
    $CaptionText = 'caption:' + $CaptionText
  }
  # Less than 6 characters is pretty useless, so force extracting at least the last 6 characters.
  elseif (([int]$WM_Length -gt 0) -and ([int]$WM_Length -lt 7))
  {
    $CaptionText = 'caption:' + $CaptionText.Substring($CaptionText.Length - 6, 6)
  }
  # If it's anything else, use the value the user has chosen.
  else
  {
    $CaptionText = 'caption:' + $CaptionText.Substring($CaptionText.Length - $WM_Length, $WM_Length)
  }
  # Set the caption's font size, width (using 80% of the calculated width), and destination path.
  $CaptionSize  = ([int]$WM_FontSize * ($Width / 128)).ToString()
  $CaptionWidth = ($Width * 0.80).ToString() + 'x'
  $CaptionFile  = $OutputPath + '\cap.png'

  # Create the caption that will overlay the texture.
  Magick-Convert -Arguments @('-define', 'png:color-type=6', '-background', 'transparent', '-fill', $WM_FontColor, '-undercolor', $WM_BGColor, '-font', $WM_FontFace, '-pointsize', $CaptionSize, '-size', $CaptionWidth, '-gravity', 'center', $CaptionText) -OutputFile $CaptionFile

  # Return the path to the caption so it can be set to a variable on creation and referenced.
  return $CaptionFile
}
#==============================================================================================================================================================================================
#  Master function that creates a texture with a watermark using part or all of the texture's name.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddTextureWatermark()
{
  # Check to see if it is an icon file, and the operation is set to "Convert".
  if ($Texture.IsIcon) { TexList_SetTextureStatus -Status 'Fail' -Message 'Watermarks can not be added to icon files.' ; return }

  # Set the full path to output texture.
  $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\WatermarkTextures' + $Texture.Relative)
  $OutputFile = $OutputPath + '\' + $Texture.Name + $PNG

  # If the user wants to skip textures that already exist, allow doing this.
  if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $OutputFile)) { TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Already Exists in Output Path' ; return }

  # Create a temporary folder for the base texture and the caption.
  $WatermarkTempPath = CreatePath -LiteralPath ($TempFolder + '\TempWatermark')

  # Calculate the dimensions that will be used for the watermark. Returns ".Width" and ".Height".
  $Calculated = GetWatermarkDimensions -Width $Texture.Width -Height $Texture.Height

  # Create the base texture.
  $TextureFile = CreateWatermarkTexture -Width $Calculated.Width -Height $Calculated.Height -OutputPath $WatermarkTempPath

  # Don't waste time if we don't have to.
  if ($CancelMasterLoop) { return }

  # Create the caption that will be applied to the base texture.
  $CaptionFile = CreateWatermarkCaption -TextureInfo $Texture -Width $Calculated.Width -OutputPath $WatermarkTempPath

  # Test if the texture and caption were created.
  if ((TestPath -LiteralPath $TextureFile) -and (TestPath -LiteralPath $CaptionFile))
  {
    # Apply the caption to the texture using the composite command.
    Magick-Convert -ImageFile $TextureFile -Arguments @('-define', 'png:color-type=6', $CaptionFile, '-gravity', 'center', '-composite') -OutputFile $OutputFile
  }
  # Don't waste time if we don't have to.
  if ($CancelMasterLoop) { return }

  # Test to make sure that the texture exists.
  if (TestPath -LiteralPath $OutputFile)
  {
    # Report to the user that the texture was created.
    TexList_SetTextureStatus -Status (GetStatus) -Message 'Texture Watermark Successfully Created'

    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $OutputFile -NewFormat $PNG -Width $Calculated.Width -Height $Calculated.Height
  }
  # The texture does not exist.
  else
  {
    # Report to the user that the texture was not created.
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
  # Clean up the temporary files and folders.
  RemovePath -LiteralPath $WatermarkTempPath
}
#==============================================================================================================================================================================================
#  OPERATION 07: CREATE MATERIALS WITH MATERIAL MAP GENERATOR
#==============================================================================================================================================================================================
#  Branches off the arguments for cleaner code. No arguments because it will inherit the variable set in the parent function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function BuildGeneratorArguments()
{
  # Create an empty list of arguments for the user selected options.
  $ArgumentList = New-Object Collections.Generic.List[string]

  # Set the input and output paths.
  $ArgumentList.Add('--input')
  $ArgumentList.Add($MaterialInput)
  $ArgumentList.Add('--output')
  $ArgumentList.Add($MaterialOutput)

  # The tile size defaults to 512 so only assign it if set to something else.
  if ($MatMapTileSize -ne '512x512')
  {
    # Split the value on the X since we only need the first number.
    $SplitX = $MatMapTileSize.Split('x')
  
    # Set the tile size to whatever it is set to.
    $ArgumentList.Add('--tile_size')
    $ArgumentList.Add($SplitX[0])
  }
  # Check to see how to handle edge pixels.
  switch ($MatMapEdgePixels)
  {
    # Unless it is set to "None", add the appropriate argument.
    'Seamless'  { $ArgumentList.Add('--seamless')  }
    'Mirror'    { $ArgumentList.Add('--mirror')    }
    'Replicate' { $ArgumentList.Add('--replicate') }
  }
  # If the user disabled CUDA then force using the CPU.
  if ($MatMapDisableGPU) { $ArgumentList.Add('--cpu') }
  
  # We want the naming scheme that Ishiiruka uses.
  $ArgumentList.Add('--ishiiruka')

  # Return the argument list for the generator.
  return $ArgumentList
}
#==============================================================================================================================================================================================
#  Creates materials from a texture using an AI python script.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMaterialTextures()
{
  # Make sure to only run this on PNG files.
  if ($Texture.Extension -ne $PNG) { TexList_SetTextureStatus -Status 'Skipped' -Message 'Image file not in PNG format' ; return }

  # Get the extension as text for the output folder.
  $FileType = ExtensionToText -Extension $IshiirukaFormat

  # The output folder will be different if the user wants to generate material maps.
  switch ($MatMapCreateMaps)
  {
    # Store converted textures in their own unique directory.
    $true  { $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\MaterialMaps (' + $FileType + ')' + $Texture.Relative) }
    $false { $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\MaterialsCreated' + $Texture.Relative) }
  }
  # The material map generator expects input and output paths to be folders instead of files.
  $MaterialInput  = CreatePath -LiteralPath ($TempFolder + '\MatMapInput')
  $MaterialOutput = CreatePath -LiteralPath ($TempFolder + '\MatMapOutput')

  # Set the path to the input texture.
  $CopyTexture = $MaterialInput + '\' + $Texture.FullName

  # Create a copy of the texture in the input path.
  Copy-Item -LiteralPath $Texture.FullPath -Destination $CopyTexture

  # Get a list of all the arguments to send the material map generator.
  $ArgumentList = BuildGeneratorArguments

  # Run the python script to generate the materials.
  GenerateMaterials -Arguments $ArgumentList

  # Make sure the destination folder actually contains files.
  if ((EnumerateFiles -LiteralPath $MaterialOutput).Count -gt 0)
  {
    # Check to see if the user wanted to create material maps instead of materials.
    if ($MatMapCreateMaps)
    {
      # Move the texture to where the materials are.
      Move-Item -LiteralPath $CopyTexture -Destination $MaterialOutput -Force

      # Set the path to the input texture.
      $ColorTexture = $MaterialOutput + '\' + $Texture.FullName

      # Get texture info which is needed to create textures.
      $NewTexInfo = CreateTextureInfo -ImageFile $ColorTexture -Extended

      # Attempt to create the material map.
      CreateMaterialMap_FromMaterials -TextureInfo $NewTexInfo -Width $NewTexInfo.Width -Height $NewTexInfo.Height -Format $IshiirukaFormat -OutputPath $OutputPath

      # Update the texture on the texture list with the converted message.
      TexList_SetTextureStatus -Status 'OK' -Message 'Material maps created successfully.'
    }
    else
    {
      # Move the texture to the destination folder.
      Move-Item -LiteralPath $CopyTexture -Destination $OutputPath -Force

      # Loop through all the created materials in the output path.
      foreach ($Material in Get-ChildItem -LiteralPath $MaterialOutput)
      {
        # Move the materials to the destination folder.
        Move-Item -LiteralPath $Material.FullName -Destination $OutputPath -Force
      }
      # Update the texture on the texture list with the converted message.
      TexList_SetTextureStatus -Status 'OK' -Message 'Material textures created successfully.'
    }
  }
  # The materials were never generated for some reason.
  else
  {
    # Report this error on the texture list.
    TexList_SetTextureStatus -Status 'Fail' -Message 'Materials Failed Creation'
  }
  # Clean up your room. Lobsters make for some good eating.
  RemovePath -LiteralPath $MaterialInput
  RemovePath -LiteralPath $MaterialOutput
}
#==============================================================================================================================================================================================
#  OPERATION 08: CREATE MATERIAL MAPS WITH ISHIIRUKA TOOL
#==============================================================================================================================================================================================
#  Creates material maps from bump/spec/nrm/lum textures. Parameter "$InPlaceMethod" defines where to create the texture. 1 - Output Folder, 2 - Overwrite the Textures/Destroy Materials
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMaterialMaps([int]$InPlaceMethod)
{
  # Cleaner code I guess. Easier to read maybe.
  $SomeMessage = 'No material textures (bump/spec/nrm/lum) exist for this texture.'

  # If the texture does not have included materials, then there is no point in continuing.
  if (!$Texture.HasMats) { TexList_SetTextureStatus -Status 'OK' -Message $SomeMessage ; return }

  # Get the extension as text for the output folder.
  $FileType = ExtensionToText -Extension $IshiirukaFormat

  # A work-around for when both "In-Place" options are checked for both the optimize operation and process selected.
  if (($ProcessSelected) -and ($ProcessOverwrite) -and ($InPlaceMaterial)) { $InPlaceMethod = 1 }

  # This method creates the material map in the output path.
  if ($InPlaceMethod -eq 1)
  {
    # Set up the path to create material map to a new folder.
    $MaterialOutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\MaterialMaps (' + $FileType + ')' + $Texture.Relative)

    # Paths to where the final textures will be created.
    $ColorTexOutput = $MaterialOutputPath + '\' + $Texture.Name + $IshiirukaFormat
    $MaterialOutput = $MaterialOutputPath + '\' + $Texture.Name + '.mat' + $IshiirukaFormat

    # Attempt to create the material map.
    CreateMaterialMap_FromMaterials -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height -Format $IshiirukaFormat -OutputPath $MaterialOutputPath

    # Check to see if the textures were created or not.
    switch (((TestPath -LiteralPath $ColorTexOutput) -and (TestPath -LiteralPath $MaterialOutput)))
    {
      # Report if the material map succeeded or failed creation.
      $true  { TexList_SetTextureStatus -Status 'OK' -Message 'Material Map Successfully Created' }
      $false { TexList_SetTextureStatus -Status 'Fail' -Message 'Material Map Failed Creation (Unknown Reason)' }
    }
  }
  # This method creates the material map in-place.
  else
  {
    # Set up the path to create material maps to a new folder.
    $InPlaceMaterials = CreatePath -LiteralPath ($TempFolder + '\InPlaceMaterials')

    # Paths to where the temporary textures will be created.
    $ColorTexOutput = $InPlaceMaterials + '\' + $Texture.Name + $IshiirukaFormat
    $MaterialOutput = $InPlaceMaterials + '\' + $Texture.Name + '.mat' + $IshiirukaFormat

    # Attempt to create the material map.
    CreateMaterialMap_FromMaterials -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height -Format $IshiirukaFormat -OutputPath $InPlaceMaterials

    # Check to see if the textures were created or not.
    switch (((TestPath -LiteralPath $ColorTexOutput) -and (TestPath -LiteralPath $MaterialOutput)))
    {
      # There are a few extra things to do when creating in place.
      $true   {
                # Remove the old material textures.
                RemovePath -LiteralPath $Texture.FullPath
                RemovePath -LiteralPath ($Texture.PathName + '.nrm' + $PNG)
                RemovePath -LiteralPath ($Texture.PathName + '.bump' + $PNG)
                RemovePath -LiteralPath ($Texture.PathName + '.spec' + $PNG)
                RemovePath -LiteralPath ($Texture.PathName + '.lum' + $PNG)

                # Loop through all Material Maps in the temp materials directory.
                foreach ($MaterialMap in EnumerateFiles -LiteralPath $InPlaceMaterials)
                {
                  # Move all textures to the current texture path.
                  Move-Item -LiteralPath $MaterialMap -Destination $Texture.Path -Force
                }
                # Report if the material map succeeded or failed creation.
                TexList_SetTextureStatus -Status 'OK' -Message 'Material Map Successfully Created In-Place' 
              }
      # Report if the material map succeeded or failed creation.
      $false  { TexList_SetTextureStatus -Status 'Fail' -Message 'Material Map Failed Creation (Unknown Reason)' }
    }
    # Clean up on aisle four.
    RemovePath -LiteralPath $InPlaceMaterials
  }
}
#==============================================================================================================================================================================================
#  OPERATION 09: OPTIMIZE PNG TEXTURES WITH OPTIMIZER PROGRAM
#==============================================================================================================================================================================================
#  Calculate/store stuff for the optimizer program using a hash table.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePNGOptimizerData([string]$ImageFile) 
{
  # Initialize a hash table.
  $OptimizeData = @{}

  # Get the texture as an object so it can be analyzed.
  $OptimizeObject = Get-Item -LiteralPath $ImageFile

  # Store the name of the texture.
  $OptimizeData.Name     = $OptimizeObject.BaseName
  $OptimizeData.FullName = $OptimizeObject.Name

  # Store the size of the texture in Bytes.
  $OptimizeData.Size = $OptimizeObject.Length

  # If the user doesn't want broken Dolphin textures.
  if ($OptiDolphinCheck)
  {
    # This function will generate ass-loads of errors if a channel is not in the string, so silence them all.
    $ErrorActionPreference = 'silentlycontinue'

    # Run the "-verbose" command on the texture to find the channel information. Verbose is stored as an array of strings.
    $Verbose = Magick-Identify -ImageFile $ImageFile -Arguments @('-quiet','-verbose')

    # Search the array of strings for color data. Find the numeric value of the bit depth stored in the string.
    $R_String = (($Verbose | Select-String -Pattern 'Red.*bit') -Split 'Red: ') -Split '-bit'
    $G_String = (($Verbose | Select-String -Pattern 'Green.*bit') -Split 'Green: ') -Split '-bit'
    $B_String = (($Verbose | Select-String -Pattern 'Blue.*bit') -Split 'Blue: ') -Split '-bit'
    $A_String = (($Verbose | Select-String -Pattern 'Alpha.*bit') -Split 'Alpha: ') -Split '-bit'

    # Initialize an array to store the depth in each channel.
    $Channel = New-Object int[] 4

    # Search for the channel depth and convert it to an integer. If the channel is not found, set depth to zero.
    if ($R_String[1]) { $Channel[0] = [int]$R_String[1] } else { $Channel[0] = 0 }
    if ($G_String[1]) { $Channel[1] = [int]$G_String[1] } else { $Channel[1] = 0 } # Heh. G-String.
    if ($B_String[1]) { $Channel[2] = [int]$B_String[1] } else { $Channel[2] = 0 }
    if ($A_String[1]) { $Channel[3] = [int]$A_String[1] } else { $Channel[3] = 0 }

    # Default the depth fail to false.
    $OptimizeData.DepthFail = $false

    # Loop through all the channels.
    for ($i=0; $i -lt $Channel.Length; $i++)
    {
      # See if the bit depth falls between 0 and 8, meaning it must be 1-7 to fail.
      if (($Channel[$i] -gt 0) -and ($Channel[$i] -lt 8))
      {
        # If any of the channels failed to be greater than 8 bit set the depth fail.
        $OptimizeData.DepthFail = $true

        # Track which channel failed.
        switch ($i)
        {
          '0' { $OptimizeData.ChannelFailed = 'Red' }
          '1' { $OptimizeData.ChannelFailed = 'Green' }
          '2' { $OptimizeData.ChannelFailed = 'Blue' }
          '3' { $OptimizeData.ChannelFailed = 'Alpha' }
        }
        # Exit the loop so it isn't overwritten if another channel passes.
        break
      }
    }
    # Store if the image has indexed color space.
    $OptimizeData.Indexed = ([string]$Verbose -match 'Indexed')
  }
  # We aren't checking for bad optimizations that can break Dolphin support.
  else
  {
    # Just force these to false so nothing fails.
    $OptimizeData.DepthFail = $false
    $OptimizeData.Indexed   = $false
  }
  # Return the hash table.
  return $OptimizeData
}
#==============================================================================================================================================================================================
#  Displays a warning message if a texture was skipped optimizing due to errors.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Optimize-ShowFailMessage([hashtable]$OldImageData, [hashtable]$NewImageData)
{
  # Check if the image failed in both indexed color and the depth check.
  if (($OldImageData.Indexed) -and ($OldImageData.DepthFail))
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message ('Skipped ' + $OldImageData.Name + ' (' + $OldImageData.ChannelFailed + ' Channel Less Than 8bpp + Indexed)')
  }
  # Check if the image only failed as indexed color space.
  elseif ($OldImageData.Indexed)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message ('Skipped ' + $OldImageData.Name + ' (Indexed Color Space)')
  }
  # Check if the image only failed the depth check.
  elseif ($OldImageData.DepthFail)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message ('Skipped ' + $OldImageData.Name + ' (' + $OldImageData.ChannelFailed + ' Channel Less Than 8bpp)')
  }
  # Check if the new image failed in both indexed color and the depth check.
  elseif (($NewImageData.Indexed) -and ($NewImageData.DepthFail))
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message ('Skipped ' + $OldImageData.Name + ' (Result ' + $NewImageData.ChannelFailed + ' Channel Less Than 8bpp + Indexed)')
  }
  # Check if the new image only failed as indexed color space.
  elseif ($NewImageData.Indexed)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message ('Skipped ' + $OldImageData.Name + ' (Result Indexed Color Space)')
  }
  # Check if the new image only failed the depth check.
  elseif ($NewImageData.DepthFail)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message ('Skipped ' + $OldImageData.Name + ' (Result ' + $NewImageData.ChannelFailed + ' Channel Less Than 8bpp)')
  }
}
#==============================================================================================================================================================================================
#  Each supported PNG optimizer program has its own set of arguments.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPNGOptimizerArgumentsList()
{
  # Create an empty list to store arguments in.
  $OptimizeArgs = New-Object Collections.Generic.List[string]

  # Use the executable as a switch.
  switch -wildcard ((Get-Item -LiteralPath $OptimizerPath).Name)
  {
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # OPTIPNG ARGUMENTS
    'optipng.exe'
    {
      # Start with the number of tests.
      $OptimizeArgs.Add(('-o' + $OptimizeTests))

      # If strip metadata is enabled then add the flags.
      if ($OptimizeStripMeta)
      {
        $OptimizeArgs.Add('-strip')
        $OptimizeArgs.Add('all')
      }
      # Prevents bit depth and color type reductions.
      if ($OptimizeReuseColors)
      { 
        $OptimizeArgs.Add('-nb')
        $OptimizeArgs.Add('-nc')
        $OptimizeArgs.Add('-np')
      }
      # The output path of the optimized texture.
      $OptimizeArgs.Add('-dir')
      $OptimizeArgs.Add($OptiTempPath)

      # Finally the input texture.
      $OptimizeArgs.Add($ImageFile)
    }
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # OXIPNG ARGUMENTS
    'oxipng.exe'
    {
      # Start with the number of tests. Instead of a number OxiPNG wants "max" when at 7.
      $OptimizeArgs.Add('--opt')
      if ($OptimizeTests -ge 7) { $OptimizeArgs.Add('max') }
      if ($OptimizeTests -lt 7) { $OptimizeArgs.Add($OptimizeTests) }

      # OxiPNG allows configuring the threads.
      $OptimizeArgs.Add('--threads')
      $OptimizeArgs.Add($OptimizeThreads)

      # If strip metadata is enabled then add the flags.
      if ($OptimizeStripMeta)
      {
        $OptimizeArgs.Add('--strip')
        $OptimizeArgs.Add('all')
      }
      # Prevents bit depth and color type reductions.
      if ($OptimizeReuseColors)
      { 
        $OptimizeArgs.Add('--nb')
        $OptimizeArgs.Add('--nc')
        $OptimizeArgs.Add('--np')
      }
      # The output path of the optimized texture.
      $OptimizeArgs.Add('--dir')
      $OptimizeArgs.Add($OptiTempPath)

      # Finally the input texture.
      $OptimizeArgs.Add($ImageFile)
    }
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PINGO ARGUMENTS
    'pingo.exe'
    {
      # Get the image name and set up the path to the temporary image.
      $ImageItem = Get-Item -LiteralPath $ImageFile
      $Optimized = $OptiTempPath + '\' + $ImageItem.Name

      # Create a copy of the image in the temp path. Pingo will optimize this one.
      Copy-Item -LiteralPath $ImageFile -Destination $Optimized

      # Check if forcing lossless.
      if ($OptimizeLossless)
      {
        # If so then add a zero to the compression.
        $OptimizeArgs.Add('-s0')
      }
      # If lossless is not forced.
      else
      {
        # Set the compression level using the value on the GUI.
        $OptimizeArgs.Add(('-s' + $OptimizeTests))
      }
      # If strip metadata is enabled then add the flags.
      if ($OptimizeStripMeta) { $OptimizeArgs.Add('-strip') }

      # Use the number of threads to determine if multithreading is disabled.
      if ($OptimizeThreads -le 1) { $OptimizeArgs.Add('-nomulti') }

      # Add the flag to prevent converting PNG to JPG.
      $OptimizeArgs.Add('-noalpha')

      # Prevents bit depth and color type reductions.
      if ($OptimizeReuseColors) { $OptimizeArgs.Add('-noconversion') }

      # Set the input texture to the copy in the temp path.
      $OptimizeArgs.Add($Optimized)
    }
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # EFFICIENT COMPRESSION TOOL ARGUMENTS
    'ect*.exe'
    {
      # Get the image name and set up the path to the temporary image.
      $ImageItem = Get-Item -LiteralPath $ImageFile
      $Optimized = $OptiTempPath + '\' + $ImageItem.Name

      # Create a copy of the image in the temp path. ECT will optimize this one.
      Copy-Item -LiteralPath $ImageFile -Destination $Optimized

      # Add the number of tests.
      $OptimizeArgs.Add(('-' + $OptimizeTests))

      # If strip metadata is enabled then add the flags.
      if ($OptimizeStripMeta) { $OptimizeArgs.Add('-strip') }

      # Maybe add options for these? (Edit: Okay, done.)
      if ($OptimizeLossless)    { $OptimizeArgs.Add('--strict') }
      if ($OptimizeReuseColors) { $OptimizeArgs.Add('--reuse')  }

      # ECT allows configuring the threads.
      $OptimizeArgs.Add(('--mt-file=' + $OptimizeThreads))

      # Set the input texture to the copy in the temp path.
      $OptimizeArgs.Add($Optimized)
    }
  }
  # Return the list of arguments to add to the programs.
  return $OptimizeArgs
}
#==============================================================================================================================================================================================
#  Optimizes a texture with a PNG Optimizer program and returns the reduction in Bytes. Input parameter takes a full path to the texture + file extension.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function OptimizeTexture([string]$ImageFile, [int]$OptiMethod)
{
  #--------------------------------------------------------------------------------------------------------------
  #  First create a path to the output texture so it can be tested to see if it already exists.
  #--------------------------------------------------------------------------------------------------------------
  # A work-around for when both "In-Place" options are checked for both the optimize operation and process selected.
  if (($ProcessSelected) -and ($ProcessOverwrite) -and ($OptimizeInPlace)) { $OptiMethod = 1 }

  # Method 1: Output the optimized texture to a new folder.
  if ($OptiMethod -eq 1)
  {
    # Get the image as an object.
    $ImageItem = Get-Item -LiteralPath $ImageFile

    # Create the path to the output texture.
    $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\OptimizedTextures(' + $OptimizerTool + ')' + $Texture.Relative)
    $OutputFile = $OutputPath + '\' + $ImageItem.Name
  }
  # Method 2: Optimize the files in-place if the user wished it.
  elseif ($OptiMethod -eq 2)
  {
    # Set the output path to the position of the input image.
    $OutputFile = $ImageFile
  }
  # If the user wants to skip textures that already exist, allow doing this.
  if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $OutputFile))
  {
    # Let the user know it already exists.
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Already Exists in Output Path'

    # Return null which lets the calling function know that it was skipped.
    return $null
  }
  #--------------------------------------------------------------------------------------------------------------
  #  If we got here, the output doesn't exist so generate the optimized texture.
  #--------------------------------------------------------------------------------------------------------------
  # Initialize a hash table so multiple values can be returned.
  $OptimizeResults = @{}

  # Create information of the old image before optimization.
  $OldImageData = CreatePNGOptimizerData -ImageFile $ImageFile

  # Set up temporary paths to the optimized texture.
  $OptiTempPath = CreatePath -LiteralPath ($TempFolder + '\OptiTemp')
  $OptiTempFile = $OptiTempPath + '\' + $OldImageData.FullName

  # Run the optimizer program and create a new texture in the temp path.
  RunPNGOptimizer -Arguments (GetPNGOptimizerArgumentsList) | Out-Null

  # Don't waste time if we don't have to.
  if ($CancelMasterLoop) { return }

  # Create information of the new image after optimization.
  $NewImageData = CreatePNGOptimizerData -ImageFile $OptiTempFile

  #--------------------------------------------------------------------------------------------------------------
  #  Test to see if the image failed any of the tests.
  #--------------------------------------------------------------------------------------------------------------
  # If any of the tests failed then fail the texture.
  if (($NewImageData.Indexed) -or ($NewImageData.DepthFail))
  {
    # Track whether or not any tests failed on either texture.
    $OptimizeResults.FailTests = $true

    # Show the user which test failed.
    Optimize-ShowFailMessage $OldImageData $NewImageData

    # Remove the temp path and send data back to the host function.
    RemovePath -LiteralPath $OptiTempPath
    $OptimizeResults.Reduction = 0
    return $OptimizeResults
  }
  #--------------------------------------------------------------------------------------------------------------
  #  Verify that optimizing actually had an impact and move the texture.
  #--------------------------------------------------------------------------------------------------------------
  # Check if there was actually any reduction in file size.
  if ($NewImageData.Size -lt $OldImageData.Size)
  {
    # Calculate the size difference in Bytes.
    $OptimizeResults.Reduction = $OldImageData.Size - $NewImageData.Size

    # Move the optimized texture to the new path.
    Move-Item -LiteralPath $OptiTempFile -Destination $OutputFile -Force

    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $OutputFile -NewFormat $PNG -Width $Texture.Width -Height $Texture.Height
  }
  # If there was no reduction....
  else
  {
    # Store that the amount of reduction is zero so it can be returned as 0.
    $OptimizeResults.Reduction = 0
  }
  #--------------------------------------------------------------------------------------------------------------
  # Cleanup the temp texture path.
  RemovePath -LiteralPath $OptiTempPath

  # Return the reduction.
  return $OptimizeResults
}
#==============================================================================================================================================================================================
#  Initially validates whether or not it will optimize the texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function OptimizeValidate()
{
  # Make sure to only run this on PNG files.
  if ($Texture.Extension -ne $PNG)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Image file not in PNG format.'
    return $false
  }
  # Do not run this on textures with material maps.
  if ($Texture.HasMatMap)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Textures with Material Maps are skipped.'
    return $false
  }
  # Making it here means it passed validation.
  return $true
}
#==============================================================================================================================================================================================
#  The master function to start optimizing textures. Parameter "$OptiMethod" defines where to create the texture. 1 - Output Folder, 2 - Overwrite the Texture
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function OptimizeWithOptimizer([int]$OptiMethod)
{
  # Quickly validate a few basic things before doing important stuff.
  if (!(OptimizeValidate)) { return }

  # Optimize the base texture and get the results in a hash table.
  $BaseOptimizeData = OptimizeTexture -ImageFile $Texture.FullPath -OptiMethod $OptiMethod

  # If the user wants to skip existing textures and it exists, this will come back null so leave now. Also leave if the MasterLoop was cancelled.
  if (($BaseOptimizeData -eq $null) -or ($CancelMasterLoop)) { return }

  # Store the amount of reduction so far.
  $TotalReduction = $BaseOptimizeData.Reduction

  # Keep track of the number of mipmaps that may fail the tests.
  $MipmapsFailedTests = 0

  # If the texture is a Mipmap, look for Mipmap levels and optimize them too.
  if (($Texture.IsMipmap) -or ($Texture.Mipmaps -gt 0))
  {
    # Create a Mipmap hash table.
    $Mipmap = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

    # Loop through all lower levels.
    for ($i=1; $i -le $Mipmap.Levels; $i++)
    {
      # If the Mipmap level exists, optimize it and store any reduction to the total texture reduction.
      if ($Mipmap.Exists[$i])
      {
        # Optimize the mipmap and get the results.
        $MipmapOptimizeData = OptimizeTexture -ImageFile $Mipmap.FullPath[$i] -OptiMethod $OptiMethod

        # Can't reference data that doesn't eixst.
        if ($MipmapOptimizeData -eq $null) { continue }

        # Add to the amount of reduction.
        $TotalReduction += $MipmapOptimizeData.Reduction

        # Store the total number of mipmaps that failed tests.
        if ($MipmapOptimizeData.FailTests) { $MipmapsFailedTests += 1 }
      }
    }
  }
  # --------------------------------------------------------------------------------------------------------------
  # Check to see if the base texture failed the tests.
  if ($BaseOptimizeData.FailTests)
  {
    # Check if the texture was a mipmap.
    if ($Texture.IsMipmap)
    {
      # See if all mipmaps failed the tests.
      if ($MipmapsFailedTests -eq $Mipmap.Levels)
      {
        # If they did, leave now so nothing is logged.
        return
      }
    }
    # It's not a mipmap.
    else
    {
      # If the base texture failed tests then log nothing.
      return
    }
  }
  # --------------------------------------------------------------------------------------------------------------
  # Check to see if there was actually any reduction between the original and custom textures. 
  if ($TotalReduction -gt 0)
  {
    # Increment the total number of optimized textures.
    $global:CountOptimized++

    # Display the reduced size in Bytes if it's less than 1 KB.
    if ($TotalReduction -lt 1024)
    {
      TexList_SetTextureStatus -Status 'Optimized' -Message ('Texture Optimized (Reduction: ' + $TotalReduction.ToString() + ' Bytes)')
    }
    # Display the size in KB if its over or equal to 1 KB.
    else
    {
      $TotalReductionKB = B2KB -Bytes $TotalReduction
      TexList_SetTextureStatus -Status 'Optimized' -Message ('Texture Optimized (Reduction: ' + $TotalReductionKB.ToString() + ' KB)')
    }
  }
  # If there was no reduction then the texture was already optimized.
  else
  {
      TexList_SetTextureStatus -Status 'OK'
  }
  # Store the total reduction so far in Bytes.
  $global:OptimizedBytes = $OptimizedBytes + $TotalReduction
}
#==============================================================================================================================================================================================
#  OPERATION 10: APPLY UPSCALING FILTER TO ALL TEXTURES - HASHTABLE
#==============================================================================================================================================================================================
#  The upscale hash table was created in v40.1 to help me keep all the information for an upscale in one place, and have an easy way to reference all the data that is needed
#  to upscale the texture. The upscaling code has not changed much from the beginning until now, so this ended up being a rather large rewrite (but it was worth it). All of
#  the functions found in this section of the script help set up the upscale hashtable, and the section after this is the actual upscaling section that uses the data from here.
#==============================================================================================================================================================================================
#  $Upscale.OutputPath       - string     -  Where the final upscale texture will be created (IE: the output path).
#  $Upscale.TexInfo          - hashtable  -  Stores the texture hash table for the texture that will be upscaled. The input texture may be replaced when this hash table is created.
#  $Upscale.Factor           - integer    -  The upscale factor that will actually be used to upscale the texture. This can change from the input "Upscale Factor" depending on the conditions. 
#  $Upscale.NewWidth         - integer    -  The calculated width of the texture after it is upscaled.
#  $Upscale.NewHeight        - integer    -  The calculated height of the texture after it is upscaled.
#  $Upscale.NewDimensions    - string     -  The calculated dimensions of the texture after it is upscaled.
#  $Upscale.Width            - integer    -  The width of the texture before it is upscaled.
#  $Upscale.Height           - integer    -  The height of the texture before it is upscaled.
#  $Upscale.Dimensions       - string     -  The dimensions of the texture before it is upscaled.
#  $Upscale.Alpha            - boolean    -  Stores true or false of whether or not the texture has an alpha channel.
#  $Upscale.AlphaIM          - string     -  Holds string value of either "on" or "off" for ImageMagick.
#  $Upscale.PNGType          - string     -  Holds string value of either "png:color-type=2" for RGB images or "png:color-type=6" for RGBA images for ImageMagick.
#  $Upscale.Seamless         - string     -  Stores true or false of whether or not the seamless method will be applied. This is determined from several factors.
#==============================================================================================================================================================================================
#  Sub-function of "GetBaseUpscaleTextureInfo" that generates a temporary PNG texture if it's a grayscale image and returns the "TextureInfo" hashtable.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetBaseUpscalePNGInfo([hashtable]$TextureInfo, [string]$TempFilterPath)
{
  # We need a place to store the temporary texture.
  $BaseTempPath = CreatePath -LiteralPath ($TempFilterPath + '\TempBase')
  $BaseTempFile = $BaseTempPath + '\' + $TextureInfo.Name + $PNG

  # Recreate the texture with ImageMagick and convert it to RGBA.
  Magick-Convert -ImageFile $TextureInfo.FullPath -Arguments @('-alpha', 'on', '-define', 'png:color-type=6', '-background', 'none') -OutputFile $BaseTempFile ; if ($CancelMasterLoop) { return }

  # If it's a mipmap texture, we'll assume they are also in grayscale format.
  if ($TextureInfo.IsMipmap)
  {
    # Create a Mipmap hash table.
    $Mipmap = CreateMipmapInfo -TextureInfo $TextureInfo -Width $TextureInfo.Width -Height $TextureInfo.Height

    # Loop through all lower levels.
    for ($i=1; $i -le $Mipmap.Levels; $i++) 
    {
      # Check to see if the mipmap level exists.
      if ($Mipmap.Exists[$i])
      {
        # Get the path to the newly created texture.
        $NewMipmapFile = $BaseTempPath + '\' + $Mipmap.Name[$i] + $PNG

        # Recreate the mipmap with ImageMagick and convert it to RGBA.
        Magick-Convert -ImageFile $Mipmap.FullPath[$i] -Arguments @('-alpha', 'on', '-define', 'png:color-type=6', '-background', 'none') -OutputFile $NewMipmapFile ; if ($CancelMasterLoop) { return }
      }
    }
  }
  # Create a texture hash table from the result and return it.
  return CreateTextureInfo -ImageFile $BaseTempFile -Extended
}
#==============================================================================================================================================================================================
#  Sub-function of "GetBaseUpscaleTextureInfo" that generates a temporary PNG texture from a DDS texture and returns the "TextureInfo" hashtable.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetBaseUpscaleDDSInfo([hashtable]$TextureInfo, [string]$TempFilterPath)
{
  # We need a place to store the temporary texture.
  $BaseTempPath = CreatePath -LiteralPath ($TempFilterPath + '\TempBase')

  # Create the temporary texture as a PNG texture.
  CreateTexture -TextureInfo $TextureInfo -Width $TextureInfo.Width -Height $TextureInfo.Height -Format $PNG -OutputPath $BaseTempPath -NoReturn ; if ($CancelMasterLoop) { return }

  # Get the path to the newly created texture and create a texture hash table from the result.
  $NewTexFile = $BaseTempPath + '\' + $TextureInfo.Name + $PNG

  # Return the new texture info.
  return CreateTextureInfo -ImageFile $NewTexFile -Extended
}
#==============================================================================================================================================================================================
#  If the texture is a PNG grayscale or DDS texture, create a temporary PNG image to use as the base texture to create an upscale from. The function itself will return the hashtable of which 
#  texture will be used as a base for the upscaling program. The reason "TempFilterPath" is chained through so many functions is so I remember that I am using it this far down the line.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetBaseUpscaleTextureInfo([hashtable]$TextureInfo, [string]$TempFilterPath)
{
  # Determine the action based on the file extension.
  switch ($TextureInfo.Extension)
  {
    # Most of the time PNG can just be used directly.
    $PNG    {
              # Some upscalers do not like grayscale format textures and expect RGBA color space.
              switch ($TextureInfo.Gray)
              {
                # Only create a new texture if its grayscale. Otherwise just use the base texture.
                $true   { $NewTextureInfo = GetBaseUpscalePNGInfo -TextureInfo $TextureInfo -TempFilterPath $TempFilterPath }
                $false  { return $TextureInfo }
              }
            }
    # DDS textures can not be upscaled directly, so a temporary texture must be created.
    $DDS    { $NewTextureInfo = GetBaseUpscaleDDSInfo -TextureInfo $TextureInfo -TempFilterPath $TempFilterPath }

    # I really don't care what happens to the other formats. Just use the texture info directly.
    default { return $TextureInfo }
  }
  # Give me whatever hashtable was set.
  return $NewTextureInfo
}
#==============================================================================================================================================================================================
#  The output of upscaling programs has a limit of how big textures can be created. I personally placed a limit of 32768x32768.
#  If this rather large limit is exceeded, attempted to auto-reduce the upscale factor for this texture so it can still be upscaled.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FindUpscaleFactor([hashtable]$TextureInfo, [int]$Factor)
{
  # Calculate the dimensions that the upscale would yield.
  $UpscaleWidth  = $TextureInfo.Width * $Factor
  $UpscaleHeight = $TextureInfo.Height * $Factor

  # Check to see if the result of the upscale will yield dimensions beyond the 32768x32768 limit.
  if (($UpscaleWidth -gt 32768) -or ($UpscaleHeight -gt 32768))
  {
    # Choose the greater of the two dimensions to find the new scaling value.
    $BaseDimension = [Math]::Max($TextureInfo.Width, $TextureInfo.Height)

    # The result must fall below 32768 during the loop to end it.
    $ReducedResult = [Math]::Max($UpscaleWidth, $UpscaleHeight)

    # Loop until the result is less than the maximum if possible.
    while($ReducedResult -gt 32768)
    {
      # Each iteration decrements the upscale factor by 1x.
      $Factor = $Factor - 1

      # Calculate the new dimension to see if it passes the condition to end the loop.
      $ReducedResult = $BaseDimension * $Factor
    }
    # Check to see if the upscaling factor was not reduced to one (or zero).
    if ($Factor -gt 1)
    {
      # If the upscaling factor was successfully reduced, report it to the user.
      TexList_SetTextureStatus -Message ('Upscale Factor reduced to: ' + $Factor + 'x ; ')
    }
  }
  # Return whatever the value is now. If everything failed, it will return an integer zero "0".
  return $Factor
}
#==============================================================================================================================================================================================
#  When the upscale factor is set as the target, the actual upscale factor that is used to match/exceed the target must be calculated.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetFactorAsTarget([hashtable]$TextureInfo, [int]$Factor)
{
  # Calculate the target width and height.
  $TargetWidth  = $TextureInfo.OldWidth * $Factor
  $TargetHeight = $TextureInfo.OldHeight * $Factor

  # If the texture dimensions exceeds the target upscale then don't do anything.
  if (($TextureInfo.Width -ge $TargetWidth) -or ($TextureInfo.Height -ge $TargetHeight)) { return 1 }

  # Start the factor at 2 and use the calculated width to determine the new factor.
  $Factor = 2
  $NewWidth = $TextureInfo.Width

  # Loop and increment the upscale factor each iteration until the width matches or exceeds the target width.
  while($NewWidth -lt $TargetWidth)
  {
    # Calculate the new dimension to see if it passes the condition to end the loop.
    $NewWidth = $TextureInfo.Width * $Factor

    # Each iteration increments the upscale factor by 1x.
    $Factor = $Factor + 1
  }
  # Return whatever the value is now.
  return $Factor
}
#==============================================================================================================================================================================================
#  A hash table that holds all the required data needed to more easily upscale the texture. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function BuildUpscaleHashTable([hashtable]$TextureInfo, [string]$TempFilterPath)
{
  # Initialize the hash table.
  $Upscale = @{}

  # Create a variable to the output path (for readability).
  $OutputPath = $MasterOutputPath + '\FilteredTextures(' + $UpscaleFilter + ')' + $TextureInfo.Relative

  # Make sure the directory to create rescaled textures exists. If it doesn't, create it.
  $Upscale.OutputPath = CreatePath -LiteralPath $OutputPath

  # Get texture info for the texture that will be used as a base to upscale.
  $Upscale.TexInfo = GetBaseUpscaleTextureInfo -TextureInfo $TextureInfo -TempFilterPath $TempFilterPath ; if ($CancelMasterLoop) { return }

  # Upscale Factor: Special Case: If the filter is waifu2x and set to "noise", scale will not be used so set the upscale factor to 1.
  if (($UpscaleFilter -like 'waifu*') -and ($Waifu2xCMode -eq 'noise'))
  {
    # Doing this now makes my code much easier later.
    $Upscale.Factor = 1
  }
  # Upscale Factor: This is what happens almost all the time for everything.
  else
  {
    # The condition to get the appropriate upscale factor.
    $DoUpscaleAsTarget = (($UpscaleAsTarget) -and (($TextureInfo.Dolphin) -or ($Texture.DBTexture)))

    # When the upscale factor is used as the target in Dolphin Mode, it must be calculated differently.
    switch ($DoUpscaleAsTarget)
    {
      # Get the actual upscale factor that will be used.
      $true   { $Upscale.Factor = GetFactorAsTarget -TextureInfo $Upscale.TexInfo -Factor $UpscaleFactor }
      $false  { $Upscale.Factor = FindUpscaleFactor -TextureInfo $Upscale.TexInfo -Factor $UpscaleFactor }
    }
  }
  # Get the new width and height based on the upscale factor.
  $Upscale.NewWidth      = $Upscale.TexInfo.Width * $Upscale.Factor
  $Upscale.NewHeight     = $Upscale.TexInfo.Height * $Upscale.Factor
  $Upscale.NewDimensions = $Upscale.NewWidth.ToString() + 'x' + $Upscale.NewHeight.ToString()

  # Get the old width and height. Basically a shortcut to the dimensions (instead of having to refer to "$Upscale.TexInfo.Dimension".
  $Upscale.Width      = $Upscale.TexInfo.Width
  $Upscale.Height     = $Upscale.TexInfo.Height
  $Upscale.Dimensions = $Upscale.Width.ToString() + 'x' + $Upscale.Height.ToString()

  # Store whether or not the image has an alpha channel.
  $Upscale.Alpha = $TextureInfo.Alpha

  # The alpha channel determines the PNG type and sets a flag for ImageMagick.
  switch ($Upscale.Alpha)
  {
    # Forcing alpha on for these image is crucial.
    $true   {
              $Upscale.AlphaIM = 'on'
              $Upscale.PNGType = 'png:format=png32'
            }
    # Likewise for opaque images. It avoids a lot of bugs down the road.
    $false  {
              $Upscale.AlphaIM = 'off'
              $Upscale.PNGType = 'png:format=png24'
            }
  }
  # Figuring out when to use the seamless method can create quite a headache.
  if (($FilterSelected -like '*GAN') -and ($ESRGANUseSegments))
  {
    # ESRGAN and SFTGAN already have their own seamless method when using segmented textures.
    $Upscale.Seamless = $false
  }
  # The seamless method will only be used based on user selection and whether or not the image has transparency.
  else
  {
    # Create a boolean array for the seamless tests.
    $SeamlessTests = New-Object bool[] 2

    # A few conditions to see if the seamless method will be used.
    $SeamlessTests[0] = (($Upscale.Alpha) -and ($SeamlessMethod -eq 'All'))
    $SeamlessTests[1] = ((!$Upscale.Alpha) -and ($SeamlessMethod -ne 'Disable'))

    # If either condition passes, use the seamless method.
    $Upscale.Seamless = TestBooleanArray -Or -Array $SeamlessTests
  }
  # Return the entire hash table.
  return $Upscale
}
#==============================================================================================================================================================================================
#  OPERATION 10: APPLY UPSCALING FILTER TO ALL TEXTURES - ESRGAN & SFTGAN SETUP
#==============================================================================================================================================================================================
#  ESRGAN and SFTGAN are complex filters that require a lot of setup to get working the way we want. Below are a bunch of functions that are unique to these two filters. One of the
#  biggest reasons that they are so much more complex than the other filters is because of their excessive VRAM requirement. This script has the ability to split the image into seamless
#  segments and upscale the individual pieces to bypass this limitation. The script also has the ability to preserve the alpha channel by extracting it from the image, then upscaling it
#  separately from the main image, then applying the upscaled alpha to the upscaled RGB image. This doubles the time it takes to upscale. All of this functionality can be found below.
#==============================================================================================================================================================================================
#  Sub-function of "RunUpscalerAISegments". This creates an image with additional pixels that the upscaler can work with. The type created depends on the type set by the user which is
#  either "Standard" or "Seamless". The Standard setting inverts the outer edges of the image into the buffer, while the Seamless setting replicates the tiling of a seamless image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetBufferedImage([string]$ImageFile, [int]$Width, [int]$Height, [string]$OutputFolder)
{
  # Create a hashtable array and a string array to hold the created tiles.
  $Tile      = New-Object hashtable[] 8
  $Seamless  = New-Object string[] 8

  # Fill the hashtable array with nodes and empty values.
  for ($i = 0 ; $i -lt 8 ; $i++) { $Tile[$i] = @{X=0;Y=0;W=0;H=0} }

  # This is the amount of overhang that will make up the tile to give the upscaler seamless pixels to work with.
  $Extra = $ESRGANExtraPixels / 2

  # Find out which kind of border is going to be created.
  switch ($ESRGANPixelBuffer)
  {
    # The standard method grabs pieces from the edges and inverts them to create the border.
    'Standard'  {
                  # Set up the crop values for each tile. X and Y are the start points, W and H are the width/height of the tiles.
                  $Tile[0].X = 0                ;  $Tile[0].Y = 0                ;  $Tile[0].W = $Extra         ;  $Tile[0].H = $Extra
                  $Tile[1].X = 0                ;  $Tile[1].Y = 0                ;  $Tile[1].W = $Width         ;  $Tile[1].H = $Extra
                  $Tile[2].X = $Width - $Extra  ;  $Tile[2].Y = 0                ;  $Tile[2].W = $Extra         ;  $Tile[2].H = $Extra
                  $Tile[3].X = 0                ;  $Tile[3].Y = 0                ;  $Tile[3].W = $Extra         ;  $Tile[3].H = $Height
                  $Tile[4].X = $Width - $Extra  ;  $Tile[4].Y = 0                ;  $Tile[4].W = $Extra         ;  $Tile[4].H = $Height
                  $Tile[5].X = 0                ;  $Tile[5].Y = $Height - $Extra ;  $Tile[5].W = $Extra         ;  $Tile[5].H = $Extra
                  $Tile[6].X = 0                ;  $Tile[6].Y = $Height - $Extra ;  $Tile[6].W = $Width         ;  $Tile[6].H = $Extra
                  $Tile[7].X = $Width - $Extra  ;  $Tile[7].Y = $Height - $Extra ;  $Tile[7].W = $Extra         ;  $Tile[7].H = $Extra
                }
    # The seamless method will grab tiles as if the image was tiled in a 3x3 grid.
    'Seamless'  {
                  # Set up the crop values for each tile. X and Y are the start points, W and H are the width/height of the tiles.
                  $Tile[0].X = $Width - $Extra  ;  $Tile[0].Y = $Height - $Extra ;  $Tile[0].W = $Extra         ;  $Tile[0].H = $Extra
                  $Tile[1].X = 0                ;  $Tile[1].Y = $Height - $Extra ;  $Tile[1].W = $Width         ;  $Tile[1].H = $Extra 
                  $Tile[2].X = 0                ;  $Tile[2].Y = $Height - $Extra ;  $Tile[2].W = $Extra         ;  $Tile[2].H = $Extra 
                  $Tile[3].X = $Width - $Extra  ;  $Tile[3].Y = 0                ;  $Tile[3].W = $Extra         ;  $Tile[3].H = $Height
                  $Tile[4].X = 0                ;  $Tile[4].Y = 0                ;  $Tile[4].W = $Extra         ;  $Tile[4].H = $Height
                  $Tile[5].X = $Width - $Extra  ;  $Tile[5].Y = 0                ;  $Tile[5].W = $Extra         ;  $Tile[5].H = $Extra 
                  $Tile[6].X = 0                ;  $Tile[6].Y = 0                ;  $Tile[6].W = $Width         ;  $Tile[6].H = $Extra 
                  $Tile[7].X = 0                ;  $Tile[7].Y = 0                ;  $Tile[7].W = $Extra         ;  $Tile[7].H = $Extra
                }
  }
  # Create a place to store the temporary segments.
  $SeamlessSegments = CreatePath -LiteralPath ($OutputFolder + '\SeamlessSegments')

  # Debug:Show a debug message to let me know shits being created.
  DebugMessage -Message '' -FollowUp ($FilterSelected + ': Creating the seamless segments.')

  # Loop through and create each segment from the main image.
  for ($i = 0 ; $i -lt 8 ; $i++)
  {
    # Debug:Display information about each tile.
    DebugMessage -Message ('Creating Segment 0' + ($i+1) + ' : Dimensions=' + $Tile[$i].W + 'x' + $Tile[$i].H + ' : X: ' + $Tile[$i].X + ' Y: ' + $Tile[$i].Y )
    
    # Set up some properties to crop the image.
    $CropGeometry = '' + $Tile[$i].W + "x" + $Tile[$i].H + "+" + $Tile[$i].X + "+" + $Tile[$i].Y
    $ArgumentList = [Collections.Generic.List[string]]@('-crop', $CropGeometry, '+repage', '-alpha', 'off', '-define', 'png:color-type=6', '-background', 'none')
    $Seamless[$i] = $SeamlessSegments + '\tile_0' + $i + '.png'

    # If border setting is set to "Standard" some adjustments need to be made to the segments.
    if ($ESRGANPixelBuffer -eq 'Standard')
    {
      # I don't feel like making something fancy, so use the amazing switch function.
      switch ($i)
      {
        # Some images need rotated, some need flipped horizontally, and some need flipped vertically.
        '0' { $ArgumentList.Add('-rotate') | Out-Null ; $ArgumentList.Add('180') | Out-Null }
        '1' { $ArgumentList.Add('-flip') | Out-Null }
        '2' { $ArgumentList.Add('-rotate') | Out-Null ; $ArgumentList.Add('180') | Out-Null }
        '3' { $ArgumentList.Add('-flop') | Out-Null }
        '4' { $ArgumentList.Add('-flop') | Out-Null }
        '5' { $ArgumentList.Add('-rotate') | Out-Null ; $ArgumentList.Add('180') | Out-Null }
        '6' { $ArgumentList.Add('-flip') | Out-Null }
        '7' { $ArgumentList.Add('-rotate') | Out-Null ; $ArgumentList.Add('180') | Out-Null }
      }
    }
    # Crop the seamless pixels from the main image.
    Magick-Convert -ImageFile $ImageFile -Arguments $ArgumentList -OutputFile $Seamless[$i] ; if ($CancelMasterLoop) { return $null }
  }
  # Create the array of tiles.
  $TileArray = @($Seamless[0], $Seamless[1], $Seamless[2], $Seamless[3], $ImageFile, $Seamless[4], $Seamless[5], $Seamless[6], $Seamless[7])

  # Set the output image.
  $TileImage = $OutputFolder + '\tiled.png'

  # Debug:Show a debug message to let me know shits being created.
  DebugMessage -Message '' -FollowUp ($FilterSelected + ': Creating tiled image using seamless pixel segments.')

  # Assemble all the segments into the final image.
  Magick-Montage -Collection $TileArray -Arguments @('-tile', '3x3', '-geometry', '+0+0', '-alpha', 'off', '-background', 'none') -OutputFile $TileImage

  # Remove the segments now that they are no longer needed.
  RemovePath -LiteralPath $SeamlessSegments

  # Return the created image.
  return $TileImage
}
#==============================================================================================================================================================================================
#  Sub-function of "StartUpscalerAI / GetSegmentInfo". Gets the divisor which is used to split the images into segments.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetSuperScalerDivisor([int]$Dimension)
{
  # Split the selected segment size on the "x" to extract one of the dimensions.
  $SplitSegmentSize = $ESRGANMaxSegment.Split('x')

  # Convert this into an integer and add the extra pixels that were selected.
  $SegmentMax = [Convert]::ToInt32($SplitSegmentSize[0])

  # Always round the divisor up to the next highest value.
  $Divisor = RoundUp -Value ($Dimension / $SegmentMax)

  # See if the value is an odd number.
  if ($Divisor % 2 -eq 1 )
  {
    # Add 1 to the value to make it even.
    $Divisor++
  }
  # Return the calculated divisor.
  return $Divisor
}
#==============================================================================================================================================================================================
#  Sub-function of "StartUpscalerAI". Gets the size and starting position of segments.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetSegmentInfo([int]$Factor, [int]$Width, [int]$Height)
{
  # God bless hash tables.
  $Segment = @{}

  # Find out what divisor to use based on the largest dimension.
  $Segment.DivisorX = GetSuperScalerDivisor -Dimension $Width
  $Segment.DivisorY = GetSuperScalerDivisor -Dimension $Height

  # Get the size of tiles. "Tile" refers to the normal size, and "Over" refers to the tile + the seamless overhang pixels.
  $Segment.TileSizeX  = $Width  / $Segment.DivisorX
  $Segment.TileSizeY  = $Height / $Segment.DivisorY
  $Segment.OverSizeX  = $Width  / $Segment.DivisorX + $ESRGANExtraPixels
  $Segment.OverSizeY  = $Height / $Segment.DivisorY + $ESRGANExtraPixels

  # Depending on the filter, different parameters need to be set up.
  switch ($FilterSelected)
  {
    # ESRGAN needs everything multiplied by 4. 
    'ESRGAN'  {
                # Set the size and coordinates for the final image.
                $Segment.FinalSizeX = $Segment.TileSizeX * $Factor
                $Segment.FinalSizeY = $Segment.TileSizeY * $Factor
                $Segment.FinalOffsetX = ($ESRGANExtraPixels / 2) * $Factor
                $Segment.FinalOffsetY = ($ESRGANExtraPixels / 2) * $Factor
              }
    # SFTGAN was already multiplied so use unmodified sizes.
    'SFTGAN'  {
                # Set the size and coordinates for the final image.
                $Segment.FinalSizeX = $Segment.TileSizeX
                $Segment.FinalSizeY = $Segment.TileSizeY
                $Segment.FinalOffsetX = $ESRGANExtraPixels / 2
                $Segment.FinalOffsetY = $ESRGANExtraPixels / 2
              }
  }
  # Show some information pertaining to the segments.
  DebugMessage -Message '' -FollowUp 'Segment Information'
  DebugMessage -Message ('Extra Pixels : ' + $ESRGANExtraPixels) -FollowUp ('UpscaleFactor: ' + $UpscaleFactor)
  DebugMessage -Message ('Divisor X    : ' + $Segment.DivisorX)  -FollowUp ('Divisor Y    : ' + $Segment.DivisorY)
  DebugMessage -Message ('TileSize X   : ' + $Segment.TileSizeX) -FollowUp ('TileSize Y   : ' + $Segment.TileSizeY)
  DebugMessage -Message ('Seamless X   : ' + $Segment.OverSizeX) -FollowUp ('Seamless Y   : ' + $Segment.OverSizeY)

  # Return the hash table values.
  return $Segment
}
#==============================================================================================================================================================================================
#  Sub-function of "RunUpscalerAISegments". Branched out to keep the code tidier since it's used a few times.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TestImageExists([string]$ImageFile, [string]$ErrorMessage)
{
  # If we're out of VRAM, add this to the error message.
  if ($OutOfVRAM) { $ErrorMessage += ' Not enough VRAM to complete the upscale! Try entering a lower segment multiplier.' }

  # If the segment failed to be created, fail the image entirely.
  if (!(TestPath -LiteralPath $ImageFile))
  {
    # Show an error message to the user.
    $Title   = $FilterSelected + ' Error'
    ShowOKDialog -Title $Title -SizeX (DPISize 240) -SizeY (DPISize 30) -OffsetX (DPISize 46) -OffsetY (DPISize 12) -TimeOut 5 -Message $ErrorMessage

    # Return false which fails the texture.
    return $false
  }
  # The segment exists so don't fail.
  return $true
}
#==============================================================================================================================================================================================
#  Sub-function of "RunUpscalerAISegments". Branched out to keep the code tidier since it's used a few times.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TryCreateSegment([string]$ImageFile, [string]$CropGeometry, [string]$OutputFile)
{
  # If arguments are specified in "CropGeometry", create the segment using ImageMagick.
  if ($CropGeometry -ne '')
  {
    # Set up the ImageMagick argument list.
    $ArgumentList = @('-crop', $CropGeometry, '+repage', '-define', 'png:format=png24', '-alpha', 'off', '-background', 'none')

    # Crop the image with imageMagick.
    Magick-Convert -ImageFile $ImageFile -Arguments $ArgumentList -OutputFile $OutputFile ; if ($CancelMasterLoop) { return $false }
  }
  # Otherwise create the segment using the upscaling program.
  else
  {
    # Upscale the segment with the selected filter.
    Invoke-Expression -Command ('Execute-' + $FilterSelected + ' -ImageFile $ImageFile -OutputFile $OutputFile') ; if ($CancelMasterLoop) { return $false }
  }
  # Make sure the segment exists. If it doesn't fail the image.
  return (TestImageExists -ImageFile $OutputFile -ErrorMessage 'Error: A segment failed to be created.')
}
#==============================================================================================================================================================================================
#  Sub-function of "StartUpscalerAI". This does the same as the above function, but splits the image into segments to avoid the limitations of ESRGAN and SFTGAN.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunUpscalerAISegments([string]$ImageFile, [string]$Factor, [int]$Width, [int]$Height, [string]$OutputFile)
{
  # Create a temporary path for the textures.
  $SuperScalerTemp = CreatePath -LiteralPath ($TempFolder + '\SuperScaler')

  # Create the master image that will hold the extra pixels for the upscaler.
  $TileImage = GetBufferedImage -ImageFile $ImageFile -Width $Width -Height $Height -OutputFolder $SuperScalerTemp

  # Create temporary paths for the segments.
  $SegmentsOldPath = CreatePath -LiteralPath ($SuperScalerTemp + '\SegmentsOld')
  $SegmentsNewPath = CreatePath -LiteralPath ($SuperScalerTemp + '\SegmentsNew')
  $SegmentsFinPath = CreatePath -LiteralPath ($SuperScalerTemp + '\SegmentsFin')

  # This array will hold a collection of the final images.
  $FinalCollection = New-Object Collections.Generic.List[string]

  # Get info for the segment sizes and coordinates.
  $Segment = GetSegmentInfo -Factor $Factor -Width $Width -Height $Height

  # Set the starting points for the Y axis.
  $OverPointY = 0

  # Loop through all height possibilities.
  for ($y = 1 ; $y -le $Segment.DivisorY ; $y++)
  {
    # Set the starting points for the X axis.
    $OverPointX = 0

    # Loop through all width possibilities.
    for ($x = 1 ; $x -le $Segment.DivisorX ; $x++)
    {
      # Set up the ImageMagick parameters to crop the image.
      $CropGeometry = '' + $Segment.OverSizeX + "x" + $Segment.OverSizeY + "+" + $OverPointX + "+" + $OverPointY

      # Create the path to the base segment. This will be upscaled shortly.
      $SegmentOld = $SegmentsOldPath + '\segment-old_x' + $x + '_y' + $y + '.png'

      # Attempt to create the segment. If it fails to be created, exit this function.
      if (!(TryCreateSegment -ImageFile $TileImage -CropGeometry $CropGeometry -OutputFile $SegmentOld)) { return }

      # Create the path to the upscaled segment.
      $SegmentNew = $SegmentsNewPath + '\segment-new_x' + $x + '_y' + $y + '.png'

      # Attempt to upscale the segment. If it fails to be created, exit this function.
      if (!(TryCreateSegment -ImageFile $SegmentOld -CropGeometry '' -OutputFile $SegmentNew)) { return }

      # Set up the geometry to crop the center image from the upscaled image.
      $CropGeometry = '' + $Segment.FinalSizeX + "x" + $Segment.FinalSizeY + "+" + $Segment.FinalOffsetX + "+" + $Segment.FinalOffsetY

      # Create the path to the final segment. This will be the finished product that is cropped from the above image.
      $SegmentFin = $SegmentsFinPath + '\segment-fin_x' + $x + '_y' + $y + '.png'

      # Attempt to crop the segment. If it fails to be cropped, exit this function.
      if (!(TryCreateSegment -ImageFile $SegmentNew -CropGeometry $CropGeometry -OutputFile $SegmentFin)) { return }

      # Add the final image to the collection of finished images.
      $FinalCollection.Add($SegmentFin) | Out-Null

      # Shift to the next tile on the X axis.
      $OverPointX += $Segment.TileSizeX
    }
    # Shift to the next tile on the Y axis.
    $OverPointY += $Segment.TileSizeY
  }
  # Set the tile order of the segments.
  $TileOrder = $Segment.DivisorX.ToString() + 'x' + $Segment.DivisorY.ToString()

  # Assemble all the segments into the final image.
  DebugMessage -Message '' -FollowUp ($FilterSelected + ': Combining segmented tiles into final image.')
  Magick-Montage -Collection $FinalCollection -Arguments @('-tile', $TileOrder, '-geometry', '+0+0', '-alpha', 'off', '-background', 'none') -OutputFile $OutputFile

  # We're done with these images, clean them up.
  RemovePath -LiteralPath $TileImage
  RemovePath -LiteralPath $SegmentsOldPath
  RemovePath -LiteralPath $SegmentsNewPath
  RemovePath -LiteralPath $SegmentsFinPath
}
#==============================================================================================================================================================================================
#  Sub-function of "StartUpscalerAI". Upscales an image and its alpha channel with either ESRGAN or SFTGAN, then combines the images together.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunUpscalerAISimple([string]$ImageFile, [string]$Factor, [string]$AlphaFile, [string]$OutputFile)
{
  # Show a debug message.
  DebugMessage -Message '' -FollowUp ($FilterSelected + ': Upscaling image...')

  # Check to see if the image did not have an alpha channel.
  if (($AlphaFile -eq "") -or (!(TestPath -LiteralPath $AlphaFile)))
  {
    # Upscale the image with the selected filter.
    Invoke-Expression -Command ('Execute-' + $FilterSelected + ' -ImageFile $ImageFile -OutputFile $OutputFile') ; if ($CancelMasterLoop) { return }

    # If the segment failed to be created, fail the image entirely.
    if (!(TestImageExists -ImageFile $OutputFile -ErrorMessage 'Error: Image failed to be upscaled.')) { return }
  }
  # If the image did have an alpha channel, upscale both and combine them.
  else
  {
    # Create a temporary path for the textures.
    $SimpleTemp  = CreatePath -LiteralPath ($TempFolder + '\SimpleUpscale')
    $SimpleImage = $SimpleTemp + '\base.png'
    $SimpleAlpha = $SimpleTemp + '\alpha.png'

    # Show a debug message.
    DebugMessage -Message '' -FollowUp ($FilterSelected + ': Upscaling main image...')

    # Upscale the image with the selected filter.
    Invoke-Expression -Command ('Execute-' + $FilterSelected + ' -ImageFile $ImageFile -OutputFile $SimpleImage') ; if ($CancelMasterLoop) { return }

    # If the image failed to be created, fail the image entirely.
    if (!(TestImageExists -ImageFile $SimpleImage -ErrorMessage 'Error: Image failed to be upscaled.')) { return }

    # Show a debug message.
    DebugMessage -Message '' -FollowUp ($FilterSelected + ': Upscaling alpha channel...')

    # Now lets upscale the alpha channel.
    Invoke-Expression -Command ('Execute-' + $FilterSelected + ' -ImageFile $AlphaFile -OutputFile $SimpleAlpha') ; if ($CancelMasterLoop) { return }

    # If the image failed to be created, fail the image entirely.
    if (!(TestImageExists -ImageFile $SimpleAlpha -ErrorMessage 'Error: Alpha channel failed to be upscaled.')) { return }

    # Combine the upscaled image with the upscaled alpha channel.
    $ArgumentList = @('(', $SimpleAlpha, '-colorspace', 'gray', '-alpha', 'off', ')', '-compose', 'copy-opacity', '-composite')
    Magick-Convert -ImageFile $SimpleImage -Arguments $ArgumentList -OutputFile $OutputFile

    # Take out the trash.
    RemovePath -LiteralPath $SimpleTemp
  }
}
#==============================================================================================================================================================================================
#  Attempts to run the function to upscale the image directly instead of splitting it into segments. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageWithinSegmentSizeLimit([int]$Width, [int]$Height)
{
  # Get the number of pixels in the image.
  $PixelCount = $Width * $Height

  # Split the selected segment size on the "x" to extract one of the dimensions.
  $SplitSegmentSize = $ESRGANMaxSegment.Split('x')

  # Convert this into an integer and add the extra pixels that were selected.
  $SegmentMax = [Convert]::ToInt32($SplitSegmentSize[0])

  # Calculate the pixel limit using the maximum segment size.
  $PixelLimit = [Math]::Pow($SegmentMax,2) 

  # If segments are disabled, or the image is within a reasonable range, we can just simply generate it directly.
  if ((!$ESRGANUseSegments) -or ($PixelCount -le $PixelLimit))
  {
    # Get out of here because we're done.
    return $true
  }
  # The upscaler did not run.
  return $false
}
#==============================================================================================================================================================================================
#  Sub-function of "StartUpscalerAI". Creates an image that is (ImageSize * UpscaleFactor) for SFTGAN using the point filter.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMultipliedImage([string]$ImageFile, [string]$Factor, [string]$OutputPath, [string]$OutputName)
{
  # The filter must be set to SFTGAN and the pre-scale checkbox enabled.
  if (($FilterSelected -eq 'SFTGAN') -and ([int]$Factor -gt 1))
  {
    # Set the path to the temporary image.
    $MultipliedImage = $OutputPath + '\' + $OutputName

    # Upscale the image by the upscale factor using the Point filter.
    Magick-Upscaler -ImageFile $ImageFile -Factor $Factor -OutputFile $MultipliedImage -Filter 'Point'

    # Recreate the image without an alpha channel. 
    Magick-Convert -ImageFile $MultipliedImage -Arguments @('-alpha', 'off', '-define', 'png:format=png24', '-background', 'none') -OutputFile $MultipliedImage

    # Return the newly created texture.
    return $MultipliedImage
  }
  # Return the original image.
  return $ImageFile
}
#==============================================================================================================================================================================================
#  Gets the extracted alpha channel. Multiplies it by 4x using nearest neighbor if SFTGAN is enabled.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetExtractedAlpha([string]$ImageFile, [string]$Factor, [string]$AlphaFile)
{
  # Extract the alpha channel to its own image.
  Magick-Convert -ImageFile $ImageFile -Arguments @('-alpha', 'extract', '-define', 'png:format=png24') -OutputFile $AlphaFile

  # If SFTGAN is enabled, attempt to get an upscaled version of the image.
  $AlphaFile = GetMultipliedImage -ImageFile $AlphaFile -Factor $Factor -OutputPath $OutputPath -OutputName 'alpha.png'

  # Return whatever image was created.
  return $AlphaFile
}
#==============================================================================================================================================================================================
#  The main function that runs ESRGAN/SFTGAN.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StartUpscalerAI([string]$ImageFile, [string]$Factor, [string]$OutputFile)
{
  # Create a temporary path for the textures.
  $SuperScalerTemp = CreatePath -LiteralPath ($TempFolder + '\SuperScaler')

  # Do a transparency check which is longer than an alpha check but could save potentially far more minutes of wasted
  # time. When AlphaImage is fed to "RunUpscalerAISimple" as a blank string, only the color texture is generated.
  $AlphaCheck = Magick-IndentifyTransparency -ImageFile $ImageFile
  $AlphaImage = ""

  # Condition on whether or not alpha channel is extracted and reapplied.
  $PreserveAlpha = (($ESRGANSaveAlpha) -and ($AlphaCheck))

  # Check to see if the image has an alpha channel.
  if ($PreserveAlpha) { $AlphaImage = GetExtractedAlpha -ImageFile $ImageFile -Factor $Factor -AlphaFile ($SuperScalerTemp + '\alpha.png') }

  # Tracks if ESRGAN is out of VRAM. This will only get set to true if the output error from ESRGAN reports it is out of VRAM.
  $global:OutOfVRAM = $false

  # Create an image with dimensions that is multiplied by the upscale factor and set up the various properties.
  $ImageFile = GetMultipliedImage -ImageFile $ImageFile -Factor $Factor -OutputPath $SuperScalerTemp -OutputName 'multiplied.png'

  # Get some information from the image.
  $ImageInfo = GetImageInfo -ImageFile $ImageFile

  # If the upscale value is within the segment dimensions limit, just upscale the image directly.
  if (ImageWithinSegmentSizeLimit -Width $ImageInfo.Width -Height $ImageInfo.Height)
  {
    # Do not do segmentation, use the image directly.
    RunUpscalerAISimple -ImageFile $ImageFile -Factor $Factor -AlphaFile $AlphaImage -OutputFile $OutputFile
  }
  # Looks like a simple upscale isn't going to happen so use the more complex methods below.
  else
  {
    # Check to see if the image did not have an alpha channel.
    switch ($PreserveAlpha)
    {
      # If the image did not have an alpha channel, upscale just the base image.
      $false  {
                # Time to run the upscaling function that segments the image.
                RunUpscalerAISegments -ImageFile $ImageFile -Factor $Factor -Width $ImageInfo.Width -Height $ImageInfo.Height -OutputFile $OutputFile ;  if ($CancelMasterLoop) { return }
              }
      # If the image did have an alpha channel, upscale it too and combine it with the newly upscaled image.
      $true   {
                # Store the upscaled image to a temporary location.
                $ImageFinal = $SuperScalerTemp + '\image_final.png'

                # Upscale the base image using the segmented method.
                RunUpscalerAISegments -ImageFile $ImageFile -Factor $Factor -Width $ImageInfo.Width -Height $ImageInfo.Height -OutputFile $ImageFinal ;  if ($CancelMasterLoop) { return }

                # Create a path to the upscaled alpha channel.  
                $AlphaFinal = $SuperScalerTemp + '\alpha_final.png'

                # Upscale the extracted alpha channel.
                RunUpscalerAISegments -ImageFile $AlphaImage -Factor $Factor -Width $ImageInfo.Width -Height $ImageInfo.Height -OutputFile $AlphaFinal ;  if ($CancelMasterLoop) { return }

                # Set up the ImageMagick arguments to combine the image.
                $ArgumentList = @('(', $AlphaFinal, '-colorspace', 'gray', '-alpha', 'off', ')', '-compose', 'copy-opacity', '-composite')
                
                # Combine the upscaled image with the upscaled alpha channel.
                Magick-Convert -ImageFile $ImageFinal -Arguments $ArgumentList -OutputFile $OutputFile
              }
    }
  }
  # We're done with these images, clean them up.
  RemovePath -LiteralPath ($TempFolder + '\SuperScaler')
}
#==============================================================================================================================================================================================
#  OPERATION 10: APPLY UPSCALING FILTER TO ALL TEXTURES - MAIN FUNCTIONS
#==============================================================================================================================================================================================
#  This section of the upscaling code is where the actual upscaling takes place (for the most part, there are more upscaling functions found higher up for the individual 
#  programs). This section makes use of the data set up from the above section. 
#==============================================================================================================================================================================================
#  Check that makes sure the texture should be upscaled. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function VerifyApplyUpscaleFilter([hashtable]$TextureInfo, [int]$UpscaleFactorCheck)
{
  # Do not allow upscale factors of "1" unless the filter is "SFTGAN" or "Waifu2x".
  if (($UpscaleFactorCheck -eq 1) -and (($FilterSelected -ne 'SFTGAN') -and ($FilterSelected -ne 'Waifu2x')))
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture already matches or exceeds the expected upscaling value.'
    return $false
  }
  # Do not run this on enormous textures. The current input limit "16384" is half the current output limit "32768".
  elseif (($TextureInfo.Width -gt 16384) -or ($TextureInfo.Height -gt 16384))
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Input dimensions exceeds the limit of 16384x16384.'
    return $false
  }
  # If the resulting upscale would exceed the dimensions limit (function "FindUpscaleFactor" returns "0"), do not create the texture.
  elseif ($UpscaleFactorCheck -lt 1)
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Output dimensions would exceed the limit of 32768x32768.'
    return $false
  }
  # Do not attempt to filter Ishiiruka DDS textures.
  elseif (($TextureInfo.HasMatMap) -and ($TextureInfo.Extension -ne $DDS))
  {
    TexList_SetTextureStatus -Status 'Skipped' -Message 'Ishiiruka DDS textures can not have upscaling filters applied.'
    return $false
  }
  # If we made it down here, allow upscaling the texture.
  return $true
}
#==============================================================================================================================================================================================
#  Selectively choose the upscaling program and use it to create the image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunUpscaleProgram([string]$InputImage, [int]$ScaleFactor, [string]$OutputFile)
{
  # Choose the filter program based on the type of upscale being applied.
  switch -wildcard ($UpscaleFilter)
  {
    '*xBRZ'  { xBRZ-ScalerTest -ImageFile $InputImage -Factor $ScaleFactor -OutputFile $OutputFile }
    'waifu*' { Waifu2x-Upscale -ImageFile $InputImage -Factor $ScaleFactor -OutputFile $OutputFile }
    '*GAN*'  { StartUpscalerAI -ImageFile $InputImage -Factor $ScaleFactor -OutputFile $OutputFile }
    default  { Magick-Upscaler -ImageFile $InputImage -Factor $ScaleFactor -OutputFile $OutputFile -Filter $UpscaleFilter }
  }
}
#==============================================================================================================================================================================================
#  Applies an upscaling filter to an image using a special method to account for the edges of seamless textures. This function is not used when using ESRGAN/SFTGAN while performing segmented 
#  upscales as there is a separate function that takes care of those (check "GetBufferedImage"). This seamless method is however used for ESRGAN/SFTGAN when not upscaling using segments.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunSeamlessMethod([string]$InputImage, [string]$OutputFile)
{
  # The dimensions of the image are required to calculate the segments.
  $I = GetImageInfo -ImageFile $InputImage

  # Create a hashtable array and a string array to hold the created tiles.
  $Tile    = New-Object hashtable[] 8
  $Segment = New-Object string[] 8

  # Fill the hashtable array with nodes and empty values.
  for ($i = 0 ; $i -lt 8 ; $i++) { $Tile[$i] = @{X=0;Y=0;W=0;H=0} }

  # This is the amount of overhang that will make up the tile to give the upscaler seamless pixels to work with.
  $Value = $SeamlessPixels / 2

  # Set up the crop values for each tile. X and Y are the start points, W and H are the width/height of the tiles.
  $Tile[0].X = $I.Width - $Value  ;  $Tile[0].Y = $I.Height - $Value ;  $Tile[0].W = $Value             ;  $Tile[0].H = $Value
  $Tile[1].X = 0                  ;  $Tile[1].Y = $I.Height - $Value ;  $Tile[1].W = $I.Width           ;  $Tile[1].H = $Value 
  $Tile[2].X = 0                  ;  $Tile[2].Y = $I.Height - $Value ;  $Tile[2].W = $Value             ;  $Tile[2].H = $Value 
  $Tile[3].X = $I.Width - $Value  ;  $Tile[3].Y = 0                  ;  $Tile[3].W = $Value             ;  $Tile[3].H = $I.Height
  $Tile[4].X = 0                  ;  $Tile[4].Y = 0                  ;  $Tile[4].W = $Value             ;  $Tile[4].H = $I.Height
  $Tile[5].X = $I.Width - $Value  ;  $Tile[5].Y = 0                  ;  $Tile[5].W = $Value             ;  $Tile[5].H = $Value 
  $Tile[6].X = 0                  ;  $Tile[6].Y = 0                  ;  $Tile[6].W = $I.Width           ;  $Tile[6].H = $Value 
  $Tile[7].X = 0                  ;  $Tile[7].Y = 0                  ;  $Tile[7].W = $Value             ;  $Tile[7].H = $Value

  # Create a place to store the temporary images.
  $TempSegments = CreatePath -LiteralPath ($TempFolder + '\TempSegments')

  # Loop through and create each segment from the main image.
  for ($i = 0 ; $i -lt 8 ; $i++)
  {
    # Set up some properties to crop the image.
    # NOTE: Forcing the PNG type here causes some segments to fail creation!
    $CropGeometry = '' + $Tile[$i].W + "x" + $Tile[$i].H + "+" + $Tile[$i].X + "+" + $Tile[$i].Y
    $ArgumentList = [Collections.Generic.List[string]]@('-crop', $CropGeometry, '+repage', '-alpha', $Upscale.AlphaIM, '-background', 'none')
    $Segment[$i]  = $TempSegments + '\tile_0' + $i + '.png'

    # Crop the seamless pixels from the main image.
    Magick-Convert -ImageFile $InputImage -Arguments $ArgumentList -OutputFile $Segment[$i] ; if ($CancelMasterLoop) { return }
  }
  # Create the array of tiles and the output image.
  $TileArray  = @($Segment[0], $Segment[1], $Segment[2], $Segment[3], $InputImage, $Segment[4], $Segment[5], $Segment[6], $Segment[7])
  $Arguments  = [Collections.Generic.List[string]]@('-tile', '3x3', '-geometry', '+0+0', '-alpha', $Upscale.AlphaIM, '-define', $Upscale.PNGType, '-background', 'none')
  $TiledImage = $TempSegments + '\tiled.png'

  # Assemble all the segments into the final image.
  Magick-Montage -Collection $TileArray -Arguments $Arguments -OutputFile $TiledImage ; if ($CancelMasterLoop) { return }

  # Set a path to the resulting filtered image.
  $FilteredImage = $TempSegments + '\filtered.png'

  # Upscale the texture using the selected filter and filter method.
  RunUpscaleProgram -InputImage $TiledImage -ScaleFactor $Upscale.Factor -OutputFile $FilteredImage ; if ($CancelMasterLoop) { return }

  # Set the size and coordinates for the final image.
  $FinalSizeX   = $I.Width * $Upscale.Factor
  $FinalSizeY   = $I.Height * $Upscale.Factor
  $FinalOffsetX = ($SeamlessPixels / 2) * $Upscale.Factor
  $FinalOffsetY = ($SeamlessPixels / 2) * $Upscale.Factor

  # Create an argument list for ImageMagick and set the path to the final image.
  $CropGeometry  = $FinalSizeX.ToString() + "x" + $FinalSizeY.ToString() + "+" + $FinalOffsetX.ToString() + "+" + $FinalOffsetY.ToString()
  $ArgumentList  = [Collections.Generic.List[string]]@('-crop', $CropGeometry, '+repage', '-alpha', $Upscale.AlphaIM, '-define', $Upscale.PNGType, '-background', 'none')
  $FinishedImage = $TempSegments + '\final.png'

  # Crop the center image from what remains of the tiled image to create the finished product.
  Magick-Convert -ImageFile $FilteredImage -Arguments $ArgumentList -OutputFile $FinishedImage ; if ($CancelMasterLoop) { return }

  # Move the texture to the output path specified which also renames it in the process.
  Move-Item -LiteralPath $FinishedImage -Destination $OutputFile -Force

  # Remove the segments now that they are no longer needed.
  RemovePath -LiteralPath $TempSegments
}
#==============================================================================================================================================================================================
#  Resizes the upscaled texture if the result does not match the calculated dimensions when "Upscale Factor as Target" is checked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpscaleAsTargetTempResize([string]$ImageFile, [int]$Width, [int]$Height)
{
  # It only works with Dolphin textures.
  if (($UpscaleAsTarget) -and (($Upscale.TexInfo.Dolphin) -or ($Upscale.TexInfo.DBTexture))) 
  {
    # Get the width and height of the image supplied.
    $ImageInfo = GetImageInfo -ImageFile $ImageFile

    # Calculate the target width and height.
    $TargetWidth  = [int]$UpscaleFactor * $Width
    $TargetHeight = [int]$UpscaleFactor * $Height

    # Check to see if the texture's upscaled dimensions already match the expected dimensions.
    if (($TargetWidth -ne $ImageInfo.Width) -and ($TargetHeight -ne $ImageInfo.Height))
    {
      # Dimensions that ImageMagick likes to see. 
      $NewDimensions = '' + $TargetWidth + 'x' + $TargetHeight + '!'

      # Recreate the texture with ImageMagick with the expected dimensions.
      Magick-Convert -ImageFile $ImageFile -Arguments @('-resize', $NewDimensions, '-alpha', $Upscale.AlphaIM, '-define', $Upscale.PNGType, '-background', 'none') -OutputFile $ImageFile
    }
  }
}
#==============================================================================================================================================================================================
#  If the texture was a mipmap texture, also upscale all the mipmaps that are found.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AttemptFindUpscaleMipmaps([string]$ImageFile, [string]$OutputPath)
{
  # Checks to see if mipmaps are disabled or there are no mipmaps to be found.
  $FailUpscaleMipmaps = New-Object bool[] 3

  # Build the array of checks. If any are true, the function will exit.
  $FailUpscaleMipmaps[0] = ($DisableMipmaps -eq $true)
  $FailUpscaleMipmaps[1] = ($Upscale.TexInfo.IsMipmap -eq $false)
  $FailUpscaleMipmaps[2] = ($Upscale.TexInfo.Mipmaps -eq 0)

  # Run my handy dandy boolean array function to test the conditions.
  if (TestBooleanArray -Or -Array $FailUpscaleMipmaps) { return }

  # Get info about the new image.
  $FilteredInfo = GetImageInfo -ImageFile $ImageFile

  # Create the mipmap hash table from the recently upscaled texture.
  $Mipmap = CreateMipmapInfo -TextureInfo $Upscale.TexInfo -Width $FilteredInfo.Width -Height $FilteredInfo.Height

  # Keeps track of the path to the last mipmap that had a filter applied to it. Default it to the top level.
  $LastUpscaledMipmap = $ImageFile

  # Loop through all mipmap levels.
  for ($i=1; $i -le $Mipmap.Levels; $i++) 
  {
    # Create a temporary path to the filtered mipmap.
    $TempMipmapFile = $OutputPath + '\' + $Mipmap.Name[$i] + $PNG

    # Check to see if the mipmap level exists.
    if ($Mipmap.Exists[$i])
    {
      # Upscale the mipmap using the selected filter and filter method.
      switch ($Upscale.Seamless)
      {
        # The seamless method adds a border around the image to simulate a seamless pattern before upscaling the texture.
        $true   { RunSeamlessMethod -InputImage $Mipmap.FullPath[$i] -OutputFile $TempMipmapFile ; if ($CancelMasterLoop) { return } }

        # Calls the upscaler program. Depending on the filter, a bunch of additional code may be ran. Waifu2x, ESRGAN, and SFTGAN for example are very complex.
        $false  { RunUpscaleProgram -InputImage $Mipmap.FullPath[$i] -ScaleFactor $Upscale.Factor -OutputFile $TempMipmapFile ; if ($CancelMasterLoop) { return } }
      }
      # If the user chose the upscale factor as a target upscale, the image may be larger than the expected result so it must be resized.
      UpscaleAsTargetTempResize -ImageFile $TempMipmapFile -Width $Mipmap.Width[$i] -Height $Mipmap.Height[$i] ; if ($CancelMasterLoop) { return }

      # For levels that do not exist, use the last created mipmap to use as a base.
      $LastUpscaledMipmap = $TempMipmapFile
    }
    # If the mipmap does not exist, create it from the filtered textured if it exists, or the last created mipmap if it doesn't.
    else
    {
      # Calculate the new dimensions of the mipmap which is determined by the scaling factor.
      $MipmapDimensions = $Mipmap.Width[$i].ToString() + 'x' + $Mipmap.Height[$i].ToString() + '!'

      # Create the missing mipmap from the last mipmap that was found (or the top level if no mipmaps were found).
      Magick-Convert -ImageFile $LastUpscaledMipmap -Arguments @('-resize', $MipmapDimensions, '-define', 'png:color-type=6') -OutputFile $TempMipmapFile
    }
  }
}
#==============================================================================================================================================================================================
#  Validates the master upscale function. Not all image types are compatible with this operation. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ValidateUpscaleFilter([hashtable]$TextureInfo)
{
  # Check to see if it is an icon file, and the operation is set to "Convert".
  if ($TextureInfo.IsIcon)
  {
    TexList_SetTextureStatus -Status 'Fail' -Message 'Icon files can not be upscaled.'
    return $false
  }
  # Only allow ImageMagick upscaling filers to be applied to TIF, TIFF, and TGA.
  if (($FilterSelected -eq 'xBRZ') -or ($FilterSelected -eq 'Waifu2x') -or ($FilterSelected -eq 'ESRGAN') -or ($FilterSelected -eq 'SFTGAN'))
  {
    # Check to see if it is a TIF file.
    if (($TextureInfo.Extension -eq $TIF) -or ($TextureInfo.Extension -eq $TIFF))
    {
      TexList_SetTextureStatus -Status 'Fail' -Message 'TIF/TIFF files are not supported for xBRZ, waifu2x, ESRGAN, and SFTGAN.'
      return $false
    }
    # Check to see if it is a TGA file.
    if ($TextureInfo.Extension -eq $TGA)
    {
      TexList_SetTextureStatus -Status 'Fail' -Message 'TGA files are not supported for xBRZ, waifu2x, ESRGAN, and SFTGAN.'
      return $false
    }
  }
  # All checks pass so we can upscale this texture.
  return $true
}
#==============================================================================================================================================================================================
#  The master function that is ran from the main loop which sets up data for the above functions. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ApplyUpscalingFilter()
{
  # Make sure that the script supports upscaling this file.
  if (!(ValidateUpscaleFilter -TextureInfo $Texture)) { return }

  # Define a folder to store all upscale-temp shit now that will be reused for everything.
  $TempFilterPath = CreatePath -LiteralPath ($TempFolder + '\TempFiltered')

  # Get a hash table that holds all information for the upscaled texture.
  $global:Upscale = BuildUpscaleHashTable -TextureInfo $Texture -TempFilterPath $TempFilterPath ; if ($CancelMasterLoop) { return }

  # Create a path to the final texture so it's easier to reference.
  $FinalUpscaleTexture = $Upscale.OutputPath + '\' + $Upscale.TexInfo.Name + $UpscaleFormat

  # If the user wants to skip textures that already exist, allow doing this.
  if ((!$AlwaysOverwrite) -and (TestPath -LiteralPath $FinalUpscaleTexture)) { TexList_SetTextureStatus -Status 'Skipped' -Message 'Texture Already Exists in Output Path' ; return }

  # Verify that the texture should be upscaled.
  if (!(VerifyApplyUpscaleFilter -TextureInfo $Upscale.TexInfo -UpscaleFactorCheck $Upscale.Factor)) { return }

  # Create a link to the filtered texture. This is the path to the "final result".
  $UpscaledTexture = $TempFilterPath + '\' + $Upscale.TexInfo.Name + $PNG

  # Upscale the texture using the selected filter and filter method.
  switch ($Upscale.Seamless)
  {
    # The seamless method adds a border around the image to simulate a seamless pattern before upscaling the texture.
    $true   { RunSeamlessMethod -InputImage $Upscale.TexInfo.FullPath -OutputFile $UpscaledTexture ; if ($CancelMasterLoop) { return } }

    # Calls the upscaler program. Depending on the filter, a bunch of additional code may be ran. Waifu2x, ESRGAN, and SFTGAN for example are very complex.
    $false  { RunUpscaleProgram -InputImage $Upscale.TexInfo.FullPath -ScaleFactor $Upscale.Factor -OutputFile $UpscaledTexture ; if ($CancelMasterLoop) { return } }
  }
  # If the user chose the upscale factor as a target upscale, the image may be larger than the expected result so it must be resized.
  UpscaleAsTargetTempResize -ImageFile $UpscaledTexture -Width $Upscale.TexInfo.OldWidth -Height $Upscale.TexInfo.OldHeight ; if ($CancelMasterLoop) { return }

  # If the image was a mipmap texture, attempt to create mipmaps for it.
  AttemptFindUpscaleMipmaps -ImageFile $UpscaledTexture -OutputPath $TempFilterPath ; if ($CancelMasterLoop) { return }

  # The final step in creating the texture in the output path depending on the output format.
  switch ($UpscaleFormat)
  {
    # If creating DDS, the filtered results must be converted.
    $DDS
    {
      # Replace the texture info one more time to grab any mipmaps that were created.
      $DDSInfo = CreateTextureInfo -ImageFile $UpscaledTexture -Extended

      # Create the DDS texture directly into the output path.
      CreateTexture -TextureInfo $DDSInfo -Width $DDSInfo.Width -Height $DDSInfo.Height -Format $DDS -OutputPath $Upscale.OutputPath -NoReturn ; if ($CancelMasterLoop) { return }
    }
    # If creating PNG or JPG, all the upscaled textures can be sent directly to the output path.
    default
    {
      # Loop through all images found in the temp path.
      foreach ($UpscaleImage in EnumerateFiles -LiteralPath $TempFilterPath)
      {
        # Move all upscaled textures from the temp path to the output path.
        Move-Item -LiteralPath $UpscaleImage -Destination $Upscale.OutputPath -Force
      }
    }
  }
  # Test to see if the texture was actually created or not.
  if (TestPath -LiteralPath $FinalUpscaleTexture)
  {
    # Report slightly different information if the upscale factor is used as a target upscale.
    if (($UpscaleAsTarget) -and (($Upscale.TexInfo.Dolphin) -or ($Upscale.TexInfo.DBTexture)))
    {
      # Calculate the new width/height which is determined by the scaling factor.
      $UpscaleDimensions = ($Upscale.TexInfo.OldWidth * $Upscale.Factor).ToString() + 'x' + ($Upscale.TexInfo.OldHeight * $Upscale.Factor).ToString()

      # Report that the texture has been created.
      TexList_SetTextureStatus -Status (GetStatus) -Message ('Successfully upscaled to: (' + $UpscaleFactor + 'x, ' + $UpscaleDimensions + ', ' + $UpscaleFilter + ')')
    }
    # Use the factor and dimensions from the upscale hash table for all other cases.
    else
    {
      # Report that the texture has been created.
      TexList_SetTextureStatus -Status (GetStatus) -Message ('Successfully upscaled to: (' + $Upscale.Factor + 'x, ' + $Upscale.NewDimensions + ', ' + $UpscaleFilter + ')')
    }
    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $FinalUpscaleTexture -NewFormat $UpscaleFormat -Width $Upscale.Width -Height $Upscale.Height
  }
  # We failed to create a texture for some reason.
  else
  {
    # Report that the texture failed to be created.
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
  # Clean up any temporary images that were generated throughout this process.
  RemovePath -LiteralPath $TempFilterPath

  # Clear the hash table since it's just garbage at this point.
  $global:Upscale = $null
}
#==============================================================================================================================================================================================
#  OPERATION 11: CALCULATE TEXTURES VRAM REQUIREMENT
#==============================================================================================================================================================================================
#  Runs a loop separate from the master loop and calculates VRAM for all textures in the "VRAMPackPath" variable which is set from the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CalculateTexturesVRAM()
{
  # Determine how to find the size based on the given extension.
  switch ($Texture.Extension)
  {
    # PNG is simple, just return (width * height * 4.)
    $PNG    {
              # Add to the number of PNG textures.
              [int64]$global:VRAMCountPNG += 1

              # Calculate the amount of VRAM usage in MB.
              $VRAMSize = ($Texture.Width * $Texture.Height * 4)
            }
    # JPG is also simple, it's the same formula)
    $JPG    {
              # Add to the number of JPG textures.
              [int64]$global:VRAMCountJPG += 1

              # Calculate the amount of VRAM usage.
              $VRAMSize = ($Texture.Width * $Texture.Height * 4)
            }
    # DDS we can just use the file size minus the header bytes.
    $DDS    {
              # Add to the number of DDS textures.
              [int64]$global:VRAMCountDDS += 1

              # A switch within a switch because it's fancy.
              switch -wildcard ($Texture.Format)
              {
                # The D3D9 header is 128 bytes, and the DX10 header is 148 bytes.
                'DXT*'  { $VRAMSize = ($Texture.Size - 128) }
                'BC7'   { $VRAMSize = ($Texture.Size - 148) }
                'ARGB8' { $VRAMSize = ($Texture.Size - 128) }
                'RGBA8' { $VRAMSize = ($Texture.Size - 128) }
                default { $VRAMSize = $Texture.Size }
              }
            }
    # If any other file extensions manage to pass, just ignore them.
    default {
              $VRAMSize = 0
            }
  }
  # Add the calculated VRAM usage to the total usage.
  [int64]$global:VRAMTotal += $VRAMSize

  # Calculate the VRAM usage in MB to display to the user.
  $VRAMSizeMB = (B2MB -Bytes $VRAMSize).ToString() + ' MB'

  # Add the VRAM usage to texture list.
  TexList_SetTextureStatus -Status $Texture.Format -Message $VRAMSizeMB
}
#==============================================================================================================================================================================================
#  OPERATION 12: GENERATE NEW MIPMAPS FOR DOLPHIN TEXTURES
#==============================================================================================================================================================================================
#  Generates new mipmaps within the texture pack itself.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GenerateNewMipmaps()
{
  # Leave now if the texture is not a mipmap texture.
  if (!($Texture.IsMipmap)) { TexList_SetTextureStatus -Status 'OK' -Message 'Not a Mipmap Texture' ; return }

  # Create a temporary folder to generate the Mipmaps to.
  $TempMipmapsPath = CreatePath -LiteralPath ($TempFolder + '\TempForceMipmaps')

  # Create the converted texture. The below function will automatically handle creating mipmaps.
  $TextureCreated = CreateTexture -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height -Format $Texture.Extension -OutputPath $TempMipmapsPath

  # Before removing textures and throwing shit around, make sure the new texture exists.
  if (!$TextureCreated) { TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation' ; return }

  # If the user wanted mipmaps created in-place, remove the images currently in the pack.
  if ($InPlaceMipmaps)
  {
    # Loop through all textures within the texture's current path to also find mipmaps.
    foreach ($Image in EnumerateFiles -LiteralPath $Texture.Path)
    {
      # Get the image as an item to get basic properties.
      $ImageItem = Get-Item -LiteralPath $Image

      # Check to see if the current texture name is similar to the target texture name.
      if ($ImageItem.BaseName -like ($Texture.Name + '*'))
      {
        # Remove the image/mipmap. They will be replaced with the newly generated files.
        RemovePath -LiteralPath $Image
      }
    }
    # Set the output path to the location of the texture.
    $OutputPath = $Texture.Path
  }
  # The user wants to create mipmaps in the output directory.
  else
  {
    # Create the output path to send the new mipmap textures to.
    $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\NewlyGeneratedMipmaps' + $Texture.Relative)
  }
  # Loop through all textures found in the temp directory.
  foreach ($Image in EnumerateFiles -LiteralPath $TempMipmapsPath)
  {
    # Get the image as an item to get basic properties.
    $ImageItem = Get-Item -LiteralPath $Image

    # Check to see if the current texture name is similar to the target texture name.
    if ($ImageItem.BaseName -like ($Texture.Name + '*'))
    {
      # Move the texture and mipmaps to wherever the output path was set to.
      Move-Item -LiteralPath $Image -Destination $OutputPath -Force
    }
  }
  # Create a path to the output file so it can be sent to the function below.
  $OutputFile = $OutputPath + '\' +  $Texture.FullName

  # If using the "Process Selected" menu, the output may overwrite the input.
  ProcessSelectedOutput -NewTexturePath $OutputFile -NewFormat $Texture.Extension -Width $Texture.Width -Height $Texture.Height

  # Count the number of textures that had mipmaps generated for them.
  $global:CountMipmapped += 1

  # Add the logging events.
  TexList_SetTextureStatus -Status 'OK' -Message 'Generated New Mipmaps'

  # Cleanup the temporary textures.
  RemovePath -LiteralPath $TempMipmapsPath
}
#==============================================================================================================================================================================================
#  OPERATION 13: REMOVE INVALID MIPMAPS FROM DOLPHIN TEXTURES
#==============================================================================================================================================================================================
#  Removes mipmaps from textures that aren't actually mipmap textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveInvalidMipmaps()
{
  # We only want to work with Dolphin textures that are not mipmap or material map textures.
  if ((!$Texture.Dolphin) -or ($Texture.IsIcon) -or ($Texture.IsMipmap) -or ($Texture.HasMatMap))
  {
    TexList_SetTextureStatus -Status 'OK' 
    return
  }
  # Count bad external mipmaps.
  $ExternalMipmaps = 0

  # External Mipmaps: Loop through all textures in the current directory.
  foreach ($Image in EnumerateFiles -LiteralPath $Texture.Path)
  {
    # Skip mipmap files that may have already been removed.
    if (!(TestPath -LiteralPath $Image)) { continue }
  
    # Get the image as an item to get the name.
    $ImageItem = Get-Item -LiteralPath $Image
  
    # Match the texture name with images that have the mipmap suffix attached.
    $SearchName = $Texture.Name + '*_mip*' + $Texture.Extension

    # Search for any textures that are invalid mipmaps.
    if ($ImageItem.Name -like $SearchName)
    {
      # If it passes, remove the file.
      RemovePath -LiteralPath $Image

      # Track that Mipmaps were deleted and count how many.
      $ExternalMipmaps++
      $global:CountInvalidMips++
    }
    # Check to see if mipmaps were deleted.
    if ($ExternalMipmaps -gt 0)
    {
      # Set the log message to the number of mipmaps that were removed.
      TexList_SetTextureStatus -Status 'OK' -Message ('Removed ' + $ExternalMipmaps + ' Invalid Mipmaps')
    }
    # At least say the texture is OK so the log file has something to print.
    else { TexList_SetTextureStatus -Status 'OK' }

    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
  }
  # Internal Mipmaps: Delete mipmaps from the texture if they exist.
  if ($Texture.Extension -eq $DDS)
  {
    # Get the number of internal mipmaps.
    $MipmapLevels = CountInternalMipmaps -ImageFile $Texture.FullPath

    # Track that Mipmaps were deleted and count how many.
    $global:CountInvalidMips += $MipmapLevels

    # If there are internal mipmaps.
    if ($MipmapLevels -gt 0)
    {
      # Create a folder to extract Mipmaps to.
      $ExtractedPath = CreatePath -LiteralPath ($TempFolder + '\Extracted')
      $ExtractedFile = $ExtractedPath + '\' + $Texture.FullName

      # Extract Mipmaps from the texture to see if it has internal Mipmaps.
      ExtractInternalDDSMipmaps -ImageFile $Texture.FullPath -OutputPath $ExtractedPath

      # Overwrite the texture in the pack that has internal mipmaps with the texture that does not have internal mipmaps.
      Move-Item -LiteralPath $ExtractedFile -Destination $Texture.Path -Force

      # Set the log message to the number of mipmaps that were removed.
      TexList_SetTextureStatus -Status 'OK' -Message ('Removed ' + $MipmapLevels + ' Invalid Mipmaps')

      # Remove the temporary directory and all extracted mipmaps.
      RemovePath -LiteralPath $ExtractedPath
    }
    # At least say the texture is OK so the log file has something to print.
    else { TexList_SetTextureStatus -Status 'OK' }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 14: EXTRACT INTERNAL MIPMAPS
#==============================================================================================================================================================================================
#  Extracts internal mipmaps from all DDS Textures found.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractInternalMipmaps()
{
  # Create a series of conditions that determine when to extract mipmaps.
  $ExtractConditions = New-Object bool[] 3
  $ExtractConditions[0] = ($Texture.Extension -eq $DDS)
  $ExtractConditions[1] = ($Texture.Extension -eq $TIF)
  $ExtractConditions[2] = ($Texture.Extension -eq $TIFF)

  # Test to see if mipmaps were disabled, and any other condition matches.
  if (!(TestBooleanArray -Or -Array $ExtractConditions)) { TexList_SetTextureStatus -Status 'OK' ; return }

  # Get the number of internal mipmaps.
  $MipmapLevels = CountInternalMipmaps -ImageFile $Texture.FullPath

  # Check to see if there are actually any internal mipmaps to be found.
  if ($MipmapLevels -gt 0)
  {
    # Create a folder to extract Mipmaps to.
    $TempExtractedPath = CreatePath -LiteralPath ($TempFolder + '\DDSExtracted')

    # Run the function associated with the extension.
    switch -wildcard ($Texture.Extension)
    {
      # Extract all internal Mipmaps.
      '.dds'  { ExtractInternalDDSMipmaps -ImageFile $Texture.FullPath -OutputPath $TempExtractedPath }
      '.tif*' { ExtractInternalTIFMipmaps -ImageFile $Texture.FullPath -OutputPath $TempExtractedPath }
    }
    # If the user wants to extract textures directly.
    switch ($InPlaceExtractDDS)
    {
      # Set the path directly to the texture path to overwrite it and extract the mipmaps here, otherwise send it to the output path.
      $true   { $ExtractedPath = $Texture.Path }
      $false  { $ExtractedPath = CreatePath -LiteralPath ($MasterOutputPath + '\ExtractedMipmaps' + $Texture.Relative) }
    }
    # Loop through all DDS mipmaps.
    foreach ($Image in EnumerateFiles -LiteralPath $TempExtractedPath)
    {
      # Get the image as an item to get the name.
      $ImageItem = Get-Item -LiteralPath $Image

      # Set the path to where the image will be moved.
      $Destination = $ExtractedPath + '\' + $ImageItem.Name

      # Move the mipmap to the texture path.
      Move-Item -LiteralPath $Image -Destination $Destination -Force

      # Don't waste time if we don't have to.
      if ($CancelMasterLoop) { return }
    }
    # Create a path to the output file so it can be sent to the function below.
    $ExtractedFile = $ExtractedPath + '\' +  $Texture.FullName
    
    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $ExtractedFile -NewFormat $Texture.Extension -Width $Texture.Width -Height $Texture.Height

    # Remove the temporary folder.
    RemovePath -LiteralPath $TempExtractedPath

    # If any mipmaps were moved at all then log the number of them moved.
    TexList_SetTextureStatus -Status 'OK' -Message ('Extracted ' + $MipmapLevels + ' mipmaps from the texture.')
  }
}
#==============================================================================================================================================================================================
#  OPERATION 15: REMOVE ALPHA CHANNEL FROM OPAQUE TEXTURES
#==============================================================================================================================================================================================
#  Scans a texture for an alpha channel and transparent pixels and removes the alpha channel if it does not have transparency.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveAlphaChannelFromTexture([string]$ImageFile)
{
  # Check to see if the image has an alpha channel.
  $ImageInfo = GetImageInfo -ImageFile $ImageFile

  # Check if the image has an alpha channel but no transparent pixels.
  if (($ImageInfo.Alpha) -and (!(Magick-IndentifyTransparency -ImageFile $ImageFile)))
  {
    # Get the name of the image.
    $ImageName = (Get-Item -LiteralPath $ImageFile).Name

    # Set up the temporary path.
    $TempPath = CreatePath -LiteralPath ($TempFolder + '\AlphaRemoved')
    $TempFile = $TempPath + '\' + $ImageName

    # Create the PNG image with ImageMagick.
    Magick-Convert -ImageFile $ImageFile -Arguments @('-define', 'png:color-type=2') -OutputFile $TempFile

    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }

    # Make sure the texture was created.
    if (TestPath -LiteralPath $TempFile)
    {
      # Move the result to the output path.
      Move-Item -LiteralPath $TempFile -Destination $ImageFile -Force

      # Destroy the temporary path.
      RemovePath -LiteralPath $TempPath

      # The image had it's alpha removed so verify this.
      return $true
    }
  }
  # Destroy the temporary path if its still lingering around.
  RemovePath -LiteralPath $TempPath

  # Nothing was done to the image.
  return $false
}
#==============================================================================================================================================================================================
#  Recreates a texture that has an alpha channel but doesn't actually contain transparent pixels, into a texture that does not have an alpha channel.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveAlphaChannel()
{
  # Only attempt to remove alpha from PNG textures.
  if ($Texture.Extension -ne $PNG) { TexList_SetTextureStatus -Status 'OK' ; return }

  # Attempt to remove the alpha channel from the texture.
  $AlphaRemoved = RemoveAlphaChannelFromTexture -ImageFile $Texture.FullPath

  # Calculate the number of mipmap levels the texture should have.
  $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($Texture.Width, $Texture.Height))

  # Get the number of external mipmaps.
  $MipmapsFound = CountExternalMipmaps -ImageFile $Texture.FullPath -Levels $MipmapLevels

  # Check to see if there are actually any external mipmaps to be found.
  if ($MipmapsFound -gt 0)
  {
    # Create a Mipmap hash table from the base texture found in the pack.
    $Mipmap = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

    # Loop through all mipmap levels.
    for ($i = 1 ; $i -le $MipmapsFound ; $i++)
    {
      # Check for it's existence.
      if ($Mipmap.Exists[$i])
      {
        # Attempt to remove the alpha channel.
        $AlphaRemoved = RemoveAlphaChannelFromTexture -ImageFile $Mipmap.FullPath[$i]
      }
      # Don't waste time if we don't have to.
      if ($CancelMasterLoop) { return }
    }
  }
  # See if the texture or any mipmaps had alpha removed.
  if ($AlphaRemoved)
  {
    # Count the number of textures that had their alpha channel removed.
    $global:CountSlicedAlpha += 1

    # Report stuff.
    TexList_SetTextureStatus -Status 'OK' -Message 'Successfully Removed Alpha Channel'
  }
  # If we're this deep and nothing was done...
  else
  {
    # I'll be damned if it isn't a good image.
    TexList_SetTextureStatus -Status 'OK'
  }
}
#==============================================================================================================================================================================================
#  OPERATION 16: COMBINE MULTIPLE TEXTURES - MAIN FUNCTIONS
#==============================================================================================================================================================================================
#  Updates the progress % on the texture list when combining.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_UpdateProgress([int]$Iterations)
{
  # Format the decimal. Replace commas with periods.
  $ProgressSplit = (FormatDecimal -Value (($Iterations / ($TextureRows * $TextureCols)) * 100).ToString()).Split('.', 2)

  # Update the number of textures to the amount that was counted.
  TexList_UpdateStatus -Status 'TextureCount' -Value ('' + $Iterations + '/' + ($TextureRows * $TextureCols))
  TexList_UpdateStatus -Status 'Progress'     -Value $ProgressSplit[0]
}
#==============================================================================================================================================================================================
#  Prepares the texture list for what's to come.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_PrepareTexList([string]$Message)
{
  # Hide the main GUI.
  if ($TextureListMode -ne 'Docked') { $MainDialog.Visible = $false }

  # Do not clear the list when batching images to split.
  if (!$SplitBatchImages)
  {
    # Fake the masterloop running.
    $global:MasterLoopRunning = $true
  
    # Clear the texture list.
    TexList_SetInitialState -Rows 150

    # Start the timer that tracks the amount of time the operation takes to complete.
    TexList_StartTimer
  }
  # Disable the GUI while combining textures.
  ToggleDialogStates -State $false

  # Set visibility of the progress indicating shit.
  $TexListTexLabel.Visible   = $true
  $TexListTexValue.Visible   = $true
  $TexListProgLabel.Visible  = $true
  $TexListProgBar.Visible    = $true
  $TexListProgValue.Visible  = $true
  $TexListTimerLabel.Visible = $true
  $TexListTimerValue.Visible = $true

  # Update the number of textures to the amount that was counted.
  TexList_UpdateStatus -Status 'TextureCount' -Value ('0/' + ($TextureRows * $TextureCols))
  TexList_UpdateStatus -Status 'Operation'    -Value $TexListOperation
  TexList_UpdateStatus -Status 'Progress'     -Value '0'
  TexList_UpdateStatus -Status 'Timer'        -Value '0'

  # Report that textures are being processed.
  TexList_AddString -TexEntry $Message
  TexList_AddString -TexEntry ''
}
#==============================================================================================================================================================================================
#  If the test file exists, creates a CTT file. Also updates the Texture List and enables the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_CreateCTTFile([string]$TestFile, [string]$OutputPath)
{
  # Check to see if the texture was created.
  if (TestPath -LiteralPath $TestFile)
  {
    # If we have a texture, create the CTT file.
    CreateCTTFile -OutputPath $OutputPath

    # Report that the textures combined.
    TexList_AddString -TexEntry ''
    TexList_AddString -TexEntry 'All textures successfully combined!'
  }
  # Something went wrong somewhere.
  else
  {
    # Report that the textures combined.
    TexList_AddString -TexEntry ''
    TexList_AddString -TexEntry 'Error: The combined texture was not created!'
  }
  # Now that we are done enable the GUI.
  ToggleDialogStates -State $true

  # Show the main dialog and force it forward.
  ActivateDialog -Dialog $MainDialog
}
#==============================================================================================================================================================================================
#  Builds an array to montage the textures together and adds them to the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_SetStandardTextureArray()
{
  # Create an empty array because we need each texture in a normal array instead of a 2D one.
  $MontageTextures = @()

  # Count the total number of iterations to keep track of the current texture.
  $Iterations = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Count this iteration.
      $Iterations++

      # Add the current texture to the collection.
      $MontageTextures += $TextureArray[$row,$col]

      # Add the texture to the texture list.
      TexList_AddString -TexEntry (Get-Item -LiteralPath $TextureArray[$row,$col]).Name

      # Update the number of textures to the amount that was counted.
      CombineTextures_UpdateProgress -Iterations $Iterations
    }
  }
  # Return the array so it can be ran through ImageMagick.
  return $MontageTextures
}
#==============================================================================================================================================================================================
#  Child function of "CombineTextures_SetOverlapTextureArray". Returns the values necessary to properly crop the texture to account for "Overlap" or "Garbage" pixels.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_GetCropValues([string]$Type, [int]$Row, [int]$Col)
{
  # Hash tables were a gift from the gods.
  $CropValue = @{}

  # Get ImageInfo about the texture so its dimensions can be referenced.
  $ImageInfo = GetImageInfo -ImageFile $TextureArray[$row,$col]

  # Simulate overlapping of textures by cropping certain pixels.
  if ($Type -eq 'Overlap')
  {
    # There are four possible outcomes of how the texture will be cropped.
    if (($Row -eq 1) -and ($Col -eq 1)) { $Case = '1' }
    if (($Row -eq 1) -and ($Col -gt 1)) { $Case = '2' }
    if (($Row -gt 1) -and ($Col -eq 1)) { $Case = '3' }
    if (($Row -gt 1) -and ($Col -gt 1)) { $Case = '4' }

    # Modify the texture depending on where it is in the grid.
    switch ($Case)
    {
      # Case 1: Its the top-left texture, so use the full thing.
      '1' {
            $CropValue.W = $ImageInfo.Width
            $CropValue.H = $ImageInfo.Height
            $CropValue.X = 0
            $CropValue.Y = 0
          }
      # Case 2: It's a top texture. Crop the left only.
      '2' {
            $CropValue.W = $ImageInfo.Width - $CombineOverlapValue
            $CropValue.H = $ImageInfo.Height
            $CropValue.X = $CombineOverlapValue
            $CropValue.Y = 0
          }
      # Case 3: It's a left texture. Crop the top only.
      '3' {
            $CropValue.W = $ImageInfo.Width
            $CropValue.H = $ImageInfo.Height - $CombineOverlapValue
            $CropValue.X = 0
            $CropValue.Y = $CombineOverlapValue
          }
      # Case 4: It's an inner texture. Crop both the left and the top.
      '4' {
            $CropValue.W = $ImageInfo.Width - $CombineOverlapValue
            $CropValue.H = $ImageInfo.Height - $CombineOverlapValue
            $CropValue.X = $CombineOverlapValue
            $CropValue.Y = $CombineOverlapValue
          }
    }
  }
  # Remove garbage pixels from the texture.
  elseif ($Type -eq 'Garbage')
  {
    # Set up the the new dimensions and crop coordinates.
    $CropValue.W = $ImageInfo.Width - $CombinePixelCropR - $CombinePixelCropL
    $CropValue.H = $ImageInfo.Height - $CombinePixelCropB - $CombinePixelCropT
    $CropValue.X = $CombinePixelCropL
    $CropValue.Y = $CombinePixelCropT
  }
  # Return the hash table.
  return $CropValue
}
#==============================================================================================================================================================================================
#  A special type of crop that can simulate overlapping pixels, or remove garbage pixels. "Type" should be "Overlap" or "Garbage".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_SetSpecialCropArray([string]$Type)
{
  # Create a place to store the temporary images.
  $TempArrayPath = CreatePath -LiteralPath ($TempFolder + '\TempTextureArray')

  # Stores a copy of the current array so it can be restored after the textures are combined. 
  $global:BackupArray = New-Object 'string[,]' ($TextureRows+1),($TextureCols+1)

  # Create an empty array because we need each texture in a normal array instead of a 2D one.
  $MontageTextures = @()

  # Count the total number of iterations to keep track of the current texture.
  $Iterations = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Count this iteration.
      $Iterations++

      # Add the texture to the texture list.
      TexList_AddString -TexEntry (Get-Item -LiteralPath $TextureArray[$row,$col]).Name

      # Create a path to the modified texture.
      $TempTexPath = $TempArrayPath + '\' + (Get-Item -LiteralPath $TextureArray[$row,$col]).Name

      # Pass over the texture type to get the values that will be used to crop the texture.
      $CropValue = CombineTextures_GetCropValues -Type $Type -Row $row -Col $col

      # Compile the information into a string for ImageMagick and compile the arguments into an array.
      $CropGeometry = '' + $CropValue.W + "x" + $CropValue.H + "+" + $CropValue.X + "+" + $CropValue.Y
      $ArgumentList = [Collections.Generic.List[string]]@('-crop', $CropGeometry, '-define', 'png:color-type=6', '+repage', '-background', 'none')

      # Create the cropped image in the temporary folder.
      Magick-Convert -ImageFile $TextureArray[$row,$col] -Arguments $ArgumentList -OutputFile $TempTexPath

      # Backup the old texture position in the backup array, and set the new texture position in the texture array.
      $global:BackupArray[$row,$col]  = $TextureArray[$row,$col]
      $global:TextureArray[$row,$col] = $TempTexPath

      # Add the current texture to the collection.
      $MontageTextures += $TempTexPath

      # Update the number of textures to the amount that was counted.
      CombineTextures_UpdateProgress -Iterations $Iterations
    }
  }
  # Return the array so it can be ran through ImageMagick.
  return $MontageTextures
}
#==============================================================================================================================================================================================
#  Make sure the grid is full of textures. If it's not, do not run the function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_Verify()
{
  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Make sure the array exists and that it holds valid paths for each button.
      if ((!$TextureArray) -or ($TextureArray[$row,$col] -eq ''))
      {
        # If a texture has not been selected do not pass.
        $Title   = 'CTT-PS Error'
        $Message = 'Error: Not all textures have been selected!'
        ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 44) -OffsetY (DPISize 18) -Message $Message

        # Exit the function now.
        return $false
      }
    }
  }
  # We're okay for launch.
  return $true
}
#==============================================================================================================================================================================================
#  There is a limit to how many images can be fed to ImageMagick when montaging a collection of textures. When the number of images exceeds 64, this function will break down the number
#  number of images by montaging each row individually, and then montaging all the rows together to create the final image. This makes it possible to montage a huge collection of images.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Special-Montage([string[]]$Collection, [string]$OutputFile)
{
  # Keeps track of the current texture in the collection.
  $Pos = 0

  # List of tiles to montage to create the master image.
  $NewMontage = New-Object Collections.Generic.List[string]

  # Create a path to store the temporary tiles.
  $TempTilePath = CreatePath -LiteralPath ($TempFolder + '\TempTiles')

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # Create a temporary list that holds the entire first row of images.
    $TempList = New-Object Collections.Generic.List[string]

    # Create a variable to store the name/location of the generated tile.
    $TempTile = $TempTilePath + '\TempImage_' + $row + $PNG

    # Now loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Add the current texture to the temp list.
      $TempList.Add($Collection[$Pos])

      # Increment the counter.
      $Pos++
    }
    # Create the image by montaging all images in the texture array.
    Magick-Montage -Collection $TempList -Arguments @('-tile', 'x1', '-geometry', '+0+0', '-background', 'none') -OutputFile $TempTile

    # Add the generated tile to the master list.
    $NewMontage.Add($TempTile)
  }
  # Create the image by montaging all images in the texture array.
  Magick-Montage -Collection $NewMontage -Arguments @('-tile', ('x' + $TextureRows), '-geometry', '+0+0', '-background', 'none') -OutputFile $OutputFile
}
#==============================================================================================================================================================================================
#  Combines multiple textures into a single texture. Textures are added through a grid window.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_Start()
{
  # Make sure the texture grid is full before attempting to combine textures.
  if (!(CombineTextures_Verify)) { return }

  # Prepare the texture list.
  CombineTextures_PrepareTexList -Message 'Combining selected textures...'

  # The Texture Array is replaced when overlapping pixels. A backup is stored in this array and is restored at the end.
  $global:BackupArray = $null

  # Create the output path if it doesn't exist.
  $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\CombinedTextures\' + $CombinedName + $PNG)

  # Set the full texture output path to include the "CombinedName" which is inherited from the GUI text box "Texture Output Name" (aka $CombineNameTextBox).
  $OutputFile = $OutputPath + '\' + $CombinedName + $PNG

  # How to combine the tiled textures is determined by the enabled options: overlapping, garbage pixels, or standard (nothing special done).
  if ($CombineOverlapEnable) { $MontageTextures = CombineTextures_SetSpecialCropArray -Type 'Overlap' }
  elseif ($CombinePixelCrop) { $MontageTextures = CombineTextures_SetSpecialCropArray -Type 'Garbage' }
  else                       { $MontageTextures = CombineTextures_SetStandardTextureArray }

  # ImageMagick can only handle montaging so many images because of a path/filename/command character limit. 
  if (($TextureRows * $TextureCols) -le 64)
  {
    # Create the image by montaging all images in the texture array.
    Magick-Montage -Collection $MontageTextures -Arguments @('-tile', ('x' + $TextureRows), '-geometry', '+0+0', '-background', 'none') -OutputFile $OutputFile
  }
  # If that limit is exceeded, then peform some trickery to work around the limit.
  else
  {
    # Instead of trying to montage images all at once, this function will break it up and build it row by row.
    Special-Montage -Collection $MontageTextures -OutputFile $OutputFile
  }
  # If the backup array was defined.
  if ($BackupArray -ne $null)
  {
    # Restore the original texture array
    $global:TextureArray = $BackupArray

    # No reason to keep this in RAM any longer.
    $global:BackupArray = $null
  }
  # Clean up the temporary textures.
  RemovePath -LiteralPath ($TempFolder + '\TempTextureArray')

  # Create the CTT file if the texture exists.
  CombineTextures_CreateCTTFile -TestFile $OutputFile -OutputPath $OutputPath

  # Stop the timer and destroy it now that the loop has finished.
  TexList_StopTimer -Destroy $true

  # Fake the masterloop running.
  $global:MasterLoopRunning = $false
  $TexListCancelButton.Enabled = $false

  # Always return false so the MasterLoop doesn't run.
  return $false
}
#==============================================================================================================================================================================================
#  OPERATION 17: SPLIT COMBINED MULTI-TEXTURE
#==============================================================================================================================================================================================
#  Creates a hash table with information about the CTT file. This is only used when batching multiple CTT files.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateCTTInfo([string]$InputFile)
{
  # Initialize the texture hash table.
  $CTTInfo = @{}

  # Get the file path as an item so properties can be extracted.
  $FileInfo = Get-Item -LiteralPath $InputFile

  # Let's get down to business.
  $CTTInfo.Name       = $FileInfo.BaseName
  $CTTInfo.FullName   = $FileInfo.Name
  $CTTInfo.Extension  = $FileInfo.Extension
  $CTTInfo.Path       = [string]$FileInfo.Directory
  $CTTInfo.PathName   = $CTTInfo.Path + '\' + $CTTInfo.Name
  $CTTInfo.FullPath   = $CTTInfo.Path + '\' + $CTTInfo.FullName
  $CTTInfo.Relative   = GetRelativePath -TexturePath $CTTInfo.Path
  $CTTInfo.Folder     = [System.IO.Path]::GetFileName($CTTInfo.Path)
  $CTTInfo.Format     = ExtensionToText -Extension $CTTInfo.Extension
  $CTTInfo.Texture    = $CTTInfo.Path + '\' + $CTTInfo.Name + $PNG

  # Debug:Let me know a file is about to be processed.
  DebugMessage -Message '' -FollowUp '- FileInfo created for file:'
  DebugMessage -Message $InputFile -FollowUp ' '

  # Return the texture data so it can be set to a global and used basically everywhere in the script.
  return $CTTInfo
}
#==============================================================================================================================================================================================
#  Updates the progress % on the texture list when combining or splitting.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_UpdateProgress([int]$Iteration)
{
  # Format the decimal. Replace commas with periods.
  $ProgressSplit = (FormatDecimal -Value (($Iteration / $SplitTextureCount) * 100).ToString()).Split('.', 2)

  # Update the number of textures to the amount that was counted.
  TexList_UpdateStatus -Status 'TextureCount' -Value ('' + $Iteration + '/' + ($SplitTextureCount))
  TexList_UpdateStatus -Status 'Progress'     -Value $ProgressSplit[0]
}
#==============================================================================================================================================================================================
#  Adds the textures to the list and renames them back to their original names if a CTT file was loaded.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_FinalizeTextures([string]$TextureName, [string]$OutputPath, [bool]$UpdateList=$true)
{
  # Count the iterations.
  $Iteration  = 1
  $BonusCount = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Get the name of the texture that matches ImageMagick's output based on the loop iteration.
      $UpdateName = $TextureName + '_' + ($Iteration - 1) + $PNG

      # If a CTT file was loaded, the split array is defined.
      if ($CTTFileLoaded)
      {
        # Get the name of the texture from the array.
        $OldPath = $OutputPath + '\' + $UpdateName
        $NewPath = $OutputPath + '\' + $CTTSplitArray[$row,$col]

        # Rename the texture using Move-Item to the name found in the CTT file.
        Move-Item -LiteralPath $OldPath -Destination $NewPath -Force

        # Overwrite the name with the new texture name.
        $UpdateName = $CTTSplitArray[$row,$col]

        # Check to see if an alternate name was stored.
        if ($AltSplitArray[$row,$col] -ne $null)
        {
          # Create a path to the texture with the alternate name.
          $AltName = $AltSplitArray[$row,$col]
          $AltPath = $OutputPath + '\' + $AltName

          # Copy the texture using the new name.
          Copy-Item -LiteralPath $NewPath -Destination $AltPath -Force

          # Add the alternate texture to the name so it appears on the texture list.
          $UpdateName = $CTTSplitArray[$row,$col] + ' \ ' + $AltSplitArray[$row,$col]

          # Add a bonus texture to the counts.
          $BonusCount++
        }
      }
      # If adding back garbage pixels, do not update the texture list.
      if ((!$CTTFileLoaded) -or (!$SplitZeldaRestore))
      {
        # Add the texture to the texture list.
        TexList_AddString -TexEntry $UpdateName

        # When batching images, do not count the textures.
        if (!$SplitBatchImages)
        {
          # Update the number of textures to the amount that was counted.
          SplitTextures_UpdateProgress -Iteration ($Iteration + $BonusCount)
        }
      }
      # Increment the iteration.
      $Iteration++
    }
  }
}
#==============================================================================================================================================================================================
#  When all we really wanted to do is just split some fucking textures, call this function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_NormalOperations([string]$OutputName, [string]$OutputPath)
{
  # Get the image "CombineSelected" fed from the GUI, get its dimensions, and set up the size of the square.
  $ImageInfo = GetImageInfo -ImageFile $CombineSelected

  # If the user wanted to force the size of the segments.
  if (($SplitDefineBoundary) -and ($SplitBoundaryWidth -gt 0) -and ($SplitBoundaryHeight -gt 0))
  {
    # Set how the image will be divided.
    $DivideGeometry = '' + $SplitBoundaryWidth + 'x' + $SplitBoundaryHeight
  }
  # The segments will be calculated by diving the number of rows/columns by the width/height.
  else
  {
    # Check to see if a CTT file was loaded.
    if ($CTTFileLoaded)
    {
      # WORKAROUND: If a texture was defined with a CTT file, then use the dimensions of the first texture.
      if (($CTTSplitArray[1,1] -ne $null) -and ($CTTSplitArray[1,1] -like 'tex1'))
      {
        # Split on the underscore to grab the dimensions.
        $SplitUnderscore = $CTTSplitArray[1,1].Split('_')

        # Split the dimensions to get the width and height.
        $SplitX = $SplitUnderscore[1].Split('x')

        # If garbage pixels are being restored, calculate the dimensions.
        if ($SplitZeldaRestore)
        {
          # Subtract the number of garbage pixels from the dimensions. We need the values before they were multiplied by the upscaling factor.
          $SplitWidth  = [int]$SplitX[0] - ($SplitPixelRestoreL / $SplitInteger) - ($SplitPixelRestoreR / $SplitInteger)
          $SplitHeight = [int]$SplitX[1] - ($SplitPixelRestoreT / $SplitInteger) - ($SplitPixelRestoreB / $SplitInteger)
        }
        # Garbage is not being restored so use the dimensions directly.
        else
        {
          # Store them in integer variables.
          $SplitWidth  = [int]$SplitX[0]
          $SplitHeight = [int]$SplitX[1]
        }
        # Now multiply them by the upscale integer.
        $MultWidth  = $SplitWidth * $SplitInteger
        $MultHeight = $SplitHeight * $SplitInteger

        # Use these values for the geometry.
        $DivideGeometry = '' + $MultWidth + 'x' + $MultHeight
      }
      # This is a backup code path. I don't know if this is technically correct.
      else
      {
        # Calculate how the image will be divided.
        $DivideGeometry = '' + ($ImageInfo.Width / $TextureCols) + 'x' + ($ImageInfo.Height / $TextureRows)
      }
    }
    # Under normal circumstances, the size of the segments is determined by the number of row/columns.
    else
    {
      # Calculate how the image will be divided.
      $DivideGeometry = '' + ($ImageInfo.Width / $TextureCols) + 'x' + ($ImageInfo.Height / $TextureRows)
    }
  }
  # Create the file in the output path plus the IM "_%d" parameter to give each image a digit (0, 1, 2, etc).
  $OutputFile = $OutputPath + '\' + $OutputName + '_%d.png'

  # Divide the image up based on the calculated dimensions. This command creates multiple images. 
  Magick-Convert -ImageFile $CombineSelected -Arguments @('-define', 'png:color-type=6', '-crop', $DivideGeometry, '+repage', '-background', 'none') -OutputFile $OutputFile

  # Add the textures to the texture list and rename them if a CTT file is loaded.
  SplitTextures_FinalizeTextures -TextureName $OutputName -OutputPath $OutputPath
}
#==============================================================================================================================================================================================
#  The meat and potatoes that takes care of splitting a texture with overlapping pixels.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_AddOverlapPixels([string]$OutputName, [string]$OutputPath)
{
  # Gonna need some information about the image.
  $SplitInfo = GetImageInfo -ImageFile $CombineSelected

  # Calculate what the width and height should be without split pixels.
  $SplitCalcWidth  = $SplitInfo.Width + ($TextureCols * $SplitPixelOverlap) - $SplitPixelOverlap
  $SplitCalcHeight = $SplitInfo.Height + ($TextureRows * $SplitPixelOverlap) - $SplitPixelOverlap

  # Get the size of each segment.
  $SegmentSizeX = $SplitCalcWidth / $TextureCols
  $SegmentSizeY = $SplitCalcHeight / $TextureRows

  # Track iterations and the position of where to crop the next texture.
  $XPos = $YPos = $Iteration = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Count this iteration.
      $Iteration++

      # Set up the dimensions and location to crop out the segment.
      $CropGeometry = '' + $SegmentSizeX + "x" + $SegmentSizeY + "+" + $XPos + "+" + $YPos

      # If a CTT file was loaded, the split array is defined.
      switch ($CTTFileLoaded)
      {
        # If a CTT was used, restore the name. If it wasn't, name it from the main texture + the iteration.
        $true   { $CroppedFile = $OutputPath + '\' + $CTTSplitArray[$row,$col] }
        $false  { $CroppedFile = $OutputPath + '\' + $OutputName + '_' + $Iteration + $PNG }
      }
      # Crop the image from the combined texture.
      Magick-Convert -ImageFile $CombineSelected -Arguments @('-crop', $CropGeometry, '+repage', '-background', 'none') -OutputFile $CroppedFile

      # Add the texture to the texture list.
      TexList_AddString -TexEntry (Get-Item -LiteralPath $CroppedFile).Name

      # Update the number of textures to the amount that was counted.
      SplitTextures_UpdateProgress -Iteration $Iteration

      # Increment the X position.
      $XPos = ($XPos + $SegmentSizeX) - $SplitPixelOverlap
    }
    # Reset the X position and increment the Y position.
    $XPos = 0
    $YPos = ($YPos + $SegmentSizeY) - $SplitPixelOverlap
  }
}
#==============================================================================================================================================================================================
#  Gets the sizes and positions used when grabbing a row or column of edge pixels to duplicate.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_GetGarbageCoords([string]$Position, [int]$Width, [int]$Height)
{
  # Create a hashtable.
  $Coords = @{}

  # Use a switch to pick the correct values.
  switch ($Position)
  {
    # The top row.
    'Top'   {
              $Coords.Width  = $Width
              $Coords.Height = 1
              $Coords.XPos = 0
              $Coords.YPos = 0
              $Coords.Tile = '1x'
            }
    # The bottom row.
    'Bot'   {
              $Coords.Width  = $Width
              $Coords.Height = 1
              $Coords.XPos = 0
              $Coords.YPos = $Height - 1
              $Coords.Tile = '1x'
            }
    # The left columns.
    'Left'  {
              $Coords.Width  = 1
              $Coords.Height = $Height
              $Coords.XPos = 0
              $Coords.YPos = 0
              $Coords.Tile = 'x1'
            }
    # The right columns.
    'Right' {
              $Coords.Width  = 1
              $Coords.Height = $Height
              $Coords.XPos = $Width - 1
              $Coords.YPos = 0
              $Coords.Tile = 'x1'
            }
  }
  # Return the values.
  return $Coords
}
#==============================================================================================================================================================================================
#  Assembles the texture with the garbage pixels.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_AssembleGarbage([string]$GarbageTexture, [string]$Position, [int]$RestoreVar, [string]$TileMethod)
{
  # Build a list of textures.
  $MontageTextures = New-Object Collections.Generic.List[string]

  # For bottom and right positions, add the master texture first.
  if (($Position -eq 'Bot') -or ($Position -eq 'Right'))
  {
    # Add the master image to the list.
    $MontageTextures.Add($TempMasterFile) | Out-Null
  }
  # Loop to create the number of garbage rows specified.
  for ($i = 0 ; $i -lt $RestoreVar ; $i++)
  {
    # Add the argument including the garbage file to the list.
    $MontageTextures.Add($GarbageTexture) | Out-Null
  }
  # For left and top positions, add the master texture last.
  if (($Position -eq 'Left') -or ($Position -eq 'Top'))
  {
    # Add the master image to the list.
    $MontageTextures.Add($TempMasterFile) | Out-Null
  }
  # Start this texture as the main file to update.
  $global:TempMasterFile = $TempMasterPath + '\' + $SplitFile.BaseName + '_' + $Position + $PNG

  # Create the image by montaging all images in the texture array.
  Magick-Montage -Collection $MontageTextures -Arguments @('-tile', $TileMethod, '-geometry', '+0+0', '-background', 'none') -OutputFile $TempMasterFile
}
#==============================================================================================================================================================================================
#  This method of garbage pixel addition duplicates a row of pixels along the edge and copies to the number of rows/cols defined by the user.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_AddTextureGarbage([string]$Position, [int]$RestoreVar)
{
  # If no extra garbage pixels were defined, do not add them.
  if ($RestoreVar -eq 0) { return }

  # Get information on the image.
  $ImageInfo = GetImageInfo -ImageFile $TempMasterFile

  # Create a sub-folder to store these segments or shit will get messy.
  $GarbageSegmentPath = CreatePath -LiteralPath ($TempGarbagePath + '\SplitFile')
  $GarbageSegmentFile = $GarbageSegmentPath + '\' + $SplitFile.BaseName + '_garbage' + $PNG

  # Get the hashtable that holds calculated dimensions and positions of the segment.
  $Coords = SplitTextures_GetGarbageCoords -Position $Position -Width $ImageInfo.Width -Height $ImageInfo.Height

  # Set up the dimensions and location to crop out the segment.
  $CropGeometry = '' + $Coords.Width + "x" + $Coords.Height + "+" + $Coords.XPos + "+" + $Coords.YPos

  # Crop the garbage pixels from the texture.
  Magick-Convert -ImageFile $TempMasterFile -Arguments @('-crop', $CropGeometry, '+repage', '-background', 'none') -OutputFile $GarbageSegmentFile

  # WORKAROUND: A workaround for textures that have different numbers of garbage pixels (e.g. World Map in Zelda OoT and MM).
  if (($SplitFile.BaseName -like 'tex1*') -and ($Position -eq 'Bot'))
  {
    # Split the name to get the dimensions then split those too.
    $SplitName = $SplitFile.BaseName.Split('_')
    $SplitDims = $SplitName[1].Split('x')

    # Calculate the upscaled dimensions.
    $MultWidth  = [int]$SplitDims[0] * $SplitInteger
    $MultHeight = [int]$SplitDims[1] * $SplitInteger

    # Calculate the expected height of the image.
    $ExpectedHeight = $SplitPixelRestoreB + $ImageInfo.Height

    # The pixels should match. If they don't, we have a texture with differing amounts of garbage.
    if ($MultHeight -ne $ExpectedHeight)
    {
      # If they don't match, override the garbage pixel amount with the new value.
      $RestoreVar = $RestoreVar - ($ExpectedHeight - $MultHeight)
    }
  }
  # Add the texture and all garbage segments together.
  SplitTextures_AssembleGarbage -GarbageTexture $GarbageSegmentFile -Position $Position -RestoreVar $RestoreVar -TileMethod $Coords.Tile
}
#==============================================================================================================================================================================================
#  This is a special case to handle background textures in The Legend of Zelda: Ocarina of Time. When Link does a roll into the edge of the screen, there is a screen shake effect
#  that takes place. This dumps an additional (up to) six textures that can be cropped from the "combined" image. Handle generating those here.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_ZeldaGetScreenShakeProps([string]$Position, [int]$Width, [int]$Height)
{
  # Create a hashtable.
  $BonkProp = @{}

  # A switch is a nice and elegant way to programatically select specific information.
  switch ($Position)
  {
    # Top 01: 5 usable pixel rows, 3 rows of garbage, 1 pixel offset from top
    '1' {
          $BonkProp.Width    = $Width
          $BonkProp.Height   = 5 * $SplitInteger
          $BonkProp.GarbageX = 4 * $SplitInteger
          $BonkProp.GarbageY = 3 * $SplitInteger
          $BonkProp.XPos     = 0
          $BonkProp.YPos     = 1 * $SplitInteger
        }
    # Top 02: 4 usable pixel rows, 0 rows of garbage, 2 pixel offset from top
    '2' { 
          $BonkProp.Width    = $Width
          $BonkProp.Height   = 4 * $SplitInteger
          $BonkProp.GarbageX = 4 * $SplitInteger
          $BonkProp.GarbageY = 0
          $BonkProp.XPos     = 0
          $BonkProp.YPos     = 2 * $SplitInteger
        }
    # Top 03: 3 usable pixel rows, 1 row of garbage, 3 pixel offset from top
    '3' { 
          $BonkProp.Width    = $Width
          $BonkProp.Height   = 3 * $SplitInteger
          $BonkProp.GarbageX = 4 * $SplitInteger
          $BonkProp.GarbageY = 1 * $SplitInteger
          $BonkProp.XPos     = 0
          $BonkProp.YPos     = 3 * $SplitInteger
        }
    # Bot 01: 5 usable pixel rows, 3 rows of garbage, 6 pixel offset from bottom
    '4' {
          $BonkProp.Width    = $Width
          $BonkProp.Height   = 5 * $SplitInteger
          $BonkProp.GarbageX = 4 * $SplitInteger
          $BonkProp.GarbageY = 3 * $SplitInteger
          $BonkProp.XPos     = 0
          $BonkProp.YPos     = $Height - (6 * $SplitInteger)
        }
    # Bot 02: 4 usable pixel rows, 0 rows of garbage, 6 pixel offset from bottom
    '5' { 
          $BonkProp.Width    = $Width
          $BonkProp.Height   = 4 * $SplitInteger
          $BonkProp.GarbageX = 4 * $SplitInteger
          $BonkProp.GarbageY = 0
          $BonkProp.XPos     = 0
          $BonkProp.YPos     = $Height - (6 * $SplitInteger)
        }
    # Bot 03: 3 usable pixel rows, 0 rows of garbage, 6 pixel offset from bottom
    '6' { 
          $BonkProp.Width    = $Width
          $BonkProp.Height   = 3 * $SplitInteger
          $BonkProp.GarbageX = 4 * $SplitInteger
          $BonkProp.GarbageY = 1 * $SplitInteger
          $BonkProp.XPos     = 0
          $BonkProp.YPos     = $Height - (6 * $SplitInteger)
        }
  }
  # Return the properties of the current bonk texture.
  return $BonkProp
}
#==============================================================================================================================================================================================
#  This is a special case to handle background textures in The Legend of Zelda: Ocarina of Time. When Link does a roll into the edge of the screen, there is a screen shake effect
#  that takes place. This dumps an additional six textures that can be cropped from the "combined" image. Handle generating those here.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_ZeldaScreenShakeTextures([int]$Iteration)
{
  # Get information about the "CombineSelected" image most likely loaded from a CTT file.
  $ImageInfo = GetImageInfo -ImageFile $CombineSelected

  # Create sub-folders to store these segments or shit will get messy.
  $BonkTexturePath = CreatePath -LiteralPath ($TempFolder + '\BonkTextures')

  # Loop through the texures in the array.
  foreach ($BonkTex in $ZeldaSplitArray)
  {
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 00: CREATE INFORMATION
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
    
    # If this texture is skipped, continue the loop.
    if ($BonkTex -eq $null) { continue }

    # Split the line on the "=" sign.
    $BonkTexSplit = $BonkTex.Split('=')

    # The identifier determines whether its top or bottom texture.
    $Identifier  = $BonkTexSplit[0].Substring(2,1)
    $AnimsFrame  = [int]$BonkTexSplit[0].Substring(3,1)
    $BonkTexName = $BonkTexSplit[1]

    # If it's a bottom texture, add 3 to the determine the actual position in the array.
    if ($Identifier -eq 't') { $CurrentPhase = $AnimsFrame } else { $CurrentPhase = $AnimsFrame + 3 }

    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 01: CREATE INFORMATION
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Set up the path for both the base texture and the garbage pixel files.
    $BonkTextureFile = $BonkTexturePath + '\' + $BonkTexName.Replace($PNG,'') + '_texture' + $PNG
    $BonkInterimFile = $BonkTexturePath + '\' + $BonkTexName.Replace($PNG,'') + '_interim' + $PNG
    $BonkGarbBotFile = $BonkTexturePath + '\' + $BonkTexName.Replace($PNG,'') + '_garbbot' + $PNG
    $BonkGarbRigFile = $BonkTexturePath + '\' + $BonkTexName.Replace($PNG,'') + '_garbrig' + $PNG
    $BonkOutputPath  = CreatePath -LiteralPath ($OutputPath + '\Screen Shake\')
    $BonkOutputFile  = $OutputPath + '\Screen Shake\' + $BonkTexName

    # Start by getting the information about the current texture.
    $PhaseInfo = SplitTextures_ZeldaGetScreenShakeProps -Position $CurrentPhase -Width $ImageInfo.Width -Height $ImageInfo.Height

    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 02: CROP SCREEN SHAKE TEXTURE
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Set up the dimensions and location to crop out the segment.
    $CropGeometry = '' + $PhaseInfo.Width + "x" + $PhaseInfo.Height + "+" + $PhaseInfo.XPos + "+" + $PhaseInfo.YPos

    # Crop the texture out of the combined image.
    Magick-Convert -ImageFile $CombineSelected -Arguments @('-crop', $CropGeometry, '+repage', '-background', 'none') -OutputFile $BonkTextureFile

    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 03: CROP/COPY BOTTOM PIXEL ROW FROM TEXTURE
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Reuse this function to crop out a line of garbage pixels from the bottom.
    $Coords = SplitTextures_GetGarbageCoords -Position 'Bot' -Width $PhaseInfo.Width -Height $PhaseInfo.Height

    # Set up the dimensions and location to crop out the segment.
    $CropGeometry = '' + $Coords.Width + "x" + $Coords.Height + "+" + $Coords.XPos + "+" + $Coords.YPos

    # Crop the garbage pixels from the texture.
    Magick-Convert -ImageFile $BonkTextureFile -Arguments @('-crop', $CropGeometry, '+repage', '-background', 'none') -OutputFile $BonkGarbBotFile

    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 04: ADD BOTTOM GARBAGE BACK TO TEXTURE
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Builds a list of the texture plus all garbage pixels that will be added to the bottom.
    $MontageTextures = New-Object Collections.Generic.List[string]

    # Add the main image to the list.
    $MontageTextures.Add($BonkTextureFile) | Out-Null

    # Loop to create the number of garbage rows specified.
    for ($i = 0 ; $i -lt $PhaseInfo.GarbageY ; $i++)
    {
      # Add the argument including the garbage file to the list.
      $MontageTextures.Add($BonkGarbBotFile) | Out-Null
    }
    # Create the image by montaging all images in the texture array.
    Magick-Montage -Collection $MontageTextures -Arguments @('-tile', $Coords.Tile, '-geometry', '+0+0', '-background', 'none') -OutputFile $BonkInterimFile

    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 05: CROP/COPY RIGHT PIXEL ROW FROM TEXTURE
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Get the dimensions of the newly created image.
    $InterimInfo = GetImageInfo -ImageFile $BonkInterimFile

    # Reuse this function to crop out a line of garbage pixels from the right.
    $Coords = SplitTextures_GetGarbageCoords -Position 'Right' -Width $InterimInfo.Width -Height $InterimInfo.Height

    # Set up the dimensions and location to crop out the segment.
    $CropGeometry = '' + $Coords.Width + "x" + $Coords.Height + "+" + $Coords.XPos + "+" + $Coords.YPos

    # Crop the garbage pixels from the texture.
    Magick-Convert -ImageFile $BonkInterimFile -Arguments @('-crop', $CropGeometry, '+repage', '-background', 'none') -OutputFile $BonkGarbRigFile

    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 06: ADD RIGHT GARBAGE BACK TO TEXTURE
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Builds a list of the texture plus all garbage pixels that will be added to the right.
    $MontageTextures = New-Object Collections.Generic.List[string]

    # Add the main image to the list.
    $MontageTextures.Add($BonkInterimFile) | Out-Null

    # Loop to create the number of garbage rows specified.
    for ($i = 0 ; $i -lt $PhaseInfo.GarbageX ; $i++)
    {
      # Add the argument including the garbage file to the list.
      $MontageTextures.Add($BonkGarbRigFile) | Out-Null
    }
    # Create the image by montaging all images in the texture array.
    Magick-Montage -Collection $MontageTextures -Arguments @('-tile', $Coords.Tile, '-geometry', '+0+0', '-background', 'none') -OutputFile $BonkOutputFile
    
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # PART 07: UPDATE TEXTURE LIST
    #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Add the texture to the texture list.
    TexList_AddString -TexEntry $BonkTexName

    # When batching images, do not count the textures.
    if (!$SplitBatchImages)
    {
      # Update the number of textures to the amount that was counted.
      SplitTextures_UpdateProgress -Iteration $Iteration
    }
    # Continue counting the iterations from the previous function.
    $Iteration = $Iteration + 1
  }
}
#==============================================================================================================================================================================================
#  Adds in garbage pixels to textures that previously had them removed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_AddGarbagePixels([string]$OutputName, [string]$OutputPath)
{
  # Create the texture in a temporary path.
  $TempGarbagePath = CreatePath -LiteralPath ($TempFolder + '\AddGarbage')

  # Create a link to the "master path" which will have files that have work done them over and over until the end.
  $TempMasterPath = CreatePath -LiteralPath ($TempFolder + '\MasterFile')

  # Start with doing the normal split method.
  SplitTextures_NormalOperations -OutputName $OutputName -OutputPath $TempGarbagePath

  # Count the iterations.
  $Iteration = 1

  # Loop through all the results of the split textures.
  foreach ($SplitFile in EnumerateFiles -LiteralPath $TempGarbagePath)
  {
    # Get the file as an item to get the name.
    $SplitItem = Get-Item -LiteralPath $SplitFile
  
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }
  
    # Start this texture as the main file to update.
    $global:TempMasterFile = $TempMasterPath + '\' + $SplitItem.BaseName + $PNG

    # A starting point is needed so create a copy of the file.
    Copy-Item -LiteralPath $SplitFile -Destination $TempMasterFile -Force 

    # Add the duplicate pixels.
    SplitTextures_AddTextureGarbage -Position 'Top'   -RestoreVar $SplitPixelRestoreT
    SplitTextures_AddTextureGarbage -Position 'Bot'   -RestoreVar $SplitPixelRestoreB
    SplitTextures_AddTextureGarbage -Position 'Left'  -RestoreVar $SplitPixelRestoreL
    SplitTextures_AddTextureGarbage -Position 'Right' -RestoreVar $SplitPixelRestoreR

    # Add the texture to the texture list.
    TexList_AddString -TexEntry $SplitItem.Name

    # When batching images, do not count the textures.
    if (!$SplitBatchImages)
    {
      # Update the number of textures to the amount that was counted.
      SplitTextures_UpdateProgress -Iteration $Iteration
    }
    # Set the full path to where the final file will be created.
    $OutputFile = $OutputPath + '\' + $SplitItem.BaseName + $PNG

    # Move the resulting textures to the output folder.
    Move-Item -LiteralPath $TempMasterFile -Destination $OutputFile -Force 

    # Increment the iteration.
    $Iteration++
  }
  # If the combined image is a Zelda:OoT background that has "bonk" textures.
  if ($ZeldaSplitArray -ne $null)
  {
    # Run the function that attempts to generate them.
    SplitTextures_ZeldaScreenShakeTextures -Iteration $Iteration
  }
  # Remove the temporary folders that are no longer needed.
  RemovePath -LiteralPath $TempGarbagePath
  RemovePath -LiteralPath $TempMasterPath
}
#==============================================================================================================================================================================================
#  Make sure that a texture was selected to split.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTexturesVerify()
{
  # Make sure a texture has been selected.
  if (!(TestPath -LiteralPath $CombineSelected))
  {
    # If a texture or CTT file was not loaded, this variable will hold the following message.
    if ($CombineSelected -eq 'Select or drag and drop a texture to split into multiple textures...')
    {
      # Display an error message to the user.
      $Title   = 'CTT-PS Error'
      $Message = 'Error: A texture has not been selected to split!'
      ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 36) -OffsetY (DPISize 18) -Message $Message
    }
    # If the selected file, or the file loaded from a CTT file, does not exist.
    else
    {
      # Display an error message to the user.
      $Title   = 'CTT-PS Error'
      $Message = 'Error: Texture could not be found in the selected path!'
      ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 20) -OffsetY (DPISize 18) -Message $Message
    }
    # Run like hell.
    return $false
  }
  # Blast off!
  return $true
}
#==============================================================================================================================================================================================
#  Resets all texture arrays to null values when batch splitting textures so "ghost" data doesn't exist between runs.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResetTextureArrays()
{
  # These arrays are multi-dimensional so loop through all rows and columns.
  if ($TextureArray -ne $null)
  {
    for ($row = 0; $row -le [int]$TextureRows; $row++)
    {
      for ($col = 0; $col -le [int]$TextureCols; $col++)
      {
        $global:TextureArray[$row,$col]  = $null
        $global:CTTSplitArray[$row,$col] = $null
        $global:AltSplitArray[$row,$col] = $null
      }
    }
  }
  # Both of these arrays are identical in size.
  if ($ZeldaBonkArray -ne $null)
  {
    for ($i = 0; $i -lt $ZeldaBonkArray.Length ; $i++)
    {
      $global:ZeldaBonkArray[$i]  = $null
      $global:ZeldaSplitArray[$i] = $null
    }
  }
}
#==============================================================================================================================================================================================
#  Updates the Texture List and enables the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_Finish()
{
  # Only add this gap when running it on a single texture.
  if (!$SplitBatchImages) { TexList_AddString -TexEntry '' }

  # Report that the textures have been created.
  TexList_AddString -TexEntry ('Successfully split into ' + $SplitTextureCount + ' textures!')

  # Check to see if images are being batched.
  if ($SplitBatchImages)
  {
    # Add an extra blank line if running the batch operation.
    TexList_AddString -TexEntry ''

    # Clear all data from all arrays so future CTT files don't bug out.
    ResetTextureArrays
  }
  # If they are not, then we are done.
  else
  {
    # The fake master loop is now finished.
    $global:MasterLoopRunning = $false
    $TexListCancelButton.Enabled = $false

    # Stop the timer and destroy it now that the loop has finished.
    TexList_StopTimer -Destroy $true

    # Now that we are done enable the GUI.
    ToggleDialogStates -State $true

    # Show the main dialog and force it forward.
    ActivateDialog -Dialog $MainDialog

    # Clean the temporary path out.
    ClearPath -LiteralPath $TempFolder
  }
}
#==============================================================================================================================================================================================
#  Sets a global variable to say that a texture has been loaded into "split textures".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_DismissCTTFile()
{
  # Make sure the loaded texture exists.
  if (TestPath -LiteralPath $CombineSelected)
  {
    # Set the flag to say that a texture has been loaded.
    $global:CTTFileLoaded = $false

    # Reset the texture arrays in case anything was loaded.
    ResetTextureArrays

    # Clear the stored values that are no longer used when a CTT file is not loaded.
    $TexSegDimensions = $null
    $CTTSplitPixelOverlap = $null
    $CTTSplitPixelRestoreL = $null
    $CTTSplitPixelRestoreT = $null
    $CTTSplitPixelRestoreB = $null
    $CTTSplitPixelRestoreR = $null

    # Disable the button after it's been cleared.
    $SplitClearCTTButton.Enabled = $false
  }
}
#==============================================================================================================================================================================================
#  When a texture is loaded while a CTT is in memory, try to update the overlap and garbage pixels to match the new dimensions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextures_TryUpdateGarbageOverlap()
{
  # Check to see if a CTT file has been loaded.
  if ($CTTFileLoaded)
  {
    # Get info about the texture that was selected.
    $CombTexInfo = CreateTextureInfo -ImageFile $CombineSelected

    # Split both the dimensions from the (.ctt) file and the loaded textures dimensions.
    $SplitOriginal = $TexSegDimensions.Split('x')
    $SplitSelected = $CombTexInfo.Dimensions.Split('x')

    # Now we only need a single dimension to get scale so width will work.
    $OriginalWidth = [Convert]::ToInt32($SplitOriginal[0])
    $SelectedWidth = [Convert]::ToInt32($SplitSelected[0])

    # Determine the scaling value based on the texture.
    $ScalingValue = $SelectedWidth / $OriginalWidth

    # Calculate the new values.
    $global:SplitPixelOverlap  = $CTTSplitPixelOverlap * $ScalingValue
    $global:SplitPixelRestoreL = $CTTSplitPixelRestoreL * $ScalingValue
    $global:SplitPixelRestoreT = $CTTSplitPixelRestoreT * $ScalingValue
    $global:SplitPixelRestoreB = $CTTSplitPixelRestoreB * $ScalingValue
    $global:SplitPixelRestoreR = $CTTSplitPixelRestoreR * $ScalingValue

    # Update the Zelda GUI split values.
    $SplitOverlapNumBox.Value = $SplitPixelOverlap
    $SplitZeldaRestoreL.Value = $SplitPixelRestoreL
    $SplitZeldaRestoreT.Value = $SplitPixelRestoreT
    $SplitZeldaRestoreB.Value = $SplitPixelRestoreB
    $SplitZeldaRestoreR.Value = $SplitPixelRestoreR
  }
}
#==============================================================================================================================================================================================
#  Splits textures into multiple textures. The rows and columns are defined by the user, and the texture is split based on the values set. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTexturesMain()
{
  # If $SplitBatchImages is enabled, then the hash table will be null.
  if ($SplitBatchImages)
  {
    # Store the info in a name that makes more sense than "texture".
    $CTTInfo = $Texture

    # Load the CTTFile which should automatically fill out most properties.
    LoadCTTFile -CTTFile $CTTInfo.FullPath

    # Set the path to the output textures.
    $OutputName = (Get-Item -LiteralPath $CombineSelected).BaseName
    $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\SplitTextures' + $CTTInfo.Relative + '\')
  }
  # During normal operations, use the selected texture or CTT file.
  else
  {
    # Make sure that a texture was selected to split.
    if (!(SplitTexturesVerify)) { return }

    # Set the path to the texture.
    $OutputName = (Get-Item -LiteralPath $CombineSelected).BaseName
    $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\SplitTextures\' + $OutputName + $PNG)
    
    # Update the Texture List. Here the function used when combining textures can be recycled, but don't start the timer when batching.
    CombineTextures_PrepareTexList -Message ('Splitting: ' + $OutputName + $PNG)
  }
  # Keeps track of the total number of textures.
  $global:SplitTextureCount = 0

  # Check to see if a CTT file is loaded which uses a different method of counting.
  if ($CTTFileLoaded)
  {
    # Add the number of textures found in each array.
    foreach ($SplitTex in $CTTSplitArray)   { if (($SplitTex -ne $null) -and ($SplitTex -ne '')) { $SplitTextureCount++ } }
    foreach ($SplitTex in $AltSplitArray)   { if (($SplitTex -ne $null) -and ($SplitTex -ne '')) { $SplitTextureCount++ } }

    # Only count screenshake textures when garbage pixels are enabled.
    if ($SplitZeldaRestore) { foreach ($SplitTex in $ZeldaSplitArray) { if (($SplitTex -ne $null) -and ($SplitTex -ne '')) { $SplitTextureCount++ } } }
  }
  # Use the columns and rows to determine the counting.
  else
  {
    # The number of resulting textures will be the rows times the columns.
    $global:SplitTextureCount = $TextureRows * $TextureCols
  }
  # If a normal texture is loaded (image with no CTT file) or the user wanted to force the size of the segments.
  if ((!$CTTFileLoaded) -or (($SplitDefineBoundary) -and ($SplitBoundaryWidth -gt 0) -and ($SplitBoundaryHeight -gt 0)))
  {
    # I hacked this in here cause it was easier.
    SplitTextures_NormalOperations -OutputName $OutputName -OutputPath $OutputPath
  }
  # Run through the normal motions.
  else
  {
    # Check to see if overlap pixels should be added.
    if ($SplitOverlapEnable)
    {
      # When enabled add back overlapping pixels to each texture.
      SplitTextures_AddOverlapPixels -OutputName $OutputName -OutputPath $OutputPath
    }
    # If overlapping is disabled, check to see if garbage pixels should be added instead.
    else
    {
      # Check to see if the method to add garbage is enabled.
      switch ($SplitZeldaRestore)
      {
        # If true add garbage, if false do the normal method of splitting.
        $true   { SplitTextures_AddGarbagePixels -OutputName $OutputName -OutputPath $OutputPath }
        $false  { SplitTextures_NormalOperations -OutputName $OutputName -OutputPath $OutputPath }
      }
    }
  }
  # Do some GUI stuff just before exiting this function.
  SplitTextures_Finish

  # Always return false so the MasterLoop doesn't run.
  return $false
}
#==============================================================================================================================================================================================
#  OPERATION 18: ADD/REMOVE ARBITRARY MIPMAP SUFFIX
#==============================================================================================================================================================================================
#  Adds or removes the "_arb" suffix to mipmap textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddRemoveArbSuffix()
{
  # Dolphin mipmap texture club members ONLY.
  if ((!$Texture.IsMipmap) -or (!$Texture.Dolphin) -or ($Texture.IsIcon)) { TexList_SetTextureStatus -Status 'OK' ; return }

  # This will hold the new name to the texture. If it's not set below, the function will exit.
  $ArbRenameFile = ''

  # Switch between adding and removing the suffix from the name based on which option was selected.
  switch -wildcard ($ArbSuffixChoice)
  {
    # When adding the suffix to textures, it must not have the "_arb" flag.
    'Add*'  {
              # The texture must not have the arb suffix to pass.
              if (!$Texture.ArbMips)
              {
                # Modify the name to have the suffix.
                $ArbRenameFile = $Texture.PathName + '_arb' + $Texture.Extension

                # May as well set it up now.
                TexList_SetTextureStatus -Status (GetStatus) -Message 'Added Arbitrary Mipmap Suffix'
              }
            }
    # When removing the suffix from textures, it must have the "_arb" flag.    
    'Rem*'  {
              # The texture must have the arb suffix to pass.
              if ($Texture.ArbMips)
              {
                # Remove the suffix from the name.
                $ArbRenameFile = $Texture.PathName.Replace('_arb','') + $Texture.Extension

                # More crap.
                TexList_SetTextureStatus -Status (GetStatus) -Message 'Removed Arbitrary Mipmap Suffix'
              }
            }
  }
  # Use the file name as a way out of here if was not set.
  if ($ArbRenameFile -eq '') { return }

  # Calculate the number of mipmap levels the texture should have.
  $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($Texture.Width, $Texture.Height))

  # Count the number of available mipmaps before renaming.
  $MipmapsFound = CountExternalMipmaps -ImageFile $Texture.FullPath -Levels $MipmapLevels

  # Rename the file with move item because it works perfectly with PS v2.
  Move-Item -LiteralPath $Texture.FullPath -Destination $ArbRenameFile -Force

  # Check to see if external mipmaps exist.
  if ($MipmapsFound -gt 0)
  {
    # Create a mipmap hash table from the texture.
    $MipmapInfo = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

    # Loop through all mipmap levels.
    for ($i = 1; $i -le $MipmapsFound; $i++)
    {
      # Make sure the mipmap exists.
      if ($MipmapInfo.Exists[$i])
      {
        # Switch between adding and removing the suffix from the name based on which option was selected.
        switch -wildcard ($ArbSuffixChoice)
        {
          # Match the name up with the selected format. No need for checks or returns this time around.
          'Add*'  { $ArbRenameFile = $Texture.PathName + '_arb_mip' + $i + $Texture.Extension }
          'Rem*'  { $ArbRenameFile = $MipmapInfo.FullPath[$i].Replace('_arb','') }
        }
        # Rename the file with move item because it works perfectly with PS v2.
        Move-Item -LiteralPath $MipmapInfo.FullPath[$i] -Destination $ArbRenameFile -Force
      }
    }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 19: PNG ALPHA PIXEL MANIPULATION
#==============================================================================================================================================================================================
#  Sub-function of "ManipulateAlphaPixels". Manipulates the pixels of a texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AlphaPixelManipulate($RawData, [string]$TextureName, [string]$TexturePath)
{
  # Show me a message telling me it's starting.
  DebugMessage -Message 'Manipulating alpha pixel data for:' -FollowUp $TexturePath
  DebugMessage -Message ' '

  # Loop through each alpha Byte.
  for ($p = $RawData.Channels - 1 ; $p -lt $RawData.Bytes.Length ; $p += $RawData.Channels)
  {
    # Get the color positions of the pixel.
    $Red = $p - 1
    $Grn = $p - 2
    $Blu = $p - 3
    $Alp = $p

    # Get the color values of the pixel.
    $RValue = $RawData.Bytes[$Red]
    $GValue = $RawData.Bytes[$Grn]
    $BValue = $RawData.Bytes[$Blu]
    $AValue = $RawData.Bytes[$Alp]

    # The operation is determined by the user selected option.
    switch ($AlphaPixelMode)
    {
      # Convert Fully Transparent Color Pixels to Opaque
      0 {
          # Check to see if the pixel has color data and alpha is set to maximum transparency.
          if ((($RValue -ne 0) -or ($GValue -ne 0) -or ($BValue -ne 0)) -and ($AValue -eq 0))
          {
            # Remove alpha from the pixel.
            $RawData.Bytes[$Alp] = 255
          }
        }
      # Add Full Transparency and Keep Pixel Color Data
      1 {
          # Simply set all alpha values to zero across the entire image.
          $RawData.Bytes[$Alp] = 0
        }
      # Set Fully Transparent Black Pixels to White
      2 {
          # Check to see if the pixel is fully transparent with no color data.
          if (($RValue -eq 0) -and ($GValue -eq 0) -and ($BValue -eq 0) -and ($AValue -eq 0))
          {
            # Set all color values to max.
            $RawData.Bytes[$Red] = 255
            $RawData.Bytes[$Grn] = 255
            $RawData.Bytes[$Blu] = 255
          }
        }
      # Set Fully Transparent White Pixels to Black
      3 {
          # Search for white pixels that are fully transparent.
          if (($RValue -eq 255) -and ($GValue -eq 255) -and ($BValue -eq 255) -and ($AValue -eq 0))
          {
            # Set all color values to zero.
            $RawData.Bytes[$Red] = 0
            $RawData.Bytes[$Grn] = 0
            $RawData.Bytes[$Blu] = 0
          }
        }
      # Remove All Color Data From Fully Transparent Pixels
      4 {
          # Check to see if the pixel has color data but alpha is set to maximum transparency.
          if ((($RValue -ne 0) -or ($GValue -ne 0) -or ($BValue -ne 0)) -and ($AValue -eq 0))
          {
            # Set all color values to to zero.
            $RawData.Bytes[$Red] = 0
            $RawData.Bytes[$Grn] = 0
            $RawData.Bytes[$Blu] = 0
          }
        }
      # Customize Data For Transparent Pixels
      5 {
          # Set up the conditions to run the option.
          $ConditionA = (($AlphaSearch -eq 'No Color Data') -and ($RValue -eq 0) -and ($GValue -eq 0) -and ($BValue -eq 0) -and ($AValue -le $AlphaThreshold))
          $ConditionB = (($AlphaSearch -eq 'Allow Color Data') -and ($AValue -le $AlphaThreshold))

          # If either condition passes.
          if (($ConditionA) -or ($ConditionB))
          {
            # Set the custom values for the pixel.
            if ($BAlphaRed) { $RawData.Bytes[$Red] = $CAlphaRed }
            if ($BAlphaGrn) { $RawData.Bytes[$Grn] = $CAlphaGrn }
            if ($BAlphaBlu) { $RawData.Bytes[$Blu] = $CAlphaBlu }
            if ($BAlphaAlp) { $RawData.Bytes[$Alp] = $CAlphaAlp }
          }
        }
    }
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return $false }
    
    # Perform "DoEvents" so the dialog refreshes itself.
    [Windows.Forms.Application]::DoEvents()
  }
  # Create the texture in a temporary path.
  $TempExportPath = CreatePath -LiteralPath ($TempFolder + '\AlphaManipulated')
  $TempExportFile = $TempExportPath + '\' + $TextureName + $PNG

  # Write the texture using the updated raw pixel data.
  WritePixelDataToImage -PixelData $RawData -OutputFile $TempExportFile

  # Do not attempt to do anything with the image if it doesn't exist.
  if (TestPath -LiteralPath $TempExportFile)
  {
    # Show a message if the image was created.
    DebugMessage -Message "Alpha manipulated image successfully created." -FollowUp ' '

    # If the user just wants to write the texture in-place.
    if ($InPlaceAlphaPixel)
    {
      # Set the export path to the input texture path.
      $ExportFile = $TexturePath

      # Just to be safe, remove the original texture before replacing it with the new one.
      RemovePath -LiteralPath $TexturePath

      # Show me a message telling me it's starting.
      DebugMessage -Message "In-Place option enabled. Replacing the original image..." -FollowUp ' '
    }
    # The user wants to create the textures in the output folder.
    else
    {
      # Create the destination folder and the path to the final texture.
      $ExportPath = CreatePath -LiteralPath ($MasterOutputPath + '\AlphaManipulatedTextures' + $Texture.Relative)
      $ExportFile = $ExportPath + '\' + $TextureName + $PNG
      
      # Show me a message telling me it's starting.
      DebugMessage -Message "Moving the image to the output folder..." -FollowUp ' '
    }
    # Move the final texture to the destination.
    Move-Item -LiteralPath $TempExportFile -Destination $ExportFile -Force

    # Do one final test to make sure the image is there.
    if (TestPath -LiteralPath $ExportFile)
    {
      # Show me a message that will reduce my stress.
      DebugMessage -Message "Everything was successful." -FollowUp ' '
    }
    # If using the "Process Selected" menu, the output may overwrite the input.
    ProcessSelectedOutput -NewTexturePath $ExportFile -NewFormat $PNG -Width $Texture.Width -Height $Texture.Height
  }
  # The image failed to be created.
  else
  {
    # Show a message if the image was created.
    DebugMessage -Message "Alpha manipulated image failed to be created!" -FollowUp ' '
  }
  # Decimate the temporary folder.
  RemovePath -LiteralPath $TempExportPath
  
  # Return if the texture exists. Used to notify if it was created or not.
  return (TestPath -LiteralPath $ExportFile)
}
#==============================================================================================================================================================================================
#  Provides several options to modify alpha found within textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ManipulateAlphaPixels()
{
  # Test if its PNG and if not, exit the function.
  if ($Texture.Extension -ne $PNG) { TexList_SetTextureStatus -Status 'Not PNG' ; return }

  # Get the raw pixel data of the image.
  $RawData = GetRawImageData -ImageFile $Texture.FullPath

  # If there is no alpha channel, or it's a paletted image with less than 8bpp, leave now.
  if ((!$RawData.AlphaChannel) -or ($RawData.Channels -lt 4)) { TexList_SetTextureStatus -Status 'No Alpha Channel' ; return }

  # Check to see if the texture has mipmaps.
  if ($Texture.IsMipmap)
  {
    # Create a mipmap hash table.
    $Mipmap = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

    # Loop through all lower levels.
    for ($i=1; $i -le $Mipmap.Levels; $i++) 
    {
      # Make sure the current level exists.
      if ($Mipmap.Exists[$i])
      {
        # Get the raw pixel data of the image.
        $RawDataMipmap = GetRawImageData -ImageFile $Mipmap.FullPath[$i]

        # Apply alpha manipulation to the mipmap texture. Store the return value in a nonsense variable.
        $McDonalds = AlphaPixelManipulate -RawData $RawDataMipmap -TextureName $Mipmap.Name[$i] -TexturePath $Mipmap.FullPath[$i]
      }
    }
  }
  # Apply the alpha manipulation to the main texture. Checks to see if the texture was created.
  switch (AlphaPixelManipulate -RawData $RawData -TextureName $Texture.Name -TexturePath $Texture.FullPath)
  {
    # Report to the user if it failed or succeeded.
    $true  { TexList_SetTextureStatus -Status 'OK' -Message 'Alpha Pixels Successfully Modified' }
    $false { TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation' }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 20: SEPARATE/COMBINE TEXTURE RGBA CHANNELS - SPLIT TEXTURE
#==============================================================================================================================================================================================
#  Subfunction used to create a hashtable that is necessary to write images using the function "WritePixelDataToImage".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateRGBAChannelData([int]$Width, [int]$Height, [byte[]]$ChannelBytes, [string]$OutputName)
{
  # Set up pixel data for red image.
  $ChannelData          = @{}
  $ChannelData.Width    = $Width
  $ChannelData.Height   = $Height
  $ChannelData.Channels = 4
  $ChannelData.Bytes    = $ChannelBytes
  $ChannelData.Output   = $OutputPath + '\' + $OutputName + $Texture.Extension

  # Return the hash table.
  return $ChannelData
}
#==============================================================================================================================================================================================
#  Splits a texture into 3/4 separate images that contain only the data from the corresponding channel.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SplitTextureIntoChannelData()
{
  # Get the raw pixel data of the image.
  $RawData = GetRawImageData -ImageFile $Texture.FullPath

  # If there is no alpha channel, or it's a paletted image with less than 8bpp, leave now.
  if (!$RawData.Channels) { TexList_SetTextureStatus -Status 'Paletted Not Allowed' ; return }

  # If it's a channel identifier, exit the function.
  if ($Texture.Name -like '*_!R*') { TexList_SetTextureStatus -Status 'Channel Identifier' ; return }
  if ($Texture.Name -like '*_!G*') { TexList_SetTextureStatus -Status 'Channel Identifier' ; return }
  if ($Texture.Name -like '*_!B*') { TexList_SetTextureStatus -Status 'Channel Identifier' ; return }
  if ($Texture.Name -like '*_!A*') { TexList_SetTextureStatus -Status 'Channel Identifier' ; return }

  # Set the output path.
  $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\RGBAChannelsSplit' + $Texture.Relative)

  # If the image does not have an alpha channel, create a temporary version of the texture that has an alpha channel.
  if ($RawData.Channels -lt 4)
  {
    # Set up the temporary path.
    $TempPath = CreatePath -LiteralPath ($TempFolder + '\RGBA-AlphaTemp')
    $TempFile = $TempPath + '\' + $Texture.Name + $PNG

    # Create the PNG image with ImageMagick.
    Magick-Convert -ImageFile $Texture.FullPath -Arguments @('-define' , 'png:color-type=6') -OutputFile $TempFile

    # Replace the raw data with a version of the image that has an alpha channel.
    $RawData = GetRawImageData -ImageFile $TempFile
  }
  # Create empty arrays to hold the new pixel bytes.
  $RedArray = New-Object byte[] ($RawData.Height * $RawData.Stride)
  $GrnArray = New-Object byte[] ($RawData.Height * $RawData.Stride)
  $BluArray = New-Object byte[] ($RawData.Height * $RawData.Stride)
  $AlpArray = New-Object byte[] ($RawData.Height * $RawData.Stride)

  # Set the alpha for background pixels depending on the user's selection.
  if ($RGBABackGroundChoice -eq 'Black') { $UserAlphaValue = 255 } else { $UserAlphaValue = 0 }

  # Loop through each alpha Byte.
  for ($p = $RawData.Channels - 1 ; $p -lt $RawData.Bytes.Length ; $p += $RawData.Channels)
  {
    # Get the color positions of the pixel.
    $Red = $p - 1
    $Grn = $p - 2
    $Blu = $p - 3
    $Alp = $p

    # Set the color values of the pixel.
    $RValue = $RawData.Bytes[$Red]
    $GValue = $RawData.Bytes[$Grn]
    $BValue = $RawData.Bytes[$Blu]
    $AValue = $RawData.Bytes[$Alp]

    # Transfer the red value to the red array.
    $RedArray[$Red] = $RValue
    $RedArray[$Grn] = 0
    $RedArray[$Blu] = 0

    # Transfer the green value to the green array.
    $GrnArray[$Red] = 0
    $GrnArray[$Grn] = $GValue
    $GrnArray[$Blu] = 0

    # Transfer the blue value to the blue array.
    $BluArray[$Red] = 0
    $BluArray[$Grn] = 0
    $BluArray[$Blu] = $BValue

    # If the pixel has color data, make it fully opaque. If there is no data, the alpha value is set to the background choice.
    if ($RValue -eq 0) { $RedArray[$Alp] = $UserAlphaValue } else { $RedArray[$Alp] = $RawData.Bytes[$Alp] }
    if ($GValue -eq 0) { $GrnArray[$Alp] = $UserAlphaValue } else { $GrnArray[$Alp] = $RawData.Bytes[$Alp] }
    if ($BValue -eq 0) { $BluArray[$Alp] = $UserAlphaValue } else { $BluArray[$Alp] = $RawData.Bytes[$Alp] }

    # Check to see if the user wants to extract the alpha channel.
    if ($RGBAUtilizeAlpha)
    {
      # The alpha texture is a bit tricker, we want the colors to represent transparency rather than color. So black would mean fully transparent
      # while white means fully opaque. To do this, copy the alpha value in all channels except the alpha channel which will be 255 (or fully opaque).
      $AlpArray[$Red] = $AValue
      $AlpArray[$Grn] = $AValue
      $AlpArray[$Blu] = $AValue
      $AlpArray[$Alp] = 255
    }
    # Don't waste time if we don't have to.
    if ($CancelMasterLoop) { return }

    # Perform "DoEvents" so the dialog refreshes itself.
    [Windows.Forms.Application]::DoEvents()
  }
  # Create the necessary hashtables for each image so they can be written with my custom function.
  $RedPixelData = CreateRGBAChannelData -Width $RawData.Width -Height $RawData.Height -ChannelBytes $RedArray -OutputName ($Texture.Name + '_!R')
  $GrnPixelData = CreateRGBAChannelData -Width $RawData.Width -Height $RawData.Height -ChannelBytes $GrnArray -OutputName ($Texture.Name + '_!G')
  $BluPixelData = CreateRGBAChannelData -Width $RawData.Width -Height $RawData.Height -ChannelBytes $BluArray -OutputName ($Texture.Name + '_!B')

  # Write the new textures to images.
  WritePixelDataToImage -PixelData $RedPixelData -OutputFile $RedPixelData.Output
  WritePixelDataToImage -PixelData $GrnPixelData -OutputFile $GrnPixelData.Output
  WritePixelDataToImage -PixelData $BluPixelData -OutputFile $BluPixelData.Output

  # Check to see if the user wants to extract the alpha channel.
  if ($RGBAUtilizeAlpha)
  {
    # Only write the alpha channel if the user wants to keep it.
    $AlpPixelData = CreateRGBAChannelData -Width $RawData.Width -Height $RawData.Height -ChannelBytes $AlpArray -OutputName ($Texture.Name + '_!A')
    WritePixelDataToImage -PixelData $AlpPixelData -OutputFile $AlpPixelData.Output
  }
  # Update the texture status.
  TexList_SetTextureStatus -Status 'OK'

  # Dump the temp folder into the shredder.
  RemovePath -LiteralPath $TempPath
}
#==============================================================================================================================================================================================
#  OPERATION 20: SEPARATE/COMBINE TEXTURE RGBA CHANNELS - COMBINE TEXTURES
#==============================================================================================================================================================================================
#  Creates a temporary channel texture as RGBA to avoid RGB textures. Here for code deduplication.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateTempChannelTexture([string]$ColorFlag, [string]$InputTexture, [string]$OutputPath)
{
  # Set the output path of the temporary texture.
  $TempTexture = $OutputPath + '\' + $Texture.Name.Replace('_!R','') + $ColorFlag + $Texture.Extension

  # Create the texture as an RGBA.
  Magick-Convert -ImageFile $InputTexture -Arguments @('-define', 'png:color-type=6') -OutputFile $TempTexture

  # Return the path so it can be set to a variable.
  return $TempTexture
}
#==============================================================================================================================================================================================
#  Combines 3/4 channel textures into a single texture using the appropriate channel data from each.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineChannelDataIntoTexture()
{
  # Only use the red channel as an identifier.
  if ($Texture.Name -like '*_!G*') { TexList_SetTextureStatus -Status 'OK: Green' ; return }
  if ($Texture.Name -like '*_!B*') { TexList_SetTextureStatus -Status 'OK: Blue' ; return }
  if ($Texture.Name -like '*_!A*') { TexList_SetTextureStatus -Status 'OK: Alpha' ; return }

  # Only use the red channel as the main identifier.
  if ($Texture.Name -like '*_!R*')
  {
    # Set the path to the other channels to reference them and test if they exist.
    $RedPath = $Texture.FullPath
    $GrnPath = $Texture.PathName.Replace('_!R','') + '_!G' + $Texture.Extension
    $BluPath = $Texture.PathName.Replace('_!R','') + '_!B' + $Texture.Extension
    $AlpPath = $Texture.PathName.Replace('_!R','') + '_!A' + $Texture.Extension

    # In order to combine all channels, at least the green and the blue must exist with the red.
    if ((TestPath -LiteralPath $GrnPath) -and (TestPath -LiteralPath $BluPath))
    {
      # Set the output path.
      $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\RGBAChannelsCombined' + $Texture.Relative)

      # Set up the temporary path.
      $TempPath = CreatePath -LiteralPath ($TempFolder + '\RGBA-ChannelTemp')

      # Recreate each texture as a temporary texture to make sure it has 4 channels.
      $RedTempImg = CreateTempChannelTexture -ColorFlag '_!R' -InputTexture $RedPath -OutputPath $TempPath
      $GrnTempImg = CreateTempChannelTexture -ColorFlag '_!G' -InputTexture $GrnPath -OutputPath $TempPath
      $BluTempImg = CreateTempChannelTexture -ColorFlag '_!B' -InputTexture $BluPath -OutputPath $TempPath

      # Get the raw pixel data of the image.
      $RedRawData = GetRawImageData -ImageFile $RedTempImg
      $GrnRawData = GetRawImageData -ImageFile $GrnTempImg
      $BluRawData = GetRawImageData -ImageFile $BluTempImg

      # The result of whether or not all channels have equal dimensions. Used as a condition to create the final texture.
      $MergeCondition = ($RedRawData.Dimensions -eq $GrnRawData.Dimensions -eq $BluRawData.Dimensions)

      # Test to see if the alpha path exists.
      $AlpPathExists = TestPath -LiteralPath $AlpPath

      # Check if the user wants to use the alpha channel.
      if ($AlpPathExists)
      {
        # Now create the temporary alpha image and get its pixel data.
        $AlpTempImg = CreateTempChannelTexture -ColorFlag '_!A' -InputTexture $AlpPath -OutputPath $TempPath
        $AlpRawData = GetRawImageData -ImageFile $AlpTempImg

        # The same condition as above but toss in the alpha channel as well.
        $MergeCondition = ($RedRawData.Dimensions -eq $GrnRawData.Dimensions -eq $BluRawData.Dimensions -eq $AlpRawData.Dimensions)
      }
      # If the condition doesn't pass then leave now.
      if (!$MergeCondition) { RemovePath -Literalpath $TempPath ; TexList_SetTextureStatus -Status 'Failed' ; return }

      # Create an empty array to hold the new pixel bytes.
      $NewByteArray = New-Object byte[] ($RedRawData.Height * $RedRawData.Stride)

      # All arrays have the same size and channels so use the red as reference to loop through all arrays.
      for ($p = $RedRawData.Channels - 1 ; $p -lt $RedRawData.Bytes.Length ; $p += $RedRawData.Channels)
      {
        # Get the color positions of the pixel.
        $Red = $p - 1
        $Grn = $p - 2
        $Blu = $p - 3
        $Alp = $p

        # Transfer the values to the appropriate arrays.
        $NewByteArray[$Red] = $RedRawData.Bytes[$Red]
        $NewByteArray[$Grn] = $GrnRawData.Bytes[$Grn]
        $NewByteArray[$Blu] = $BluRawData.Bytes[$Blu]

        # If the alpha channel was used, grab the value from the red channel as all channels 
        # should  be equal. And if it's not used, then default the value as fully opaque.
        if ($AlpPathExists) { $NewByteArray[$Alp] = $AlpRawData.Bytes[$Red] } else { $NewByteArray[$Alp] = 255 }

        # Don't waste time if we don't have to.
        if ($CancelMasterLoop) { return }

        # Perform "DoEvents" so the dialog refreshes itself.
        [Windows.Forms.Application]::DoEvents()
      }
      # Set up the raw data for the newly combined image.
      $NewPixelData = CreateRGBAChannelData -Width $RedRawData.Width -Height $RedRawData.Height -ChannelBytes $NewByteArray -OutputName $Texture.Name.Replace('_!R','')

      # Write the texture using the updated raw pixel data.
      WritePixelDataToImage -PixelData $NewPixelData -OutputFile $NewPixelData.Output

      # Update the texture status.
      TexList_SetTextureStatus -Status 'OK: Combined'
      
      # Dump the temp folder into the shredder.
      RemovePath -LiteralPath $TempPath
    }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 20: SEPARATE/COMBINE TEXTURE RGBA CHANNELS
#==============================================================================================================================================================================================
#  Separates a texture into separate channels, or combines separate channels into a texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TextureToRGBAChannels()
{
  # Test if its PNG and if not, exit the function.
  if ($Texture.Extension -ne $PNG) { TexList_SetTextureStatus -Status 'Not PNG' ; return }

  # Run the selected operation.
  switch -wildcard ($RGBAChannelChoice)
  {
    # Split into Channels
    'Split*' { SplitTextureIntoChannelData }

    # Combine Channels  
    'Combi*' { CombineChannelDataIntoTexture }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 21: EXTRACT TRAILS OF COLD STEEL PKA FILES
#==============================================================================================================================================================================================
#  Creates some properties for ToCS 1/2 PKG file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePKAInfo([string]$InputFile)
{
  # Initialize the hash table.
  $PKAInfo = @{}

  # Get the input file as an object.
  $InputItem = Get-Item -LiteralPath $InputFile

  # Get the path to the file.
  $PKAInfo.Path = [string]$InputItem.Directory

  # Make sure it's actually a PKA file.
  if ($InputItem.Name -notlike '*.pka') { return $null }

  # Create strings referencing texture name/path data.
  $PKAInfo.Name      = $InputItem.BaseName
  $PKAInfo.FullName  = $InputItem.Name
  $PKAInfo.Extension = $InputItem.Extension
  $PKAInfo.PathName  = $PKAInfo.Path + '\' + $PKAInfo.Name
  $PKAInfo.FullPath  = $PKAInfo.Path + '\' + $PKAInfo.FullName
  $PKAInfo.Relative  = $PKAInfo.Path.Replace($MasterInputPath,'')

  # Return the hash table.
  return $PKAInfo
}
#==============================================================================================================================================================================================
#  Extracts a ToCS III/IV PKA file into the output directory.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractColdSteelPKA()
{
  # Store the info in a varname that makes sense.
  $PKAInfo = $Texture

  # Create the output path that the file will be extracted to.
  $ExtractPath = CreatePath -LiteralPath ($MasterOutputPath + '\PKA_Extracted' + $PKAInfo.Relative)

  # If the script for extracting CS3/CS4 PKA files doesn't exist then create it.
  if (!(TestPath -LiteralPath $PKAPyScript)) { Set-Content -LiteralPath $PKAPyScript -Value $PKAScriptContent }

  # If a specific file is to be extracted.
  if ($PhyrePKAType -like 'CS* Specific File')
  {
    # Get the PKG file that the user wants to extract.
    $ExtractPKGName = $ToCSPKASpecificCombo.SelectedItem
    $ExtractPKGFile = $ExtractPath + '\' + $ExtractPKGName

    # Extract the PKG from the PKA file using the python script by CeruleanSky.
    RunPythonScript -Script $PKAPyScript -Arguments @($PKAInfo.FullPath, $ExtractPKGName) -OutputPath $ExtractPath

    # Check to make sure the PKG folder exists.
    if (TestPath -LiteralPath $ExtractPKGFile)
    {
      # Report to the user if the file extracted correctly.
      TexList_SetTextureStatus -Status 'OK' -Message ('Successfully extracted: ' + $ExtractPKGName)

      # Set the path to a name without the ".pkg" in it.
      $RenamePath = $ExtractPKGFile.Replace('.pkg','')

      # Rename the folder to not have the ".pkg" part.
      Move-Item -LiteralPath $ExtractPKGFile -Destination $RenamePath
    }
    # Also report if the file failed.
    else { TexList_SetTextureStatus -Status 'Failed' -Message ('Failed to extract "' + $ExtractPKGName + '" from archive.') }
  }
  # If the user wanted to extract all PKG files from the PKA archive.
  else
  {
    # Run the python script by CeruleanSky.
    RunPythonScript -Script $PKAPyScript -Arguments @($PKAInfo.FullPath) -OutputPath $ExtractPath

    # Now that all the folders have been extracted loop through them.
    foreach ($PKGFolder in EnumerateFolders -LiteralPath $ExtractPath)
    {
      # Get the name of the PKG Folder.
      $PKGFolderName = (Get-Item -LiteralPath $PKGFolder).BaseName

      # Make sure we have a folder that has ".pkg" in the name.
      if ($PKGFolderName -like '*.pkg')
      {
        # Set the path to a name without the ".pkg" in it.
        $RenamePath = $ExtractPath + '\' + $PKGFolderName.Replace('.pkg','')

        # Rename the folder to not have the ".pkg" part.
        Move-Item -LiteralPath $PKGFolder -Destination $RenamePath
      }
    }
    # Check to make sure the extracted folder actually contains files.
    if ((EnumerateFiles -LiteralPath $ExtractPath -Recurse).Count -gt 0)
    {
      # Report to the user if the file extracted correctly.
      TexList_SetTextureStatus -Status 'OK' -Message ('Successfully extracted: ' + $PKAInfo.FullName) 
    }
    # Also report if the file failed.
    else { TexList_SetTextureStatus -Status 'Failed' -Message ('Failed to extract files from "' + $PKAInfo.FullName + '" archive.') }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 22: EXTRACT TRAILS OF COLD STEEL PKG FILES
#==============================================================================================================================================================================================
#  Creates some properties for ToCS 1/2 PKG file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePKGInfo([string]$InputFile)
{
  # Initialize the hash table.
  $PKGInfo = @{}

  # Get the input file as an object.
  $InputItem = Get-Item -LiteralPath $InputFile

  # Get the path to the texture.
  $PKGInfo.Path = [string]$InputItem.Directory

  # Make sure it's actually a PKG file.
  if ($InputItem.Name -notlike '*.pkg') { return $null }

  # Create strings referencing texture name/path data.
  $PKGInfo.Name      = $InputItem.BaseName
  $PKGInfo.FullName  = $InputItem.Name
  $PKGInfo.Extension = $InputItem.Extension
  $PKGInfo.PathName  = $PKGInfo.Path + '\' + $PKGInfo.Name
  $PKGInfo.FullPath  = $PKGInfo.Path + '\' + $PKGInfo.FullName
  $PKGInfo.Relative  = $PKGInfo.Path.Replace($MasterInputPath,'')

  # Return the hash table.
  return $PKGInfo
}
#==============================================================================================================================================================================================
#  Extracts a PKG file into the output directory.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractColdSteelPKG([string]$InputFile='', [string]$ExtractPath)
{
  # If the script for extracting CS3/CS4 PKG files doesn't exist then create it.
  if (!(TestPath -LiteralPath $PKGPyScript)) { Set-Content -LiteralPath $PKGPyScript -Value $PKGScriptContent }

  # If an input file was not provided, this function was called from the master loop so use the global "Texture" hash table.
  if ($InputFile -eq '')
  {
    # If there is data in the texture hash table, then use this.
    $PKGInfo = $Texture
    $Extract = CreatePath -LiteralPath ($MasterOutputPath + '\PKG_Extracted' + $PKGInfo.Relative)
  }
  # This can also function as a stand-alone function if an input file is provided.
  else
  {
    # Create a PKG hash table using the input file as a source.
    $PKGInfo = CreatePKGInfo -InputFile $InputFile
    $Extract = CreatePath -LiteralPath $ExtractPath
  }
  # The destination path of the extracted files.
  $OutputPath = $Extract + '\' + $PKGInfo.Name

  # Errors will happen if the output path already exists in the output folder so remove the contents before moving the new files.
  RemovePath -LiteralPath $OutputPath

  # Get the file as a byte array. The 85th byte is used to determine the type of PKG file.
  $ByteArray = [IO.File]::ReadAllBytes($PKGInfo.FullPath)

  # Cold Steel 1 and 2 compression (LZ77). The 85th byte is always a "1". If it's a "0" then it is uncompressed, but Kiseki PKG Sharp can handle that too.
  if ($ByteArray[84] -le 1)
  {
    # Attempt to extract the contents. This should succeed if it's a CS1 or CS2 PKG file.
    RunPKGTool -PKGFile $PKGInfo.FullPath | Out-Null

    # The PKG Tool by Sewer56 creates some junk so attempt to remove it.
    RemovePath -LiteralPath ($OutputPath + '\Start_Header.bin')

    # Move the extracted contents to the destination path.
    Move-Item -LiteralPath $PKGInfo.PathName -Destination $Extract -Force

    # Only do reporting if the input file was not specified.
    if ($InputFile -ne '') { return }

    # Check to see if there are files in the extracted folder (meaning extraction succeeded).
    if ((EnumerateFiles -LiteralPath $OutputPath -Recurse).Count -gt 0)
    {
      # Report to the user if the PKG file extracted correctly.
      TexList_SetTextureStatus -Status 'OK' -Message ('Successfully extracted: ' + $PKGInfo.FullName) 
    }
    # Also report if it failed to be extracted.
    else
    {
      # Remove the folder since it only contains garbage.
      RemovePath -LiteralPath $OutputPath

      # If it was sewer56's tool that failed, suggest thesupersonic16's PKG tool.
      if ($PhyrePKGTool -like '*.dll') { TexList_SetTextureStatus -Status 'Failed' -Message ('Failed extraction. Make sure .NET Core 2.0-2.6 is installed, or try the tool by thesupersonic16.') }

      # If it was thesupersonic16's tool that failed, there isn't much other advice to offer since it's generally less feature rich than the other.
      else { TexList_SetTextureStatus -Status 'Failed' -Message ('Failed to extract PKG archive contents.') }
    }
  }
  # Cold Steel 3 and 4 compression (LZ4). The 85th byte is always a "4".
  elseif ($ByteArray[84] -eq 4)
  {
    # But since it never ran, the folder was never created, so create it now.
    CreatePath -LiteralPath $PKGInfo.PathName -NoReturn
    
    # If python is installed we can attempt to use the python script.
    if (TestPath -LiteralPath $Python)
    {
      # Run the python script which attempts to extract a CS3 PKG file.
      RunPythonScript -Script $PKGPyScript -Arguments @($PKGInfo.FullPath) -OutputPath $PKGInfo.PathName
    }
    # If python is not installed alert the user.
    else
    {
      # Not the best explanation but I don't have much space to work with.
      TexList_SetTextureStatus -Status 'Failed' -Message 'Trying to extract CS3/CS4 PKG file? Install Python and try again.'
    }
    # Move the extracted contents to the destination path.
    Move-Item -LiteralPath $PKGInfo.PathName -Destination $Extract -Force

    # Check to see if there is more than a single file in the extracted folder (meaning extraction succeeded). The python script can only extract "assets.pka" from CS1/CS2 PKG files.
    if ((EnumerateFiles -LiteralPath $OutputPath -Recurse).Count -gt 1)
    {
      # Report to the user if the PKG file extracted correctly.
      TexList_SetTextureStatus -Status 'OK' -Message ('Successfully extracted: ' + $PKGInfo.FullName) 
    }
    # Also report if it failed to be extracted.
    else
    {
      # Remove the folder since it only contains garbage.
      RemovePath -LiteralPath $OutputPath
    
      # Let the user know that something went wrong.
      TexList_SetTextureStatus -Status 'Failed' -Message ('Failed to extract PKG archive contents.')
    }
  }
}
#==============================================================================================================================================================================================
#  LEGEND OF HEROES: TRAILS OF COLD STEEL - FUNCTIONS
#==============================================================================================================================================================================================
#  A list of all values stored in the hash table created by "CreatePhyreInfo". 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $PhyreInfo.Name
#  $PhyreInfo.FullName
#  $PhyreInfo.RealName
#  $PhyreInfo.Extension
#  $PhyreInfo.Path
#  $PhyreInfo.PathName
#  $PhyreInfo.FullPath
#  $PhyreInfo.RealPath
#  $PhyreInfo.Relative
#  $PhyreInfo.Width
#  $PhyreInfo.Height
#  $PhyreInfo.Dimensions
#  $PhyreInfo.Aspect
#  $PhyreInfo.Mipmaps
#  $PhyreInfo.Format
#  $PhyreInfo.HeaderLength
#  $PhyreInfo.HeaderArray
#  $PhyreInfo.PixelArray
#  $PhyreInfo.FilePath
#  $PhyreInfo.FilePathOffset
#  $PhyreInfo.WidthOffset 
#  $PhyreInfo.HeightOffset 
#  $PhyreInfo.MipmapOffset 
#  $PhyreInfo.FormatOffset 
#  $PhyreInfo.PNGExtraOffset
#  $PhyreInfo.DDSExtraOffset
#  $PhyreInfo.FormatFlagOffset
#  $PhyreInfo.ColdSteel
#==============================================================================================================================================================================================
#  This is where the magic of reverse engineering happens. Gets all the necessary information from a ToCS phyre engine texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePhyreInfo([string]$InputFile)
{
  # Initialize the texture hash table.
  $PhyreInfo = @{}

  # Get the file as an object to extract properties from it.
  $InputItem = Get-Item -LiteralPath $InputFile

  # Get the path to the texture.
  $PhyreInfo.Path = [string]$InputItem.Directory

  #===================================================================================================================
  # VERIFY IT'S AN IMAGE FILE
  #===================================================================================================================
  # Make sure it's actually a phyre image or header.
  if (($InputItem.Name -notlike '*.phyre') -and ($InputItem.Name -notlike '*.header')) { return $null }

  # Get the real extension of the texture and not the .phyre extension.
  if ($InputItem.Name -like '*.png*') { $PhyreInfo.Extension = '.png' }
  if ($InputItem.Name -like '*.dds*') { $PhyreInfo.Extension = '.dds' }
  if ($InputItem.Name -like '*.bmp*') { $PhyreInfo.Extension = '.bmp' }

  # If it is a header generated by this script.
  if (!$PhyreInfo.Extension) { $PhyreInfo.Extension = '.header' }

  #===================================================================================================================
  # IMAGE PROPERTIES
  #===================================================================================================================
  # Get the real properties including the .phyre extension. 
  $PhyreInfo.RealName  = $InputItem.Name
  $PhyreInfo.RealPath  = $PhyreInfo.Path + '\' + $PhyreInfo.RealName
  $PhyreInfo.Relative  = $PhyreInfo.Path.Replace($MasterInputPath,'')

  # Get properties from the texture. These properties would be the converted result without .phyre.
  $PhyreInfo.Name      = $InputItem.BaseName.Replace($PhyreInfo.Extension, '')
  $PhyreInfo.FullName  = $PhyreInfo.Name + $PhyreInfo.Extension
  $PhyreInfo.PathName  = $PhyreInfo.Path + '\' + $PhyreInfo.Name
  $PhyreInfo.FullPath  = $PhyreInfo.Path + '\' + $PhyreInfo.FullName

  #===================================================================================================================
  # PHYRE TEXTURE TYPE
  #===================================================================================================================
  # Create a byte array from the image to pull the byte values.
  $ByteArray = [IO.File]::ReadAllBytes($PhyreInfo.RealPath)

  # Use the value found in byte 2391 to find out what kind of texture it is.
  switch ($ByteArray[2391])
  {
    # Save the version of the game the texture comes from. CS3 and CS4 share "3".
    '112'   { $PhyreInfo.ColdSteel = 1 }
    '116'   { $PhyreInfo.ColdSteel = 2 }
    '22'    { $PhyreInfo.ColdSteel = 3 }
    default { $PhyreInfo.ColdSteel = 0 }
  }
  #===================================================================================================================
  # VERIFY IT'S A PHYRE TEXTURE / HEADER
  #===================================================================================================================
  # Do a search for PTexture2D to verify that this is indeed a texture.
  $PTexture2D = ''

  # TODO: This is a mess. I need to find a better way to find where PTexture2D is and if it exists.
  if ($ByteArray.Count -lt 2644) { $EndPoint = $ByteArray.Length - 1 } else { $EndPoint = 2644 }

  # It will be somewhere within this range.
  for ($i = 2466 ; $i -le $EndPoint ; $i++)
  {
    # I don't convert the entire byte array to a string because it would be inefficient.
    $Letter = [BitConverter]::ToString($ByteArray[$i])
    $Letter = [char][byte]([Convert]::ToInt16($Letter, 16))
    $PTexture2D += $Letter.ToString()
  }
  # If it's not a texture then leave now and return nothing.
  if ($PTexture2D -notlike '*PTexture2D*') { return $null }

  #===================================================================================================================
  # INTERNAL IMAGE PATH
  #===================================================================================================================
  # The image path starts at a different offset depending on the game.
  switch ($PhyreInfo.ColdSteel)
  {
    # Image path ALWAYS starts at Byte[2459] for CS1/CS2, and Byte[2423] for CS3/CS4.
    '1' { $PhyreInfo.FilePathOffset = $Offset = 2459 }
    '2' { $PhyreInfo.FilePathOffset = $Offset = 2459 }
    '3' { $PhyreInfo.FilePathOffset = $Offset = 2423 }
  }
  # Default the path to an empty string.
  $PhyreInfo.FilePath = ''

  # Continue to loop until the file extension is found.
  while(($PhyreInfo.FilePath -notlike '*.png') -and ($PhyreInfo.FilePath -notlike '*.dds') -and ($PhyreInfo.FilePath -notlike '*.bmp'))
  {
    # Update the offset to find the exact byte the the file name ends.
    $Letter = [BitConverter]::ToString($ByteArray[$Offset])
    $Letter = [char][byte]([Convert]::ToInt16($Letter, 16))

    # When the loop ends, this will contain the entire path in the header.
    [string]$PhyreInfo.FilePath += $Letter.ToString()
    $Offset += 1

    # Fix entering an infinite loop if the path cannot be found.
    if ($Offset -gt $EndPoint) { return $null }
  }
  #===================================================================================================================
  # GET THE MASTER OFFSET
  #===================================================================================================================
  # Continue to loop and update the offset until "PTexture" is found in the translated hex string.
  $PTexSearch = ''

  # When the loop is done, $Offset will contain the value we need to get the rest of the data. Find the phrase "PTexture2D" then 
  # subtract 10 from it, which will give us the exact byte that PTexture2D starts on.
  while($PTexSearch -notlike '*PTexture2D*')
  {
    # While I could have chosen any byte from this point to use as an offset, the start of PTexture2D seemed like a good spot.
    $Letter = [BitConverter]::ToString($ByteArray[$Offset])
    $Letter = [char][byte]([Convert]::ToInt16($Letter, 16))
    [string]$PTexSearch += $Letter.ToString()
    $Offset += 1
  }
  # Set the offset to directly where PTexture2D starts.
  $Offset -= 10

  #===================================================================================================================
  # WIDTH / HEIGHT / MIPMAPS
  #===================================================================================================================
  # Depending on which game the texture came from, the offets are different.
  switch ($PhyreInfo.ColdSteel)
  {
    # CS1 textures have 112 bytes between the path and image format, found at offset 957 (and also 95B).
    '1'
    {
      # General information.
      $PhyreInfo.WidthOffset  = $W = $Offset - 84
      $PhyreInfo.HeightOffset = $H = $Offset - 80
      $PhyreInfo.MipmapOffset = $M = $Offset - 96

      # The PNG extra offset is always 2 in PNG files and 0 in DDS files. The DDS extra offset is always 0 in PNG files and the mipmap value in DDS files.
      $PhyreInfo.PNGExtraOffset = $Offset - 92
      $PhyreInfo.DDSExtraOffset = $Offset - 100
    }
    # CS2 textures are four bytes longer than CS1 headers, found at offset 957 (and also 95B).
    '2'
    {
      # General information.
      $PhyreInfo.WidthOffset  = $W = $Offset - 88
      $PhyreInfo.HeightOffset = $H = $Offset - 84
      $PhyreInfo.MipmapOffset = $M = $Offset - 100

      # The PNG extra offset is always 2 in PNG files and 0 in DDS files. The DDS extra offset is always 0 in PNG files and the mipmap value in DDS files.
      $PhyreInfo.PNGExtraOffset = $Offset - 96
      $PhyreInfo.DDSExtraOffset = $Offset - 104
    }
    # The values found for CS3/CS4 textures is much smaller than the previous two.
    '3'
    {
      # General information.
      $PhyreInfo.WidthOffset  = $W = $Offset - 8
      $PhyreInfo.HeightOffset = $H = $Offset - 4
      $PhyreInfo.MipmapOffset = $M = $Offset - 16

      # These have no effect for CS3/CS4 textures so zero them out.
      $PhyreInfo.PNGExtraOffset = 0
      $PhyreInfo.DDSExtraOffset = 0
    }
  }
  # Get the range of bytes that hold the width and height.
  $WidthArray  = $ByteArray[$W..($W+3)]
  $HeightArray = $ByteArray[$H..($H+3)]

  # Convert each byte to a string and add them together.
  foreach ($WByte in $WidthArray)  { $Width  += [BitConverter]::ToString($WByte) }
  foreach ($HByte in $HeightArray) { $Height += [BitConverter]::ToString($HByte) }

  # This creates a string contiguously storing the bytes, but the endian needs to be reversed.
  $Width  = FlipEndian -ByteChain $Width  
  $Height = FlipEndian -ByteChain $Height  

  # Finally the bytes need to be converted to integer format. 
  $PhyreInfo.Width  = [Convert]::ToInt32($Width,16)
  $PhyreInfo.Height = [Convert]::ToInt32($Height,16)

  # Grab the mipmaps value while were in the general area.
  $Mipmaps = [BitConverter]::ToString($ByteArray[$M])
  $PhyreInfo.Mipmaps = [Convert]::ToInt32($Mipmaps,16)

  #===================================================================================================================
  # IMAGE FORMAT
  #===================================================================================================================
  # The start of the format will be 11 bytes past the offset (after "PTexture2D.").
  $PhyreInfo.FormatOffset = $F = $Offset + 11

  # There will always be a 0 after the format. This "CheckValue" is a trigger for when 0 is found to end the loop.
  $CheckValue = $ByteArray[$F]

  # The first byte after the format will always be zero, so loop until "0" is found.
  while($CheckValue -ne 0)
  {
    # Loop until zero is found. Translate each byte into a string to get the format.
    $PhyreInfo.Format += [char][byte]([Convert]::ToInt16(([BitConverter]::ToString($ByteArray[$F])), 16))

    # Move on to the next byte value.
    $F++

    # Update the check to trigger when 0 is hit.
    $CheckValue = $ByteArray[$F]
  }
  # Store where the format ends in a name I can read. This will be used to reference further byte positions.
  $FormatEndByte = $F

  # Special Byte: Located 18 bytes after the format. Not sure what it represents, but I know it is different depending on the format.
  $PhyreInfo.FormatFlagOffset = $FormatEndByte + 17

  #===================================================================================================================
  # SHIT THAT CTT-PS WANTS IN OTHER PARTS OF THE SCRIPT
  #===================================================================================================================
  # Get this stuff just because the normal functionality of the script wants it.
  $PhyreInfo.Dimensions = $PhyreInfo.Width.ToString() + 'x' + $PhyreInfo.Height.ToString()
  $PhyreInfo.Aspect     = CalculateAspectRatio -Width $PhyreInfo.Width -Height $PhyreInfo.Height

  #===================================================================================================================
  # STORE HEADER/PIXEL DATA INTO BYTE ARRAYS
  #===================================================================================================================
  # If it's a texture and not a header, store both the header and pixel bytes into arrays.
  if ($PhyreInfo.Extension -ne '.header')
  {
    # The pixel data will always start 38 bytes after the format.
    $PixelsStart = $FormatEndByte + 38
    $PixelLength = $ByteArray.Length - $PixelsStart
    $PhyreInfo.PixelArray = New-Object Byte[] $PixelLength
    [Array]::Copy($ByteArray, $PixelsStart, $PhyreInfo.PixelArray, 0, $PixelLength)

    # Grab the header as well.
    $PhyreInfo.HeaderLength = $ByteArray.Length - $PhyreInfo.PixelArray.Length
    $PhyreInfo.HeaderArray = New-Object Byte[] $PhyreInfo.HeaderLength
    [Array]::Copy($ByteArray, 0, $PhyreInfo.HeaderArray, 0, $PhyreInfo.HeaderLength)
  }
  # If it's just a header, then just grab the total size of the array.
  else
  {
    $PhyreInfo.HeaderLength = $ByteArray.Length
    $PhyreInfo.HeaderArray  = $ByteArray
  }
  #===================================================================================================================
  # DEBUG MESSAGES
  #===================================================================================================================
  # Just in case. I'll probably have to end up returning here later.
  DebugMessage -Message ''
  DebugMessage -Message ('Deciphered properties of ' + $PhyreInfo.RealName)
  DebugMessage -Message ('Width      : ' + $PhyreInfo.Width)
  DebugMessage -Message ('Height     : ' + $PhyreInfo.Height)
  DebugMessage -Message ('Dimensions : ' + $PhyreInfo.Dimensions)
  DebugMessage -Message ('Aspect     : ' + $PhyreInfo.Aspect)
  DebugMessage -Message ('Format     : ' + $PhyreInfo.Format)
  DebugMessage -Message ('Mipmaps    : ' + $PhyreInfo.Mipmaps)
  DebugMessage -Message ('PNG Extra  : ' + $ByteArray[$PhyreInfo.PNGExtraOffset])
  DebugMessage -Message ('DDS Extra  : ' + $ByteArray[$PhyreInfo.DDSExtraOffset])
  DebugMessage -Message ('Special    : ' + $ByteArray[$PhyreInfo.FormatFlagOffset])
  DebugMessage -Message ''

  # Return the hash table.
  return $PhyreInfo
}
#==============================================================================================================================================================================================
#  OPERATION 23: CONVERT PHYRE TEXTURES TO PNG TEXTURES
#==============================================================================================================================================================================================
#  Sub-function of "Convert Phyre Textures" to convert a "png.phyre" or "bmp.phyre" to a standard PNG image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ConvertPNGPhyreToPNG([hashtable]$PhyreInfo, [string]$OutputPath)
{
  # The function to write pixel data expects a hash table.
  $PixelData          = @{}
  $PixelData.Width    = $PhyreInfo.Width
  $PixelData.Height   = $PhyreInfo.Height
  $PixelData.Channels = 4
  $PixelData.Bytes    = $PhyreInfo.PixelArray

  # The full path to where the new texture will be created.
  $OutputFile = $OutputPath + '\' + $PhyreInfo.Name + $PNG

  # Write the raw pixel data to an image. Both PNG and BMP phyre images are just raw pixel data.
  WritePixelDataToImage -PixelData $PixelData -OutputFile $OutputFile

  # The red and blue channels are reversed in RGBA so swap them with ImageMagick.
  if (($PhyreInfo.Format -eq 'RGBA8') -or ($PhyreSwizzle))
  {
    # Build a list of default arguments.
    $ArgumentList = New-Object Collections.Generic.List[string]

    # Build the arguments list if its an RGBA texture.
    if ($PhyreInfo.Format -eq 'RGBA8')
    {
      # This flips the red and blue channels since they are reversed.
      $ArgumentList.Add('-define') | Out-Null
      $ArgumentList.Add('png:color-type=6') | Out-Null
      $ArgumentList.Add('-separate') | Out-Null
      $ArgumentList.Add('-swap') | Out-Null
      $ArgumentList.Add('0,2') | Out-Null
      $ArgumentList.Add('-combine') | Out-Null
    }
    # Also add the argument to flip the texture if its to be unswizzled.
    if ($PhyreSwizzle)
    {
      # Imitates unswizzling the texture.
      $ArgumentList.Add('-flip') | Out-Null
    }
    # Recreate the texture with the required arguments.
    Magick-Convert -ImageFile $OutputFile -Arguments $ArgumentList -OutputFile $OutputFile
  }
}
#==============================================================================================================================================================================================
#  Sub-function of "Convert Phyre Textures" to convert a dds.phyre to a standard PNG image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ConvertDDSPhyreToPNG([hashtable]$PhyreInfo, [string]$OutputPath)
{
  # A temporary DDS texture will be created from the phyre DDS texture.
  $TempPath = CreatePath -LiteralPath ($TempFolder + '\TempToCSDDS')
  $TempFile = $TempPath + '\' + $PhyreInfo.Name + $DDS

  # My script uses absolute mipmaps and counts the top level so add +1.
  $MipmapLevels = $PhyreInfo.Mipmaps + 1

  # Set the FourCC value accordingly. We can use the image format here since it will match up with the FourCC value.
  switch -wildcard ($PhyreInfo.Format)
  {
    'BC7'   { $FourCC = 'DX10' }
    'DXT*'  { $FourCC = $PhyreInfo.Format }
    default { $FourCC = '' }
  }
  # Generate a header for the new texture.
  $HeaderArray = GenerateDDSHeader -ImageFormat $PhyreInfo.Format -FourCC $FourCC -Width $PhyreInfo.Width -Height $PhyreInfo.Height -MipmapLevels $MipmapLevels

  # Get the full length of the new image byte array.
  $ByteCount = $HeaderArray.Length + $PhyreInfo.PixelArray.Length

  # Create a new byte array to store all the collective data in.
  $ImageByteArray = New-Object byte[] $ByteCount

  # Copy the generated header and the pixel data into the new byte array.
  [Array]::Copy($HeaderArray, 0, $ImageByteArray, 0, $HeaderArray.Length)
  [Array]::Copy($PhyreInfo.PixelArray, 0, $ImageByteArray, $HeaderArray.Length, $PhyreInfo.PixelArray.Length)

  # Write all data to create the image.
  [IO.File]::WriteAllBytes($TempFile, $ImageByteArray)

  # DDS textures may have the mipmap flag set, but not actually contain mipmaps. The function below will fix the header.
  $HideResult = ValidateDDSHeader -ImageFile $TempFile

  # Create texture info for the temporary DDS file.
  $PNGInfo = CreateTextureInfo -ImageFile $TempFile -Extended

  # Force the PNG color type to 6 (which is a 32-bit RGBA texture). This prevents creating an indexed image.
  $PNGInfo['PNGColorType'] = '6'

  # Set the number of mipmaps if they are to be saved.
  if ($PhyreSaveMipmaps)
  {
    # Back up the settings for the "Max Mipmap Levels" option.
    $OldMaxMipmapEnabled = $MaxMipmapEnabled
    $OldMaxMipmapLevels  = $MaxMipmapLevels

    # Use that option to only create as many mipmaps as the texture actually has.
    $global:MaxMipmapEnabled = $true
    $global:MaxMipmapLevels  = $PhyreInfo.Mipmaps

    # Set the mipmap levels.
    $PNGInfo['IsMipmap'] = $true
    $PNGInfo['Mipmaps']  = $PhyreInfo.Mipmaps
  }
  # The user disabled saving phyre mipmaps.
  else
  {
    # Do not create any mipmaps.
    $PNGInfo['IsMipmap'] = $false
    $PNGInfo['Mipmaps']  = 0
  }
  # Create the PNG version of the texture. This function will also take care of unswizzling if it was set.
  CreatePNGTexture -TextureInfo $PNGInfo -Width $PhyreInfo.Width -Height $PhyreInfo.Height -Format $PNG -OutputPath $OutputPath -FlipTexture $PhyreSwizzle

  # Check to see if this is enabled one last time.
  if ($PhyreSaveMipmaps)
  {
    # Restore the old forced mipmap values.
    $global:MaxMipmapEnabled = $OldMaxMipmapEnabled
    $global:MaxMipmapLevels  = $OldMaxMipmapLevels
  }
  # Gotta clean up all the dog shit.
  RemovePath -LiteralPath $TempPath
}
#==============================================================================================================================================================================================
#  Converts a png.phyre or dds.phyre into a standard PNG image. The MasterLoop can use the function without parameters and it will create the texture into the proper
#  output folder. The function can also act as a stand-alone to convert a ToCS phyre file by forcing the image hash table and output folder.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ConvertPhyreTextures([hashtable]$PhyreInfo = $null, [string]$OutputPath = '')
{
  # Allow forcing a hash table. If it was not forced, use the global texture hash table.
  if ($PhyreInfo -eq $null) { $PTextureInfo = $Texture } else { $PTextureInfo = $PhyreInfo }

  # Because the hash table works on external header files, which don't work with this function.
  if ($PTextureInfo.Extension -eq '.header') { return }

  # If the user just wants to scan phyre information, then only scan information.
  if ($PhyreOnlyScan)
  {
    # Compile a list of useful information about the texture.
    $ScanInfo = 'ColdSteel:' + $PTextureInfo.ColdSteel + ', Extension:' + (ExtensionToText -Extension $PTextureInfo.Extension) + ', Format:' + $PTextureInfo.Format + ', Mipmaps:' + $PTextureInfo.Mipmaps
  
    # Set the status so it's printed to the log file.
    TexList_SetTextureStatus -Status 'ScanOnly' -Message $ScanInfo

    # Exit now so nothing is converted.
    return
  }
  # Allow forcing an output path if this function is not called from the master loop.
  if ($OutputPath -eq '') { $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\ConvertedPhyre' + $PTextureInfo.Relative) }

  # Convert the phyre texture with a method that depends on the file extension.
  switch ($PTextureInfo.Extension)
  {
    # PNG and BMP images share the same function, but DDS requires special attention since the data is compressed.
    $PNG  { ConvertPNGPhyreToPNG -PhyreInfo $PTextureInfo -OutputPath $OutputPath }
    $BMP  { ConvertPNGPhyreToPNG -PhyreInfo $PTextureInfo -OutputPath $OutputPath }
    $DDS  { ConvertDDSPhyreToPNG -PhyreInfo $PTextureInfo -OutputPath $OutputPath }
  }
  # Check to see if the user wants to preserve the header.
  if ($PhyreSaveHeader)
  {
    # Store the header information into a separate file so it can be converted back if desired.
    $HeaderFile = $OutputPath + '\' + $PTextureInfo.Name + '.header'

    # Write the header to a file.
    [IO.File]::WriteAllBytes($HeaderFile, $PTextureInfo.HeaderArray)
  }
  # Test to see if the texture exists in the output path.
  if (TestPath -Literalpath ($OutputPath + '\' + $PTextureInfo.Name + $PNG))
  {
    TexList_SetTextureStatus -Status 'OK' -Message 'Successfully converted to PNG and Header file'
  }
  else
  {
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
}
#==============================================================================================================================================================================================
#  OPERATION 24: CREATE PHYRE TEXTURES FROM PNG/PHYRE - SUPPORT FUNCTIONS
#==============================================================================================================================================================================================
#  To prevent a large unreadable function, I have broken out several of the smaller bits of code into their own functions. This should help abstract issues that arise when creating
#  phyre images. No matter how well I made this code in the past, future changes that do not even mess with it somehow keep end up breaking. This is probably because I'm awful at
#  coding. But to my defense, this script was initially created without these images in mind, so everything had to be hacked in over time. Hopefully the last time I have to update this. 
#==============================================================================================================================================================================================
#  Gets the path to the header based on the location of the texture. Removes the "mm" flag if found.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPhyreHeaderPath([hashtable]$TextureInfo)
{
  # Build a path to the phyre ".header" file. Check for mipmap flag.
  if (($TextureInfo.Name -match '_mm(.{1})') -or ($TextureInfo.Name -like '*_mm'))
  {
    # If a number was specified, "Matches" exists so use it. If no number was used, only "_mm" exists so replace that.
    if ($Matches -ne $null) { $ReplaceText = $Matches[0] } else { $ReplaceText = '_mm' }
  
    # If the texture has the mipmap flag, remove it from the search so the header can be found.
    return ($TextureInfo.PathName.Replace($ReplaceText, '') + '.header')
  }
  # Just use the normal path to the header.
  return ($TextureInfo.PathName + '.header')
}
#==============================================================================================================================================================================================
#  Gets the image path as seen in the phyre header, and modifies it with the new extension if the user has changed it from the source.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPhyreFilePath([string]$OriginalPath)
{
  # If the format is set to "Source".
  if ($PhyreExtension -eq $NUL)
  {
    # Get the full name of the file.
    return $OriginalPath
  }
  # Get the file name from the header without the extension, and add the forced format.
  return (ExtractExtension -FilePath $OriginalPath -ReturnFile) + $PhyreExtension
}
#==============================================================================================================================================================================================
#  Gets the extension that the phyre image will now use.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPhyreExtension([string]$OriginalPath)
{
  # If the format is set to "Source".
  if ($PhyreExtension -eq $NUL)
  {
    # Get the extension from the original path.
    return ExtractExtension -FilePath $OriginalPath
  }
  # Set the extension to convert to from the value set in the menu.
  return $PhyreExtension
}
#==============================================================================================================================================================================================
#  Checks the value of a selected format and make sure it is viable for PNG images. Returns the selected format, or forces a compatible one for PNG.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPhyreImageFormat($PhyreInfo, [string]$Extension)
{
  # If "Source" is selected as the format.
  if ($PhyreImageFormat -eq 'Source')
  {
    # PNG/BMP can only use RGBA or ARGB, so force RGBA if the format is invalid.
    if ((($Extension -eq $PNG) -or ($Extension -eq $BMP)) -and ($PhyreInfo.Format -ne 'RGBA8') -and ($PhyreInfo.Format -ne 'ARGB8'))
    {
      # Force RGBA since the format is invalid for PNG/BMP.
      return 'RGBA8'
    }
    # Allow the user to convert DXT1 source files with alpha to DXT5. 
    if (($PhyreDXT1AToDXT5) -and ($Extension -eq $DDS) -and ($PhyreInfo.Format -eq 'DXT1'))
    {
      # Make sure the image actually has transparent pixels.
      if (Magick-IndentifyTransparency -ImageFile ($PhyreInfo.PathName + ".png"))
      {
        # Override the format to DXT5 instead of outputting DXT1.
        return 'DXT5'
      }
    }
    # If the source format is valid and doesn't trigger the above condition, then use it.
    return $PhyreInfo.Format
  }
  # Attempt to force an image format.
  else
  {
    # Unfortunately, BC7 textures will not work with the engine in CS1 and CS2.
    if (($PhyreImageFormat -eq 'BC7') -and ($PhyreInfo.ColdSteel -lt 3))
    {
      # Force DXT5 since it is basically the inferior D3D9 equivalent of BC7.
      return 'DXT5'
    }
    # PNG and BMP can only use RGBA8 or ARGB8, so force RGBA if the format is invalid.
    if (($PhyreImageFormat -ne 'RGBA8') -and ($PhyreImageFormat -ne 'ARGB8') -and (($Extension -eq $PNG) -or ($Extension -eq $BMP)))
    {
      # Force RGBA since the format is invalid for PNG.
      return 'RGBA8' 
    }
    # If the source format is valid and doesn't trigger the above condition, then use it.
    return $PhyreImageFormat
  }
}
#==============================================================================================================================================================================================
#  Computes the pitch for one of those phyre texture bastards that say fuck all to standards. No clue if my calculations are correct, but the
#  results appear to match the 30 test cases that I threw at it. Yes I was angry when I wrote this.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPhyrePitchBytes([int]$Width, [int]$Height, [string]$ImageFormat)
{
  # Get the block size of the format. Phyre images interpret uncompressed formats as "blocks" rather than the standard by Microsoft 
  # formula that uses the pixel depth. For example, RGBA is 32-bit depth, but technically 64 bytes per pixel (or a 64-byte block).
  switch ($ImageFormat)
  {
    'DXT1'  { $BlockSize = 8  }
    'DXT2'  { $BlockSize = 16 }
    'DXT3'  { $BlockSize = 16 }
    'DXT4'  { $BlockSize = 16 }
    'DXT5'  { $BlockSize = 16 }
    'BC7'   { $BlockSize = 16 }
    'RGB8'  { $BlockSize = 48 }
    'ARGB8' { $BlockSize = 64 }
    'RGBA8' { $BlockSize = 64 }
    'L8'    { $BlockSize = 16 }
    'A8'    { $BlockSize = 16 }
    'LA8'   { $BlockSize = 32 }
  }
  # All textures use the same computation as normal compressed DDS textures (unlike the Microsoft formula).
  [int]$Pitch = [Math]::Max(1,($Width / 4)) * [Math]::Max(1,($Height / 4)) * $BlockSize

  # DDS is little endian, so swap the byte order. Convert the value to hex and pad it to 8 digits. 
  $PitchBytes = (FlipEndian -ByteChain ('{0:X8}' -f $Pitch)).ToCharArray()

  # Store all bytes into a byte array so they can be accessed easier.
  $PitchByteArray = New-Object Byte[] 4
  $PitchByteArray[0] = '{0:D}' -f ('0x' + $PitchBytes[0] + $PitchBytes[1])
  $PitchByteArray[1] = '{0:D}' -f ('0x' + $PitchBytes[2] + $PitchBytes[3])
  $PitchByteArray[2] = '{0:D}' -f ('0x' + $PitchBytes[4] + $PitchBytes[5])
  $PitchByteArray[3] = '{0:D}' -f ('0x' + $PitchBytes[6] + $PitchBytes[7])

  # Return the byte array.
  return $PitchByteArray
}
#==============================================================================================================================================================================================
#  Determines the number of mipmaps to create.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPhyreMipmapCount()
{
  # Create a series of conditions that determine when to create mipmaps.
  $CreatPhyreMipmaps = New-Object bool[] 3
  $CreatPhyreMipmaps[0] = $ForceCreateMipmaps
  $CreatPhyreMipmaps[1] = ($Texture.Name -like '*_mm*')
  $CreatPhyreMipmaps[2] = ($PhyreInfo.Mipmaps -gt 0)

  # Test to see if mipmaps were disabled, and any other condition matches.
  if ((!$DisableMipmaps) -and (TestBooleanArray -Or -Array $CreatPhyreMipmaps))
  {
    # The mipmap flag was used on the texture or a certain number of levels were forced with the GUI.
    if (($Texture.Name -like '*_mm*') -or ($MaxMipmapEnabled))
    {
      # Create a mipmap hash table.
      $MipmapInfo = CreateMipmapInfo -TextureInfo $Texture -Width $Texture.Width -Height $Texture.Height

      # Get the number of mipmaps the texture should be created with.
      return (GetCorrectMipmapLevels -TextureName $Texture.Name -MaxLevels $MipmapInfo.Levels)
    }
    # If the number wasn't forced, calculate the maximum number of mipmap levels based on the texture dimensions.
    return (CalculateMipmapLevels -Dimension ([Math]::Max($Texture.Width, $Texture.Height)))
  }
  # If the texture doesn't have mipmaps or they were disabled, don't create them.
  return $MipmapLevels = 0
}
#==============================================================================================================================================================================================
#  OPERATION 24: CREATE PHYRE TEXTURES FROM PNG/PHYRE
#==============================================================================================================================================================================================
#  Create Trails of Cold Steel png.phyre and dds.phyre images from a .phyre header file and a PNG image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreatePhyreTextures()
{
  # Limit this to PNG files as it's already overwhelming enough.
  if ($Texture.Extension -ne $PNG) { return }

  #===================================================================================================================
  # GET THE HEADER FILE AND HEADER ARRAY
  #===================================================================================================================
  # Get the path to the header.
  $HeaderPath = GetPhyreHeaderPath -TextureInfo $Texture

  # If the header is not found, we can not create the texture.
  if (!(TestPath -LiteralPath $HeaderPath)) { return }

  # Create info from the header file. If using the output path from the previous option, bypass the "~" character.
  $PhyreInfo = CreatePhyreInfo -InputFile $HeaderPath

  # If the user just wants to scan phyre information, then only scan information.
  if ($PhyreOnlyScan)
  {
    # To get the extension, it will need to be pulled from the path found in the header.
    $GrabExtension = $PhyreInfo.FilePath.Split('.', 2)
    $PathExtension = ExtensionToText -Extension ('.' + $GrabExtension[1])

    # Compile a list of useful information about the header.
    $ScanInfo = 'ColdSteel:' + $PhyreInfo.ColdSteel + ', Extension:' + $PathExtension + ', Format:' + $PhyreInfo.Format + ', Mipmaps:' + $PhyreInfo.Mipmaps

    # Set the status so it's printed to the log file.
    TexList_SetTextureStatus -Status 'ScanOnly' -Message $ScanInfo

    # Exit now so nothing is created.
    return
  }
  # Store converted textures in their own unique directory.
  $OutputPath = CreatePath -LiteralPath ($MasterOutputPath + '\CreatedPhyre' + $Texture.Relative)

  # Check to see if the previous texture that was created was not from the same path as the current path.
  if ($LastPhyreCreatePath -ne $OutputPath)
  {
    # When we hit a new path, clear out all the files in the path.
    ClearPath -LiteralPath $OutputPath -Exclude "*asset_D3D11.xml"
  }
  # This path is used to know if the folder should be cleared of files before creating new files in it. Some users may
  # accidentally run the tool twice without cleaning out the files first. This just prevents issues due to irresponsibility.
  $global:LastPhyreCreatePath = $OutputPath

  # Create a copy of the header array that will be modified with new data.
  $HeaderArray = New-Object byte[] $PhyreInfo.HeaderLength
  [Array]::Copy($PhyreInfo.HeaderArray, 0, $HeaderArray, 0, $PhyreInfo.HeaderLength)

  #===================================================================================================================
  # UPDATE THE FILE PATH IN THE HEADER ARRAY
  #===================================================================================================================
  # Get the correct file path that will be entered into the header.
  $NewFilePath = (GetPhyreFilePath -OriginalPath $PhyreInfo.FilePath).ToCharArray()

  # Set the start of the value to where the string starts in the header.
  $Offset = $PhyreInfo.FilePathOffset

  # Loop through all letters in the path, writing all values of the path into the array.
  foreach ($Character in $NewFilePath)
  {
    # Get the character in the form of a hex value.
    $HexValue = '{0:X}' -f [int][char]$Character
    $DecValue = '{0:D}' -f [int]('0x' + $HexValue)

    # Write the new value into the byte array. 
    $HeaderArray[$Offset] = $DecValue

    # Increment the offset.
    $Offset++
  }
  #===================================================================================================================
  # UPDATE THE IMAGE FORMAT AND EXTENSION
  #===================================================================================================================
  # Get the extension that the new phyre image will use.
  $NewExtension = GetPhyreExtension -OriginalPath $PhyreInfo.FilePath

  # Get the image format that the new phyre image will use.
  $NewFormat = GetPhyreImageFormat -PhyreInfo $PhyreInfo -Extension $NewExtension

  # Rather than try to extend the HeaderArray, create a new one. Length is determined by the format offset (all bytes up to that point), the
  # length of the new format, and 38 bytes that are always present after the format. These will be copied back later.
  $NewLength = $PhyreInfo.FormatOffset + $NewFormat.Length + 38
  $TempHeaderArray = New-Object byte[] $NewLength

  # Copy all data from the header array into the new header array, up to the point of the image format
  [Array]::Copy($HeaderArray, 0, $TempHeaderArray, 0, $PhyreInfo.FormatOffset)

  # The "BytePos" var keeps track of which format byte will be written. 
  # The "CharPos" var is the format broken into a character array to be converted to a hex value.
  $BytePos = $PhyreInfo.FormatOffset
  $CharPos = $NewFormat.ToCharArray()

  # Loop through all characters in the format.
  for ($i = 0 ; $i -lt $NewFormat.Length ; $i++)
  {
    # Convert the hex value into a decimal and store it as such.
    $HexValue = '{0:X}' -f [int][char]$CharPos[$i]
    $DecValue = '{0:D}' -f [int]('0x' + $HexValue)
    $TempHeaderArray[$BytePos] = $DecValue
    $BytePos++
  }
  # To copy those last 38 bytes, the position needs to be calculated from the format offset and the old format length.
  $OldStart = $PhyreInfo.FormatOffset + $PhyreInfo.Format.Length
  $NewStart = $PhyreInfo.FormatOffset + $NewFormat.Length

  # Copy the final 38 bytes using the positions calculated above.
  [Array]::Copy($HeaderArray, $OldStart, $TempHeaderArray, $NewStart, 38)

  # Replace the HeaderArray with the new array.
  $HeaderArray = $TempHeaderArray

  #===================================================================================================================
  # SETTING UP THE IMAGE FORMAT FLAGS
  #===================================================================================================================
  # Set up the flags based on the image format found.
  switch -wildcard ($NewFormat)
  {
    'L8'    { $FlagOne = 14 ; $FlagTwo = 3 }
    'LA8'   { $FlagOne = 15 ; $FlagTwo = 4 }
    'BC7'   { $FlagOne = 15 ; $FlagTwo = 4 }
    'DXT*'  { $FlagOne = 16 ; $FlagTwo = 5 }
    '*RGB*' { $FlagOne = 17 ; $FlagTwo = 6 }
  }
  # The first flag is easy as the offset is at a fixed location near the top of the header.
  $HeaderArray[52] = $FlagOne

  # For the second flag, get the difference in length between the old format and the new if there is one.
  $FlagLoc = $PhyreInfo.FormatFlagOffset + ($NewFormat.Length - $PhyreInfo.Format.Length)

  # Not sure what it represents, but I know it is different depending on the format.
  $HeaderArray[$FlagLoc] = $FlagTwo

  #===================================================================================================================
  # SETTING UP THE SPECIAL HEADER LENGTH VALUE
  #===================================================================================================================
  # Cold Steel 1/2 special byte that determines some length of data. I'm still not sure what it's supposed to represent,
  # but I think I'm close enough to the general area that I can calculate the value correctly every time.
  if ($PhyreInfo.ColdSteel -lt 3)
  {
    # So the value at 0x38 seems to equal the length of data that starts at the start of the path, and extends until
    # the value of 58 hex (88) is hit if DXT1/DXT5, or the byte before 58 hex (88) if uncompressed (ARGB8/RGBA8).
    $Offset = $PhyreInfo.FilePathOffset
    $Value  = 0
    $Total  = 0
    $Found  = 0

    # We need to find the value of 88 to know when to stop counting.
    while($Value -ne 88)
    {
      # Offset tells which byte we're on. Value tells the value of the byte. Total is how many times the loop ran.
      $Value = $HeaderArray[$Offset]
      $Offset++
      $Total++

      # DXT1/DXT3/DXT5 makes this tricky, as 88 in ASCII is "X" which gives a false positive.
      if (($NewFormat -like 'DXT*') -and ($Found -eq 0) -and ($Value -eq 88))
      {
        # Skip this first find by resetting the value to 0 so the loop continues. But remember it was found.
        $Value = 0
        $Found = 1
      }
    }
    # So I'll try to explain what I'm doing here. The "Total" value we have is either over or under the value we want, which
    # depends on the format. So, subtract 2 from the total which always seems to put it in range, and the formula below will
    # pad the value to the nearest multiple of four since the value always seems to be a multiple of four (180, 184, 188, 192, etc).
    $Total = $Total - 2 + 4 - 1 - (($Total - 2 + 4 - 1) % 4)
  }
  # Cold Steel 3/4 value seems to be total length of four bytes before the path until PTexture2D is hit.
  elseif ($PhyreInfo.ColdSteel -ge 3)
  {
    # We want to start counting bytes 3 bytes before the path starts instead of 4 to account for the +1 count when "80" is found.
    $Offset = $PhyreInfo.FilePathOffset - 3
    $Value  = 0
    $Total  = 0

    # We need to find the value of 80 to know when to stop counting.
    while($Value -ne 80)
    {
      # Offset tells which byte we're on. Value tells the value of the byte. Total is how many times the loop ran.
      $Value = $HeaderArray[$Offset]
      $Offset++
      $Total++
    }
  }
  # Set the value to the header array.
  $HeaderArray[56] = $Total

  #===================================================================================================================
  # SETTING UP THE WIDTH AND HEIGHT
  #===================================================================================================================
  # Convert the width/height of the texture to hex and flip the endianess. Store the result in a character array.
  $ByteWidth  = (FlipEndian -ByteChain ('{0:X8}' -f $Texture.Width)).ToCharArray()
  $ByteHeight = (FlipEndian -ByteChain ('{0:X8}' -f $Texture.Height)).ToCharArray()

  # Store all width bytes stored in the character array into the header array.
  $HeaderArray[$PhyreInfo.WidthOffset]   = '{0:D}' -f ('0x' + $ByteWidth[0] + $ByteWidth[1])
  $HeaderArray[$PhyreInfo.WidthOffset+1] = '{0:D}' -f ('0x' + $ByteWidth[2] + $ByteWidth[3])
  $HeaderArray[$PhyreInfo.WidthOffset+2] = '{0:D}' -f ('0x' + $ByteWidth[4] + $ByteWidth[5])
  $HeaderArray[$PhyreInfo.WidthOffset+3] = '{0:D}' -f ('0x' + $ByteWidth[6] + $ByteWidth[7])

  # And store all height bytes into the header array.
  $HeaderArray[$PhyreInfo.HeightOffset]   = '{0:D}' -f ('0x' + $ByteHeight[0] + $ByteHeight[1])
  $HeaderArray[$PhyreInfo.HeightOffset+1] = '{0:D}' -f ('0x' + $ByteHeight[2] + $ByteHeight[3])
  $HeaderArray[$PhyreInfo.HeightOffset+2] = '{0:D}' -f ('0x' + $ByteHeight[4] + $ByteHeight[5])
  $HeaderArray[$PhyreInfo.HeightOffset+3] = '{0:D}' -f ('0x' + $ByteHeight[6] + $ByteHeight[7])

  #===================================================================================================================
  # SETTING UP THE PITCH
  #===================================================================================================================
  # Calculate the pitch for the texture.
  $Pitch = GetPhyrePitchBytes -Width $Texture.Width -Height $Texture.Height -ImageFormat $NewFormat

  # Fortunately the offsets are static.
  $HeaderArray[80] = $Pitch[0]
  $HeaderArray[81] = $Pitch[1]
  $HeaderArray[82] = $Pitch[2]
  $HeaderArray[83] = $Pitch[3]

  #===================================================================================================================
  # SETTING UP THE MIPMAP LEVELS 
  #===================================================================================================================
  # Get the number of mipmaps that the texture will be created with.
  $MipmapLevels = GetPhyreMipmapCount

  # Set the number of mipmaps in the header.
  $HeaderArray[$PhyreInfo.MipmapOffset] = $MipmapLevels

  #===================================================================================================================
  # SETTING UP EXTRA BYTES THAT ARE FORMAT SPECIFIC
  #===================================================================================================================
  # These bytes do not seem to be used in Cold Steel 3/4.
  if ($PhyreInfo.ColdSteel -lt 3)
  {
    # PNG/BMP textures seem to have a unique byte set.
    if ($NewExtension -ne $DDS)
    {
      # In all the PNG/BMP files I analyzed, this byte was always 2 for some reason.
      $HeaderArray[$PhyreInfo.PNGExtraOffset] = 2
      $HeaderArray[$PhyreInfo.DDSExtraOffset] = 0
    }
    # DDS textures have the mipmap value set twice.
    else
    {
      # I don't know why that is, but the game crashes without this being correct.
      $HeaderArray[$PhyreInfo.PNGExtraOffset] = 0
      $HeaderArray[$PhyreInfo.DDSExtraOffset] = $MipmapLevels 
    }
  }
  #===================================================================================================================
  # CREATING THE PIXEL DATA
  #===================================================================================================================
  # A temporary texture must be created so the attributes match what we need.
  $PhyreTempPNGPath = CreatePath -LiteralPath ($TempFolder + '\PhyreTempPNG')
  $PhyreTempPNGFile = $PhyreTempPNGPath + '\' + $Texture.Name + $PNG

  # The "CreateTexture" functions will take care of "swizzling" and creating the proper PNG color type.
  CreatePNGTextureSingle -TextureInfo $Texture -ImageFile $Texture.FullPath -Width $Texture.Width -Height $Texture.Height -Format $PNG -OutputPath $PhyreTempPNGPath -FlipTexture $PhyreSwizzle

  # Some hacks that need to be performed depending on the output format.
  if (($NewFormat -eq 'RGBA8') -and ($NewExtension -ne $DDS))
  {
    # To create the RGBA format, swap the red and blue channels. ImageMagick makes it fast and easy to do this.
    Magick-Convert -ImageFile $PhyreTempPNGFile -Arguments @('-define', 'png:color-type=6', '-separate', '-swap', '0,2', '-combine') -OutputFile $PhyreTempPNGFile
  }
  # Getting the pixel data for a PNG texture. PNG does not have mipmap pixel data so only the top level is grabbed.
  if (($NewExtension -eq $PNG) -or ($NewExtension -eq $BMP))
  {
    # Get information about the PNG image (most importantly the pixel data).
    $RawPNGInfo = GetRawImageData -ImageFile $PhyreTempPNGFile

    # Set the pixel data to a familiar variable name.
    $PixelArray = $RawPNGInfo.Bytes
  }
  # Getting the pixel data for a DDS texture.
  else
  {
    # I have only ever found a single L8 texture. Here is what I found: It's a DDS texture. It has the mipmap flag set to "10". But,
    # the texture does not actually have mipmaps within the texture (like PNG). This is odd as other uncompressed DDS textures do.
    $DoMipmapHack = New-Object bool[] 3
    $DoMipmapHack[0] = ($NewFormat -eq 'L8')
    $DoMipmapHack[1] = ($NewFormat -eq 'A8')
    $DoMipmapHack[2] = ($NewFormat -eq 'LA8')

    # While I don't know if all formats behave this way, or its just an oddity, treat all uncompressed luminance/alpha textures the same.
    if (TestBooleanArray -Or -Array $DoMipmapHack) { $MipmapLevels = 0 } else { $MipmapLevels }

    # DDS Images will need to be created to generate pixel data. Use the temporary PNG texture as a base.
    $DDSInfo = CreateTextureInfo -ImageFile $PhyreTempPNGFile -Extended

    # The DDS compression must be forced in the texture info so that the desired format is created. Also force the number of mipmaps.
    $DDSInfo['DDSCompression'] = $NewFormat
    $DDSInfo['Mipmaps'] = $MipmapLevels

    # Create a temporary location for the DDS file.
    $PhyreTempDDSPath = CreatePath -LiteralPath ($TempFolder + '\PhyreTempDDS')
    $PhyreTempDDSFile = $PhyreTempDDSPath + '\' + $DDSInfo.Name + $DDS

    # Create the temporary DDS texture to grab pixel data from. It will also contain the mipmap pixel data.
    CreateTexture -TextureInfo $DDSInfo -Width $DDSInfo.Width -Height $DDSInfo.Height -Format $DDS -OutputPath $PhyreTempDDSPath -NoReturn

    # use the format to determine the header size.
    switch ($NewFormat)
    {
      # BC7 is a DX11 format so it uses the 148 byte header.
      'BC7'   { $HeaderSize = 148 }
      default { $HeaderSize = 128 }
    }
    # Create a byte array from the image to pull the pixel byte values.
    $NewDDSBytes = [IO.File]::ReadAllBytes($PhyreTempDDSFile)
    $PixelLength = $NewDDSBytes.Length - $HeaderSize
    $PixelArray  = New-Object byte[] $PixelLength

    # Set up the pixel array by cropping out only the pixel bytes (skip the header).
    [Array]::Copy($NewDDSBytes, $HeaderSize, $PixelArray, 0, $PixelLength)
  }
  #===================================================================================================================
  # WRITING THE IMAGE FILE
  #===================================================================================================================
  # If the texture has the mipmap flag then remove it.
  if (($Texture.Name -match '_mm(.{1})') -or ($Texture.Name -like '*_mm'))
  {
    # If a number was specified, "Matches" exists so use it. If no number was used, only "_mm" exists so replace that.
    if ($Matches -ne $null) { $ReplaceText = $Matches[0] } else { $ReplaceText = '_mm' }

    # Replace the mipmap flag in the texture name.
    $FinalName = $Texture.Name.Replace($ReplaceText, '')
  }
  # There was no mipmap flag.
  else
  {
    # Set the final name to the texture name.
    $FinalName = $Texture.Name
  }
  # Now to combine the header and pixel data.
  $ImageArray  = New-Object byte[] ($HeaderArray.Length + $PixelArray.Length)

  # Copy all bytes from the header and pixel data into the new array.
  [Array]::Copy($HeaderArray, 0, $ImageArray, 0, $HeaderArray.Length)
  [Array]::Copy($PixelArray, 0, $ImageArray, $HeaderArray.Length, $PixelArray.Length)

  # Set the output path to the file.
  $OutputFile = $OutputPath + '\' + $FinalName + $NewExtension + '.phyre'

  # Write the image to a file.
  [IO.File]::WriteAllBytes($OutputFile, $ImageArray)

  # Let the user know if the texture was created or not.
  if (TestPath -LiteralPath $OutputFile)
  {
    TexList_SetTextureStatus -Status 'OK' -Message ('Successfully created as PhyreEngine ' + (ExtensionToText -Extension $NewExtension) + ' ' + $NewFormat + ' Format')
  }
  else
  {
    TexList_SetTextureStatus -Status 'Fail' -Message 'Texture failed creation'
  }
  # As always clean up the shit laying around.
  RemovePath -LiteralPath $PhyreTempPNGPath
  RemovePath -LiteralPath $PhyreTempDDSPath
}
#==============================================================================================================================================================================================
#  Updates all "asset_D3D11.xml" files with the new texture names. This is ran after the master loop is finished and all textures have been created.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdatePhyreAssetD3D11XML()
{
  # Leave now if it's not the correct operation or updating the XML was disabled.
  if (($MasterOperation -ne 'CreateFromPhyre') -or (!$PhyreXMLUpdate)) { return }

  # Show me that this is happening.
  DebugMessage -Message 'Updating asset_D3D11.xml files...' -FollowUp ' '

  # Set the path to loop through to where phyre textures were created.
  $LoopPath = $MasterOutputPath + '\CreatedPhyre'

  # Make sure the path exists before trying to do anything with it.
  if (!(TestPath -LiteralPath $LoopPath)) { return }

  # Loop through all folders to search for the XML files.
  foreach ($Folder in EnumerateFolders -LiteralPath $LoopPath -Recurse)
  {
    # Build a path to the XML file that would be found in this folder.
    $AssetXMLPath = $Folder + '\asset_D3D11.xml'

    # Make sure the file exists before attempting to update it.
    if (TestPath -LiteralPath $AssetXMLPath)
    {
      # Show me the path to the asset xml file.
      DebugMessage -Message $AssetXMLPath

      # Get the contents of the XML file.
      $XMLContent = Get-Content -LiteralPath $AssetXMLPath

      # Loop through all files in the path.
      foreach ($ToCSFile in EnumerateFiles -LiteralPath $Folder -Filter @('*.png.phyre','*.dds.phyre','*.bmp.phyre'))
      {
        # Get the file as an item to get properties of it.
        $FileItem = Get-Item -LiteralPath $ToCSFile

        # So now that we have a texture name, loop through the XML and try to find it.
        for ($i=0 ; $i -lt $XMLContent.Length ; $i++)
        {
          # The extension before (.phyre) in the XML is not known, so for now get just the name without either extension.
          $BaseName = ExtractExtension -FilePath $FileItem.BaseName -ReturnFile

          # Search for the name with the (.phyre) extension but use a wildcard for the file type extension (.png/.dds/.bmp).
          $SearchName = '*' + $BaseName + ".*.phyre*" 

          # The name was found in the XML file.
          if ($XMLContent[$i] -like $SearchName)
          {
            # Now the extension of the file must be found before the (.phyre) extension.
            $FindExtension = ($XMLContent[$i] -Split $BaseName | select -last 1).Substring(0,4)

            # The full name of the file in the XML is now known.
            $ReplaceName = $BaseName + $FindExtension

            # Make sure the extension we're replacing is a valid one.
            if (($FindExtension -eq '.png') -or ($FindExtension -eq '.dds') -or ($FindExtension -eq '.bmp'))
            {
              # Check to see if the entry needs to be updated.
              if ($ReplaceName -ne $FileItem.BaseName)
              {
                # Replace the old name with the new name.
                $XMLContent[$i] = $XMLContent[$i].Replace($ReplaceName, $FileItem.BaseName)

                # Show me that this is happening.
                DebugMessage -Message ('- Replaced "' + $ReplaceName + '" with "' + $FileItem.BaseName + '".')
              }
              # If it doesn't need to be updated, let me know.
              else
              {
                # Show me that this is happening.
                DebugMessage -Message ('- The file "' + $FileItem.BaseName + '" already matches the asset_D3D11.xml entry.')
              }
            }
          }
        }
      }
      # Separate each file with a blank space.
      DebugMessage -Message ' '

      # Update the XML with any updated values.
      Set-Content -LiteralPath $AssetXMLPath -Value $XMLContent
    }

  }
}
#==============================================================================================================================================================================================
#  OPERATION 25: REPACK FOLDERS/TEXTURES INTO PKG FILES
#==============================================================================================================================================================================================
#  Because of the way the master loop works, we need something to fill the "Texture" hash table.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateNewPKGInfo($InputFile)
{
  # Get the item as an object to get properties.
  $InputItem = Get-Item -LiteralPath $InputFile

  # Only accept folders as a candidate for a PKG file.
  if ($InputItem.PSIsContainer)
  {
    # Look for the "asset_D3D11.xml" file.
    $PKGPath = $InputItem.FullName + '\asset_D3D11.xml'

    # Check to see if the XML file exists.
    if (TestPath -Literalpath $PKGPath)
    {
      # Initialize the hash table.
      $PKGInfo = @{}
      $PKGInfo.Name = $InputItem.BaseName
      $PKGInfo.FullName  = $InputItem.Name
      $PKGInfo.Extension = $PKG
      $PKGInfo.Path = $InputItem.FullName
      $PKGInfo.FullPath = $PKGInfo.Path + $PKG
      $PKGInfo.Relative = $PKGInfo.Path.Replace($MasterInputPath,'').Replace($PKGInfo.Name,'')

      # Set "Texture" to the full path to the folder.
      return $PKGInfo
    }
  }
  # If we have nothing then just return null.
  return $null
}
#==============================================================================================================================================================================================
#  Packs a folder containing "asset_D3D11.xml" into a PKG file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PackColdSteelPKG()
{
  # Seeing the name "Texture" will just confuse me so put it in something else.
  $PKGInfo = $Texture

  # If the folder name contains ".pkg" this will cause issues with the PKG tool. Folders extracted by CeruleanSky's PKA scripts will
  # extract PKG file to folders with the extension in the name, so create a workaround by temporarily renaming the folder.
  if ($PKGInfo.Name -like '*.pkg')
  {
    # Use the same location but crop the '.pkg' from the name.
    $OldFolderPath = $PKGInfo.Path
    $NewFolderPath = $PKGInfo.Path.Replace('.pkg','')

    # Using this works fine to rename items in-place.
    Move-Item -LiteralPath $PKGInfo.Path -Destination $NewFolderPath

    # The info on the file is going to need updated.
    $PKGInfo = CreateNewPKGInfo -InputFile $NewFolderPath

    # Because I like to keep things the way they were, rename the file back to what it was.
    $FileRenamed = $true
  }
  # The destination path of the extracted files.
  $DestinationPath = CreatePath -LiteralPath ($MasterOutputPath + '\PKG_Repacked' + $PKGInfo.Relative)
  $DestinationFile = $DestinationPath + $PKGInfo.Name + $PKG

  # Compress the contents.
  RunPKGTool -PKGFile $PKGInfo.Path

  # Errors will happen if the file already exists in the output folder.
  if (TestPath -LiteralPath $DestinationFile)
  {
    # So remove the contents before moving the new files.
    RemovePath -LiteralPath $DestinationFile
  }
  # Move the extracted contents to the destination path.
  Move-Item -LiteralPath $PKGInfo.FullPath -Destination $DestinationFile -Force

  # Time to restore the file name if it had ".pkg" in it.
  if ($FileRenamed) { Move-Item -LiteralPath $NewFolderPath -Destination $OldFolderPath }

  # Make sure the file actually exists in the output path.
  if (TestPath -LiteralPath $DestinationPath)
  {
    # Report to the user if the PKG file packed correctly.
    TexList_SetTextureStatus -Status 'OK' -Message ('Successfully packed the contents of ' + $PKGInfo.Name + '.')
  }
  # Also report to the user if the PKG file failed.
  else
  {
    # If it was sewer56's tool that failed, suggest thesupersonic16's PKG tool.
    if ($PhyrePKGTool -like '*.dll')
    {
      TexList_SetTextureStatus -Status 'Failed' -Message ('Failed repacking. Make sure .NET Core 2.0-2.6 is installed, or try tool by thesupersonic16.')
    }
    # If it was thesupersonic16's tool that failed, there isn't much other advice to offer since it's generally less feature rich than the other.
    else
    {
      TexList_SetTextureStatus -Status 'Failed' -Message ('Failed to repack the PKG file.')
    }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 26: BASIC IMAGE VIEWER
#==============================================================================================================================================================================================
#  Opens the Basic Image Viewer for the user. Function exists to help establish connections.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function OpenBasicImageViewer()
{
  # Show the Image Viewer dialog.
  InitiateBasicImageViewer

  # Always return false so the MasterLoop doesn't run.
  return $false
}
#==============================================================================================================================================================================================
#  OPERATION 27: DOLPHIN RESOURCE PACK MANAGER
#==============================================================================================================================================================================================
#  The function that sets up and opens the Basic Image Viewer. Function exists to help establish connections.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateResourcePack()
{
  # Show the resource pack creation dialog.
  InitiateResourcePackDialog

  # Always return false so the MasterLoop doesn't run.
  return $false
}
#==============================================================================================================================================================================================
#  OPERATION 28: METROID PRIME 2 - HELPER FUNCTIONS
#==============================================================================================================================================================================================
#  Metroid Prime 2 Module: holds the binary hashes for the textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function InitiatePrime2Hashes()
{
  # If it's already been loaded then get out of here.
  if ($MP2MD5HashA -ne $null) { return }

  # Create the two arrays to store the MD5 hashes.
  $global:MP2MD5HashA = New-Object string[] 14
  $global:MP2MD5HashB = New-Object string[] 6

  # The 14 primary font textures found in Metroid Prime 2. 
  $MP2MD5HashA[00] = 'DA289E4E73760FF5B0CF968BB82AF00B'
  $MP2MD5HashA[01] = '9870D00509D4675F9F5AED199BC8C6A2'
  $MP2MD5HashA[02] = 'F823F4A0FB28B6110458A3037F643672'
  $MP2MD5HashA[03] = '0D7FBCBFCBA19AFE56A15D8F51701887'
  $MP2MD5HashA[04] = '047AB790D93355A967DB3259BC6677EA'
  $MP2MD5HashA[05] = '22E376BCA87205336C2B1CA090B7BD8B'
  $MP2MD5HashA[06] = '772CE80DE16B068666E01BAECD8173D8'
  $MP2MD5HashA[07] = 'E1A5DDB90762B4F7D3D72A1D0CD7FB1C'
  $MP2MD5HashA[08] = '367159C762DCEE1CF45FD87C6E4AB861'
  $MP2MD5HashA[09] = 'F7B0A76D617FABEA30BEC0DCF91B970F'
  $MP2MD5HashA[10] = '36B2FE0BCD0B4A348A4346CDDF01F90C'
  $MP2MD5HashA[11] = '81156C8266C59BAFFCBDBBE2CF6FB766'
  $MP2MD5HashA[12] = '6404AC8AE032D9DB80EBEB15230D825B'
  $MP2MD5HashA[13] = 'EE4C1525127C54D9506BB8365C3D5BA2'

  # The 6 alternate versions of textures 8-13 that do not have a black border.
  $MP2MD5HashB[00] = '7D8B14A14AC6D6BFD8A834C51BB16CAC'
  $MP2MD5HashB[01] = 'C07649D2D60896122B1D80EE5C02E079'
  $MP2MD5HashB[02] = '6FD5F1C8A1652C0084E9673B2A45427E'
  $MP2MD5HashB[03] = '637460EFA006F1AB964C2AC123A21B2B'
  $MP2MD5HashB[04] = 'A5A544CAB11BE926452EA68E6D8A7FCB'
  $MP2MD5HashB[05] = '8CEF41C0C83F7889C6FA4D95A2C39269'
}
#==============================================================================================================================================================================================
#  Avoids duplicate code which I don't like.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMetroidIndex([string]$MD5Hash, [string[]]$MD5HashArray, [switch]$TwoTone=$false)
{
  # Loop through all the images.
  for ($x = 0 ; $x -lt $MD5HashArray.Length ; $x++)
  {
    # Check if the hash array contains the hash.
    if ($MD5Hash -eq $MD5HashArray[$x])
    {
      # If it's an image with a colored border.
      switch ($TwoTone)
      {
        # Return a calculated index. Otherwise, return the index.
        $true  { return ($MP2MD5HashA.Length - $MP2MD5HashB.Length) + $x }
        $false { return $x }
      }
    }
  }
  # We should never get here, but if we do, I'm sure a random 99 popping up somewhere will raise a red flag.
  return 99
}
#==============================================================================================================================================================================================
#  Assembles a bunch of useful data into a hashtable for the current image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMetroidImageData([string]$ImagePath)
{
  # Get the raw pixel data of the image.
  $RawData = GetRawImageData -ImageFile $ImagePath

  # If there is no alpha channel, or it's a paletted image with less than 8bpp, leave now.
  if ((!$RawData.AlphaChannel) -or (!$RawData.Channels)) { return $null }

  # Create an empty hash table.
  $MetroidData = @{}

  # Calculate the total number of bytes to loop through.
  $MetroidBytes = New-Object byte[] ($RawData.Width * $RawData.Height)

  # The type is just an easy way to reference if it has one or two colors.
  $MetroidData.Type = 0

  # Determines the position by counting loop iterations. Needed because the loop itself is incremented by 4 instead of 1.
  $BytePos = 0

  # Loop through the alpha bytes and grab the lower bytes in variables.
  for ($p = ($RawData.Channels - 1) ; $p -lt $RawData.Bytes.Length ; $p += $RawData.Channels)
  {
    # Get the color values of the pixel.
    $RValue = $RawData.Bytes[$p - 1]
    $GValue = $RawData.Bytes[$p - 2]
    $BValue = $RawData.Bytes[$p - 3]
    $AValue = $RawData.Bytes[$p]

    # Check to see if the pixel has any level of red, green, or blue above zero.
    $BoolID = (($RValue -gt 0) -or ($GValue -gt 0) -or ($BValue -gt 0))

    # If it has color, store a "1" in the current array. If it doesn't have color, store a "0".
    $MetroidBytes[$BytePos] = [Convert]::ToByte($BoolID)

    # See if the pixel has any color at all.
    if (($BoolID) -and (!$StopChecking))
    {
      # Check to see if the font has been created yet.
      if ($MetroidData.FontColor -eq $null)
      {
        # If it hasn't then create it.
        $MetroidData.FontColor   = ColorRGBA -R $RValue -G $GValue -B $BValue -A $AValue
      }
      # If it has been created, but a new color has been found.
      elseif (($RValue -ne $MetroidData.FontColor.R) -and ($GValue -ne $MetroidData.FontColor.G) -and ($BValue -ne $MetroidData.FontColor.B))
      {
        # Move the old color to the border and set the new color to the font.
        $MetroidData.BorderColor = ColorRGBA -R $MetroidData.FontColor.R -G $MetroidData.FontColor.G -B $MetroidData.FontColor.B -A $AValue
        $MetroidData.FontColor   = ColorRGBA -R $RValue -G $GValue -B $BValue -A $AValue

        # A switch to make sure no colors get overwritten and provides a speed-up.
        $StopChecking = $true
      }
    }
    # Increment the byte position.
    $BytePos++
  }
  # Calculate a MD5 hash from the byte array.
  $MD5Hash = CalculateHash -ByteArray $MetroidBytes -Algorithm 'MD5'

  # If the border color is null then it's a single color.
  switch ($MetroidData.BorderColor -eq $null)
  {
    # If it's not null then there is two colors.
    $true  { $MetroidData.Index = GetMetroidIndex -MD5Hash $MD5Hash -MD5HashArray $MP2MD5HashA          ; MetroidData.Type = 0 }
    $false { $MetroidData.Index = GetMetroidIndex -MD5Hash $MD5Hash -MD5HashArray $MP2MD5HashB -TwoTone ; MetroidData.Type = 1 }
  }
  # This is the image the user selected on the texture selection screen for the corresponding index.
  $MetroidData.UserImage = $MetroidBase[$MetroidData.Index]

  # All the values created here will be useful.
  return $MetroidData
}
#==============================================================================================================================================================================================
#  OPERATION 28: CREATE NEW METROID PRIME 2 FONTS FROM BASE
#==============================================================================================================================================================================================
#  Colorizes the fonts using the base textures and the sorted dumps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ColorizeMetroidFonts()
{
  # Test if its PNG and if not, exit the function.
  if ($Texture.Extension -ne $PNG) { TexList_SetTextureStatus -Status 'OK' ; return }

  # Make sure the texture has the proper dimensions in both the name and for real.
  $DimensionChecks = New-Object bool[] 6
  $DimensionChecks[0] = ($Texture.Name -like '*64x80*')
  $DimensionChecks[1] = ($Texture.Name -like '*104x128*')
  $DimensionChecks[2] = ($Texture.Name -like '*120x112*')
  $DimensionChecks[3] = ($Texture.Dimensions -ne '64x80')
  $DimensionChecks[4] = ($Texture.Dimensions -ne '104x128')
  $DimensionChecks[5] = ($Texture.Dimensions -ne '120x112')

  # Perform the check and exit if not.
  if (!(TestBooleanArray -Or -Array $DimensionChecks)) { TexList_SetTextureStatus -Status 'OK' -Message 'Not a MP2 font texture.' ; return }

  # Create a dataset for the image.
  $MetroidData = GetMetroidImageData -ImagePath $Texture.FullPath

  # Same stuff: check for null data, image not in byte list, and also make sure the folder is named like a color (ex: #3F5A00FF).
  if     ($MetroidData -eq $null)           { TexList_SetTextureStatus -Status 'OK'      -Message 'Not a MP2 font texture.' ; return }
  elseif ($MetroidData.FontColor -eq $null) { TexList_SetTextureStatus -Status 'Skipped' -Message 'No match found!' ; return }
  elseif ($MetroidData.UserImage -eq '')    { TexList_SetTextureStatus -Status 'Skipped' -Message 'No replacement texture was found!' ; return }

  # Get the raw pixel data of the base image.
  $RawData = GetRawImageData -ImageFile $MetroidData.UserImage

  # Convert the font color from a string to decimal values per color.
  $RNew = $MetroidData.FontColor.R
  $GNew = $MetroidData.FontColor.G
  $BNew = $MetroidData.FontColor.B
  $ANew = $MetroidData.FontColor.A

  # Loop through each alpha Byte.
  for ($p = ($RawData.Channels - 1) ; $p -lt $RawData.Bytes.Length ; $p += $RawData.Channels)
  {
    # Get the color positions of the pixel.
    $Red = $p - 1
    $Grn = $p - 2
    $Blu = $p - 3
    $Alp = $p

    # Get the color values of the pixel.
    $RValue = $RawData.Bytes[$Red]
    $GValue = $RawData.Bytes[$Grn]
    $BValue = $RawData.Bytes[$Blu]
    $AValue = $RawData.Bytes[$Alp]

    # Check to see if there is any color value in the pixel.
    if (($RValue -ne 0) -or ($GValue -ne 0) -or ($BValue -ne 0))
    {
      # A switch would be nicer looking here, but if/else statements are MUCH faster.
      $NewAlpha = $AValue - (255 - $ANew)

      # Don't allow the new alpha value to fall below zero.
      if ($NewAlpha -lt 0) { $NewAlpha = 0 }

      # If the pixel is fully white, then color it in with the new color.
      if (($RValue -eq 255) -and ($GValue -eq 255) -and ($BValue -eq 255))
      {
        # Simple enough.
        $RawData.Bytes[$Red] = $RNew
        $RawData.Bytes[$Grn] = $GNew
        $RawData.Bytes[$Blu] = $BNew
        $RawData.Bytes[$Alp] = $NewAlpha
      }
      # If a pixel that has "anti-aliasing" or "shading" is found.
      else
      {
        # Calculate the % difference of the pixel from black to white for each channel.
        $RedDiff = 1 - ($RValue / 255)
        $GrnDiff = 1 - ($GValue / 255)
        $BluDiff = 1 - ($BValue / 255)

        # If the border has a different color than the fill.
        if ($MetroidData.BorderColor -ne $null)
        {
          # Probably not necessary since all channels should be the same, but average them anyway.
          $AvgDiff = ($RedDiff + $GrnDiff + $BluDiff) / 3

          # Get the new color by interpolating them and using the distance between them.
          $NewColor = InterpolateColors -StartColor $MetroidData.FontColor -EndColor $MetroidData.BorderColor -Distance $AvgDiff

          # Now set the new values to the pixels.
          $RawData.Bytes[$Red] = $NewColor.R
          $RawData.Bytes[$Grn] = $NewColor.G
          $RawData.Bytes[$Blu] = $NewColor.B
          $RawData.Bytes[$Alp] = $NewColor.A
        }
        # For a black border, just calculate the fill pixel.
        else
        {
          # So using the % diff from white to gray (255-0), transform that to the value pulled from the hex (value-0).
          $RedCalc = [Math]::Round($RNew - ($RNew * $RedDiff))
          $GrnCalc = [Math]::Round($GNew - ($GNew * $GrnDiff))
          $BluCalc = [Math]::Round($BNew - ($BNew * $BluDiff))

          # Now set the new values to the pixels.
          $RawData.Bytes[$Red] = $RedCalc
          $RawData.Bytes[$Grn] = $GrnCalc
          $RawData.Bytes[$Blu] = $BluCalc
          $RawData.Bytes[$Alp] = $NewAlpha
        }
      }
    }
    # Check to see if the pixel is completely black and also visible. This should be the border.
    elseif (($MetroidData.BorderColor -ne $null) -and ($RValue -eq 0) -and ($GValue -eq 0) -and ($BValue -eq 0) -and ($AValue -ne 0))
    {
      # Color the border with the first color which will be the border color.
      $RawData.Bytes[$Red] = $MetroidData.BorderColor.R
      $RawData.Bytes[$Grn] = $MetroidData.BorderColor.G
      $RawData.Bytes[$Blu] = $MetroidData.BorderColor.B
      $RawData.Bytes[$Alp] = $AValue
    }
  }
  # Create the texture in a temporary path.
  $ExportPath = CreatePath -LiteralPath ($MasterOutputPath + '\MPNewFonts')
  $ExportFile = $ExportPath + '\' + $Texture.Name + $PNG

  # Write the texture using the updated raw pixel data.
  WritePixelDataToImage -PixelData $RawData -OutputFile $ExportFile

  # Build the string that will go into the message box.
  $Message = 'Created with color: R=' + $MetroidData.FontColor.R + ' G=' + $MetroidData.FontColor.G + ' B=' + $MetroidData.FontColor.B + ' A=' + $MetroidData.FontColor.A

  # If it has a non-black border then add that too.
  if ($MetroidData.Type -eq 1)
  {
    # Set the message to show the real index and the border message.
    $Message += ', Non-Black Border'
  }
  # Check to see if it was created.
  if (TestPath -LiteralPath $ExportFile)
  {
    # Write a comforting message.
    TexList_SetTextureStatus -Status 'OK' -Message $Message
  }
}
#==============================================================================================================================================================================================
#  OPERATION 29: RUN CUSTOM CLI EXECUTABLE WITH CTT-PS
#==============================================================================================================================================================================================
#  This is used once during initialization to load the executables from the ini and select the first in the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateCLIProgramsList()
{
  # If the ini file doesn't exist, it can't be populated.
  if (!(TestPath -LiteralPath $CustomExecutables)) { return }

  # Get the file that stores the custom executables.
  $CLISettings = Get-Content -LiteralPath $CustomExecutables

  # Loop through each line in the settings file.
  foreach ($Line in $CLISettings)
  {
    # Get the entire line without the first character (identifier).
    $LineValue = $Line.Substring(1,($Line.Length - 1))

    # Lines that start with "~" hold the program path.
    if ($Line -like '~*')
    {
      # Make sure this path still exists.
      if (TestPath -LiteralPath $LineValue)
      {
        # Get the executable as an item to get properties.
        $LineItem = Get-Item -LiteralPath $LineValue

        # Add the executable to the GUI list.
        $CLIProgramCombo.Items.Add($LineItem.Name) | Out-Null
      }
    }
  }
  # Make sure there is at least a single program in the list.
  if ($CLIProgramCombo.Items.Count -gt 0)
  {
    # Select the first program added to the list.
    $CLIProgramCombo.SelectedIndex = 0
  }
}
#==============================================================================================================================================================================================
#  This sets the output folder when creating stuff with the custom CLI program.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetCustomCLIExecutableOutputFolder()
{
  # Now I don't need "this" everywhere.
  $Text = $this.Text

  # There must be some text entered.
  if (($Text -eq '') -or ($Text -eq $null))
  {
    # If it's empty just restore the original text that was here.
    $Text = 'CustomExecutable'
  }
  # Update the text with a version that has illegal characters removed.
  $this.Text = RemoveIllegalCharacters -Value $Text
}
#==============================================================================================================================================================================================
#  Updates the ini with the input executable, its file extensions list, and the commands.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateCustomCLIExecutableINI([string]$Executable)
{
  # If the dialog hasn't been shown yet there is nothing on the GUI to update with.
  if (!$MainDialog.Visible) { return }

  # Get the file that stores the custom executables.
  $CLISettings = Get-Content -LiteralPath $CustomExecutables

  # Create an empty string list to recreate the ini file.
  $NewCLISettings = New-Object Collections.Generic.List[string]

  # Loop through each line in the settings file.
  foreach ($Line in $CLISettings)
  {
    # The ini always starts with a program so always start with WriteData as true.
    if ($Line -like '~*') { $WriteData = $true }
  
    # If the flag is set to record to the new content file.
    if ($WriteData) { $NewCLISettings.Add($Line) }

    # Make sure an executable was selected at least once.
    if ($Executable -ne $null)
    {
      # The executable on the line matches the previously selected one.
      if ($Line -like ('~*' + $Executable + '*'))
      {
        # Now to import the commands list. Loop through each row on the grid.
        foreach ($Row in $CLIGridView.Rows)
        {
          # Without this check, it crashes in C# code. So add it for the sake 
          if ($Row.Cells[0].Value -ne $null)
          {
            # Make sure something was actually entered here.
            if (($Row.Cells[0].Value -ne '') -and ($Row.Cells[0].Value -ne $null))
            {
              # Add the command to the ini file.
              $NewCLISettings.Add(('>' + $Row.Cells[0].Value))
            }
          }
        }
        # Now the file extensions are needed.
        $NewCLISettings.Add((':' + $CLIInputExtensionsBox.Text))
        $NewCLISettings.Add((';' + $CLIOutputExtensionBox.Text))
        $NewCLISettings.Add(('-' + $CLIOutFolderNameBox.Text))

        # Don't even bother writing any properties for this executable since everything will be read from the GUI.
        $WriteData = $false
      }
    }
  }
  # Replace the file with the modified content.
  Set-Content -LiteralPath $CustomExecutables -Value $NewCLISettings
}
#==============================================================================================================================================================================================
#  Handles when an executable is selected from the combobox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SelectCustomCLIExecutable()
{
  # First update the ini with the previously selected item so changes aren't lost.
  UpdateCustomCLIExecutableINI -Executable $CustomCLISelected

  # Now reload the ini file that stores the custom CLI executables.
  $CLISettings = Get-Content -LiteralPath $CustomExecutables

  # Clear all the shit off the rows.
  $CLIGridView.Rows.Clear()

  # Loop through each line in the settings file.
  foreach ($Line in $CLISettings)
  {
    # Get the entire line without the first character (identifier).
    $LineValue = $Line.Substring(1,($Line.Length - 1))
  
    # Stop reading data when the next executable after the selected one is found.
    if (($ReadData) -and ($Line -like '~*')) { $ReadData = $false }
  
    # Start reading data when the line contains the selected executable.
    if ($Line -like ('~*' + $this.SelectedItem + '*')) { $ReadData = $true }

    # If currently reading data...
    if ($ReadData)
    {
      # Use the first character to determine what to do with the line.
      switch ($Line.Substring(0,1))
      {
        # > = Commands, : = Input Extensions, ; = Output Extension, - = Output Folder
        '>' { $CLIGridView.Rows.Add($LineValue) }
        ':' { $CLIInputExtensionsBox.Text = $LineValue }
        ';' { $CLIOutputExtensionBox.Text = $LineValue }
        '-' { $CLIOutFolderNameBox.Text   = $LineValue }
      }
    }
  }
  # Update the global variable to the selected item.
  $global:CustomCLISelected = $this.SelectedItem
}
#==============================================================================================================================================================================================
#  Adds a custom CLI executable with the [+] button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddCustomCLIExecutable()
{
  # Ask the user to select a file.
  $SelectedFile = Get-FileName -StartPath $BaseFolder -FileName '*.*' -Description 'Executable File'

  # Check to see if a file was selected and that it exists and exit if not.
  if (($SelectedFile -eq '') -or (!(TestPath -LiteralPath $SelectedFile))) { return }

  # Get the executable as an item.
  $ExeItem = Get-Item -LiteralPath $SelectedFile

  # Create an empty string list to recreate the ini file.
  $NewCLISettings = New-Object Collections.Generic.List[string]

  # If the INI already exists then read from it.
  if (TestPath -LiteralPath $CustomExecutables)
  {
    # Load the ini file that stores the custom CLI executables.
    $CLISettings = Get-Content -LiteralPath $CustomExecutables

    # Loop through each line in the settings file.
    foreach ($Line in $CLISettings)
    {
      # Create a perfect copy of the ini file as its being looped through.
      $NewCLISettings.Add($Line)

      # See if the ini file already contains this executable.
      if ($Line -like ('~*' + $ExeItem.Name + '*'))
      {
        # Set up title and error message.
        $Title   = 'Error: Duplicate Entry'
        $Message = 'The selected file already exists in the executable list.'

        # Show the dialog to the user.
        ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 18) -OffsetY (DPISize 18) -Message $Message

        # Nothing left to do except make like a tree and... LEAVE! hahahah
        return
      }
    }
  }
  # Add the new program to the ini file.
  $NewCLISettings.Add(('~' + $SelectedFile))

  # Replace the file with the modified content.
  Set-Content -LiteralPath $CustomExecutables -Value $NewCLISettings

  # Add the executable to the combobox and select it which forces an update.
  $CLIProgramCombo.Items.Add($ExeItem.Name) | Out-Null
  $CLIProgramCombo.SelectedItem = $ExeItem.Name

  # Reset the extension textboxes.
  $CLIInputExtensionsBox.Text = ''
  $CLIOutputExtensionBox.Text = ''
  $CLIOutFolderNameBox.Text   = 'CustomExecutable'
}
#==============================================================================================================================================================================================
#  Removes a custom CLI executable with the [-] button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RemoveCustomCLIExecutable()
{
  # Set the title and message of the Yes/No dialog.
  $Title   = 'Remove Executable'
  $Message = 'Are you sure you want to remove the selected executable and its properties from the list?'

  # Show the dialog to the user and exit if the user says no.
  if (!(ShowYesNoDialog -Title $Title -SizeX (DPISize 270) -SizeY (DPISize 30) -OffsetX (DPISize 34) -OffsetY (DPISize 12) -Message $Message)) { return }

  # Get the file that stores the custom executables.
  $CLISettings = Get-Content -LiteralPath $CustomExecutables

  # Create an empty string list to recreate the ini file.
  $NewCLISettings = New-Object Collections.Generic.List[string]

  # Set the entry to whatever is currently selected.
  $Index = $CLIProgramCombo.SelectedIndex

  # Make sure there is actually a selected item.
  if ($CustomCLISelected -eq $null) { return }

  # Loop through each line in the settings file.
  foreach ($Line in $CLISettings)
  {
    # When a line with a program is found.
    if ($Line -like '~*')
    {
      # If it contains the program to remove.
      if ($Line -like ('*' + $CustomCLISelected + '*'))
      {
        # Set the delete flag to true to remove it and all of its properties.
        $DeleteData = $true
      }
      # If it's a different program in the list.
      else
      {
        # Set the delete flag to false so info gets copied into the new file.
        $DeleteData = $false
      }
    }
    # If not deleting data then copy the line into the new file.
    if (!$DeleteData) { $NewCLISettings.Add($Line) }
  }
  # Replace the file with the modified content.
  Set-Content -LiteralPath $CustomExecutables -Value $NewCLISettings

  # Remove the entry from the combobox.
  $CLIProgramCombo.Items.Remove($CustomCLISelected) | Out-Null

  # Select the program at the top of the list.
  $CLIProgramCombo.SelectedItem = $CLIProgramCombo.Items[$Index-1]
}
#==============================================================================================================================================================================================
#  OPERATION 29: RUN CUSTOM CLI EXECUTABLE WITH CTT-PS - MASTER LOOP OPERATION
#==============================================================================================================================================================================================
#  This is the function that is called from the MasterLoop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunCustomCLIExecutable()
{
  # First the input extensions must be checked but only if they exist.
  if ($CLIInputExtensionsBox.Text -ne '')
  {
    # Create an empty string array to store the extensions.
    $Extensions = New-Object Collections.Generic.List[string]

    # Split the extensions textbox on spaces and commas.
    $InputExtSplit = $CLIInputExtensionsBox.Text.Split(' ,')

    # Check each entry and make sure it's an extension.
    foreach($Split in $InputExtSplit)
    {
      # Make sure the string is not empty.
      if (($Split -eq '') -or ($Split -eq $null)) { continue }

      # Make sure that the first character is a period.
      if ($Split.Substring(0,1) -ne '.') { continue }

      # If it passed the above checks then add it to the list of valid extensions.
      $Extensions.Add($Split)

      # See if the user posted a wildcard.
      if ($Split -eq ".*") { break }
    }
    # Check for the wildcard.
    if ($Extensions -notcontains ".*")
    {
      # If the input extension is not in the list of supported extensions then skip this file.
      if ($Extensions -notcontains $Texture.Extension)
      {
        # Show the user that the file extension was the reason it failed.
        TexList_SetTextureStatus -Status 'Skipped' -Message 'File extension not in "Input Extensions"'
      }
    }
  }
  # Set up some arguments for the user.
  $InputBase       = $Texture.Name
  $InputName       = $Texture.FullName
  $InputPath       = $Texture.Path
  $InputFile       = $Texture.FullPath
  $OutputBase      = $Texture.Name
  $OutputName      = $Texture.Name + $CLIOutputExtensionBox.Text
  $OutputPath      = CreatePath -LiteralPath ($MasterOutputPath + '\' + $CLIOutFolderNameBox.Text + $Texture.Relative)
  $OutputFile      = $OutputPath + '\' + $OutputName
  $ImageWidth      = $Texture.Width
  $ImageHeight     = $Texture.Height
  $ImageDimensions = $Texture.Dimensions
 
  # Also create multiplied versions of the dimensions up to x8 (for example, if 100 width, $ImageWidthx4 is 400).
  for ($i=2 ; $i -lt 9 ; $i++)
  {
    # Set both a multiplied version of the width and height.
    Set-Variable -Name ('ImageWidthx'+$i.ToString()) -Value ($Texture.Width * $i)
    Set-Variable -Name ('ImageHeightx'+$i.ToString()) -Value ($Texture.Height * $i)
    Set-Variable -Name ('ImageDimensionsx'+$i.ToString()) -Value (($Texture.Width * $i).ToString() + 'x' + ($Texture.Height * $i).ToString())
  }
  # Load the ini file that stores the custom CLI executables.
  $CLISettings = Get-Content -LiteralPath $CustomExecutables

  # Loop through each line in the settings file.
  foreach ($Line in $CLISettings)
  {
    # See if the ini file already contains this executable.
    if ($Line -like ('~*' + $CustomCLISelected + '*'))
    {
      # The ini file stores the full path to the program.
      $CLIProgram = $Line.Substring(1,($Line.Length - 1))
    }
  }
  # Build an empty list of strings to add arguments to.
  $TempArgs  = New-Object Collections.Generic.List[string]
  $Arguments = New-Object Collections.Generic.List[string]

  # Build a list of arguments. Loop through each row on the command grid.
  foreach ($Row in $CLIGridView.Rows)
  {
    # Make sure something was actually entered here.
    if (($Row.Cells[0].Value -ne '') -and ($Row.Cells[0].Value -ne $null))
    {
      # Add the command to the arguments list.
      $TempArgs.Add($Row.Cells[0].Value)
    }
  }
  # Now to assemble the list of arguments into something usable.
  foreach ($Arg in $TempArgs)
  {
    # User may enter variables so attempt to expand them here.
    if ($Arg -like '*$*')
    {
      # Replace the argument with an expanded version.
      $Arg = $ExecutionContext.InvokeCommand.ExpandString($Arg)
    }
    # Add the argument to the final list.
    $Arguments.Add($Arg)
  }
  # So now that we have the full list of arguments, run the program.
  $ProgramOutput = & $CLIProgram $Arguments

  # Check to see if the file was created.
  switch (TestPath -LiteralPath $OutputFile)
  {
    # If it exists its a success, if it doesn't exist then it's a failure.
    $true  { TexList_SetTextureStatus -Status 'OK'   -Message 'File Successfully Created' }
    $false { TexList_SetTextureStatus -Status 'Fail' -Message 'File Failed Creation'      }
  }
}
#==============================================================================================================================================================================================
#  OPERATION 30: EXTRACT WITH DOLPHINEXTRACTION TOOL
#==============================================================================================================================================================================================
#  Takes the feedback generated during the loop, splits it up, and adds that information to the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddFeedbackToTextureList([Collections.Generic.List[string]]$JobFeedback)
{
  # Loop through all the feedback obtained so far.
  foreach ($Feedback in $JobFeedback)
  {
    # Make sure this feedback has not already been used.
    if ($UsedFeedback -notcontains $Feedback)
    {
      # Increment the number of textures found.
      $global:TextureCount++
      $global:TexListPosition++
    
      # If it hasn't, add it to the list to not show again.
      $UsedFeedback.Add($Feedback)

      # Split the feedback on semi-colons which is what I used to parse through the data.
      $TexProperties = $Feedback.Split(';')

      # Set the data into readable names.
      $Progress = $TexProperties[0]
      $Name     = $TexProperties[1]
      $Width    = $TexProperties[2]
      $Height   = $TexProperties[3]
      $Aspect   = $TexProperties[4]
      $Mipmaps  = $TexProperties[5]
      $Location = $TexProperties[6]

      # Use a dash instead of a zero for no mipmaps.
      if ($Mipmaps -eq '0') { $Mipmaps = '-' }

      # Combine the width and height.
      $Dimensions = $Width + "x" + $Height

      # Print the properties to the texture list.
      $NewListEntry = @($Name, $Dimensions, $Mipmaps, "1.00x1.00", $Aspect, "-", $Location)

      # Add the data to the texture list.
      TexList_UpdateList -Entry $NewListEntry

      # For some reason, setting texture status was not working every loop so do it manually.
      TexList_SetTextureStatus -Status "OK" -Message "Texture extraction successful."

      # Report to the user that the texture was created.
      TexList_UpdateTexture -TextureInfo $null

      # Update the texture list with the number of textures converted so far.
      TexList_UpdateStatus -Status 'TextureCount' -Value $TextureCount.ToString()

      # Update the current progress.
      TexList_UpdateStatus -Status 'Progress' -Value $Progress

      # See if the user has auto-scrolling enabled.
      TexList_AutoScroll
    }
    # Perform "DoEvents" so the dialog refreshes itself.
    [Windows.Forms.Application]::DoEvents()

    # Check to see if the loop was cancelled.
    if ($CancelMasterLoop) { return }
  }
}
#==============================================================================================================================================================================================
#  This is a bit of multi-threaded trickery. For each iteration of the extraction tool loop, start a new PowerShell instance to read the feedback from the extraction tool job and parse it
#  into usable data. This can take time so it's best not to clog up the main instance with it. This function may start several background PowerShell instances at a time. Each loop iteration
#  the status of all current jobs is checked. When they are complete, the feedback that received is added to a "total" array that collects all feedback received.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StoreFeedbackToList([string[]]$Feedback, [int]$LoopIteration)
{
  # Code block to handle feedback from TextureExtraction tool from the current loop iteration.
  $GetFeedback = {

    # The parameters required to get the correct information back.
    Param ( [string[]]$Feedback, [int]$LoopIteration, [string]$OutputPath )

    # This function can not be accessed in the job so lazily copy it here.
    function CalculateAspectRatio([int]$Width, [int]$Height)
    {
      $Aspect = ($Width / $Height).ToString()
      if ($Aspect -like '*,*')
      {
        $Aspect = $Aspect.Replace(',','.')
      }
      $PeriodSplit = $Aspect.Split('.', 2)
      $IntValue = ([int]$PeriodSplit[0]).ToString()
      $DecValue = $PeriodSplit[1]
      $DecimalPlaces = (($DecValue | Measure-Object -Character).Characters).ToString()
      switch ($DecimalPlaces)
      {
        '0'     { $AspectRatio = $IntValue }
        '1'     { $AspectRatio = $IntValue + '.' + $DecValue }
        default { $AspectRatio = $IntValue + '.' + $DecValue.Substring(0,2) }
      }
      return $AspectRatio
    }
    # Loop through all lines in the feedback.
    foreach ($Line in $Feedback)
    {
      # We only want progress lines to skip ones that don't have it.
      if ($Line -notlike "Prog*") { continue }

      # Split on the first space to break the line in two.
      $CategorySplit = $Line.Split(' ',2)

      # Split the progress on the colon to get the value.
      $ProgressSplit = $CategorySplit.Split([char[]]@(':',',','.'))

      # Splits on (.) to get both the texture and the mipcount separated.
      $TexMipSplit = $CategorySplit[1].Split('.',2)

      # Get the mipmaps and its count away from everything else.
      $ExtMipSplit = $TexMipSplit[1].Split(' ',3)

      # Get the count away from mipmaps.
      $MipmapSplit = $ExtMipSplit[1].Split(':')

      # Get the path to the texture as reported by TextureExtraction Tool.
      $TexLocation = $TexMipSplit[0].Replace("Extract:","") + '.png'

      # Split the path on slashes to get just the texture.
      $SplitFolder = $TexLocation.Split("\")

      # Split the texture name on the underscores to get the dimensions.
      $SplitForDim = $SplitFolder[$SplitFolder.Count-1].Split('_')

      # Now split the dimensions on the "x" to get the width and height.
      $SplitTexDim = $SplitForDim[1].Split('x')

      # Now get the values from all these splits: texture path / mipmap count.
      $ProgPercent = $ProgressSplit[1].Replace("%","")
      $TextureName = $SplitFolder[$SplitFolder.Count-1]
      $TexInitPath = $OutputPath + '\' + $TexLocation.Replace($TextureName,"")
      $MipmapCount = $MipmapSplit[1]
      $TexFullPath = $TexInitPath + $TextureName

      # Get the texture dimensions.
      $Width  = $SplitTexDim[0]
      $Height = $SplitTexDim[1]
      $Aspect = (CalculateAspectRatio -Width $Width -Height $Height) + ":1"

      # Send all the parsed information back using semicolons to separate it. The info can be split on the semicolons later.
      Write-Output ($ProgPercent + ';' + $TextureName + ';' + $Width + ';' + $Height + ';' + $Aspect + ';' + $MipmapCount + ';' + $TexInitPath)
    }
   }
  # Start a new job for each time the loop iteration gets feedback from the extraction tool.
  $Job = Start-Job -Name ("FeedbackJob_" + $LoopIteration.ToString()) -Scriptblock $GetFeedback -ArgumentList $Feedback,$LoopIteration,$MasterOutputPath

  # Add this job to the tracking array so the status can be checked each loop iteration.
  $FeedbackTracker.Add($LoopIteration.ToString())
}
#==============================================================================================================================================================================================
#  The script will hang out here while the tool runs in the background. The timer will attempt to update the build the list as the main thread is stuck here updating the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexExtractLoop()
{
  # Get the status of the job before going into the loop.
  $JobStatus = (Get-Job -Name 'TexExtract' -ErrorAction 'SilentlyContinue').State

  # Count the number of times it looped.
  $LoopCount = 0

  # Tracks any currently running feedback jobs. When a job is started it is added to this list.
  $FeedbackTracker = New-Object Collections.Generic.List[string]
  $UsedFeedback    = New-Object Collections.Generic.List[string]

  # Stores all feedback received from all feedback jobs.
  $TotalFeedback   = New-Object Collections.Generic.List[string]

  # Hang out here while the application is running.
  while (($JobStatus -ne 'Completed') -or ($FeedbackTracker.Count -gt 0) -or $UpdatingFeedback)
  {
    # Get the status of the job before going into the next iteration.
    $CurrentJob = Get-Job -Name 'TexExtract' -ErrorAction 'SilentlyContinue' 

    # Break early if the job no longer exists.
    if ($CurrentJob -eq $null) { break }

    # Display that we're in the job loop.
    DebugMessage -Message '<< Extract Loop Iteration >>'

    # Get any feedback the job may have had.
    $JobFeedback = Receive-Job -Job $CurrentJob

    # If there was feedback then store it to a list.
    if ($JobFeedback) { StoreFeedbackToList -Feedback $JobFeedback -LoopIteration $LoopCount }

    # An array that stores all feedback jobs to remove after they are finished executing.
    $ToRemove = New-Object Collections.Generic.List[string]

    # Loop through all the possible feedback jobs.
    foreach ($Tracker in $FeedbackTracker)
    {
      # Get the first job with feedback.
      $FeedbackJob = Get-Job -Name ("FeedbackJob_" + $Tracker) -ErrorAction 'SilentlyContinue'

      # Get any currently running feedback jobs.
      $FeedbackStatus = ($FeedbackJob).State

      # Check to see if the job is complete.
      if ($FeedbackStatus -eq "Completed")
      {
        # If completed, get the feedback it output.
        $Received = Receive-Job -Job $FeedbackJob

        # Add all that feedback to the total feedback.
        foreach ($Partial in $Received)
        {
          $TotalFeedback.Add($Partial)
        }
        # The job is complete so add it to the list to be removed.
        $ToRemove.Add($Tracker)

        # Now get rid of the job.
        Remove-Job -Job $FeedbackJob
      }
    }
    # Loop through all feedback jobs to remove from the main list.
    foreach ($Remove in $ToRemove)
    {
      # If it's not empty, remove the feedback job.
      $FeedbackTracker.Remove($Remove)
    }
    # See if any feedback was added this iteration.
    if ($TotalFeedback.Count -gt 0)
    {
      # If it was, then add it to the texture list.
      AddFeedbackToTextureList -JobFeedback $TotalFeedback
    } 
    # Get the status of the job before going into the next iteration.
    $JobStatus = $CurrentJob.State

    # Increment the loop count.
    $LoopCount++

    # Check to see if the loop was cancelled.
    if ($CancelMasterLoop) 
    {
      # All jobs need to be stopped and removed or we will have problems.
      foreach ($Tracker in $FeedbackTracker)
      {
        # Remove all the feedback jobs.
        Stop-Job   -Name ("FeedbackJob_" + $Tracker) -ErrorAction 'SilentlyContinue'
        Remove-Job -Name ("FeedbackJob_" + $Tracker) -ErrorAction 'SilentlyContinue'

        # And remove the main job.
        Stop-Job   -Name 'TexExtract' -ErrorAction 'SilentlyContinue'
        Remove-Job -Name 'TexExtract' -ErrorAction 'SilentlyContinue'
      }
      # Now that has been taken care of, leave.
      return
    }
  }
  # Now that the job is finished, clean it up.
  Remove-Job -Name 'TexExtract' -ErrorAction 'SilentlyContinue'

  # Debug:Let me know the job loop ended.
  DebugMessage -Message '--- Extract Loop Ended'
}
#==============================================================================================================================================================================================
#  TextureExtraction Tool requires the exact path to the disc folder, so if the OutputPath is within the MasterInputPath then we have a problem.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FindExtractedDiscFilePath()
{
  # Build a collection of disc images and/or folders to extract stuff from.
  $DiscCollection = New-Object Collections.Generic.List[string]

  # First lets look for files in the MasterInputPath that match disc images.
  $DiscImages = EnumerateFiles -LiteralPath $MasterInputPath -Filter "*.iso"

  # Loop through any number of discs that are found.
  foreach ($Disc in $DiscImages)
  {
    # Add the disc to the collection.
    $DiscCollection.Add($Disc)
  }
  # Now we check for folders with extracted disc contents. Start by adding a wildcard to the input path.
  $OutputCheck = $MasterInputPath + "*"

  # If the output path is within the input path then we're in trouble.
  if ($MasterOutputPath -like $OutputCheck)
  {
    # Get all folders within the MasterInputPath.
    $FolderCollection = EnumerateFolders -LiteralPath $MasterInputPath

    # Loop through all folders in the path.
    foreach ($Folder in $FolderCollection)
    {
      # The tilde character usually represents the output path so skip that.
      if ($Folder -like "*~*") { continue }

      # Add the folder to the collection.
      $DiscCollection.Add($Folder)
    }
  }
  # If the output path is not in the input path, then use the input path directly.
  else
  {
    # The MasterInputPath points directly to a game folder.
    $DiscCollection.Add($MasterInputPath)
  }
  # Return the collection of disc images found.
  return $DiscCollection
}
#==============================================================================================================================================================================================
#  This is the function that is called from the MasterLoop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExtractDiscTextures_Start()
{
  # Keep track of the number of textures that were extracted.
  $global:TextureCount = 0
  $global:TexListPosition = 0

  # Only show the main GUI in "Docked Mode" since it contains the texture list. Show the texture list if it's not in "Docked Mode".
  $MainDialog.Visible    = ($TextureListMode -eq 'Docked')
  $TexListDialog.Visible = ($TextureListMode -ne 'Docked')

  # Fake the masterloop running.
  $global:MasterLoopRunning = $true
  $global:CancelMasterLoop  = $false

  # Clear the texture list.
  TexList_SetInitialState -Rows 10000

  # Start the timer that tracks the amount of time the operation takes to complete.
  TexList_StartTimer

  # Disable the GUI while extracting textures.
  ToggleDialogStates -State $false

  # Enable the cancel button.
  $TexListCancelButton.Enabled = $true

  # Set visibility of the progress indicating shit.
  $TexListTexLabel.Visible   = $true
  $TexListTexValue.Visible   = $true
  $TexListProgLabel.Visible  = $true
  $TexListProgBar.Visible    = $true
  $TexListProgValue.Visible  = $true
  $TexListTimerLabel.Visible = $true
  $TexListTimerValue.Visible = $true

  # Update the number of textures to the amount that was counted.
  TexList_UpdateStatus -Status 'TextureCount' -Value '0'
  TexList_UpdateStatus -Status 'Operation'    -Value $TexListOperation
  TexList_UpdateStatus -Status 'Timer'        -Value '0'
  TexList_UpdateStatus -Status 'Progress'     -Value '0'

  # Create an array of commands to send to the application.
  $ExtractCommands = New-Object Collections.Generic.List[string]

  # Make things a bit more readable with this variable.
  $Tasks = $ExtractTasksCount.ToString()

  # Set the commands selected by the user.
  if ($ExtractForceUnknown)  { $ExtractCommands.Add("-force") }
  if ($ExtractRawImages)     { $ExtractCommands.Add("-raw") }
  if ($ExtractCombineRGBA)   { $ExtractCommands.Add("-rgba") }
  if ($ExtractTasksEnable)   { $ExtractCommands.Add("-tasks") }
  if ($ExtractTasksEnable)   { $ExtractCommands.Add($Tasks) }
  if ($ExtractTexMipmaps)    { $ExtractCommands.Add("-mip") }
  if ($ExtractDolphinMipmap) { $ExtractCommands.Add("-dmd") }
  if ($ExtractArbMipmap)     { $ExtractCommands.Add("-amd") }

  # The user selected a custom clean amount.
  if ($ExtractCleanType -eq "Custom")
  {
    # Internally, custom is "group" and needs a numeric value to specify the number of folders to trim back.
    $ExtractCommands.Add("-cleanup:group")
    $ExtractCommands.Add($ExtractCleanCount.ToString())
  }
  else
  {
    # There are options available for cleanup so concatenate the string with the chosen option.
    $Cleanup = "-cleanup:" + $ExtractCleanType.ToLower()
    $ExtractCommands.Add($Cleanup)
  }
  # These commands are always added as either CTT-PS relies on them or they have no toggle.
  $ExtractCommands.Add("-progress:list")
  $ExtractCommands.Add("-log")
  $ExtractCommands.Add('"' + $BaseFolder +'"')

  # Get a collection of disc images found within the "MasterInputPath". Can be files or folders.
  $DiscCollection = FindExtractedDiscFilePath

  # Loop through the potential discs.
  foreach ($InputDisc in $DiscCollection)
  {
    # Get the path as an item so properties can be referenced.
    $DiscName = (Get-Item -LiteralPath $InputDisc).BaseName
  
    # Set the output path to where textures will be extracted.
    $OutputPath = $MasterOutputPath + '\DolphinConverted' + "\" + $DiscName

    # Override the MasterInputPath and MasterOutputPath until the next iteration.
    MasterPaths_Override -InputPath $InputDisc -OutputPath $OutputPath

    # Make sure the output path is empty before trying to extract files to it.
    RemovePath -LiteralPath $MasterOutputPath 

    # Rereate the output path after removal.
    CreatePath -LiteralPath $MasterOutputPath -NoReturn

    # Run the texture extraction tool in a new thread.
    TextureExtractionTool -Operation "extract" -InputPath $MasterInputPath -OutputPath $MasterOutputPath -Commands $ExtractCommands

    # Restore the master input and output paths.
    MasterPaths_Restore
  }
  # The fake master loop is now finished.
  $global:MasterLoopRunning = $false
  $TexListCancelButton.Enabled = $false

  # Change the progress bar back to the continuous style every other operation uses.
  $TexListProgBar.Style = [Windows.Forms.ProgressBarStyle]::Continuous

  # Enable the Dock/Exit buttons on the texture list.
  $TexListCloseButton.Enabled = $true
  $MainProcessButton.Enabled = $true
  $TexListProcessButton.Enabled = $true

  # Change the "Pause" button to a second "Start" button.
  $TexListStartButton.Text = 'Start'
  $TexListStartButton.Enabled = $true

  # Check to see if "Docked Mode" is enabled.
  if ($TextureListMode -eq 'Docked')
  {
    # Also enable all the panels containing options.
    $MainDockedPanelA.Enabled = $true
    $MainDockedPanelB.Enabled = $true
    $MainDockedPanelC.Enabled = $true
  }
  # Set the rows to the number of textures counted (+1 to count for the header rows).
  $TexListCatalog.RowCount = $TexListPosition + 1
  
  # Set the operation to "Completed" status.
  TexList_UpdateStatus -Status 'Progress'  -Value '100'

  # Now that we are done enable the GUI.
  ToggleDialogStates -State $true

  # Show the main dialog and force it forward.
  ActivateDialog -Dialog $MainDialog

  # If the loop was canceled this may still be hanging around.
  $TexListWaitLabel.Visible = $false

  # Unhide the main dialog.
  $MainDialog.Visible = $true

  # If the loop was cancelled we don't want this stuff.
  if (!$CancelMasterLoop)
  {  
    # Print something to the main window.
    TexList_AddString -TexEntry " "
    TexList_AddString -TexEntry ("Total of " + $TextureCount + " textures extracted/converted to PNG.")
  }
  # Do the final update on the texture list.
  TexList_UpdateFinal

  # Unhide the texture list if invisible for whatever reason.
  if ($TextureListMode -ne 'Window') { $TexListDialog.Visible = $false }
}
#==============================================================================================================================================================================================
#  MASTER LOOP: COPY NON-TEXTURES
#==============================================================================================================================================================================================
#  Set of conditions to check whether or not to copy a "non-texture file".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckNonTextureFile($file)
{
  # Another hacked-in line of code. If working with phyre images, and the user only wants to scan, don't copy anything.
  if (($PhyreOnlyScan) -and (($MasterOperation -eq 'ConvertPhyrePNG') -or ($MasterOperation -eq 'CreateFromPhyre'))) { return $false }

  # The valid operations for copying non-texture files.
  $OperationCheck = @('ConvertTextures', 'RescaleTextures', 'ResolutionScale', 'ConvertPhyrePNG', 'CreateFromPhyre')

  # Only copy non-texture files if the user is converting, rescaling, or working with phyre textures.
  if (($OperationCheck -contains $MasterOperation) -and (!$file.PSIsContainer) -and ($file.Name.Length -gt 0))
  {
    # Fail immediately if the path has a tilde, but only if the Master paths were not overridden.
    if ((!$PathsNeedRestore) -and ($file.DirectoryName -like '*~*')) { return $false }

    # Build a series of checks to make sure we are not in the master tools path.
    $FileInToolsPath = New-Object bool[] 5
    $FileInToolsPath[0] = ($ToolsMasterPath -ne '')
    $FileInToolsPath[1] = (TestPath -LiteralPath $ToolsMasterPath)
    $FileInToolsPath[2] = ($file.DirectoryName -like ('*' + $ToolsMasterPath + '*'))
    $FileInToolsPath[3] = ($file.DirectoryName -like ('*' + $BaseFolder + '*'))
    $FileInToolsPath[4] = ($file.DirectoryName -like ('*' + $MasterInputPath + '*'))

    # All conditions pass, which means this file is within a tool path.
    if (TestBooleanArray -And -Array $FileInToolsPath) { return $false }

    # Build a list of all exclusions that will fail the file.
    $Exclusions = New-Object string[] 17               # Files not to Copy:
    $Exclusions[0] = '*tex1*.png'                      # - Dolphin PNG textures.
    $Exclusions[1] = '*tex1*.dds'                      # - Dolphin DDS textures.
    $Exclusions[2] = '*tex1*.jpg'                      # - Dolphin JPG textures.
    $Exclusions[3] = '*.png.phyre'                     # - Phyre engine PNG textures (The Legend of Heroes: Trails of Cold Steel).
    $Exclusions[4] = '*.dds.phyre'                     # - Phyre engine DDS textures (The Legend of Heroes: Trails of Cold Steel).
    $Exclusions[5] = '*.bmp.phyre'                     # - Phyre engine BMP textures (The Legend of Heroes: Trails of Cold Steel).
    $Exclusions[6] = '*.header'                        # - Phyre engine header reference (The Legend of Heroes: Trails of Cold Steel).
    $Exclusions[8] = '*.pkg'                           # - Falcom compressed archives (The Legend of Heroes: Trails of Cold Steel).
    $Exclusions[7] = '*_mip*'                          # - Lower mipmap levels (_mip1, _mip2, _mip3, etc).
    $Exclusions[9] = '*.tdb'                           # - Custom Texture Tool PS "Texture Database" file.
    $Exclusions[10] = '*.ps1'                          # - PowerShell scripts.
    $Exclusions[11] = '*.log'                          # - Log files.
    $Exclusions[12] = '*desktop.ini'                   # - Windows garbage files.
    $Exclusions[13] = '*thumbs.db'                     # - More Windows garbage files.
    $Exclusions[14] = '*CTT-PS*'                       # - Anything CTT-PS, more specifically the changelog.
    $Exclusions[15] = '*Custom Texture Tool PS*'       # - CTT-PS launcher executable.
    $Exclusions[16] = '*PS*Execution*Policy*'          # - Included Batch script to modify PowerShell execution policy.

    # Loop through the list of exclusions.
    foreach ($Check in $Exclusions)
    {
      # See if the file name contains the exclusion.
      if ($file.Name -like $Check) { return $false }
    }
    # If it made it this far, copy the file.
    return $true
  }
  # If it didn't pass the initial checks then do not copy the file.
  return $false
}
#==============================================================================================================================================================================================
#  Copies a "non-texture file" if it passes all the checks in the above function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AttemptCopyNonTextureFile($file)
{
  # Copy Non-Textures must be enabled, or it's forced when working with Phyre images.
  $CopyCondition = New-Object bool[] 2
  $CopyCondition[0] = ($CopyNonTextures)
  $CopyCondition[1] = ($file.Name -eq "asset_D3D11.xml")

  # Perform rigorous testing to see if the file should be copied.
  if (($CopyCondition) -and (CheckNonTextureFile -file $file))
  {
    # Add the output folder to the copy path if any type of conversion is going on.
    switch ($MasterOperation)
    {
      'ConvertTextures' { $ExtraText = '\ConvertedTextures' + $OutputFormatLabel }
      'RescaleTextures' { $ExtraText = '\RescaledTextures' + $OutputFormatLabel }
      'ResolutionScale' { $ExtraText = '\ResizedTextures' + $OutputFormatLabel }
      'ConvertPhyrePNG' { $ExtraText = '\ConvertedPhyre' }
      'CreateFromPhyre' { $ExtraText = '\CreatedPhyre' }
      default           { $ExtraText = '' }
    }
    # Create the folder structure of where the file should go.
    $Relative = $file.DirectoryName.Replace($MasterInputPath,'')
    $CopyPath = CreatePath -LiteralPath ($MasterOutputPath + $ExtraText + $Relative)

    # Add the file to the texture list for viewing.
    TexList_AddFile -File $file -Status 'File' -Message ('Non-texture File Copied to: ' + $ExtraText + $Relative)

    # Copy the file into the new location.
    Copy-Item -LiteralPath $file.FullName -Destination $CopyPath -Force
  }
}
#==============================================================================================================================================================================================
#  MASTER LOOP: AUTO-RENAME OUTPUT PATH
#==============================================================================================================================================================================================
#  If the user entered a custom name from the GUI when rescaling or converting textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AutoRenameOutputPath()
{
  # Check to see if convert textures was enabled and if the user entered a custom folder name.
  if (($MasterOperation -eq 'ConvertTextures') -and ($AutoRenameValue -ne ''))
  {
    # Include the format in the output folder.
    $RenamePath  = $MasterOutputPath + '\ConvertedTextures' + $OutputFormatLabel
    $NewNamePath = $MasterOutputPath + '\' + $AutoRenameValue

    # Use Move-Item to rename the folder because PS 2.0 does not like -LiteralPath in Rename-Item.
    Move-Item -LiteralPath $RenamePath -Destination $NewNamePath -Force
  }
  # Check to see if rescale textures was enabled and if the user entered a custom folder name.
  elseif (($MasterOperation -eq 'RescaleTextures') -and ($AutoRenameValue -ne ''))
  {
    # If a format was forced, include the format in the folder name.
    $RenamePath  = $MasterOutputPath + '\RescaledTextures' + $OutputFormatLabel
    $NewNamePath = $MasterOutputPath + '\' + $AutoRenameValue

    # Use Move-Item to rename the folder because PS 2.0 does not like -LiteralPath in Rename-Item.
    Move-Item -LiteralPath $RenamePath -Destination $NewNamePath -Force
  }
  # Check to see if resize textures was enabled and if the user entered a custom folder name.
  elseif (($MasterOperation -eq 'ResolutionScale') -and ($AutoRenameValue -ne ''))
  {
    # If a format was forced, include the format in the folder name.
    $RenamePath  = $MasterOutputPath + '\ResizedTextures' + $OutputFormatLabel
    $NewNamePath = $MasterOutputPath + '\' + $AutoRenameValue

    # Use Move-Item to rename the folder because PS 2.0 does not like -LiteralPath in Rename-Item.
    Move-Item -LiteralPath $RenamePath -Destination $NewNamePath -Force
  }
}
#==============================================================================================================================================================================================
#  MASTER LOOP: REMOVE EMPTY FOLDERS IN MASTER OUTPUT PATH
#==============================================================================================================================================================================================
#  Some options can move textures around or even write them in-place. This function tests for empty folders in the "Master Output Path" and removes them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CleanMasterOutputPath()
{
  # Check to see if the user has this enabled.
  if ($AutoCleanOutput)
  {
    # Make sure the output path exists before actually trying to remove anything out of it.
    if (!(TestPath -LiteralPath $MasterOutputPath)) { return }

    # Get all folders in the Master Output Path including the path itself.
    $Directories = @($MasterOutputPath)
    $Directories += EnumerateFolders -LiteralPath $MasterOutputPath -Recurse

    # Loop through all folders in the master output path and delete any folders that may be empty.
    foreach ($Directory in $Directories)
    {
      # Get the number of files in the folder.
      $Files = EnumerateFiles -LiteralPath $Directory -Recurse

      # If no files are found in the folder then remove the folder.
      if ($Files.Count -eq 0) { RemovePath -LiteralPath $Directory }
    }
  }
}
#==============================================================================================================================================================================================
#  MASTER LOOP: HANDLE EXCLUSIONS
#==============================================================================================================================================================================================
#  Checks all the exclusion settings and returns whether or not the texture should be created.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckExclusions()
{
  # Verify that the extension is not excluded.
  if ((!$ExcludePNG) -and ($Texture.Extension -eq $PNG))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'PNG textures are excluded.' ; return $false }
  if ((!$ExcludeDDS) -and ($Texture.Extension -eq $DDS))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'DDS textures are excluded.' ; return $false }
  if ((!$ExcludeJPG) -and ($Texture.Extension -eq $JPG))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'JPG textures are excluded.' ; return $false }
  if ((!$ExcludeTGA) -and ($Texture.Extension -eq $TGA))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'TGA textures are excluded.' ; return $false }
  if ((!$ExcludeTIF) -and ($Texture.Extension -eq $TIF))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'TIF textures are excluded.' ; return $false }
  if ((!$ExcludeTIF) -and ($Texture.Extension -eq $TIFF)) { TexList_SetTextureStatus -Status 'Excluded' -Message 'TIFF textures are excluded.' ; return $false }

  # Verify the mipmap selections.
  if ((!$ExcludeIsMipmap)  -and ($Texture.IsMipmap))      { TexList_SetTextureStatus -Status 'Excluded' -Message 'Mipmap [m] textures are excluded.'   ; return $false }
  if ((!$ExcludeHasMipmap) -and ($Texture.Mipmaps -gt 0)) { TexList_SetTextureStatus -Status 'Excluded' -Message 'Textures with mipmaps are excluded.' ; return $false }

  # Verify the alpha channel selections.
  if ((!$ExcludeNoAlpha)  -and (!$Texture.Alpha))         { TexList_SetTextureStatus -Status 'Excluded' -Message 'Textures without an alpha channel are excluded.' ; return $false }
  if ((!$ExcludeHasAlpha) -and ($Texture.Alpha))          { TexList_SetTextureStatus -Status 'Excluded' -Message 'Textures with an alpha channel are excluded.'    ; return $false }

  # Verify the material map selections.
  if ((!$ExcludeHasMats)    -and ($Texture.HasMats))      { TexList_SetTextureStatus -Status 'Excluded' -Message 'Textures with materials (bump/spec/nrm/lum) are excluded.' ; return $false }
  if ((!$ExcludeHasMatMaps) -and ($Texture.HasMatMaps))   { TexList_SetTextureStatus -Status 'Excluded' -Message 'Textures with material maps (mat) are excluded.'           ; return $false }

  # Verify the minimum dimensions.
  if (($ExcludeMinWidth  -gt 0) -and ($Texture.Width  -lt $ExcludeMinWidth))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'Texture width less than minimum width.'   ; return $false }
  if (($ExcludeMinHeight -gt 0) -and ($Texture.Height -lt $ExcludeMinHeight)) { TexList_SetTextureStatus -Status 'Excluded' -Message 'Texture height less than minimum height.' ; return $false }

  # Verify the maximum dimensions.
  if (($ExcludeMaxWidth  -gt 0) -and ($Texture.Width  -gt $ExcludeMaxWidth))  { TexList_SetTextureStatus -Status 'Excluded' -Message 'Texture width greater than maximum width.'   ; return $false }
  if (($ExcludeMaxHeight -gt 0) -and ($Texture.Height -gt $ExcludeMaxHeight)) { TexList_SetTextureStatus -Status 'Excluded' -Message 'Texture height greater than maximum height.' ; return $false }

  # Only do anything if it's not allowing all images.
  if ($ExcludeTransparency -ne 'Allow All (Fastest)')
  {
    # Check to see if the texture has transparent pixels.
    $HasTransparency = Magick-IndentifyTransparency -ImageFile $Texture.FullPath

    # Pick a card, any card.
    switch ($ExcludeTransparency)
    {
      'Only Fully Opaque'     { if ($HasTransparency)  { TexList_SetTextureStatus -Status 'Excluded' -Message 'Textures with transparency are excluded.' ; return $false } }
      'Only Has Transparency' { if (!$HasTransparency) { TexList_SetTextureStatus -Status 'Excluded' -Message 'Fully opaque textures are excluded.'      ; return $false } }
    }
  }
  # Check to see if there is any exclusion names or phrases.
  if ($ExcludeStrings -ne $null)
  {
    # Loop through all the strings in the array.
    foreach ($Exclusion in $ExcludeStrings)
    {
      # Add asterisks which serve as wildcards.
      $ExcludeMatch = '*' + $Exclusion + '*'

      # If there is a match, exclude the texture.
      if ($Texture.FullPath -like $ExcludeMatch) { TexList_SetTextureStatus -Status 'Excluded' -Message ('The phrase ' + $ExcludeMatch + ' has been excluded.') ; return $false }
    }
  }  
  # If it survived the minefield, we can create the texture.
  return $true
}
#==============================================================================================================================================================================================
#  MASTER LOOP: TEXTURE INFO SELECTOR
#==============================================================================================================================================================================================
#  There are several different types of "texture info" hash tables. This selects the correct one based on specific options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetTextureInfo([string]$FilePath)
{
  # The "Texture" variable needs to hold data, but depending on the desired function it can hold different data.
  switch ($MasterOperation)
  {
    # Splitting textures has a special mode to batch (.ctt) files through the MasterLoop.
    'SplitMultiImage' { $TexInfo = CreateCTTInfo     -InputFile $FilePath }
  
    # Phyre Mode operations get different types of info for different files such as (.pkg .pka .phyre .header).
    'ExtractPKAFiles' { $TexInfo = CreatePKAInfo     -InputFile $FilePath }
    'ExtractPKGFiles' { $TexInfo = CreatePKGInfo     -InputFile $FilePath }
    'ConvertPhyrePNG' { $TexInfo = CreatePhyreInfo   -InputFile $FilePath }
    'PackIntoPKGFile' { $TexInfo = CreateNewPKGInfo  -InputFile $FilePath }

    # For all other operations, create the standard texture info.
    default           { $TexInfo = CreateTextureInfo -ImageFile $FilePath -Extended }
  }
  # Return the texture hash table.
  return $TexInfo
}
#==============================================================================================================================================================================================
#  MASTER LOOP: THE MASTER LOOP
#==============================================================================================================================================================================================
#  All operations (except maybe the Basic Image Viewer) are ran through this loop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MasterLoop()
{
  # Debug:Let me know the loop is starting.Let me know the loop is starting.
  DebugMessage -Message 'Master Loop Start ---'

  # When packing into PKG files, only folders are required.
  if ($MasterOperation -eq 'PackIntoPKGFile')
  {
    # This will grab only folders and not files.
    [Collections.Generic.List[string]]$global:ProcessMasterList = EnumerateFolders -LiteralPath $MasterInputPath -Recurse
  }
  # If not using "Process Selected", then build the master list of files.
  elseif (!$ProcessSelected)
  {
    # Call the async loop to build the list of files.
    [Collections.Generic.List[string]]$global:ProcessMasterList = EnumerateFiles -LiteralPath $MasterInputPath -Recurse:$DirectoryRecursion 
  }
  # Loop through all folders and sub-folders to attempt to find texture files.
  for ($i = 0 ; $i -lt $ProcessMasterList.Count ; $i++)
  {
    # Check to see if the loop was cancelled.
    if ($CancelMasterLoop) { return }
  
    # Some operations may remove files before they are processed. In this case, just skip them to avoid errors.
    if (!(TestPath -LiteralPath $ProcessMasterList[$i])) { continue }

    # Get the file as an item.
    $ImageItem = Get-Item -LiteralPath $ProcessMasterList[$i]

    # Debug:Let me know a texture is about to be processed.
    DebugMessage -Message 'Start Processing File ---'
    DebugMessage -Message $ImageItem.FullName -FollowUp ' '

    # Check to see if the user paused the loop
    TexList_PauseLoopInProgress

    # The pause check can be ran from elsewhere, so track that a texture is being processed.
    $global:ProcessingTexture = $true

    # Proceed only if there is valid texture data.
    if (ValidateFile -InputItem $ImageItem)
    {
      # Create texture info for the input file.
      $global:Texture = GetTextureInfo -File $ImageItem.FullName

      # If we have an "RGBA_" prefix, send it off to be dealt with and skip the rest of this loop iteration.
      if (($Texture.RGBA) -and ($MasterOperation -ne 'ScanAllTextures')) { DetectAndSplitMergedRGBA ; continue }

      # Increment the number of master loop iterations.
      $global:TextureCount++

      # Add the texture to the texture list.
      TexList_AddTexture -TextureInfo $Texture

      # Run the exclusion function to test if the user disabled this type of texture.
      if (CheckExclusions)
      {
        # Run the Standard or Advanced option that was selected.
        switch ($MasterOperation)
        {
          'TextureDatabase' { CreateTexSizeDatabase }    # - Create Texture Size Database
          'ScanAllTextures' { ScanTextureForIssues }     # - Scan Dolphin/Database Textures For Issues
          'ConvertTextures' { ConvertTextureFormat }     # - Convert Textures to Another Format
          'RescaleTextures' { RescaleTextureInteger }    # - Rescale Textures With New Scaling Factor
          'ResolutionScale' { ResizeTextureResolution }  # - Resize Textures With Specific Dimensions
          'CreateWatermark' { AddTextureWatermark }      # - Add Identifying Watermark to All Textures
          'CreateMaterials' { CreateMaterialTextures }   # - Create Materials With Material Map Generator
          'MakeMaterialMap' { CreateMaterialMaps 1 }     # - Create Material Maps With Ishiiruka Tool
          'MaterialInPlace' { CreateMaterialMaps 2 }     # - Create Material Maps With Ishiiruka Tool (In-Place)
          'PNGOptimization' { OptimizeWithOptimizer 1 }  # - Optimize PNG Textures With Optimizer Program
          'InPlaceOptimize' { OptimizeWithOptimizer 2 }  # - Optimize PNG Textures With Optimizer Program (In-Place)
          'UpscaleTextures' { ApplyUpscalingFilter }     # - Apply Upscaling Filter to All Textures
          'CalculatingVRAM' { CalculateTexturesVRAM }    # - Calculate Textures VRAM Requirement
          'GenerateMipmaps' { GenerateNewMipmaps }       # - Generate New Mipmaps For Dolphin Textures
          'RemoveBadMipmap' { RemoveInvalidMipmaps }     # - Remove Invalid Mipmaps From Dolphin Textures
          'DetachDDSMipmap' { ExtractInternalMipmaps }   # - Extract Internal Mipmaps
          'AlphaChannelFix' { RemoveAlphaChannel }       # - Remove Alpha Channel From Opaque Textures
          'SplitMultiImage' { SplitTexturesMain }        # - Split Combined Multi-Texture
          'ArbitraryMipmap' { AddRemoveArbSuffix }       # - Add/Remove Arbitrary Mipmap Suffix
          'ManipulateAlpha' { ManipulateAlphaPixels }    # - PNG Alpha Pixel Manipulation
          'SeparateChannel' { TextureToRGBAChannels }    # - Separate/Combine Texture RGBA Channels
          'ExtractPKAFiles' { ExtractColdSteelPKA }      # - Extract Trails of Cold Steel PKA Files
          'ExtractPKGFiles' { ExtractColdSteelPKG }      # - Extract Trails of Cold Steel PKG Files
          'ConvertPhyrePNG' { ConvertPhyreTextures }     # - Convert Phyre Textures to PNG Textures
          'CreateFromPhyre' { CreatePhyreTextures }      # - Create Phyre Textures From PNG/Phyre
          'PackIntoPKGFile' { PackColdSteelPKG }         # - Repack Folders/Textures Into PKG Files
          'MetroidNewFonts' { ColorizeMetroidFonts }     # - Create New Metroid Prime 2 Fonts From Base Textures
          'ExecutableBatch' { RunCustomCLIExecutable }   # - Run Custom CLI Executable With CTT-PS
        }
      }
      # Add the remaining details about the texture to the texture list.
      TexList_UpdateTexture -TextureInfo $Texture
    }
    # If there is no texture data to be had, it is not a texture.
    else
    {
      # No point in creating global info for files that are not textures.
      $global:Texture = $null

      # Attempt to copy the current file in the loop if "Copy Non-Textures" is enabled.
      AttemptCopyNonTextureFile -File $ImageItem
    }
    # Attempt to update the texture list progress bar, percentage, and texture count.
    TexList_UpdateProgress -File $ImageItem

    # The texture is done being processed.
    $global:ProcessingTexture = $false

    # Debug: Show that we're done here.
    DebugMessage -Message 'End Processing File ---' -FollowUp ' '
  }
  # Attempt to remove flags from folders if the search flags option was used.
  RemoveFlagsFromFolders

  # During this operation an XML file named "asset_D3D11.xml" needs to be updated with the texture name.
  UpdatePhyreAssetD3D11XML

  # Check to see if the user wanted rescaled or converted paths renamed.
  AutoRenameOutputPath

  # Check for empty folders in the output path and remove them.
  CleanMasterOutputPath
}
#==============================================================================================================================================================================================
#  MASTER LOOP: STARTING THE MASTER LOOP
#==============================================================================================================================================================================================
#  Performs a series of checks before starting the Master Loop that determines if any important folders are within the "Tools Master Path" which can create infinite loops.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckPathsInToolsMasterPath()
{
  # Do not do these checks if the user is not using this path.
  if ($ToolsMasterPath -eq '') { return $true }

  # The path the script is in can not be in the "Tools Master Path".
  if ($BaseFolder -like ('*' + $ToolsMasterPath + '*'))
  {
    # Set up title and error message.
    $Title   = 'CTT-PS Error'
    $Message = 'The script can not be in the same path as the "Tools Master Path". Please close out the script, move it to a new location, and reload it from there.'

    # Show the dialog to the user.
    ShowOKDialog -Title $Title -SizeX (DPISize 270) -SizeY (DPISize 40) -OffsetX (DPISize 22) -OffsetY (DPISize 6) -Message $Message

    # Do not run the Master Loop.
    return $false
  }
  # The Input Path can not be in the "Tools Master Path".
  if ($MasterInputPath -like ('*' + $ToolsMasterPath + '*'))
  {
    # Set up title and error message.
    $Title   = 'CTT-PS Error'
    $Message = 'The input path can not be in the "Tools Master Path". Please select a new location to search for textures.'

    # Show the dialog to the user.
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 20) -OffsetY (DPISize 12) -Message $Message

    # Do not run the Master Loop.
    return $false
  }
  # The Output Path can not be in the "Tools Master Path".
  if ($MasterOutputPath -like ('*' + $ToolsMasterPath + '*'))
  {
    # Set up title and error message.
    $Title   = 'CTT-PS Error'
    $Message = 'The output path can not be in the "Tools Master Path". Please select a new location to output created textures.'

    # Show the dialog to the user.
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 15) -OffsetY (DPISize 12) -Message $Message

    # Do not run the Master Loop.
    return $false
  }
  # None of the special cases were triggered.
  return $true
}
#==============================================================================================================================================================================================
#  Initiates the Master Loop by setting up some stuff before and after it runs.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StartMasterLoop()
{
  # Cancel the loop if any important paths are within the "Tools Master Path" to prevent an infinite loop.
  if (!(CheckPathsInToolsMasterPath)) { $global:MasterOperation = '' ; return }

  # Debug:Let me know the master loop is about to start.
  DebugMessage -Message "--- Start MasterLoop"

  # Disable the minimize boxes when running any operation.
  $MainDialog.MinimizeBox = $false
  $TexListDialog.MinimizeBox = $false

  # Track whether or not to run the "MasterLoop" function, and since it has technically started set it to "running".
  $global:MasterLoopRunning = $true

  # Hack this in to reset the extra texture counts when combining/splitting textures.
  $global:SplitTextureCount = 0

  # Hack this in to reset the path to check the last used path when creating Phyre textures.
  $global:LastPhyreCreatePath = ""

  # Create the log file if it's not disabled.
  CreateLog

  # Cuts down on the number of checks by storing the result of the checks into a global before the loop starts.
  ValidateDBMissLog

  # Create the database log file if it's not disabled.
  CreateDBMissLog

  # Check to see if a database file exists.
  LoadTextureDatabase

  # Initialize the texture list.
  TexList_Init

  # Check to see if in docked mode.
  if ($TextureListMode -ne 'Docked')
  {
    # Hide the main GUI when in window mode
    $MainDialog.Visible = $false 

    # Show the texture list dialog and force it forward.
    ActivateDialog -Dialog $TexListDialog
  }
  # Hide the dialogs for the Image Viewer and Resource Pack and store if they were visible.
  $ImgDialogWasVisible = $ImgViewDialog.Visible
  $ResDialogWasVisible = $ResourceDialog.Visible
  $ImgViewDialog.Visible = $false
  $ResourceDialog.Visible = $false 

  # Fire up the master loop.
  MasterLoop

  # Restore the "Master" paths if they were temporarily overwritten.
  MasterPaths_Restore

  # Clean up function for the texture list.
  TexList_UpdateFinal

  # Completely remove the contents of the Temp folder.
  ClearPath -LiteralPath $TempFolder

  # The show is over boys.
  $global:MasterLoopRunning = $false

  # Show the dialog and force it forward.
  ActivateDialog -Dialog $MainDialog

  # Check to see if Process Selected dialog was used.
  if ($ProcessSelected)
  {
    # Clear the paths list.
    $ProcessMasterList.Clear()
    $ProcessMasterPaths.Clear()

    # Set it back to false.
    $global:ProcessSelected = $false
  }
  # If the resource pack dialog was visible before the loop.
  if ($ResDialogWasVisible)
  {
    # Show the GUI for the resource pack.
    $ResourceDialog.Visible = $true 
  }
  # Enable the minimize boxes when the operation is complete.
  $MainDialog.MinimizeBox = $true
  $TexListDialog.MinimizeBox = $true
  
  # Show the resource pack and/or image viewer if they were visible before the loop.
  $ImgViewDialog.Visible = $ImgDialogWasVisible
  $ResourceDialog.Visible = $ResDialogWasVisible

  # There is no operation running at the moment so set it to nothing.
  $global:MasterOperation = ''

  # Debug:Let me know the master loop has ended.
  DebugMessage -Message "--- End MasterLoop"

  # If the user wanted to automatically shut down the PC, show the dialog and start the process.
  if ($AutoShutdownPC) { $ShutdownDialog.ShowDialog() }  
}
#==============================================================================================================================================================================================
#  MASTER LOOP: INITIATE MAIN OPERATION
#==============================================================================================================================================================================================
#  Checks for a required tool before running the operation that requested it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExternalToolCheck([string]$ToolPath, [string]$ToolName, [int]$XOffset = 26)
{
  # True by default. A tool check can be passed to run this check.
  if (!(TestPath -LiteralPath $ToolPath))
  {
    # Set up the OK dialog title and message.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: ' + $ToolName + ' was not found. Click the "Options" button to locate the path to this tool.'

    # If it doesn't exist, alert the user.
    ShowOKDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize $XOffset) -OffsetY (DPISize 12) -Message $Message

    # Don't waste my precious nanoseconds.
    return $false
  }
  # The tool was found! Rock and Roll!
  return $true
}
#==============================================================================================================================================================================================
#  Set the value of "OutputFormatLabel". This is used on the generated folder name when rescaling or converting textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_OutputFormatLabel([string]$Operation)
{
  # Get the value of either ConvertFormat, RescaleFormat, or ResizeFormat.
  $TextureFormat = Get-Variable -Name ($Operation + 'Format') -ValueOnly

  # Get the text version of the stored extension.
  $FileType = ExtensionToText -Extension $TextureFormat

  # Converting/Rescaling DDS textures will show the format on the output folder.
  if (($TextureFormat -eq $DDS) -and ($DDSBlkCompress -ne '*Search Flags*') -and ($DDSBlkCompress -ne '*Passthrough*'))
  {
    # Use the DDS format as the suffix. The (BC1/BC3) option "/" character needs replaced.
    $FileType += ('-' + $DDSBlkCompress.Replace('/','-'))
  }
  # Search flags can yield all kinds of different DDS formats, so leave the format out of the suffix.
  $global:OutputFormatLabel = '(' + $FileType + ')'
}
#==============================================================================================================================================================================================
#  Specific intiation for VRAM calculate operation. Overrides the input path if the override is set.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_VRAMCalculate()
{
  # If a custom path was set for VRAM, then another operation was selected, and then switched back to VRAM...
  if (TestPath -LiteralPath $VRAMPackPath)
  {
    # Restore the VRAM path when the operation is selected for when the Master Loop is executed.
    MasterPaths_Override -InputPath $VRAMPackPath
  }
  # Run the master loop now.
  return $true
}
#==============================================================================================================================================================================================
#  Runs the SplitTextures function directly under normal circumstances. Allows batching the input folder if .
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_SplitTextures()
{
  # The user wants to batch (.ctt) files and images, run the master loop.
  if ($SplitBatchImages) { return $true }

  # Under normal operation, just run the function directly which does the split then returns false to not run the loop.
  return SplitTexturesMain
}
#==============================================================================================================================================================================================
#  Specific initiation for Phyre mode operations that override the input path with the output from a previous operation.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_PhyreModeOperations([string]$PreviousName, [string]$ExternalToolCheck='', [string]$ToolName='' )
{
  # If using the generated path from the extract PKG option.
  if ($PhyrePreviousPath)
  {
    # Set up a path that will serve as the new MasterInputPath.
    $PhyreInputPath = $MasterOutputPath + '\' + $PreviousName

    # Test to see if the path exists.
    if (TestPath -LiteralPath $PhyreInputPath)
    {
      # If it does, override the path with the new path.
      MasterPaths_Override -InputPath $PhyreInputPath
    }
  }
  # If checking for an external tool (most likely the PKG Tool).
  if ($ExternalToolCheck -ne '')
  {
    # Check to see if the path to the tool exists.
    if (!(ExternalToolCheck -ToolPath $ExternalToolCheck -ToolName $ToolName)) { return $false }
  }
  # Run the master loop now.
  return $true
}
#==============================================================================================================================================================================================
#  Checks to make sure that everything is in place to extract PKA files.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_PhyreExtractPKA()
{
  # Make sure that Python exists.
  if (!(ExternalToolCheck -ToolPath $Python -ToolName 'Python')) { return $false }

  # The lz4 python module is required to extract CS3/CS4 textures.
  if (!(PythonCheckModule -Module 'lz4'))
  {
    # As of this time, the latest version of LZ4 is broken on Windows.
    $LZ4 = "https://files.pythonhosted.org/packages/55/51/db10eeac8748eee0af2b442d231b4b89f7ae4b5ee059189f92cd1270c5aa/lz4-3.1.3-cp39-cp39-win_amd64.whl"

    # Attempt to install it now.
    if (!(PythonInstallModules -Modules $LZ4))
    {
      # If the PowerShell console is enabled, then restore the background color.
      if ($EnableThePSConsole) { $Host.UI.RawUI.BackgroundColor = 'DarkMagenta' }

      # If an internet connection was not detected this will fail.
      return $false
    }
  }
  # If the PowerShell console is enabled, then restore the background color.
  if ($EnableThePSConsole) { $Host.UI.RawUI.BackgroundColor = 'DarkMagenta' }

  # Run the master loop now.
  return $true
}
#==============================================================================================================================================================================================
#  Checks to make sure that everything is in place to extract PKG files.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_PhyreExtractPKG()
{
  # Make sure that the PKG tool is installed.
  if (!(ExternalToolCheck -ToolPath $PhyrePKGTool -ToolName 'PKG Tool')) { return $false }

  # Make sure that Python exists.
  if (!(ExternalToolCheck -ToolPath $Python -ToolName 'Python')) { return $false }

  # The lz4 python module is required to extract CS3/CS4 textures.
  if (!(PythonCheckModule -Module 'lz4'))
  {
    # As of this time, the latest version of LZ4 is broken on Windows.
    $LZ4 = "https://files.pythonhosted.org/packages/55/51/db10eeac8748eee0af2b442d231b4b89f7ae4b5ee059189f92cd1270c5aa/lz4-3.1.3-cp39-cp39-win_amd64.whl"

    # Attempt to install it now.
    if (!(PythonInstallModules -Modules $LZ4 -SkipError))
    {
      # If the PowerShell console is enabled, then restore the background color.
      if ($EnableThePSConsole) { $Host.UI.RawUI.BackgroundColor = 'DarkMagenta' }

      # If an internet connection was not found, then alert the user and ask if they wish to continue.
      $Title   = 'CTT-PS Error: No Online Connection'
      $Message = 'Python requires the LZ4 module to extract CS3/CS4 PKG files, but is not required for CS1/CS2 PKG files. Do you wish to continue with CS1/CS2 support only?'
      return (ShowYesNoDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 40) -OffsetX (DPISize 14) -OffsetY (DPISize 6) -Message $Message)
    }
  }
  # If the PowerShell console is enabled, then restore the background color.
  if ($EnableThePSConsole) { $Host.UI.RawUI.BackgroundColor = 'DarkMagenta' }

  # Run the master loop now.
  return $true
}
#==============================================================================================================================================================================================
#  Specific initiation for MP2 font generation using dumped duplicates and retextures provided by the user.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_MetroidPrime2Fonts()
{
  # If the user never opened the dialog attempt to load the base images.
  if ($MetroidDialog -eq $null)
  {
    # Load the Metroid Prime 2 bytemap hashes if they haven't been yet.
    InitiatePrime2Hashes

    # Attempt to load user imported image paths.
    MetroidLoadBaseImages
  }
  # Create a boolean array to store whether or not each image has been selected by the user.
  $MetroidCheck = New-Object bool[] $MP2MD5HashA.Count

  # Loop through each image in the array.
  for ($i = 0 ; $i -lt $MetroidCheck.Count ; $i++)
  {
    # Store whether or not the path exists.
    $MetroidCheck[$i] = (TestPath -LiteralPath $MetroidBase[$i])
  }
  # Only one image needs to be selected but fail if this is the case.
  if (!(TestBooleanArray -Or -Array $MetroidCheck))
  {
    # If a texture has not been selected do not pass.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: At least one texture must be selected.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 38) -OffsetY (DPISize 18) -Message $Message

    # Do not run the masterloop.
    return $false
  }
  # We made it to the top of the mountain.
  return $true
}
#==============================================================================================================================================================================================
#  Specific initiation for MP2 font generation using dumped duplicates and retextures provided by the user.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_CustomCLIPoop()
{
  # Get the file extension entered into the textbox.
  $FileExtBase = $CLIOutputExtensionBox.Text

  # There shouldn't be any whitespace in a file extension.
  if ($FileExtBase -like '* *')
  {
    # Show the error message to the user.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: The "Output Extension" can not contain spaces.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 14) -OffsetY (DPISize 18) -Message $Message

    # Do not run the masterloop.
    return $false
  }
  # Report that it doesn't start with a period.
  if ($FileExtBase.Substring(0,1) -ne '.')
  {
    # Show the error message to the user.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: The "Output Extension" must start with a period.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 15) -OffsetY (DPISize 18) -Message $Message

    # Do not run the masterloop.
    return $false
  }
  # A file extension must be at least 2 characters long (period with a character).
  if ($FileExtBase.Length -lt 2)
  {
    # Show the error message to the user.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: Please enter a valid "Output Extension".'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 35) -OffsetY (DPISize 18) -Message $Message

    # Do not run the masterloop.
    return $false
  }
  # Finally finished.
  return $true
}
#==============================================================================================================================================================================================
#  If the Dolphin TextureExtraction Tool is found, will start extracting/converting textures. Never runs the master loop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_ExtractDiscTextures()
{
  # Make sure that the PKG tool is installed.
  if (!(ExternalToolCheck -ToolPath $TexExtractTool -ToolName 'Dolphin Texture Extractor Tool' -XOffset 13)) { return $false }

  # Run the function to extract textures.
  $CatchJunk = ExtractDiscTextures_Start

  # Everything is taken care of above so never run the MasterLoop.
  return $false
}
#==============================================================================================================================================================================================
#  Starts the selected operation. Some operations need specific actions to be taken before running the MasterLoop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Initiate_MainOperation([string]$Operation, [string]$TexListText)
{
  # The Master Operation is a short 15 letter name that describes the operation taking place.
  $global:MasterOperation = $Operation

  # This is the operation text that is shown on the texture list.
  $global:TexListOperation = $TexListText

  # Some options require special attention and/or don't actually use the MasterLoop.
  switch ($OperationIndex)
  {
    # Convert Textures to Another Format: The output folder will include the texture format, so set that now.
    '03'  { Initiate_OutputFormatLabel -Operation 'Convert' }

    # Rescale Textures With New Scaling Factor: The output folder will include the texture format, so set that now.
    '04'  { Initiate_OutputFormatLabel -Operation 'Rescale' }

    # Resize Textures With Specific Dimensions: The output folder will include the texture format, so set that now.
    '05'  { Initiate_OutputFormatLabel -Operation 'Resize' }

    # Create Materials With Material Map Generator
    '07'  { return ExternalToolCheck -ToolPath $Python -ToolName 'Python' }

    # Create Material Maps With Ishiiruka Tool: If the tool exists, runs the MasterLoop. If it doesn't cancels the MasterLoop.
    '08'  { return ExternalToolCheck -ToolPath $IshiirukaTool -ToolName 'Ishiiruka Tool' }

    # Optimize PNG Textures With Optimizer Program: If the tool exists, runs the MasterLoop. If it doesn't cancels the MasterLoop.
    '09'  { return ExternalToolCheck -ToolPath $OptimizerPath -ToolName 'Optimizer' }

    # Calculate Textures VRAM Requirement: Override the input path with the vram path if valid.
    '11'  { return Initiate_VRAMCalculate  }

    # Combine Multiple Textures: Attempt to combine the textures.
    '16'  { return CombineTextures_Start }

    # Split Combined Multi-Texture: Attempt to split a texture into multiple textures.
    '17'  { return Initiate_SplitTextures }

    # Extract Trails of Cold Steel PKA Files
    '21'  { return Initiate_PhyreExtractPKA }

    # Extract Trails of Cold Steel PKG Files: If the tool exists, runs the MasterLoop. If it doesn't cancels the MasterLoop.
    '22'  { return Initiate_PhyreExtractPKG }

    # Convert Phyre Textures to PNG Textures: The code below allows using the generated path from extracting PKG files.
    '23'  { return Initiate_PhyreModeOperations -PreviousName 'PKG_Extracted' }
    
    # Create Phyre Textures From PNG/Phyre: The code below allows using the generated path from generating phyre images.
    '24'  { return Initiate_PhyreModeOperations -PreviousName 'ConvertedPhyre' }

    # Repack Folders/Textures Into PKG Files: If the tool exists, runs the MasterLoop. If it doesn't cancels the MasterLoop.
    '25'  { return Initiate_PhyreModeOperations -PreviousName 'CreatedPhyre' -ExternalToolCheck $PhyrePKGTool -ToolName 'PKG Tool' }

    # Basic Image Viewer: Show the Image Viewer.
    '26'  { return OpenBasicImageViewer }

    # Generate Dolphin Resource Pack: Create a resource pack for Dolphin textures.
    '27'  { return CreateResourcePack }

    # Create New Metroid Prime 2 Fonts From Base: Make sure the paths exist.
    '28'  { return Initiate_MetroidPrime2Fonts }

    # Run Custom CLI Executable With CTT-PS - Check for a number of errors.
    '29'  { return Initiate_CustomCLIPoop }

    # Extract Textures With TextureExtraction Tool - Check for a number of errors.
    '30'  { return Initiate_ExtractDiscTextures }
  }
  # Run the MasterLoop.
  return $true
}
#==============================================================================================================================================================================================
#  MASTER LOOP: ASSIGN INDEX TO OPERATIONS
#==============================================================================================================================================================================================
#  Returns an integer index string based on the operation taking place. This is necessary as not all options are always on the list at all times.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetOperationIndex([string]$SelectedOption)
{
  # Assign a unique index to each option.
  switch ($SelectedOption)
  {
    'Create Texture Size Database'                         { return '00' }
    'Scan Dolphin Textures For Issues'                     { return '01' }
    'Scan Database Textures For Issues'                    { return '02' }
    'Convert Textures to Another Format'                   { return '03' }
    'Rescale Textures With New Scaling Factor'             { return '04' }
    'Resize Textures With Specific Dimensions'             { return '05' }
    'Add Identifying Watermark to All Textures'            { return '06' }
    'Create Materials With Material Map Generator'         { return '07' }
    'Create Material Maps With Ishiiruka Tool'             { return '08' }
    'Optimize PNG Textures With Optimizer Program'         { return '09' }
    'Apply Upscaling Filter to All Textures'               { return '10' }
    'Calculate Textures VRAM Requirement'                  { return '11' }
    'Generate New Mipmaps For Dolphin Textures'            { return '12' }
    'Remove Invalid Mipmaps From Dolphin Textures'         { return '13' }
    'Extract Internal Mipmaps'                             { return '14' }
    'Remove Alpha Channel From Opaque Textures'            { return '15' }
    'Combine Multiple Textures'                            { return '16' }
    'Split Combined Multi-Texture'                         { return '17' }
    'Add/Remove Arbitrary Mipmap Suffix'                   { return '18' }
    'PNG Alpha Pixel Manipulation'                         { return '19' }
    'Separate/Combine Texture RGBA Channels'               { return '20' }
    'Extract Trails of Cold Steel PKA Files'               { return '21' }
    'Extract Trails of Cold Steel PKG Files'               { return '22' }
    'Convert Phyre Textures to PNG Textures'               { return '22' }
    'Create Phyre Textures From PNG/Phyre'                 { return '24' }
    'Repack Folders/Textures Into PKG Files'               { return '25' }
    'Basic Image Viewer'                                   { return '26' }
    'Dolphin Resource Pack Manager'                        { return '27' }
    'Create New Metroid Prime 2 Fonts From Base Textures'  { return '28' }
    'Run Custom CLI Executable With CTT-PS'                { return '29' }
    'Extract Textures With TextureExtraction Tool'         { return '30' }
  }
}
#==============================================================================================================================================================================================
#  MASTER LOOP: INITIATE OPERATION - CHECK MATERIAL MAP AND OPTIMIZER IN-PLACE OPERATION
#==============================================================================================================================================================================================
#  If an option has an "in-place" option, resolve which operation will take place based on the checkbox's current value.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetInPlaceLabel()
{
  # Material maps allow creating operations in-place.
  if ($StoredOperation -eq 'Create Material Maps With Ishiiruka Tool')
  {
    switch ($InPlaceMaterial)
    {
      $true  { return 'MaterialInPlace' } 
      $false { return 'MakeMaterialMap' }
    }
  }
  # Optimizer programs also allow creating textures in-place.
  elseif ($StoredOperation -eq 'Optimize PNG Textures With Optimizer Program')
  {
    switch ($OptimizeInPlace)
    {
      $true  { return 'InPlaceOptimize' } 
      $false { return 'PNGOptimization' }
    }
  }  
}
#==============================================================================================================================================================================================
#  MASTER LOOP: INITATING THE MASTER LOOP
#==============================================================================================================================================================================================
#  This is where it all begins, or at least where it would begin if you didn't actually have to click the 'Start' button to get here. If "Control" was held 
#  while pressing start, show the Process Selected menu. Afterwards, evaluate whether to run the MasterLoop or operation specific code.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function InitiateMasterLoop()
{
  # Get the index of the operation that is to be ran.
  $OperationIndex = GetOperationIndex -SelectedOption $StoredOperation

  # Select the operation to perform by its index.
  switch ($OperationIndex)
  {
    # Initiate the selected operation. It will return true or false of whether or not to run the master loop.
    '00'  { $RunMasterLoop = Initiate_MainOperation -Operation 'TextureDatabase' -TexListText 'Creating Database' }
    '01'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ScanAllTextures' -TexListText 'Scanning Textures' }
    '02'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ScanAllTextures' -TexListText 'Scanning Textures' }
    '03'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ConvertTextures' -TexListText 'Converting Textures' }
    '04'  { $RunMasterLoop = Initiate_MainOperation -Operation 'RescaleTextures' -TexListText 'Rescaling Textures' }
    '05'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ResolutionScale' -TexListText 'Resizing Textures' }
    '06'  { $RunMasterLoop = Initiate_MainOperation -Operation 'CreateWatermark' -TexListText 'Watermarking Textures' }
    '07'  { $RunMasterLoop = Initiate_MainOperation -Operation 'CreateMaterials' -TexListText 'Creating Materials' }
    '08'  { $RunMasterLoop = Initiate_MainOperation -Operation (GetInPlaceLabel) -TexListText 'Create Material Maps' }
    '09'  { $RunMasterLoop = Initiate_MainOperation -Operation (GetInPlaceLabel) -TexListText 'Optimizing Textures' }
    '10'  { $RunMasterLoop = Initiate_MainOperation -Operation 'UpscaleTextures' -TexListText 'Filtering Textures' }
    '11'  { $RunMasterLoop = Initiate_MainOperation -Operation 'CalculatingVRAM' -TexListText 'Calculating VRAM' }
    '12'  { $RunMasterLoop = Initiate_MainOperation -Operation 'GenerateMipmaps' -TexListText 'Mipmapping Textures' }
    '13'  { $RunMasterLoop = Initiate_MainOperation -Operation 'RemoveBadMipmap' -TexListText 'Checking Mipmaps' }
    '14'  { $RunMasterLoop = Initiate_MainOperation -Operation 'DetachDDSMipmap' -TexListText 'Extracting Mipmaps' }
    '15'  { $RunMasterLoop = Initiate_MainOperation -Operation 'AlphaChannelFix' -TexListText 'Remove Alpha Channel' }
    '16'  { $RunMasterLoop = Initiate_MainOperation -Operation 'CombineTextures' -TexListText 'Combining Textures' }
    '17'  { $RunMasterLoop = Initiate_MainOperation -Operation 'SplitMultiImage' -TexListText 'Split Multi-Texture' }
    '18'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ArbitraryMipmap' -TexListText 'Arbitrary Suffix' }
    '19'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ManipulateAlpha' -TexListText 'Manipulating Alpha' }
    '20'  { $RunMasterLoop = Initiate_MainOperation -Operation 'SeparateChannel' -TexListText 'Separating Channels' }
    '21'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ExtractPKAFiles' -TexListText 'Extracting PKAs' }
    '22'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ExtractPKGFiles' -TexListText 'Extracting PKGs' }
    '23'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ConvertPhyrePNG' -TexListText 'Converting Phyre' }
    '24'  { $RunMasterLoop = Initiate_MainOperation -Operation 'CreateFromPhyre' -TexListText 'Creating Phyre' }
    '25'  { $RunMasterLoop = Initiate_MainOperation -Operation 'PackIntoPKGFile' -TexListText 'Repacking PKGs' }
    '26'  { $RunMasterLoop = Initiate_MainOperation -Operation 'SimpleImageView' -TexListText 'Basic Image Viewer' }
    '27'  { $RunMasterLoop = Initiate_MainOperation -Operation 'GenResourcePack' -TexListText 'Dolphin Resource Pack' }
    '28'  { $RunMasterLoop = Initiate_MainOperation -Operation 'MetroidNewFonts' -TexListText 'Replacing Fonts' }
    '29'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ExecutableBatch' -TexListText 'Running CLI EXE' }
    '30'  { $RunMasterLoop = Initiate_MainOperation -Operation 'ExtractTextures' -TexListText 'Extracting Textures' }
  }
  # Only run the master loop if no errors were found, or it wasn't forcefully skipped.
  if ($RunMasterLoop) { StartMasterLoop }

  # If the selected operation was to create a resource pack.
  if ($OperationIndex -eq '27')
  {
    # Activate the resource dialog as it falls behind the main window for some reason.
    $ResourceDialog.Activate()
  }
}
#==============================================================================================================================================================================================
#  BASE64: EXPORT BASE64 IMAGE FUNCTION
#==============================================================================================================================================================================================
#  I use this to export the base64 strings into images that are found below. ( ExportImage -B64String $B64 -OutputName 'DialogIcon' )
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExportImage([string]$B64String, [string]$OutputName)
{
  # I don't think users would appreciate icons constantly being created on their desktops.
  if (!$DumpCTTPSIconAsPNG) { return }

  # Just export the image to the desktop.
  $IconDesktop = CreatePath -LiteralPath ($DesktopPath + '\CTT-PS Icons\')
  $OutputImage = $IconDesktop + $OutputName + $PNG

  # Write the image from the base64 string.
  $ImageBytes = [Convert]::FromBase64String($B64String)
  [IO.File]::WriteAllBytes($OutputImage, $ImageBytes)
}
#==============================================================================================================================================================================================
#  BASE64: CREATE ICONS FROM BASE64 STRINGS
#==============================================================================================================================================================================================
#  Takes a Base64 string and converts it into an image with the specified dimensions. Image can be referenced by the variable name.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateImageFromBase64([hashtable]$ImageData)
{
  # If I toggled the checkbox to dump the images.
  if ($DumpCTTPSIconAsPNG)
  {
    # Then dump all the images into a folder on the desktop.
    if ($ImageData.LDPI)  { ExportImage -B64String $ImageData.LDPI  -OutputName $ImageData.Name }
    if ($ImageData.HDPI)  { ExportImage -B64String $ImageData.HDPI  -OutputName ($ImageData.Name + '_HDPI') }
    if ($ImageData.Image) { ExportImage -B64String $ImageData.Image -OutputName $ImageData.Name }
  }
  # If High DPI is enabled and a HDPI Base64 string exists, then create the HDPI version.
  if (($HighDPIEnabled) -and ($ImageData.HDPI) -and ($ImageData.Threshold -le $Monitor.DPI))
  {
    # Use the HDPI version of the image by grabbing the appropriate Base64 string.
    $B64String = $ImageData.HDPI

    # Calculate the new dimensions using the DPI multiplier.
    $Width  = [int]($ImageData.Dimensions.Width * $DPIMultiplier)
    $Height = [int]($ImageData.Dimensions.Height * $DPIMultiplier)
  }
  # If a HDPI version doesn't exist, then use the 'LDPI' or 'Image' Base64 strings.
  else
  {
    # If an LDPI image exists, then create that instead.
    if ($ImageData.LDPI) { $B64String = $ImageData.LDPI } 

    # If neither LDPI/HDPI exists, use the "Image" string reference.
    else { $B64String = $ImageData.Image }

    # Use the standard dimensions.
    $Width  = $ImageData.Dimensions.Width
    $Height = $ImageData.Dimensions.Height
  }
  # Stream the base 64 string and convert it to a bitmap.
  $B64String = [regex]::Replace($B64String,'\s','')
  $B64Stream = [IO.MemoryStream][Convert]::FromBase64String($B64String)
  $TempBitmap = New-Object Drawing.Bitmap($B64Stream)

  # Create an icon or an image.
  switch ($ImageData.Type)
  {
    # Icons are shown on the application toolbar and Windows main taskbar. Bitmaps can be displayed directly on the dialog.
    'Icon'    { $NewImageType = [Drawing.Icon]::FromHandle($TempBitmap.GetHicon()) }
    'Bitmap'  { $NewImageType = New-Object Drawing.Bitmap($TempBitmap, $Width, $Height) }
  }
  # Create the variable and attach the bitmap to it.
  Set-Variable -Name $ImageData.Name -Value $NewImageType -Scope 'Global'

  # Dispose the temporary bitmap.
  $TempBitmap.Dispose()
}
#==============================================================================================================================================================================================
#  BASE64: IMAGE/ICON FUNCTIONS
#==============================================================================================================================================================================================
#  To be able to store PNG images without requiring external files, images are converted into a Base64 string and stored in the script below. When the script initializes, all Base64 strings
#  are converted into icons or bitmap data. Icons are shown on the program bar and taskbars, while bitmaps can be used to display images on the GUI. Starting with v47.0, this section has been
#  reworked so that images are referenced with hashtables. This is easier to store the various properties while tying multiple Base64 strings to a single image. Only a single Base64 string is
#  used for each image during boot depending on whether or not "High DPI" is detected or not, so every variation is not created at boot time as it would be wasteful to do so.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateImagesFromBase64()
{
  #==============================================================================================================================================================================================
  #  Main Dialog Icon - Main Icon (Blue)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSBlue = @{}
  $IconHT_CTTPSBlue.Name = 'Icon_CTTPSBlue'
  $IconHT_CTTPSBlue.Type = 'Icon'
  $IconHT_CTTPSBlue.Threshold  = 96
  $IconHT_CTTPSBlue.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSBlue.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAUmElEQVRo3sWaeZDc1XXvP/f+tl5nema6Z9c20iAJLexiM5sxpuywxX6UCUW84EBigg1eSB55hRNeiiSuZz8nlZAX27FfEmzAeNFDNjwTFSEYcCSxGCEkNCPNotmnp2e6Z3r9
                             bfe+P7pnpBHgIlu9W3Oq+tdVc3/f7z3n3HvO97bgP2iMjo5GbNveEo/Ht9u2vUEI0R6GYUxrjWEYFdu2s0qpEaXUm8BRx3Fq/P8ex44dS2ez2TvL5fJTrusWlFL6PY6C1voprfWdSqn0vweD+Lf80+Dg4M5MJvOFaDR6s+M4seXvlQoJggClQ
                             sIwRCmF1hohBFJKpDQwjLpJKRFCAlSAH2it/6eU8o3/VAIHDx7s7ezsfCiVSt1q27YJEIYBtVqNSqVMtVrFdV183ycIQkADAsOQmKaJZVnYtr3KLMvCNC2EkIHW+tEg8P+bbTsT/6EEJiYmRLlcvr27u/t/JBKJFgDPcykWlygUCiu2sJBnoV
                             CiXAvwQlC6Pr1pQNQ2aEpEyLQ1k0mnaWpqIhaLEYlETiFjYxhGPgjC+yYmxr/T17dR/7sJ7N+/P9HR0fE3PT09t5qmKcIwoFAoMDeXZXp6hrHxCcZmFimrCLFUhmRTimg0imWZSCkboaXw/YBqtUpxqYBbXCAd12ze0MW6tWtoampaIdLwklZ
                             KPzo/n/ud7u7e0r+ZwN69ezObN2/e09vbe5EQgkqlzMzMNOPj4wwMDjE8WyHatpb2jk7iiTiWZTVivTGtEPUoQtf/tCZUCt/3KZfKZGdnkNU5ztvaS/+mPhKJBI7jYJompmkC7Mtm527YsKFv7l9NYPfu3Zldu3bt7e7uPktrzeJinhMnTjA4
                             OMgvj05itW2gp3cN8Xgc0zQQQiCEaMx4+rR61UetNVprAj+gXK4wPTlOkjxXXrSTrq4ubNtuLIREKXVwdnb2mq1bt829ZwJ79uxJbNu2bW9fX99FWityuTmGhoZ5/eAhjs74rOvfTms6fTJMTplF1xcbrVcDFwhW+DVerNFopfE9n/n5ebJjx
                             /jghRvZsuUMbNtGCIHWGs/z9o2Pj19z4YUXvy2cjNO/eOaZZ0Rvb+93Nm/e/GGAXG6OwcFj7DvwKkdzBn2bt9PS1oZpmSAESkOoIAg1fqjwgrr5QYgfqLqFmiBUhKEiVBqlQTWYakBKie1EMOwY+w8eJyZrdHV2rOSQ1rrXNM11V1115e7vf/
                             +JVXjN0wlIKW/fvHnzrUIICoUFhoaG2f/yaxyelfRt6iMaT6CFJFC6EdN1C8J6ovpBSKjqe7+QEikkQgqkACkEhqyblGA0ngWghSQaT5DuXMueF49jGgYXnH/OSijZtn3runXrngO+/a4e+Na3vtV76aWX7k6lUtFKpczw8DCvvPoa+45VaO9
                             aT3NrK5bjoBAEIbiBouaFlKse8/klrKDK1q44rRHB3FyeqVwZN9T4IXiBXvGO54f4ftjwUohqLIbS9dDzfXj5jUE2dTeRyaQRQqCUEkqpy2644frvPfLId5fe0QM7d+58qLOzsyUMA2ZmphkcPMaLh7I4zWuIxJNoYeL6Gh0oAqXxgpBqzaVW
                             XOKWKzZx7rb1K26/UWtOTMyx+5+PcCTnEo3HMA2JIQAVENSqJE2FZQgCTOLJBKYhUcIkEk8irBb+YffP+f27OkilUoRhiOM4Lc3NqYeAT7zNAw8//PDOyy+//K9isZjM5xc4fvwYz750kGytidZ0J5FkE8Kw8LWg5itKVY/5/CJJXePuj57P5
                             r7u+i60nKRCkIhH6GyNMTCSI1sDXwsqrkebqHLXjWdx45XbueK8PlIRwYG3siANQgVhCH6gmMwWUdU5zjnrzGUvEATBtmuv/eCTjz/+/dlVHjj77LO/0Nraanqey9xcloHBIY5Ma5KtLWDHcZVB4Gk0Ia7vY3kl7rluOxvXnUy25VGp1Pj5vi
                             N8/9kBRioG8ZYUkYSJ9AJibonPf/xyWlIJACanczz8+MuYTa0EwsOQAq0kwophRVP89BcnuPziUTZt2ojv+0SjEbO5ufkLwCcBJMADDzyQXrt27c0AxeIS09Mz/HJgippOIqJNuMKm5AmWqop8xSc7v8QdH95O/4auVeC11rz2xnE+9eUf8t/
                             3DDMiW7AyGcJYlJo0KPsBN57fvQJ+NrvAf/3az5gPHEq+QnhVuuOwWA5wtYWMNFEOYux55iWklDiOg23bRKORm7/xjb9JrxDo7+//SGdnZywIfPL5AuMTE7w1rVFOCs+IUQ4kS56iUA3IFUpctMZh47qOFdC6vulzfHiST37tWUbNZoyONKK1
                             CZWIEjg2riGpKk13OrlC+OlnX2WkJHCliVctc8/N53Dpjk7mCxVKviAwominib2vTDE+PonjRHAch1gsHkun0x9ZIbB169abTNPEdWsUCnkGR2YoeFECO0lF2yx5UKj45PKL3HZBmrtuuQwpxQrw5djv39jL1++4hEAqgoiFH7HwHQvPNvEMA
                             88wyC1WVgj85s3v5/arelksLPAHt5zN2p40iZhNoeRSdBUVbRHaSeZrEf7lwEFM08S2bRzHJhqN3ghg3n7/A9HW1tZLNJpSqcTi4iIDY0uUZTeGEYVQQOByUUZz641bOXf7+lUhQ+OEXR5Xv28HXzEMvvRPY1iRVqQpaez0+DqksFQ+eQiZBp
                             +8+TIuOXeCLf1rAZiayVMNBWEg0Ag8I0ZNxtn7wiE+etOHTi3FL/2Tr/xZRDb5tS1tbW3NKgypVqssLOQZzilcM0YFm2IAMe3zp3dduQJea41SCqUURwZGKRYrq5L4Axefydc+sI5acRFPKzwJVd/l02fEueVDF5x+cK6ALyyW+NaTR3ANh7I
                             SlJWkKmw8M8brJ8rMZrON/sEkGo00NyWTW+WmDeu3JxIJfN+jVquRWygw75rUpENZS0oKhirw0qvHUY1qUql6WTCTLfC7/+sFvvTwMywUVpcpV1+4lT+/cg3VxTyVcpE719rcef35mObJs7PmelRrLsVSlV++Ocy9X3maN6pRXNuhgkFJCSra
                             oGZEWHAtxsenkNJYaY7i8fh2s7ura4NhGJQrPq7rkV+sUFYmrjTRWmBogWlF+NxjR3k0FWPzxi601vhByF8+sY+x1nbGpUPtf7/A1z75PtItJ5P06l1beFgrXh6Y4NMfvBDTOAm+sFTi/r94muenXJQ08aWNdJLQHEELk0BRL1GUxBUmvjKYm
                             JxeKS2kYWCZ5gaZbGrKAPieTxD4lMo1alriIaghcLXAM01ysRR3fvs1jo3O4gchbw6M82hWQXsrurON55NpPv/YPuYLxdM8cSYfv+YsCouLBEEAQH6xxH1/vZefBUm89esI1q6B7k7Clmb8qINrGLhaUNWCqoKaFtS0wfzCYiPnBLLeZ2ckmr
                             jWiiAMUErheSE+9WoxQOML8KTEdxyG46389ncP8tMXj/LjVyahvY2wOU6YjKIyKf65JcN9P36FQrG8ikR3Vwdaa3LzebK5PF/85rM8I5ugO0OYbiZoSRAko/gRG8808aTAFQJXg6vBV+BpGgTqFazSGqXCuNToemyHYWNXqT9rVL1eF4JQCnx
                             LEsSjDDanuffNCo94sfrLkw5hzEYlIuhMimea27j/By9RLK9O7K7OdoIg5LMPP8UzZgLVncZvSeDHHfyIje+Y+LaBb0o8KQmEIBSg0KAVStc7OQCtFCpU+EGA1FqXl3cVEDi2idYB6LqqoCUoKVCGJLANgkSEsK0ZlW5GNUfRMRuiVt1iNjpq
                             0d/RzMx0duWFy6O3p5N7brqQqA06bqNiNkHUIogY+LaJbxkEpiQ0BcoQaEOA0GgCtA5pa20GNKEK8XwPz/XK0vf9uUb7hJSSZDIKOgDlownRUoAhwJII2wDHhJgNCRsRtRCOiXAMsATaq/IHTZrPXnseXZ0ZxiemV+J+eVxyVj+PXt1PvJgHE
                             SJsCY6Jdgy0LetmSbRZJ6BFCCoAHZBuS6GUxvcDXNelUq3OyRPj46NBWH+JNCRtLUm08hChh9AhwgBhSYQpEbZEOgbCMerfSY3QAYQ+ulLiftvjdy7egmWaxGJRMulWDr11HNdb7YldW9byxKXraC/kEDpAWCfnxa7PjSURBkCI0C5Se/T2dB
                             KqsA6+UqFYKo+YwxOTby4VlxBCYBgG6bYUvbbPdFgD7dVBmhJpS6RtIGwDIRWJUonfarPoS0Yo+T6SgNsu3IppyBVvLlU9/vC5o1w+nOOeX7sY65Qz4OyNPTxmmdz+whCjzWmkZaIdEx3U+w0ZKLQHEh8d1siYHmvX9OB5Xl2eKRZZKJUOm0P
                             N7Udzc7nFVEtLs2EYJJNJLlgT5af5KkK5CEPVwTtG3Qw4s7rEt6/oo6+j5V0lmam5PHc99RoHN/bxuoTYi2/y25fvwDilet26toPvvd/gjmcHOJJsa5AwIFAQKHRVoVUNoWqc3+vQ2dlJqVykUqmQzxcWp5rbj8r9v3V3bS6X+4WUAmlIIpEI
                             52zpwggryLCKFCHSFnUX2wYojz/anlkBX0/+05S87AJ3PvUqB9f0Yqztwlzfy1eMGI/sfwulVottfV1p/v7abVxcnEcELtKqv0vaEilDpKphhBWue/85OI5dr9eWllhcWvzFP33m3pqMuIEYODa0JwgCDGlg2zZbNq2h16gigwoSD2lRn9QSm
                             IHLzjV1QflfDg3xwCP/SLFSW1Xg/eFP9nOoqwvZlYamGCSjGN3tfNm3+OGrAytV7MrulEnxjet28qFaHhnU6iQskHgYQYVuo8oV79tFza2xuLREfiHPfGHpyWQ1qJfTL0/nds/OZitGo8ZobUlx/Y40MijVvSAV0pJIS9JpSWzL5EcvvcktB8
                             Z4JJHm/qdfodAo6IQQpNMpZCoJsQhYJhgGRBzM7g7uK8PTB4fe5rVMKsmf33geHzNcpA7qng+rSL/Eb1y4hg3r11NYXKRQKDCbna2Ma/P/rPQDe+/4Uu7E2NiPhBAYponjRLjknDNYq0tIt4gMXaSpEbbBYiLOV/cNce+Mi9i0DtnTznPSYiw
                             7v+KBaV+BbYEhT2pnUkLEQXZ38Ls5l+eOjLyNRCxi0yIVUgV1T9SK9KolfuPXryUIfRbm58nlcszl5n944IsP5pYJaKkVrw0Ofz2fzweGYWDZFm1tLfzmBT2I0gKiuoQIPKQUeIkY37ETGGu6oClGplrmsV0b2LlxDQBjswv8XJv1lW/0AXWp
                              DpACEY0gejq5Y6zIvsHxFfB+EPDNp/fztwsekhBZXUKWFvjcB86kf9NG5hvgp6amgsli5euikXsrW8ITt9516NjxoceFECudz/k7NnFDKoSFOURxEeG7CCkQUQciFj2Bx3e3dbGztx2AmYVFHnr+MGRaEZbVuPVoiD1a1z8DIuIQ9nTy6YE5D
                             o5OkyuUePAHL/BncwGyKQFeBfJz3NSi+NhNH6JcrfcC0zMzTE5NP/7SF//40Nt0ocC0ODCZfaA9M/1rmUymxTRNIpEIt1y1k+l/fIODs1GIWGAKkDFAUgjhm4cn6Xh9mLlilT1Fn1pnO7I5iZYSoRTodxBOlQbLotLVwacOZ4kujTAhExitFq
                             paRedmObea4/7PfIRoLMrI6AjT09OcOHEiP6qMB0LLXhFejZYvfVk0fC0GdlxQ3PDC3vmOTPo60zSFEALLMjm7t5WBI0PklEBKAyElQgh8ITmiDV4ODY7YMVS6FdGcAMcGKWiIoMvi6WoLFSiomRZFywYh0OUyenaG/rkJvvrxD9K/sY+p6Sn
                             GxsYYOj6kB0fH7/35fQ89v0paPIUAAAOZNW/0HTqwKd3WtmNZMolFI1y0vp3Jo0NMVn3ESfkZpIGwLIRj1RNXyvraLCtUgYIgAD+smxeCF9TN9aHmoitVdKGAmp5iV3GOr952LVu39DOTnWHsxAmGR0Y4OnjssWdv++yDQbJJvxOBZcVb1GJx
                             vOHhZ9sW565qSaV6lnX/aMThsq1rkZMTHJwpNADqRpjUQ0Msx/mpK+0HddB+cApwDyo1dLEE+UV0LoeanODWeMCDn7ietWt7GuDHGBkZ4a2jAwde7znj1uyFl7mrLxvQYsOML08lsGwf+PE/ZK5oifzfDevX71i+VTRNk3g8zpHRKf7yxQEGo
                             ylkKgXxBCIaAdsG06xvn+JUxzaSeNkrrouu1aBUQhXybKoU+PxlZ3LN+3YhBEzPTjM5Mcno6ChHjw6+cSjS/OFDn74ny8n9TJ9K4FTgq4hc/eT32i929I/6NqzfderVTzwex7IdDrw1zN/uP85RM45IJhHRGDgOwjRBGvU8WN6JVIgOgjr4ag
                             VdXKLfL3P7ORu49pJzaW1NsVRcYmZmhumpacbGxjg6eOzA4WTmI4c/dXf2dODvROB0LwDI8577WeLy/Phfbdqw/mOJZEJYloVlWUQiDk1NzUSiMUYmZvnFWyM8PZTlcGggIxEwbUSjiddhAL6PdmucIXyuWdPKZdv62HlGH/FEjEqlQm4+R25
                             ujpnZWcbHxvXx0dHHXz/j3LtHr/svpdNWfhWJZQK8mxcAEV8qyI8++fef6O/p+tOOjvaU4zhYloXjODiOQzwRpynZhGXZLJUqzC8WWSrXqLoenu+TjEVJRh0yLc20ppqwLLN+0Vcps9goDxYWFsjOZjkxNlYYnVu4//k77vs7v6VVvRvwdyPw
                             K4lc8cO/692uKg/2dnZ8rKWlxTj90nrZlkVYwzBWZMeGNI7n1fWnarVKuVyu1/ULC0xPT4cTM9nHjzd3/NGhT909/g6g34nEKgLviYRUSrz/u3+9o98Wn8u0NP96S0tL7NQ7XtM0T/kpgVi5qFsm4Ps+tVqNcrm++tnsXGUuX9g9KiN/8epnf
                             u9NLaV6D8A1wEinVT8m38ULv5IIQoidP3kivWX2xA3tydj1iWj0omQi0RSJRjBNc4UAGkIV4vs+rusuA19aLFX25aruT4bW9O859tHb5lYkkfcI/t0I/GtIrDwrKVn3xqvRvldePCOj/W0Jy1wXscyMgJhWCl+FlZoXzBW94MScYR8eveCyga
                             lzdtXEye7m3ZL0V4IH+H9wraSe3RMv7gAAAABJRU5ErkJggg=='

  CreateImageFromBase64 -ImageData $IconHT_CTTPSBlue
  #==============================================================================================================================================================================================
  #  PowerShell Console Icon - Main Icon (Red)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSRed = @{}
  $IconHT_CTTPSRed.Name = 'Icon_CTTPSRed'
  $IconHT_CTTPSRed.Type = 'Icon'
  $IconHT_CTTPSRed.Threshold  = 96
  $IconHT_CTTPSRed.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSRed.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAUVUlEQVRo3sWaeXic1X3vP+d933ln0Yyk0W5JtvEiW7KxsQNhsRvArCktTklIaZwmBpcsNw1JMA9paMkFnrLd8KSEEloISy9Ny95rxywX2yQEsMEm2NiO8SJ502ZJMyNp9pl3
                            O+f+MaOx5KVNt+ee5/k97zzvjM75fs/v9zu/5UjwXzSOHTsWME2zs6qq6mzTNGcJIZo8zwsppdB1PW+aZkxKeVRKuRc44Pf7i/z/Hj09PQ2xWOzruVzudcuyklJK9TuOpFLqdaXU16WUDf8ZDOI/8kfd3d2LGxsb1waDwS/6/f7QxHspPVzXR
                            UoPz/OQUqKUQgiBpmlomo6ul0TTNITQAPLAy0qpv9E0bc9/K4Hdu3e3t7S03FdbW7vKNE0DwPNcisUi+XyOQqGAZVk4joPreoACBLquYRgGPp8P0zSniM/nwzB8CKG5SqnnXNf5K9P0D/yXEhgYGBC5XG5Na2vrQ+FwOApg2xaZTJpkMnlCRs
                            dwE3GMZApfoYDuOCXN+P3ISARVV0egpZn6xkaqq6sJhUIEAoFJZEx0XR93Xe/2gYH+Z2bPnqP+0wS2b98ebm5ufrytrW2VYRjC81ySySTxeIyhoWGGenvRu7tpHBqiSUGkqgpfIIBuGAhNA0Aphec42MUi2VyOuM9HZs5sAosX0TZzJtXV1RU
                            iZS0pKdVzo6OJb7a2tmf/wwQ2b97cOH/+/A3t7e0XCiHI53MMDw/R399P74EDRHbvYW6hSF19PYFQCN0wyrYtTppeoUpMkFLiui5WPs/Y+Dj9DfWYF3+GmfPmEQ6H8fv9GIaBYRgA22Kx+MpZs2bH/90E1q1b13j++edvbm1tPUcpRSo1Tm9v
                            Lz0Hu7E/2MbZqRRNjY34g0F0XS+BFidNp06/ggKUlEjPo1goEB8dpW/ObNquvoqWadMwTbPs9BpSyt0jIyNXdnUtjP/OBDZs2BBeuHDh5tmzZ1+olCSRiHP48BH279xJywcf0FVXT6S6GsMwJu12aYdRClV+TllGcILkJLKqrJF0Os1hyyLwx
                            9czp6sL0zQRQqCUwrbtbf39/VdecMFFp5iTfvKLjRs3ivb29mfmz59/DUAiEae7u4e9W7cyY8tWOpubqQ6HMXS9BFJKcF2U4yAdB2nbk8RB2Q7KsVGOi3JdlCdBSpSUKKnKXASmz0dISuJbtjBaV09jayvaCR9qNwxj5ooVl6578cWXpuA1Ti
                            agadqa+fPnrxJCkEyOcfjwEfa+/z4tv36H6dOnEzRNhFJIxykB8TyU5+E5Lq7r4jgeSnroKHRAEwIhBELTELoGuo7QddANhFH+XNZGyDSZFqnm0NPPsN/QWXTBBRVTMk1z1cyZM98Gnj4jgSeffLJ94cKFD/n9fpHP5+jt7eWTnTsJvrmRluZ
                            mQrqBmAhQUqJcF+m4OLZDsuCQO+ssIp9ague5pD7eg7F3H7WGImBoGLqG0HWEboBhoIzSE8MoOb+ugYKQYdBYVcXhx/6eSH09czs7S0ANQ4RCoYc2bXpz41VXfXbgtAQWL158X0tLS9TzXIaHh+jp7ib/6mvM9fuJGAa666CUxJMK6bq4jkOh
                            aBPT/LR+99ss+PS5JSCAuuF6Ykd76XnuJYKbNlFjCgxDR+kGtu4jrZnYzc0gfATHU0T9OqahI6QkrBvUSsmORx+j6f77qI3W4nkefr8/WlNTex+w+hQfeOyxxxZffPHFPw2FQtr4+BiHDvVw4PU3aDh0mPZINRHDwJAKZTu4xSL5fIF4qkhid
                            geL7voBrQs6EdoJhxZCEIyE8be3ET98GF/PIbBtCpZHYuFiOu75K+Z/+QamX3M1zvR24pt/hU964JV9xXVJ9fYyYvroPO88hBATR/DCq6++6hcvvPDiyBQNLFmyZG1dXZ1h2xbxeIzDBw6iv/1rmmqjhFwXCgVsy0IphWW7JJrb6Lh3Lc0dcy
                            rONjEK+Tx73tnCvmdfoGrrR7RqRTDANUwSc9r59F13EK6LAhAbGOS9Bx5mZiZF1glg6DpCSYKuR73PpOfpZ+i9/DJmd3TgOA7BYMCoqalZC9wIoAH88Ic/bJgxY8YXATKZNENDw8S3bqXO8aj2JKJQxMnmKKYz5JNpRsYLzP3+rUyb3zEFvFK
                            K/Tt38fMv3UzvV7/NzE2bmJ2PEc1lMLJ57JxD/U2rKuATIzFe+e4PqDrUjZfJMVbXRHbJUjLpLKpQIOJ5RApFPnj5FTRNw+/3Y5omwWDgi0888XhDhUBHR8fnW1paQq7rMD6eZLCvD955j6gCzbJwcnmKmSy5VJZYykJ+4VqaO+ZUQKvymd97
                            6Aivfv7PaX17C7Pyo7QUs9QWLYKFInqhiFf0qGpvqxDe+sYmjB37MAsWY8Fazr77TqJXXUk8maOYzaEVbWoVDP7zcwz0DeD3B/D7/YRCVaGGhobPVwh0dXX9kWEYWFaRZHKckX37CKWy+G0XN1+kkM2TThc4nhdU/+VtXPrdb6FpWgX4RDA7q
                            2MOVz51LzJYQ8DTCDoepu1gOC665SJsj1xitELgD77yJ5x153cY1Go558d/TePM6fiqq0mmCxQyOdx8Ab/tYibG2bVlC4ZhYJomfr9JMBj8HID2rZtuCtbV1S1TKLLZLKlUivE9ewh6AmW5WDmLVE6SvuIKFjz7U877wufQdH3S7k+NI0uvWM
                            Hsf3qERHUzrjARUqJ5HkoKbGGSSaZPnOGGwRVrvsKV659kztJzAIgPHsfJF7CyOex8AWHZBD3Frtdfx7adyan48vvvvy+gmTU1nfX19TXS8ygUCoyPjWHv/i0+V+EVHQoFh/SMdj774/uYe+6SCnApJVJKDu0/QDaTmULi7Csvo/m5RxmqnYa
                            tBfE0k0ygHu3+27jwS9efHDiZ1TkPgHQyxQd//wxmIYvMWzg5C6/gYDqK8XffIzYyUq4fDILBQE11TXWXNnfu3LPD4TCOY1MsFhmPx2F4FFywLIlddLE/OcYnW7chlcIrA5eeJDE8wrpv3s6Lt91Jemx8CrAFV6yg8flHGahrIxZqxn7gds79
                            xhp040TosYoWxUKRXDbLgY938+wttxPc/B5msYgsOriWg2u5aK5CjIwy2N+PpumV4qiqKny20draOkvXdXJ5B8uyyYwnUUrDU+B4CuF5+LwMW791B1Uv/Yyz5ncglcJ1XN589HHad+whsmMPbxYKXP3wA9Q01FcAdl2+Ave5v6X3o91cefPqK
                            eAzyRQ//8E9ZDe9j+E6+JNpqu0sIc/GAKQAT4GHQCpACY7396Mtu6iUXug6PsOYZUQikUYAx3ZwXYd8NotC4HngCoWmCTTpUnO0jzdvvpVr/uERWmbO4PDefRQff4lWO0sNEuuVN3hbKS575H9RXV9XAbro8kupX9DFeCpDQznPT48nefH7Py
                            Tyzxtoc/JoqFLFoEr5txSiBF5Rivrl9+OJBFDKrbRSnd1oAFVKSVzPRUqJbdtIBC4CTwmUp9AF+JVN/e79vPW179F5y80M7/iYxmKaMB4BJamy05ivvME7Ph8rHn6AcG1NhUTrtGaGhmMkRsfxCVj3F3dR/cKr1DsZfFBeTysLSCXwpMRTlHA
                            gkAjGx8Yq9YQs+WGVoVSJoed5pVMFcMviIRDlNF94ioCyMD/cw9CNazGlQ61bxKckOhIfkqidQrz4Gm8Gg/z+j+6hKhyukJjW0sTAwBD/dPvdtG3YRJOVIqAkSui4QuBNdDYAKRWyDFoyQQLsco2tyj7ouC6aUio3caqAwBcI4JQJSEAhynWP
                            QJeKoOsQtfLUOhYBJdEBUf6VJjQ03aSuYzbHh+I45QUnRnv7ND77nTWohnp0zY+GQCgFUpVrBIWSpTUnZMIaHCDa0AAoPOlhOza2beU0x3HiE4e5pmlUVVdjI3HKqp0o2kqfBDpgoPCh0MvfKQSeZpIONsIDt3Pxt7/OtGlN9A8M4bru1CP2o
                            gs47+UniM2YhWUEkYiJivk0xWJJAw4KB0W0vgEpFY7jYlkW+Xw+rvX29R5zvdIimq5RW1dHEQ8biZwyFWiVfQGlGdhGiKJZTd6sZSzUhPvg9/nUN/8Mw+cjFArS2FDHvr0HsC17CrR555/L0v/zFMe7OikYwfKMJU1qk9YTZStwUFhC0Tq9HU
                            96E+DJZDJHjSNHjuxNZ9IIIdB1nbqGBrzpLRT607hIQCtPdsKYXCNAqq2V2m9+iao5s7AzWdANzvvyH1eOSk3TKKQzvHfXgxz7zPlc891vYfhOHKNzlizG9+KTvHvjLdR/vBfDKUzaqNKqJQIKC4nTXM/0GTOwbZtCoUAmk2FsbPwTo6en50A
                            inkjVRqM1uq4TqY5Qd8GnyfdvxMaYomKFwtV9ZJd/iouf+Skts886Y0smfnyIN/7Hrcza9C7il+/zXijIJd9YU0lDAGZ0zeey559g09e+R3TLDnxOHqEUAoFWXtNBUsAlev55tLS0kM1lyOfzjI8nU4MDgwe0Db/YUIzH4+9rmkDTNQKBALOX
                            LiWHQx4XF1k+pSVKKApmFQvv+UEFfMn5p46RgUE2fO07TNv4K6bZcdoKQ3h/8SBbf/78Kb9vnT2La579O8b+4FJyviqkmLB8hURRxCOHx+9dey1+v1nK19JpUqnk+y+//HJREyAOHuze4LouuqZjmiZzujqx5kwnh4uFh4dEIvEQ5KqqmLF4Y
                            alXuu1Dnvqf95PLZKfUBOvuepDGX26hwRkjqFwC0qIxP0TmlrvZ9sr6ShY7MZra2/ijJ35CbtW15MwSCZA4eORxKc5qY9kll1C0iqTSacbHxhkdHfsFgKaA33z4m3UjI7G8Xs4xonV1zLnuc2RxKODi4iHLNFRbLT7Tz6//5Re8tXIN4idP88
                            odd5NJpiqpdV19DVVeAZ+SFdMzZJHG/BDDX7+Dj97YeIrWoo0NXP+TBxDfuAFLM3DLppPB4ew//TJnzZpFMpUimUwyMjKS7+/rX1+pB5566qlEb2/vvwgh0A0Dvz/A4uXLKHTOIotDsWxKEgdzeJjND/0N3atvZcZYH012FvutbQz1DVQ0UBw
                            aQVMeCoVXiSkKQxZoyg5yaPVadr397ikkAqEQRGuxUBTL4PPzZrFy1Spcz2FsdJREIkE8Hn/lpZdeSkwQUAA7d+x8eHx83NV1HZ/po66hgUVrbiKJQw4HGxepHPyxAex7H6I5P0RI6BQXdHHFy48zr2xWQ3392G9uRUi7Ar4U1Uua8Hl5mpMD
                            7P7TW/hk+28q4B3HYd3P/oHjDz2JlHmyOIxrkmW3rWVuRwejZfDHB4+7g4ODD0/uSghA7Nq1K7Zs+bK5LS0tiyfKxGhzE8eForBrF37Ah8TAw6ccfAK8pUu58PmnmbGgq1zjjvDqPQ9Su307ES+HPpG3nCRCOZj5Avt/tY3qSy5CGAYvPPhjh
                            v/6UaoLMRzlMIqHuWY1q9euxfEc+vv7OdbbS093z3PPPvvszxzbmUrAtmzR3t6+o7WtdXU4HA4qpdA0jdb58+gZGUIePoyBwihHYg2QuslgocCB3Xv5cP1rbL/1bmrfe59aN4lZjuOnI6AAoWzMdJYD72xlx8vr8Nb9X8JWAk85JFHkrrqCP/
                            vRj6irr6N/oJ++vj66D3aP79+//092fbwrPWE5+uTAt33b9szSpUtGm1ta/tAwDCGEwGeatH9qKQf7epG9feiAjkJDoWdSyA934fzqPYwPtlOfGibiZfEj0SYlZ94ZnigbIxHDd3wQ3cti4ZEEUsuX8ZVHHmFORwfHh47T19fH4UOHVffB7u/
                            947P/+M7JzV0xuUt95MiRPZ2dnXMbGhoWTbRMgqEQs5Yvp2dsDOvgwUnRUuFTNn5pEVQ2pnIxypNN3nmvLO6kpws45UBl4ZFDMQbYK1fylUceYf6CLoZjw/T19nLk6FEO7D/w/Lp16+5Jp9PqdAQqKc/Y6BiBYOCXDQ0NK6LRaJsoN2cDwSBd
                            l17CcHU1iQ8+qOTlnJS7cBrw7kmgbaBYvt3LAikgoevU3nYbq++9l+kzZ5TB93H06FH279//4Y6PdqzavXu3NWlZAHUKAUB8svcTJ1oXfa2mpubKmpqa5om2iabrLLjoAiKXX0734CBWX98ppnHqDp8AfTrg40B22TIuefRRPn/zzQSrQgwOD
                            dLf18/R0s7v+e2e367cuHHj+El3JFN6o+Lky46Pd36cj0aj64Oh4O9FIpG2CXPyPI+mtjbOvf4L6BddxOF4nFxvbwXghFiTpAgUgFwZeLoMPL98OUvvu48v3nknXUvOIVfIMTAwUAG/b9++D/fs3rPy9ddej01c7Jw+6T6NFia6Htddd114xW
                            Urfjp37twbwpGw8Pl8+Hw+AgE/1dU1BAMBjh8+wr6tWzm0YQPer9/BV266TkziTdKItnw5M6+5hrM/8xnmnXMOVeEq8vk8idEEiXic4ZER+vv6VU9Pzws7d+z89rvvvpudBH4yCcUZwJ9MRMyYMUO7ac1NqzvmdTzQ3Nxc6/f78fl8+P1+/H4
                            /VeEqqiPVmIaPbDpNKjFKLp3GKuRxbIdQJEIoEiHa2EhtXR2G6cNxHHL5HKlyejA2NkZsJEZvb2/y6LGjd6xft/5/J+IJeSbgZyLwrxJZfePq9kWLFt3TPr39hmg0qp98aT0hE03YyuVfOWt1XRfbLvWfCoUCuVyunNePMTQ05A30D7zQ091z
                            96uvvtp/GtCnI3GK7f+bJEzTFF+98auL5nXM+05jU+N10Wg0NPmO1zCMSf9KICoXdRMEHMehWCySy5V2PxaL5WOx2LpjR489sn7d+r2u68rfAXjlebrd/52IAOLaldc2LFiwYGVTU9O14Uj4wkg4Uh0IBjAm3xcr8KSH4zhYllUCnkylU6nUt
                            kQi8WpPT8+Gtza/FT8D2H8N/GkJ/HtITPnuwgsvDHZ2ds5rbGpcGA6HZwYCgUYhREgpheM6+WKhGM9kMr2xWOyT7u7ugzs+2lE8A9iT350RPMD/A3EL2ImJMZZeAAAAAElFTkSuQmCC'

  CreateImageFromBase64 -ImageData $IconHT_CTTPSRed
  #==============================================================================================================================================================================================
  #  Texture List Icon - Main Icon (Purple)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSPurple = @{}
  $IconHT_CTTPSPurple.Name = 'Icon_CTTPSPurple'
  $IconHT_CTTPSPurple.Type = 'Icon'
  $IconHT_CTTPSPurple.Threshold  = 96
  $IconHT_CTTPSPurple.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSPurple.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAURklEQVRo3sWaeXRd1X3vP3uf6U66mi3JlgfZkmVjG+MFmBASeE5IIKFNXkhpwtQQ8oC+JmFlKPCgpSXNI8kKvECbsBonLU2TvAQz1AkUCgEy8AqxAWNsDNjyoNmSroZ7r3TH
                               c87eu3/cq2vJ4D46vPWO1k9XOrr37O/3N+3f77cl+E+6BgYGIq7rrovH4xtd1+0SQixRSsWMMViWVXBdN6W17tdaHwAOep5X4v/3dfjw4ZZUKnV9Pp9/vFwuZ7TW5h1eGWPM48aY67XWLf8RDOLf86G+vr7TW1tbvxSNRi/zPC82f19rRRiGa
                               K1QSqG1xhiDEAIpJVJaWFZFpJQIIQEKwEPGmG9JKff/PyWwb9++zvb29jsbGhqucF3XBlAqpFQqUSjkKRaLlMtlgiAgDBVgAIFlSWzbxnEcXNddJI7jYNsOQsjQGPOTMAz+xHW9kf9UAiMjIyKfz1+7dOnSuxKJRCOA75eZm5slk8nUZGY6zf
                               TUHLlsQLkIKqgs4XgQq7NpaIrQ2tZAa2sLyWSSWCxGJBJZQMbFsqx0GKqbRkaG71+9eo35DxPYvXt3oq2t7bvLli27wrZtoVRIJpNhcjLF2Ng4Q4PD9PdlyPbH8bLLSNJGTCRxiGAZGwQoQgJKFEyWWZEibB6j4zTN+tOXsnLlcpLJZI1I1Up
                               Ga/OT6empP1y6tDP37ybw9NNPt/b29j7a2dn5LiEEhUKe8fExhoeHOXTwCIf25HFG1tJOD3W04BJDYiORb1nBYDBGV8kUmRWTTHAEb/0w52xbTs/aNSQSCTzPw7ZtbNsG2JVKTX6kq2v15L+ZwM6dO1u3bt369NKlSzcbY8hm0wwODtLX18fL
                               zw9D33qWs5GkbsXGQwiJMOL/alIjTIUMmoASc2KKEXmAlnPHed+HzqCjowPXdatBL9Fa75uYmPjA+vUbJt8xgUcffTSxYcOGp1evXv0uYzRTU5McPXqMvXv389qzZVbk30O77q5o3FiLH2Pegb2Fqb5VownxRZ5xcYyp9pe55Ope1q9fi+u6C
                               CEwxuD7/q7h4eEPnHPOuW9xJ+vkG0899ZTo7Oy8v7e398MAU1OT9PUd5rcv7OG1J2G1/x46VDeejiOxK4A1oARG6YqEGqMUev53rUEZjDKV95qFnCTS2ERNAlOI8ttX9lHX7tOxtA0pK65ojOm0bXvltm3/ZeeOHQ8uwmufTEBKeW1vb+8VQg
                               gymRmOHj3Grt/uYf+TIV3WJhr0EizlgjEYrdAY0JrQBITGJzQ+GoU0FhILiUQgEGKhSKSwQEiEFCDBwqGeJbQU1/LIffuxLZuzz9lScyXXda9YuXLlr4C/PSWB73//+50bNmy4y/M8USjkGRwc5NW9+9nzxCxtspekasVWHkYpQmPQRqONwtd
                               FciZN9Kw8a86Lo5Ti6ItZ0rsEMVOPJ2JY2AhhIWskKi4lpUBKG6TAwiZpmkmaDn76nZdoam6gd11PBahti1gsdtcvfvHkUx/84MUjb0vg9NNPv7O9vb1RqZDx8TH6+g7zwhMjxIJ2GpxWHO1BaAhMgNGaUAeUdYFc0wQfuqODzVvXIq2q2a80
                               DPdP8tSPDzK20yZGA7ZwKmlVhJRkHrcrwLJBDXvEg0akZWFLj6RsYXZ2ih/99TPc/BdtNDQ2oJTC87zG+vqGO4FPvSUG7rvvvtPPP//878RiMZlOz3DkyGF++eResm+4tDjLqVdteEEclESHISWVJxNOYJ87ydV3b6DntPaKO8z7thDE6yK0r
                               vA4OjxOcUBgNJR1AffdaS6/Zy0XfWYt5368k7qNPvsfH8M2NsZojFGEoszEyDRBNMOWMzcghEBrTRiGGy666IM/f+CBHROLLHDGGWd8qampyfb9MpOTKQ4dOsLA8yUaxTLiQQOWctBaEZgSvimjemf45B3drFq7BCkXJ7NCocSu517jqR8dIL
                               vHol4sIWZA4xOunuGzXz2XhqYEAMdHUvzwa78mrpZhKQdZjYu4SJIQ9Tz7o0O8d9sA3T1rCIKAaDRi19fXfwm4BqjsOLfffnvLihUrLgOYm5tlbGyc/buG8XIxEroRtxwFH4LApxjkSQcpLr1jNavXtS0Cb4xh3yt9/OlVP+bhz/YR7m6lMVy
                               BFzRBYBOogHd/uq0GPjUxzV1ffJiw3yEMFKYnS9NFZQK/jOW7xEwDVsblH//hOaSUeJ6H67pEo5HLtm//bkuNQE9Pz6Xt7e2xMAxIpzMMD48w9pJPTCWJ+AlEWRL6IaWgSDacZvU1sKqnrQbamEpePHZ0mLsufxL9Sit1upNIuAQrSGJCh1CB
                               rwOWdCZqhJ95Yjdz+yVWEKXcmOOqr29myyUtzAXTGF/jBTFiOsnuf+hneHgUz4vgeR6xWDzW0tJyaY3A+vXr/6tt25TLJTKZNEfePI494xEN67HKLqGvKIYF0kxy3lfrufoL70FKUQMuRMUKa7pXcMN92wikQIcuJvAwoYsJHHRooZRgZipfI
                               /D7V1/E+2/qIWulueZbZ9K5spV40qUY5AiDEMt3iKgkMuWw6/m92LaN67p4nks0Gv0ogLz+038WbWpqerfBkMvlyGazDL2eJlKowysnMGVJQRWo+1CBq3/Uy8UfPwPLkgu0v3gfee+Fm/jk97rJ23P4WqFCiVIV8L5WzGYLJ3K4bfGJa7dx80
                               MXsnFLFwATozOIskT7BsoWXhAnUqrjuX/ai+8HC0vx877+tW9EZKy+uK65ubleK0WxWGRmJk3mzRCvXIddjELRwupU3Hj3hWw6s6sGXGuN1ppDbw4wN1c4icRpXP79FeScND4+gVLkRZ6tt0T5yCfPOnnjZO26lQBkMzke3/4qbjmOVXSxig5
                               OKUrEr2N09yypiVS1f7CJRiP1yfq69bK7e9XGRCJBEPiUSiWmJzMw4eCW48hiBFlw8N+w2PP8EbQxqCpwrTSp8Qzf/qPn+dYfP00mnTuJxDqu/LtOcm6avJxl65/YfPKGM7HtE9VLueRTKpbJ5YocePUod9/4M8q/qcMtJZGlCKLgYBUjOOUY
                               IuUwPDyKlFatOYrH4xvtpUs7uizLIl8IKJd9sukcsmRhtIXwLUTo4KoED362j4YdMbp7O9DGEAaKn357N2J/O6n9HncXX+BL95xLU3PdCRLv78X8QLP/5VEu+8xZi8BnM3nuvfUJRp7xsUIbO+fiha1EVRRL2UgNRmmEBqkdZMlmdHgM+e5Ka
                               SEtC9u2u2RdXbIVIPADwjCgkCtjlEChCQhQWiF8G+9oE9+7bh/9RyYIQ8XBAyMc+huBVW7CKjUz87MW7v7CS8xML7bE+e9fz6V/sIlMNksYhgBk0jnuuelZJh5oIDHRRXxqJdHiUpxyI8KPYgIb41sQCLTShEZjlGBmOgPVukpW+uxWCcSN0Y
                               QqRGtN4IcYDZXWQxEQEBqF8R3kKy1sv+4NfvVYH889MoZbbIYwDmEMWWxiemcb37rpFbKZxTGxtKMNYwxT02kmUxnu/vKvmdhRj1NaAn49+HXgx9CBiwktdChQurJ2QIgixGhDejpbq9i1MWit4rYxpuLbStXSosaga23H/HeNCBz0riaeerk
                               EJoFUcYyJoo0NUiJLDmMPCe6O/JZbvnkuiURtYEFH+xJGRsb52s3PkH98KZFSC1p7YES1Hg8rbYIxGBQChUEtQhCGQYVANQbDMEQaY/LzWQUEbsRBo9AoFKpW7msEIaC0A34dJqhD6wjaOBgcjHYxJoIWLp09ScbGUgRBsMgSnZ3tXP35swkb
                               BQoPrT20tlFaEmgIDQToBdBBoatfiqbmRsCgtMIPfMq+n5dBEEzOJ3MpJYlktAo9qFEwiKpIDFYFMC4aF42NwUZLSTla5IKvKa793BY6OloZHhmr+f38dfa53XzhwS5Ky2cIbYXCQlWfqxE1ZanqzwpNSIhC0dhcj9aGIAgpl8sUCsVJOTQ0P
                               BCqyiLSkjQ01aFQhIRVXYjqhm1Va7+qxqWFcgzKVYRuSCmW44JvlLjqD3twHJtYLEprSxMHDhyhXF5siS1bl/PHj3QSrptEOaqigKoiKgqyAFl1rEokaqFYtrwDpVUVfIHcXL7f7j82emB2bhYhBJZl0dzSgFyuCYfLhITYiAXgK4soG/zOLF
                               tvsFm2xiM/pxBWwMevXItty5o1c7MB3/3zw2w+f4brbjwH2zmRRjeesZRbdtjc/ekB1CutWGGllAZnPkwxyGoIB9CmWb5iGb7vUywWmZubY2Ym/7o9drj94NTkVLahsbHesizqknUsOydGetgnJEADVk0zDtqS2OdlufX+Faxc3XjK/n3seJo
                               7//urFH/dzQu/kcRib3DV9RtqZQjA2vVLuO0nFt+87gjhPzfjBDbC6Pkmu2qBgACfjq0x2tvbyeXnKBQKpNOZbHqk7aBM/PyPSpOTUy9IKZCWJBKJ0LulnQCfAB9V1YTBQQsb3/O58ivNNfCV4F98HR+Z4avX7SP37Eq83Eqic1388pYmHv7x
                               IbReXDytWt3Mn/59L4lLpghcHy3mY8wmxNRwbPvdLXieW6nXZmfJZrMvRB66sSQNiL5DRx8NwxBLWriuS/f65bCmjE+ZgKDqkw5gE8Z91p/eDMBLu47yzT97htxcaVFPcO8dL5P/zTK8YgfSxJDaxcu38fjn6/jHRw7X0nVtn+hs4LbtG2m9f
                               IbQ9THCQiMJCQkoY7rKvOeCsymVS2RnZ0nPpJmZnv25mS+nX31xeufERKpgVWuMpqYGNn+sibIoEBIQYtBYaCFxlgpc1+LxR17nno8d5/XvLOGuW09sXkIImpoasIMGMBHM/IhX20TybTx0vcczT/S/xWotrQluuXczq24ooqQmRBPgUxYFzr
                               1qGau6VpHJZslkMkxMTBTGh5yf1foB9Tc3TQ0ODj8ihMCybTwvwpnndcO6HGWRJ8RHzwfzRIK/vWuAHZ8Jic2sxit2cvTZKMNDMzULzIxrhHZrk6zqAAKpHaJzHfzwGvjnXw2+hUQs5hJv1CgZEAofX+QxPXP83hUfIFQBM9PTTE1NMTk5/XD
                               iwb+YmidgAF7dc+yedDodWpaF4zo0tzRywafbKVgzlOUcSvqVUflEktfubCSSW47QdZj1OW57cAUbT++sTLKHZhj9hYPUTg34ovJZuUTSy9h+dZk9u09M0YMg5Mffe4m994QYo/HFHAV7mo9+eR3dPWuYroI/Pno8HB8t3DPvhLWUMPFXn3/t
                               8OGjDwghap3PGVvX0PUHPgWZwpcZlChjEMgwitAR3M0+t+5o4rRNzdUed5btdx7Em21FaueUGUoql+h4J391VZbX940zPZXj3q+8wC9v01ilOAEFCnKSNZ9SfPwTF5Ev5plIpRgbH2d0dOwB6+Gvv/aWuZCYddi7a/L2JUvGLmltbW20bZtIJ
                               MIll2/kf4++QeFXUYyxcQRYqg5hXMIJwcPbx2lo7yc9WeT1R0KciTbcUuNC3XDy4FRgEMrBG+jknitHkfEh/DfqsAOHgCJFOUFiW4obb/so0ViU/oF+xsbGGBwYTB/vd26P59zaw6yzuGPe0qK8a+uc2fLUdFt7y+/Yti2EEDiuzdotjRwY6K
                               c8IhDCQkgQAkROMrNHMvqcxcyLMdxsC7bfiDBe9ZEnKqm3FQ1kLHTKQWpBSJ6iGMfZOszN915Id08Xx8eOMzQ0xNEjR83hQ8NfcP7+G79ZNNxdQKDiSsdW7I+u293d0tK8aX64Go15bDqvhb6pY8wdDapjQQNCI41EagdLRRAqgtDzu+1CsGq
                               BhCACjCyjrSJGFtGigE+GImM0XTzBLfdeyLrTehhPjTM0OMix/n4OvXnkp9mdX/yKPZs0b0eglizkdILj0WPPJlpS2xobG5bND2SjUY+zL1hOJjHK0IsZBBohqgBF1aJSVUQokGFVfJBB5dUq14BrK48SOUKRxWeKgjXC5s/5fPl/fpgVK5dV
                               wQ/R39/PwTcPvTj4cu8ViX3nl08a4BtxA0YuJDAv3n/7QevW97n/1NW1atP8qaJt28TjcfreGGPH/zpC8cV6XNOIQwJpokhcBDbCyBNGFSf831QLZS18NEUCcpRFmuiZaa64eR3bPnA2QsLYxBijI6MMDAxw8M2+/cf2NX44+dgXU1XwZgEJI
                               26odBQL3WgBiR8u2XyefmT16lVbFx79xONxHMdj7+4Bfv7Xx8jtiuOaJBZRLLwKCSzmz2tOtEYBijIhBQIxS+ysHL9z/Ured/EWmpobmJ2bZXx8nLHjYwwNDXHo4OEXB15ru7T+8RtTJwN/OwInWwFAmo89kdj4vsHvdHev+kSiLiEcx8FxHC
                               IRj2SynmgkxuDRFC8/P8iuxybJPG9hiygSB1mdHVcaJJ+QEnVbA868uIGt713Fhs2riSdiFAoFpqanmJqcZHxiguGhYXPk8OADx/ec9bmG5y7LnaT5RSTmCXAqKwBCrcjI5dfe/6k1a9u/3ta2pMHzPBzHwfM8PM8jnoiTrEvi2C5zs0XS03P
                               MZUuUigG+H5Coi5Co82huTdLYlMRxbYIgIF/Ik62WBzMzM6QmUgwODmWGBmZu9Xf+jx+4k836VMBPReBfJWJdc3/nmk25ryxb3vaJxsZG6+RD63mZH8JallUbO1ZH4/h+Zf5ULBbJ5/PVun6GsbExNTqcemCsr+OOusduHH4b0G9HYhGBd0QC
                               Vwvnmm9vWtnDjS1L6j/W2NgYW3jGa9v2gn8lELWDunkCQRBQKpXI5yvaT6UmC5OpzM7x/uhfRnfeekCEUr8D4AZgO6IC/hRW+NeJgCh/5MGWjtOOfaR1Sex343XRd9UlEslINIJt2zUCGCojkiCgXC5XgGeys7PZwq7pqfJj04d7H61/+urJU
                               4A9JfhTEfi3kFj0t/K7XolG1v2ftQ1L/A3xhLXSi9itQhDTRhOGulAuBpO5uXAwk/JeD/ouOBR7+ezSKcCefO+U4AH+BUAJm0y2zU0sAAAAAElFTkSuQmCC'

  CreateImageFromBase64 -ImageData $IconHT_CTTPSPurple
  #==============================================================================================================================================================================================
  #  Miscellaneous Icon - Main Icon (Green)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSGreen = @{}
  $IconHT_CTTPSGreen.Name = 'Icon_CTTPSGreen'
  $IconHT_CTTPSGreen.Type = 'Icon'
  $IconHT_CTTPSGreen.Threshold  = 96
  $IconHT_CTTPSGreen.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSGreen.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAUo0lEQVRo3sWaeXyc1Xnvv+ddZtNomdFqWbaQbNmSbRwcdnMDGGripoUAbZZLuBAMISWXAtclNGnLTcgCScmFEJKWBEgLNMGJSW0cIMUmCzHecGy8YcsSXrRZ0sxIs2/vck7/
                              mNFYsgkf0uVz3/dzpPm8n9F5f99znuc5z3OOBP9F14kTJ3wej6e7qqpqicfj6RBCNLmuG1BKoet6zuPxRKSUx6WUB4Fer9db4P/31d/f3xCJRG7PZrMvF4vFhJRSvc8roZR6WSl1u5Sy4T+jQfxH/qivr29pY2PjGr/f/zGv1xuYei6li+M4S
                              Oniui5SSpRSCCHQNA1N09H1UtM0DSE0gBywTin1iKZp+/9bAfbt29fW0tLy9bq6uhs8Ho8B4LoOhUKBXC5LPp+nWCxi2zaO4wIKEOi6hmEYmKaJx+OZ0UzTxDBMhNAcpdSPHcf+W4/HO/xfCjA8PCyy2ezq1tbWh4PBYAjAsoqk0ykSiUSlTS
                              QmiToxkmaSnCePrTsAeKWHGllNWIZo8TbTWN9ITU0NgUAAn883DcaDrutxx3E/Pzw89MPOznnqPw2wc+fOYHNz8xOzZ8++wTAM4boOiUSCaDTC6OgYA6MD9BnvcLIpgmwWVAWr8Jl+TN1ACA0BSCWxXYeCXSCbyeCJ6sxPtrPUt4T21nZqamo
                              qIOVZUlKqH09MxP6itbUt8x8G2Lx5c+PChQs3trW1XSSEIJfLMjY2ytDQEL0DR9hbe5B8l004XE/AG8DQjbJtC4SY1rUChUIphZQSx3XIFXLE45M0Doa4zLiEBe1dBINBvF4vhmFgGAbAjkgkek1HR2f0DwZYv3594wUXXLC5tbX1A0opksk4
                              AwMDHOnvY7uzk/jZORobG/F7/SWnLDnkew6JQJyCkQpHlvwnFosy/8RcVrWuZFbLLDweT9npNaSU+8bHx1f29CyOvm+AjRs3BhcvXry5s7PzIqUksViUo0ePsefwHra27iK8qJGa6hoM3Zgx0mrqFgqlTn+JQJR/Tt0ASilsxyaVTmG9k+MTn
                              uvomdeDx+NBCIFSCsuydgwNDa288MKLzzAn/fQHr776qmhra/vhwoULPwIQi0Xp6+tn69vb2HLWTpq6ZxGsDqLpGkqAROLgYisHW9lY0sKSpd+2skvPlI2NjaNcXOUiy/cUsBAC0zSRVbAlto36iTpaG1rRNG0Kss0wjPYVKy5f/5Of/HSGXu
                              N0AE3TVi9cuPAGIQSJxCRHjx5j28Ft/Gr2dubMmYPH70VpCgcHKSWucnGUiyMdHNvFdkrP0RXoIDTQRCnm60JDR0cXOoYwyp81BBoIhcfvoXpWLU8dfQ7jsMGFZ19QMSWPx3NDe3v7r4Gnfy/Ak08+2bZ48eKHvV6vyOWyDAwMsOfQHl6p+iX
                              NzbPQAwauKC1QEomjHGzXwbItcgmbs7JzOC+4FNd12Z3azwGjD7MODJ+GrmvomoEhdEwMdAwMZaCjYWomuq6jhMIIGAQagnz32PeprwnTPa+7JNQwRCAQeHjTpn979aqrVg2/K8DSpUu/3tLSEnJdh7GxUfr6+9hYeAVvmw+jxsDRHZSSKAcc
                              5WA5FvmchYia/FXL7Zy/8Fz08rR/Ul3P8egAPzq6jn/z/xpPnYahG+jKQLcMRMpkltWIECaTvhS+kIHhMZC6i15t4NYJHn/rH3iw8WuE6upwXRev1xuqra37OnDzGT7wve99b+mll1763UAgoMXjk7zzTj8vH/kF/Y0DVLfVYlQbSENiKZuCU
                              ySTyxGP5pkX6+Cri+9j0ayFaNMcWghBtS/IHHM2xyb66TeOYQmLQt5hSWwRX53319zY9TH+ZPZK5hZb2TzxG5RZNkccHOVwIjGId1znvIXnIYQohWDHWfzhD1/14tq1PxmfMQPnnHPOmnA4bFhWkWg0Qu+xI/zSs4W6pnqcgEOePEW7iJQSqy
                              hpijXz0Ly76WqaV3G2qSuXz/H6ga080/s8O6v2IFotBBqaY9IR6+Iry/6acGlBZzhykm9sfYxMexI740MzdBAKx+9iNnh4qv8Zrhy4gq7OLmzbxu/3GbW1tWuATwNoAPfff3/D3LlzPwaQTqcYHR1ja2wbdsjFqXHJaXnSdoZkPkUim2JiPMP
                              fdN7FwpauGeKVUuzu3cv//NFt3D50J2+0b6bQGSETTpLypEjZBW4Lf7IifiwW4e5//QInqvpJuznCE/UsSy8llU6TVzmcGpdsdZF1O36Gpml4vV48Hg9+v+9j3//+Ew0VgK6urutbWloCjmMTjycYHBnkN9oWZFhS0PNkrQzpQopkLkU8lufj
                              7kfoappXEa3KQf+dwWNc//L/ZlfrGxQ6o6Rb06RCOdKBHFk9R96xaQvMrgC/sn0ze41DZL15zESQryz6G1bVXUkimiZdyFDUCqiQ4l9Gn2dweBiv14fX6yUQqAo0NDRcXwHo6em51jAMisUCiUScQ5FDxAMpLG+RnFMWn86QHpX83+A9/J9L7
                              0DTtIrwqcWsq30eT1/5NSQ1FPyCnN+m4LUoGhZFvYil2cSyExWAm/74E3yh/S+xT9bw2JIHaG+cQ41RQzaeJZtPkXOyWN4iEe8Eb+x7A8Mw8Hg8eL0e/H7/RwG0Wz53iz8cDi9XKDKZDMlkkv2JA7h+m6LKkStmySYdPpy8kucXPM6ff/Cj6J
                              o+bfRnriN/dM4Knmv/Dt7xVnQrAEovrcXSQBW9JDKpUzHcMLj1yv/FS1c8ybLODwAwEjuJ5eTIWWmydoaCyOP6HV7e+zKWZU9PxS958MGv+7RaT213fX19rXRd8vk8k/FJ9tr7cMwCeTdDLp+lPdXGIysf5Nx5yyrCpZRIKTn0Ti+pTHoGxMr
                              FV7C26TsER1swiz40x4uWrOdb3MsN5//56QsnPWctACCRTvLEzqexzAQ5N0POylBwc9ieIq8n32A8Ml6uHwz8fl9tTW1NjzZ//vwlwWAQ27YoFApE41HG1BgKB9cq4Ng5DtpH2XpoB1Ip3LJwV0rGYuPc8eLnuXfd3zGZis+ciZ4VrK3/DsGR
                              VjzRRh6x7uOOZasx9FNLT6FYJF8skM5meKt3H3c9dy/b/L8i70uQI03BSVN0sriaxTjjDI0MoWl6pTiqqgouMVpbWzt0XSebsykWLeLpBEKB5iiwXaRw0cwod2y/j3VVT7OwvQslFbbj8PirT/BO2x56q/eS35Tn0ZUP0VBbfwqiewVrDz7Gr
                              qF9fOaKm2aIT6STfOFHX+a1zDZc0yLvSSJr4lhVaQqmxJWgXAUuIEvuOnRyiOXaxaX0QtcxDaPDqK6ubgSwLRvHscnkMgip0GwQRVAGSC3LaN0Rbtt0Nz9c9TjtLXM5eOwQzxSfx25LUKxRbLReRr2ueOzyb1JfEz4FseRyFtX3kEikaagv5f
                              nxVIL71t3Pz6vX485O4mh2KSXUJDYKKQEXNAewQdkglSIWnyjls0KglersRgOoUqpUZEgpsWwLIUE4pYYEDIXjTdFbv5vP/uou7lxwO3vG38JtmqQQtLH8Ai2QZKP5C8zfmjx6+UPUBWsrEK2zmhkdixCbiKMZ8IUNX+KV6hcpNk5Q8Ni4spS
                              e4AIOCBeEVRIvXFAuCAmT8Ymp+ghZ8sMqQylVsm3XLYVFVepkqqPSdgMoKXF8SQ54tvK5sbcQpo1Vm8XSwRUCabpQl+Jf1S/wbgrw8Ie/THVVsAIxq6WJ4ZFR7v3Rl3l91iasxgR5v4uNKpX+grLpgigLF/IUFK7CtuwSgJRIV2I7DppSKjsV
                              VUDgNXwlcqfUgVClBiCFwvbmyddOkq1Lk/dJXB2UECghcDUdSzfpCnUwNhrFtu0Zjt02exZ3XbUan6rHNny4mkAhQJYEa1Ojr6a1KWuwoSHUAChc6WLZFpZVzGq2bUengrmmadRU1aDK04csjQxTTQNXB8dU2KZC6hoIHaF0hOtFpBr4e+7lL
                              z90O7NamhgaHsVxnBkQy5dcyE/O+z4NkXkYhRqE1CpmMb2CqzRZ8gFlQ32oASkVtu1QLBbJ5XJRbWBw4ITjll6i6Rr1dWFUAaRVBpjWoxKgNFCaAOVD2HVo+Xr0XAhtsolHnM9zx7LVeAyTQMBPY0OYA4d7KVrWDIgLFpzL+mVPMW+0BzNfi+
                              bqlf7RTiOQZV8oasyZ3YYr3SnxpNPp48axY8cOptIphBDouk5DfQNt7hzGC0Mo99SQqCkIBNi1tCQ7uLPuU8yr6SBtZdAxuPHcj1dCpaZppAppvvTbb3Lp8fO5+yOfwzROhdFzOpeyzniKm7fcyYHwW9hmomw/pUESZRAlQRah2W5mbttcLMs
                              in8+TTqeZnIy/bfT39/fGorFkXShUq+s61dXVXBC+gA3ZIYwiEIAp35ZKoJwgF2eX88yHvkdn81m/dwfiZHSUO15ew66OrewQOwhs8fPZy1ZX0hCAnrkLWbviB9z62j3sqNuOa06ihFsSr5XeqWxw83B+3fm0tLSQyabJ5XLE44nkyPBIr7bx
                              xY2FaDS6TdMEmq7h8/n4YOcyZFbg5kE6ZQAFSmmIfIiv9nyxIr7k/Kft5I2P8JmNd7Nz1hYKrRnybQn+Vn6L57atPeP7na0dPLfqH1g1eRVGtgHh6qXBKo++WwCVFVz9P67G6/WU8rVUimQysW3dunUFDR1x5EjfRsdx0DUdj8dD97xuOoqdO
                              NnS9EkXpATl6viz1SyduxiA7fve5P6nHySdzcyoCb604ZvsbthBsSFLzi8p+BwKjZPck/4qL+zcUMliK9GpaTY/+Oi3+Xj2OoxsI0gdpcC1wc3BWYUOLlt+GYVigWQqRXwyzsTE5IulBU0Kdu3atX58PJLTyzlGOBTmunnX4qYFTh5cpwwgNd
                              oJ4TW9/Ow3L/Lx127laf6ZL77wAIl0spJa14dqcaotih6FIwSuAttwKDZM8hdjf8crv3v1jFlrDDXw2J99g1u1T6EXAyinbAFpjRsXf4qOszpIJJMkEgnGx8dzQ4NDGyr1wFNPPhUbGBj4mRAC3TDwen1csnQ53flu3IzALYB0BEhJxBzn4dc
                              e4Y6+NeTnjlJszrHJ3sHg2HBlBkYL47hC4kqBckA5lMKfaVFoivHpo5/n13t/ewZEwBcgTB1GQUMVQGU0FuS6uOGaG3Bcm8mJCWKxGNFo9IWf/vSnsSkAJYRgz+49j8bjcUfXdUyPSX19A7ec/WlI6KisDpaOkjDpGeVb1qMUmifIVem0FRbw
                              wh89wdKuklkNjg7xK2sbUnOQUqEcBY5CuSAVWKZNtjnCjQfuYcehXRXxtm3zgw3/xD+OPAWyiMroiLjBX128hq75XUyUxZ8cOemMjIw8OlVE6aL0SezdtzeyfPny+S0tLUunysSmcBPiJOwtHASPAFNDmeB6JI6ps0QuYu2FT7J4Tk+lxv3KS
                              w9xqG4PxWoLRy85P3JaUyCFi2Pm2Hx4G5dVX4QhDL6x9hG+Pfo4ds0EBcfFmRCsNm9izc1rsF2boaEhTgwM0N/X/+Nnn332B1NpRQXAKlqira1td+vs1puDwaBfKYWmaSxsXcBY3yjH5CAYotKUBrprUBjJse/IATbseon7dj7Avto3KYZzFL
                              wKKUQ5/k5vCmQJIm9m+PWRLbywez2/dDdhBRMUXBc7Diuzl/P3t36TcDjM0PAQg4OD9B3pix8+fPiT+/buS00t3hUAQOzYsSO9bNk5E80tLX9qGIYo7Vl6WNa2jMHeEwy6IyUAXSA0yOpZ9sr9bLe2sdfYQ65+Aqu2SMGrynlOWbT7Lk2CxCG
                              pTzJhjmEbeYpFiZ2Ai1Pn8diN36ars4uToycZHBzk6DtHVd+RvnuefebZ16dvKE8HQAjBsWPH93d3d89vaGg4e2rLJOAPcEnHcib7o/QVj1XyIjSFNBwcn4Ptc7C8CtsoZaczTMednlUCjqpkvNJWOEWJnVW4cbjauorHbvw2Pd09jEXGGBwY
                              4Njx4/Qe7n1+/fr1D6TT6RkxeAqgkvFMTk7i8/l+2dDQsCIUCs2eOqzw+/xc1nMZNWN+tsd2nTq4KKcZUistPpLTzMYtpcJTgrEBCygAOYXKKFRCoU1orKm7g6/d9DXmzp1bFj/I8ePHOXz48Ju7f7f7hv379xdPy/vUGQCAePvtt+1QKPRSb
                              W3tytra2uaKx2s6Fy66kCtrLmWk/wSDhZOnRErAFadGekqsPU20pcrCgYyCJBBXLM98kMcv/X/cdt1tBAIBRkZHGBoc4nhp5Pcf2H/gmk2bNk0vutW0LcwZCfMMkNW3rm5afsnyn3V2dl4w/einqqoK02Ow8/Cb/OOuJ/itvguqBHgpRSv9tK
                              MTOc10bKCgIAeXOOfy2fM+w6qLVxEOh0mlU4yNjTF6cpTBwUF6e3vfPHjg4PWvvPJKpCxanQagpgOcnooDaNdee21wxRUrvjt//vxPBKuDwjRNTNPE5/NSU1OLz+/j2Mhxth7aysajP+d1ZzuY5Wg11UtFvOAS7Vw+0r6KDy2+lA8sWEpVsIp
                              cLkdsIkYsGmVsfJyhwSHV39+/ds/uPXdu2bIlM038GRDiXUzojJpizpw52i2rb7m5a0HXQ83NzXVerxfTNPF6vXi9XqqCVdRU12CaJqlMionkBMlMiryVx7YsqgPVVAeqaQw1Eq4LY5omtm2TzWVJltODyclJIuMRBgYGEidOnPjihvUb/jkW
                              i8nfJ/z3AbwnyE0339R29tlnP9A2p+0ToVBIP/3QeqpNbcLqul7ZdixvjWNZpf2nfD5PNpst5/WTjI6OusNDw2v7+/q//NJLLw29i+h3g5gB8L4gPB6PuOnmm87u6uq6q7Gp8bpQKBSYfsZrGMa0fyUQlYO6KQDbtikUCmSzpdGPRCK5SCSy/
                              sTxE4+9uOHFg47jyPchXJXzLjUV/99tFt4TRCklrr7m6oZFixZd09TUdHWwOnhRdbC6xuf3YRinzotR4EoX27YpFosl4YlkKplM7ojFYj/v7+/f+Nrm16JCCPU+R11NS93PAPhDIJgGw0UXXeTv7u5e0NjUuDgYDLb7fL5GIUSgfIyaK+QL0X
                              Q6PRCJRN7u6+s7svt3uwtl0byHk76neIB/B57KCLDPvwy3AAAAAElFTkSuQmCC'

  CreateImageFromBase64 -ImageData $IconHT_CTTPSGreen
  #==============================================================================================================================================================================================
  #  Help Icon - Main Icon (Gold)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSGold = @{}
  $IconHT_CTTPSGold.Name = 'Icon_CTTPSGold'
  $IconHT_CTTPSGold.Type = 'Icon'
  $IconHT_CTTPSGold.Threshold  = 96
  $IconHT_CTTPSGold.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSGold.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAUIklEQVRo3sWae3xdV3Xnv/s870tXryvp6mHZli3Lj8SxnbdNCYGGQmlME0pTXGgGMwMD04Y2lA5MyRD6aUqYmUKZkE9JIKGQkpRA6sRMOhMCdAh2iB3s2I7j2HIsWbqSJV1d
                             6b4f57X3/HGvXnbC0Md85nw+63N17j1nn99vr7XX/q11JPhXOs6fPx+yLGtjNBq9zLKstUKIziAIIkopdF2vWJaVllKOSilPAqdt267x//s4e/ZsIp1Of7hcLj/tOE5OSql+ySOnlHpaKfVhKWXiX4JB/HNuGh4e3trR0XFnOBx+r23bkYXvp
                             QzwfR8pA4IgQEqJUgohBJqmoWk6ul43TdMQQgOoAN9VSn1R07QT/08JHD9+vC+ZTN7T0tKyx7IsAyAIfGq1GpVKmWq1iuM4eJ6H7weAAgS6rmEYBqZpYlnWCjNNE8MwEULzlVKP+r73p5ZlT/yrEpiYmBDlcnlvT0/Pf43FYq0ArutQLBbI5X
                             KLlp2fp5pLI2pZzKCMjlv3jBZCWs1o0QRN7UkSHR3E43EikQihUGgZGQtd17O+H3xyYiL18MDAOvUvJnDo0KFYV1fXV3t7e/cYhiGCwCeXyzE7m2ZqaprJ1Bj+9Cv0iFdY0zZJe5tOJGJhmDqaLgCBDCS+F1CpuMzNS8Zzq5kPX0Xz2h309a8
                             mHo8vEml4SUmpHp2by/z7np6+0j+bwLPPPtsxNDS0v6+v7zohBJVKmenpKVKpFCPDpwmlD7Aj+TL9fSFCTWGEpYOm1UcVFw2tVD2iAonyAmqFKuOTLqfyO4lueidr128gFoth2zaGYWAYBsAL6fTs7rVrB2b/yQT27dvXcc011zzb09NzhVKK
                             fD7L2NgYw8PDFE7/I7u6D7JubRSzKQyGBppojPZ/capaIKPAl3jFKudGHU46uxm4/ma6u7uxLKux6DWklMdnZmZu2rRpy+wvTWD//v2xLVu2PDswMHCdUpJMZpZz50Y4efwo7eknuPHyeVqScTCNZcAbwBZRLn0sPaUeUkvXA1KB65ObKXBge
                             ID41R9lcONmLMtCCIFSCtd1X0ilUjdde+31l4STfvEXzzzzjOjr63t4aGjo1wEymVmGh89y7PABVuUe5q3basS7msDUG0AkKAkyAOkvWeCvPFdB45qgTlQuW5+aIBQ2SIZneO2lnzLPOjqTPWia1pgX1WcYxuobb3zLvu985/EVeLWLCWiatn
                             doaGiPEIJ8Psu5cyMcP3yQzsyD7Bh0icVD9btUANKDwAW/hnKreNUatZKDU6zhVSrIWgncEnjluvkVCKp1kw4EDgRenZQG8WabbWuy5H52FyePHVnAg6ZpWJa1Z/Xq1Xt/oQe+9rWv9e3atWtfS0tLuFIpMzIywrEjh9FHHmDrQIVVnTH0kA6
                             aAuWDdFGBS1Dzyec0MtVdOC23UdKvYy5jUctPYKgahqohpFcHG3gQ+Eg/QPoSFQSARDQ8aQiFlPOcPnoUu/taEh2dCCGQUgop5a/s3n3ztx955G8LC5iN5QS2bt16TzKZbA0Cn+npqfqCPfk4W3on6WxNYJgK8MBXoCQyCHAdwUyuH3vrZ1m9
                             4WqEpjfcvofs1HnGfv63JHLfoDVaRtcFSui4Xph8JUxFbQDNIGaM0NpUwtDANBUdrRZd2VMc3vdFuj7232hpaSEIAmzbbm1ubrkHuP2SELr//vu3rl+/fo8QglwuRyqVYuyl/017+Kd0JyyiYdA0t+5+v4pbdclkTEbzN9H61q+T3HjdIngAI
                             QTNXatI7NhDUb8Jx6sR+BXKZY2xyjuw3/QEa37r26y59VvIzV9iPu8SeFUUDuGQItluY7nf4+Azf4+u61iWhW3bRCKRPU8+uW/rJR7Ytm3bnW1tbYbrOszOpjk3fAZtfh/JdRqtTWAYLkr5iAAc12CqdD3x6z7Lxp5BhLZyKdWqFU6/dIDJl7
                             5NuzhIf+scRrSI9KPMlLayavfniMTbAMjMTHLih/cw1F6gVDPQNIHQPJpj0JnQGH7xrxi7/m0MrB/E8zzC4ZDR3Nx8J/BvFj1w1113Jfr7+98LUCwWmJqaZvb0AeLxGbraIGx7CFElCCo4jsNsNkzTtZ+lrW9oBXilFK+dOsYPHtiLf/zDXNH
                             8FJd1jdMVy2PpCt+PYK/74CL4ucwMP370E7RZL6CkZKa6kzn9/dQ8iWV6dLZCJDLGz575HpqmYds2lmURDofe+8ADX00sEhgcHLw1mUxGfN8jm80xmRpH5n9IVzs0xySGUUWqCo4XMFeIk2v6d7T2rF8ErRr5f2JshCPf/SiXNf+Eyzou0NtU
                             IGZ66EpBIAh8E6ulb5Hwzw88S5zjxEzIlDfTccMX0FbfzFzZBOEQj0g622Hy5DeYSE1g26FGGEUjiUTi1kUCmzZt+k3DMHCcGrlclpnzrxAJz9DZAhFLIVDUnCgz2V6qq/4Lm9/5BwhNWwQuGrJh1Zp17HjXX6B5bRjSRsj6NlHfsECTErc4t
                             0jgV3/jd2gd+o9Mzg2QfPMXae3qR7PjFGsaUklClqKjGWw7xfHDBzAMo7EWLMLh8LsBtP/8Hz4Ybmtr26lQlEol8vk8hcmXaY1DSxRMTaNa62AmuJ3QNY8wcP0tyzKNWtptG8fgVTdiXHkfmXw/vhuFQEAgkIFFzQlTKRaWcrhhcPU7fo/Bd3
                             +T3sErAMhmLqAJD01ITL2OobUJTjz/NK7rLZfiu77w+XtCWtVq3tje3t4sg4Bqtcr8/DxB+RjtMYjZoGFQ8TazYfe9dA9uXwQupURKydi501RKxRUk+q58K3LHV5jL9uPXYgROiGIhSaHzkwy+5bcu3jhZNbABgFIxz/nDD9FsF7E1halBNAT
                             tTVBK/4R0eqZRPxiEw6Hmpnh8k7Zm3frLYrEYnudSq9XIzc1i6TM0hyGsg0mALc8xeeqFFcCllBTmZjj/1Cd55bHPUClkVwDrufJG5NVfIZ1dTbbQS7brU6x++4fQ9KWtx3UcXKdGtVxi7MxxDnz7j+kP/4j2UJmQrrC0OoZ4GEx9hslUCk3T
                             F4ujaDR2mdHd07NW13XKFQ/HcSkXclgGhE0wBVhaQHskw9jP/4SZ2EMk+gdRUhH4PqM/+CqXx49gq6NMPlal97bPE2lpXwTYfeWNjMv7mDxznCvedvsK8JVinsOP3o1dOohleERCOa6I5ohHCliGRAlwFfhaHYttwtRkCk27vi4vdB3DNNYa8
                             XhTB4Dnevi+R7VSwtbAFmA2NgpTq7A6fobxH30c/ab7aOrqJzN6is7sY7Q2zSOEpLe2n+nHFN3v+wLhlrZFoP1XvwWzbxPzuSKJ9rrOrxRynH7sM2xR+2juyKHpAZruIwyJ0BQIUKK+/k0NLK2uHXPZDCDqNXa9zu7QUESVkviBj5QS33XrqU
                             nWJY9o6PeQKLAmegTnh3cwf+Qf4OQ+OkPzaHgI5RM250jK7zP16GeoFfIrwqm7uwulFJm5LPnMLGcf+U+s954gYaextCqGcNAIEHKh6Kk/16COgTonsvPzy1S4IghkVFNKNU6Cek5vyHrZUMkEgA/4Ekvk6bEPkjjzUZLF+7H1fF0WByCkT1i
                             fo8P9PsPf/DOq5ZXSvTvZifR9jjzwGVZXnyZmziGkX9dVAUvmN0wugZeNdOx5Xp2AlPUy1ffRlFLlhcUJAtMKEfjgNyQ9aplJha6q2Po8pig26oCF3wUKA09aGB0DTE7NLj5wcWH3drPxXXspewkCGYZAWwLtLQPfICMkiKCOIwigtS0BKAIZ
                             4HoujuuUNc/zZhcqKU3TiMSacF1w3AaBoLEZyeVkFqZGNEwjCGwKlST5tX/Chvd8mGSyk9TEFL7vrySx7Vqs3Q+SLgzi+fElEgvPCJZ9Nuof161bS1s7Uio8z8dxHKqVyqyWSo2d94P6QzRdI97SjutC1anfpIKLwQNSIKWN67dQ9TqoOgnyl
                             R6yA59i9e4PYZgmkUiYjkQbZ0+dxnPdFSQ6tlxJ6DcfZrp4Ga7fDFJbIrCciA+uA04NXEfQ07uKQAY4jkOlUqFSKo4ak+dHThaKBYQQ6LpOSyLBWb+PYnmCag2UvayklXXwrt/MfHkNXv/70RNr8aslHGWw7td+ezFVapoGlSLu39/L6OA1rL
                             /tY2jGUhptH9qK9ttfZ/p7v09X5CiWmUMIWX9YY6KUhFoFShVwvS56V/Xjui7VapVisUgpl33FSJbPns7MZvItra3Nuq7T1NSE2XktxdIE5QrICGjGgmsFfhAj7ewk/jv3E+9d84bNh9LMFJmH/ojB0HM4488zvj9M/7v3oulLNUPr2iG09z3
                             I1Hc+TlL9DNvOIkSwWPsrD8plKJXBTFxDMpmkVC5SqVTIZnP5LmfytPax7ftrs7Ozz2uaQNM1QqEQicHt5IuQL4JfW4pLJTUqtRasN39qEbyS8hLwxelJZr9+B93mjwlH0zTHpmg++3lS/+uxS65v7ltL4v1/zVTwa9ScBCrQF0PIq0GhDPkC
                             bL3hZmzbquu1QoFCPvf8Hdu/W9PwEefODu/3fR9dq1c+fes3kqsMkC9CtdzIDAqU0im7TcTXXQbA9LHDnHjgL3CXp0ylGH/kXrqMA9iheYQRoBkO8dg0sZfvZuLHTy6q2IUj1tVL1wf+iintFqpOB0rq4NXDJ1eAXGUtV7/pBmpOjXyhQHY+S
                             z47/xReQ07PnXpx38xMuqI3NEZrWxuRzbcwl4NiGXAWsoIA0YZu2kz8+Cl4ci+r5x/i/N/cTXVh8xKCWEszplVF6HKxAaSLGi2xC4Re/DQXDj5zidcibQl6P3Av+djvErgRqAmKJZjLQftV72fNmrXk8nlyuRwzMzMVM5t6crEe+OTGr2dSY2
                             NPCCHQDQPbDjFw1U7SlSEyhXo3hAAEPk3GFPn9f0ns0B+SaBkjHC2iZV4gd2FiqblVmqnH8oLW1upbqq7XaI1NYjx3J9MvPncJCTMcAasF5Qm8KmSKMFPewK++Zw9+4DE/N0cmk2EuM/u9P7v68czC0AoFIy8f/VI2m/V1Xce0TFrbEzRdv5e
                             JOSgU614QKiBqjtEy8wXisQsoTWfW3Uzrnq/SvXFLPf4vpAgXD6Lp7qW9P6EwjArtTROoH/wB6RMvLv4UeB5jT32DaOpBDL9CoagYz2j0vfMTrFs/yFwD/IXJC34lPfmlhbnR7765vuavihxLP1/Zub4rmdy6UCY2JTpJpQTh4jESFugmCCSa
                             5oMQlNmB/Z6HaB3YVFeYmRnmvnsvCf0Qplle6jpd1GLUhEfIqlJ6+QX85PUIzWDisb+k/fx/p8mewa94DGfgXPNebv7InXiBRyqV4vzYGOfOnn30z4e++aCueSu7EqZWZPaVQ3dNdXa+q6Ojo9UwDOxQiIF3vo9XH58kPvcsawE9AlgKhMSUa
                             fL/+BD5UBJVzGBe+J90RVJY4Vyj+bUMuFpGBIWpF+lsOkPhqQ9RDCJ0i1cJWVlk1WNsDl713s7b//hPCUfCjJ4fZWpqirHzY1kzM3qXtba8OC2LHgDENfFDxWemts0lupK/YRiGEEJgmBbhddsZeWmciD9O00IHXSgMLU+4doxo4ac0uYdoCk
                             9jWiWEJi/tSL9Ol1rDw9bSRLQJLEoE1YCxOTha2sX2O77MmvWDXJi6wPj4OOdeO6dSrw3/4b07vvWTFa3FZQTq+t0ZOXGovHF9eyJx+UJz1Y5EiGzaxWsvz2NUhomJuuuEUGiai2446IaLED4rR/tFLfb63iICiXACqiXFyBycYDfbPv5l1m/
                             axHR6mvGxMUZGR3nt9OnH/qh33+fioYJ6PQKLve+YNc/I+dCP0nrixpbW1l4h6gWEFQ7TvuMGzk3HKad+RkgDW71Od5iLw2XZ32qZ1vEBF/wqzJXgVFpnrO8T7Lzjz+ld3d8AP87o6ChnXn318FD5yJ439x93Lh75EgKA2NT8infktdb/UTCa
                             b4o3N3cttE00Xadn+7VUut7GuROT+LVxDAXmMu2+qJmWzfJCkbIonV3wqpAvwWgWTpV3Ern1Pt70u/+WUCTC5NQkqfEUo6OjDL96+kR75uXdH932TPb1glKoB5aAX0zkW6kPdcp1O59YMzBwzfJXP9FolJBpMHXsMLkf/DVJnqMjCvFQvXbVN
                             RDa0lsm1RBmQQCOBwUH0iWYVruIvfUjbHrLO2hpb6NQLDA9Pc3UhSnGx8c5e+b04a7syVvv2P50+iK/Ln4uJ7AC/ELX4x8mbomNJW/8ypqB9bfFmmLCNE1M0yQUsonHm4mEQ2TPj5B+6SDOif001X5CLARhA4xGGvUCqPlQrEHB2IW++dfp3P
                             ErrNpyBZFYlEqlQmYuQ2Z2lumZGVLjKTV27uzfXeUf/f33bn6udJGYX0FigQBv5AVA5Gr92sOlD96eXDv4+c6urhbbtjFNE9u2sW2baCxKvCmOZZjUigUq2TncYoHAqeC5Hna0CSPaRKy9g1hbG4Zp4nke5UqZfEMezM/Pk55JMz4+lpufGP3
                             0p9Y/+TftkYx8I+BvROAXEnl49Pa+Utfln+vq7buttbVVv/il9YItNGF1XV9sO0pZr2Fdt95/qlarlMtlisUi8/PzTE1NBenJib/rLp29+45t30+9DujXI7GCwC9FQipL3Dfye5fTteGO5kTHLa2trZHl73gNw1j2rwRi8UXdAgHP86jVapTL
                             9dmfTacruUx6Xzh7/suf3v7kSU348pcAXp/9j6AEwBt44RcSAcTjr92cGAlt3h1p77w5HI1dF4s1xUPhEIZhLBJAQSADPM/DcZw68Fy+UCnmX3Byme8PybP7P7Dlh7NvAPYNwb8RgX8KiaVzAUenrwv/NLdxgxvt2KKHY6sNO9QBIiKVQvpex
                             XNqs36lOGZX0q/c0DZ85ureI7W6jLwErHqd3eR1wQP8H1SPQRVOa+U0AAAAAElFTkSuQmCC'

  CreateImageFromBase64 -ImageData $IconHT_CTTPSGold
  #==============================================================================================================================================================================================
  #  Image Viewer Icon - Main Icon (Yellow)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSYellow = @{}
  $IconHT_CTTPSYellow.Name = 'Icon_CTTPSYellow'
  $IconHT_CTTPSYellow.Type = 'Icon'
  $IconHT_CTTPSYellow.Threshold  = 96
  $IconHT_CTTPSYellow.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSYellow.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAATpElEQVRo3sWae3Bk113nP+fcV79bLan1ntGM5p2JnfEjnnHWYCdsAiSAsRPbVebhlHchu1QIwUnABpynTUKywTEhQCqUN+EP1s5uasJAEszgCsb47dgZj8fWaGY0erfU3ZL6
                               3X1f5+wfLbWkGU/KBChu1U+37pXuOd/v73d+5/c4Evw7XVNTUxHbtvfH4/E327a9UwjRF4ZhTGuNYRgN27bzSqnzSqlXgHHHcVr8Z19nzpzpzefzv16v17/jum5JKaXf4FXSWn9Ha/3rSqnefwsG8eN8NDExcXk2m70rGo3e4jhObP29UiFBE
                               KBUSBiGKKXQWiOEQEqJlAaG0RYpJUJIgAbwf7XWfyylfPk/lMCJEydGBgYG7u/q6rrdtm0TIAwDWq0WjUadZrOJ67r4vk8QhIAGBIYhMU0Ty7KwbXuLWJaFaVoIIQOt9V8Hgf/7tu3M/bsSmJubE/V6/c6hoaEvJBKJDIDnuVSrFUql0oasrh
                               DWi0RUmYhsYgsfBATawZNJfCuDk+qnpzdLKpUiFosRiUQ2kbExDGM1CMKPzc3NPjQ2tkv/mwk8++yzif7+/r8YHh6+3TRNEYYBpVKJQiFPLrdIbm6aWGOCHalZhgdapLpsrKiFsAyEbA+vlUb7IX7Tp1LyWMgnWPT2IbOXMbRtlFQq1SGyZiW
                               tlP7r5eXi/xgaGqn92ASOHz+e3bdv37GRkZEjQggajTqLizlmZ2eZOTfOYPgSb9m1TM9QAhm3wZQgRXvYC0fWaz+UhkCh6h7LC3XG50fx+m5g+9heEokEjuNgmiamaQI8k88XfmHnzrHCv5rA0aNHs9dcc83xoaGht2itKZdXmZ6e5szEBEb+
                               Ka7bP0fvaAoRs8CQ7ZHEGzCqBrRu35VCN3yKM1VO5A7Rc+BnGBgcxLbtNaeXKKVOLC0tvfPAgYOFN0zg2LFjiYMHDx4fGxs7orWiWCxw7twk46+8yAHrn7jykIXVEwNLgljTtt6i6vZd8zrWuGBKpSHQ+Mt1Tp5yaI78EmN7DmDbNkIItNZ4n
                               vfM7OzsOw8fvvai5WRc+OLRRx8VIyMjD+3bt+/dAMVigYmJM4y/9CRvTR3n0BVxzJ5oG3wHqAIU6BBU2L5rtSabn3VbOuTW+EgwIib9yRa1yaeYrfXT0zeElO05tNYjpmmOvv3tNxx95JFvbsErLyQgpbxz3759twshKJdX25r/4VMcSjzK/j
                               1RZMIGqTfAqQCUjw48fNel1XRxGy5+q4XyWxC2QLkbol1Q3pr47e+1AgkyabN3TJLI/RkTr7y4jgcpJbZt3z46OnrnRXg3P3zta18bOXjw4BccxxGNRp3p6WnGT77EmPwuu0ZszKQNxjpwH5SHDl2ClsvqssvC0k5W3PdRbN7EfG4XxVwLt9p
                               Eu03wmxC0IHAhdFGBS+i5hJ6HCtaISI2VsNg5BMGZLzNz/iyGYaw7tYjFYl/4h3/4+5HNmM3ND5dffvn9AwMDmTAMWFzMcWZiglTlu2wfC0h2WWBpIAAFoFBhiOcq8stxIoMfZPubr0Z0zH4LleI0+XPfpNt5jFgChJRoJJ5vUKmZNL0BECZx
                               p0C6C0wpwNSkUzaDPSucffbP6e3/DF1dXYRhiOM4mXS6637gjoss8JWvfOXy3bt33y6EoFQqMTs7S3XqXxjunqev20ZGAOmD9kC5eK0Wy0WP2cV9dO//HH07rumABxBCkOgeITX2PvzgTeigBapFq+mxuHwAZ8cDbLv2T9l+5EGM7EfxynV02
                               ALhY0Sgr9si45zg1JN/g2EY2LaN4zjEYrHbv/3to5dfZIFDhw7d1d3dbXqeS6GQZ/rcafrtf6GvxyCeEGAFbUdV4HmKpeXtJMc+wu6+Xes5TedyWw1mx5+kPvUIA/GTZHo0UkoCZVIsDdJ/xd1E4hkASsV5lk78MTsHG4SuhRASQyqScUFvt8
                               Hq9F8xO30DO8b24Ps+0WjETKfTdwHv71jg3nvv7d2+ffstANVqhVxuEV18lq50nWxGICMBCBd0i9BvUloNSI7dRVf/ni3gtdbMnf0hr33nA3St3M2BbS+QHfaxUwoshR8qjO5bN8Cv5Hn1H+9hIHUWrT2Wy9spu9fiBy6GHdDbJUkkykw8cxQ
                               pJY7jYNs20Wjklq9+9S96OwT27Nlz88DAQCwIfFZXS+TmZ0gbz5PNaGIJBaYHokUYtChXQirq50lld3VAa93eExfnJll4+sPsHT5J92CInZZIpx0HtNaEAVjxoQ7hV184Tm/0NLatWSp1E9v7B6j0u2jVXZAuybiiN6NxC99ifm4Ox4msLaN4
                               rLe39+YOgQMHDvyiaZq4botSaZVWYZx4bJXeLo10fLRs4fk+hWWDuvNhxq75nwghO8CFaAenwW27GL76k1S8OEoba9F2bctVCoHCayx3CBz+qdsQ2d9gejFFbO+nSfZsQ5kpGi0PcLFsn940RCJFzp58EtM013zBJhqN3gggP/7RO6Pd3d1v0
                               2hqtRqlchnROEU65ZFIhGjTo9mCxfINyOEvMXLwRoQ0Otq/8Bo+cAO6/z6WV2IEvlgLXgqlNC1X0qhXN6KoYbL7yK+QuerP6N3e9staaQEpWyBdMD1SiZB00mfute/hef7mVPy//NHn7o/Ipk7t7+npSaswpNlsUlpdwRbj9CQVZjRAi4Baa5
                               Dhq+8ju+3QpmWj0FqRmxqn1ahuITG47+2ovs+wvBwjcAWhL6hWbCriTnZdcfPWXEZK+rftBaBRK1M++79JJloI0wfTx46EdKdCcJ8ln19aqx9MotFIOplKHZA7xna/OZFI4PteuzApF4nYRZJxjbAUwghwzFmK08+gtW5XWUqhQkW9lKd64h5
                               mn/gErdrqVhJ7b0D13Ud+Oc5qKcIq/53RK96PNDZCj++5+F4Lt1ljaeplJv/pd9jd9xxOPAQzBCPAsAOSMYVtLZNfmEVKo1McxWOJN5uDg0M7DcOg3vBxXQ+vsUrG8ok67agrzIB4qkF98Q9Ydf6cdP+etkOGAcUTX2XbwHm0nGHhGZfBw58m
                               muzZZInrmQnuY37mZd7yjl/eAr5VLzP5/c8Q5TksOyAerbF3pIUVCxEmIDfyqKijsSyPwtIsUl7bTi8MA9Myd8pUKplta8MnCHwCr45tKkxDdFJk0wzozS7SnPwolcIkYRhQWXiVtPw7IlFFLOIzkHqG3NMfp1ld2WKJ7QevZ+TQrayUqgRB0
                               AZfKzH/xCcY7TnO9u0rDA2X6cr62AmBsGQ7xTR0m4ShsU2wjJBaZRkQ7Rq7XWdnJZq41oogDFBKoUIXQ2jQ6wl+W2wzpK93Cm/yo1Qm/x4Kx0gmAqTUCKGIOl6bxFOfolUvb11Og/1orSkur1JdLTD/zx9nMPU4sbjCMDXS0AipLyh+Nh4EGi
                               k1lfJy59dKa0Kl4lJr3X4IwzXnBLRAhxqU2CK2GZLtniTtfYqM821sO2hvk6FAaE3U8snGnmLiHz9Ls7E1dR8c6EOFAaf+7hNko08TiYQIVPt7pdv5VUfW5kS2sSgBGnw/WCtR2z4Y+AFSo+vrzgkCw4wQhhCGQNgm0xEFBgrH8rGMcK26Wle
                               UQCPwA4mZ3MH8QgHf97eQGBoaZPTw+6m2EoShhHCTgsL2+Bvv5NqckjAEFQpS6R5AE6oQz/dwPbcufd8vsLafSymxIin8AHyvnXgSStByLQMVG6DXRUlQgjCUVKoRys6vsfcn/xsDA33MzuU6635jd7oGe98XyRe78X1zDez6WJstLtsSCnwf
                               ggCS6V6U0vh+gOu6NJuNgpydnZ4KwvYk0pA4iW48D1wX8NcGXS8N1YY1lDLwPIumZ9Fs2ZSrUVbtX2P08PsxTYtYLEq2t5sz4+MEnreFRHbsSiJvepDF5UE8z+woYYPM2jyhBA9cV+D7kt7+EUIV4roujUaDRq123pyfmXylUq0ghMAwDBLpX
                               urnB6g1SqiWQEZEu+7VoqMlz7NYKWfwo7+IEd9B4NZwMdl1+H2drVJKCV4V/8QDTOauZPc7PrBlG+0ZvQxpPcjiiY/R3z2D7XgIwZZ5UBLVEjQa0HKzDAxtx/M8ms0m1WqVWmXllDlgT44XC8VyVyaTNgyDRDLJinEV1fpj+E2NkxBgbJg2CA
                               zypT2k3vK/SGV3XLL5UFvOUXz899jd/ypu+CozT0fZ/rY7kHKjDM8M7UWaD5L7we8ykJnAiXqIThNAQCDw6lCrgyeupH9ggFq9SqPRYHW1VO53cuPyN977WqtQLDwlpUAakkgkgtlziEpV0KwCLdExsdaSRsPBHv3tDnit1EXgq8UFCo//LoO
                               ZU0QTHul0i3Tza8w+90203vr36b4d9B5+gFzpCloNBx3KDR9oCZp1KFcFg2/6ORzHplarUa5UqJRLT33o1pdaEs8S585MHAuCAEO2K5/08H5WKv1UahrdWNsZ1razejNCavBgO30+/TwvH/sjvOamLVNrZr7/RfrTp3FiHsJUSFORSrVIVL7M
                               3A+OXZQEJrqH6H/b58lVr6PZctrbZiDRTUGlqlmp9HHwqutpuS3KlQqrK6uUSyt/g+u00+nlqReOLi3lG8ZajpHu6qaZfA8rZU1Q1+CtaSWUQBLDspl78W9h/COMRo4x9dj9NGvl9VqSRCqFZQft4LSG1ZCKrlSTSPELLJw8fpHVYqlehq+7j
                               7L/04SeBa4kqGtWyhqdvY3tO3ZSKpcplUosLS01LHfu25164GM3PV2cnZn+lhACwzRxnAjpXdeytNpPvaqgISGQCDTJaInyS39CoviH9PbWiCZ8pPcSpfxcxwL4hY3IKgCh270fU5HpamDOf4bF1564iITlREGk0b6EpqBeCVlczXLFT91OEP
                               qsLC9TLBZZLhb+36fvOFVcJ6DRgsnXXnxgdXU1MAwDy7ZIZXpp9P8SuWKIqinwJQKIRxp08QipVAstoFDtJ/PWLzI41l5W1cIcUf0y0nj9xrJpKnq66ujJe8mffaHzPgx8Zp/8BnH3KKbSqJoiVwwxdv8mO3ftZnkN/ML8QtAozT/QjtSbuhK
                               /+Y7vnDx39szDQohO5ZPZdTUz/jtZLXpQa69LoTWmoRBS0wwGSF35JXq2tcE3SnlWXvgS6VQDKdWG9te3xg6JkN7uCsH43azOvEKrsszMY58n0/xLEhEP0dSsLnvMBD/DkZ++lXqzzlI+T25xkVxu/uHP/vIPT17UlbDMkMLkc/fmsn3vyWaz
                               GdM0cSIRxGW3cfrEIoesSWLCgYgGU4MAS1Qoj3+D8uk+dGsFq/kE/ekKdiTYUI1+/WavZYb0da9QOX0X1SDCgLNIxAgQTagXPcaX93PwpruJxKKcnzpPLpdjenp61WpO3WtbqpPyGZ/8QH8n5bxm1/nqoy8NL/f29f+caZpCCIE0LcLuy1mdP
                               EVGlLAsE6RAAKbhEZVniesTJK0JkokmlhVuzSx/RJdaCnDMBjG7ii0UwtU0ii6vLg3T+67Ps21sDwu5BWZmZjh39pyenZz48Od+9cXHL9Va1IC+ef8j3zg9/trDQRB0zracVA/q6ns4VTxAdakFFcCViFBgCoVthVh2iDTURvNZ/wjZlDZI1e
                               6XUVNU8y1eXTlI77v/hJ37D7KYX2Rudpbp6WmmJs/+n4/87HNfv1RvtKOy/kxdJauPffDsmTPPhWG4sW7jaZyfuIfx8EaWcg3Ckt8+nvPkRibZASkuyGI33dfznUCAK6EBYclncaHJa/6NjL73Qbbt2ktuKcf09DTnp6Y4M3H6uQNdpz443Oe
                               rC6oFLfQPLpObGt0d+fr3j2Ttoeu/t2PnzsvWTxVN0yQej+EtjGOc+grDyVkSKQsZMcAWa1XUmuOuj6g3nQtoNlJmT6OaIbWKz1x1GH3wt9h1+L+CEOSWcszPzTM1NcXE+PjLmfCVd//2eyfzF9ixQ2Az8C1E/urxI32q+8i3duwcu2bz0U88
                               HifmWDTOPQ+nH6IvOkUiYWJGjPa5gbE+gtiIDWt9YXxF0Aqp1gLyze2EY3cwdNW7SGa6qVQrLC4uklvIMTMzw5mJ8ef65Ws3f+im8/kLgb8egQutACC/+/yBxLS67k937Nx9WyKZEJZlYVkWkYhDKpUmEYvQXDxPc/Jp5OKjJOU5Io7EsiTSa
                               A+jQo3vK5quohqM4vW8g+jYdfTuupxIPE6j0aC4XKRYKLC4tMTszKyePn/24av7X/7gLW/P117Hizok1glwKSsAolRz5EPPvOeOgW17PtvX39/lOA6WZeE4Do7jEE/ESSVTOJZF0KjgV1YIm2W038L3PcxIEhlJ4KSzRFLdGJaF7/vUG3XKa+
                               nBysoK+aU8MzPTpZXFqXvuvvH5r/ekQ3Up4Jci8COJPPTY1SM15+Cn+gdHbstkMsaFh9brst6ENQyj03ZUShEEAZ7X7j81m03q9TrVapWVlRVyuVyYz809PGid++SHbpqcfR3Qr0diC4E3REIpIb78vSOXkdz9oXR39qZMJhPbfMZrmuamfyU
                               QnYO6dQK+79NqtajX29ov5PON0krhaNSffvCeW8dfkVKrNwC8rf2rTrbD5CWs8COJAOKbj+/unazt/YVYuu/no7HEkUQimYpEI5im2SGAhlCF+L6P67pt4KVypVErP+PWin+7r+f8sV9553zhEmAvCf5SBP41JDaehebF033RJ06P7vWM7EHD
                               iY+aViQLIqa0RoV+w/dahaBVnXZU8dT1b5o9/dYDKy200JcIe7wR8AD/HxPUVlwiT98tAAAAAElFTkSuQmCC'

  CreateImageFromBase64 -ImageData $IconHT_CTTPSYellow
  #==============================================================================================================================================================================================
  #  Combine Texture Dialog - Main Icon (Magenta)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $IconHT_CTTPSMagenta = @{}
  $IconHT_CTTPSMagenta.Name = 'Icon_CTTPSMagenta'
  $IconHT_CTTPSMagenta.Type = 'Icon'
  $IconHT_CTTPSMagenta.Threshold  = 96
  $IconHT_CTTPSMagenta.Dimensions = New-Object Drawing.Size(48, 48)
  $IconHT_CTTPSMagenta.Image = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAUrUlEQVRo3sWaeZCcZ33nP8/zXn1Nz9lzaXTMyDOSLEu2JVtGBhsfGDsBHNYVQzCpQFhgY2OOeBMoL/HumpSzbOEkRRVQsAQKJyHYZB2DA7GxAAOWQfKBJUuyNKM5NIc0R/dM
                                d09f7/k8+0f3tDU+ss6xtU/Xr7rft97u5/v9Xc/v+T0t+HcaZ86cidm2vT2ZTF5k2/agEKI7iqKE1hrDMKq2bS8ppaaUUseBU47juPz/HqdPn+5aWlr6aKVS+aHneQWllH6Do6C1/qHW+qNKqa5/Cwbxr/nS2NjY7kwmc1c8Hr/VcZzE2n2lI
                                sIwRKmIKIpQSqG1RgiBlBIpDQyjLlJKhJAAVeDvtdZ/IaV88f8pgaNHjw709vbe19bWdptt2yZAFIW4rku1WqFWq+F5HkEQEIYRoAGBYUhM08SyLGzbXieWZWGaFkLIUGv9d2EYfNa2nbl/VwJzc3OiUql8qL+//wupVKodwPc9SqVVCoVCU1
                                ZW8pRXVgkrPtpXCNWYxJQYcZNYOkFbpp2uTBfpdJpEIkEsFjuPjI1hGPkwjP54bm72m0NDW/W/mcDhw4dTPT09X92wYcNtpmmKKAopFApks0vMzy8wNzNLYSZHvGLSleigraWVWDyOZVnIuougtCIIAtxajUKpyIpXgIxN/8hGNm7eSDqdbhJ
                                pWEkrpf9ueTn3B/39A+V/NYEDBw5ktm3b9ujAwMCbhBBUqxUWFuaZnZ1lfHSc6mSegXgvfd29JJOpOmjDQAhR/2HR+Hmt0YDWChXVyVQqZRayC2RFkY17t7J1eCupVArHcTBNE9M0AQ4tLWVvHhwcyv6LCTzyyCOZffv2Hejv779Ya02xmGd6
                                epqxsTHmXphii93Hxv6NJJNJDMNsBOX/3SM1Gq3rEoYB1UqF2fk5Ci0uF1+zl76+PmzbbgS9RCl1dHFx8YYdO3Zm3zCBRx99NLVz584DQ0NDb9JakctlmZiY5NiRowSnVtm5eTtdHV1Ylo2Qkoa+0VqvoaxDrcfwy5OI+oUQ9Wc0GqUUQeizv
                                LzM6aUpht++i5Ht27BtGyEEWmt83z80Ozt7wxVX7H+VOxmvvPGjH/1IDAwMfHPbtm2/CZDLZRkbO83zh57FOFVj59AOOts6sUwbkHUgUd01dKBQfoQKIpQfoYO6qDBCBQodrYlG1xkgEEghcRybhBHj9OGX8BIRPX29SCnXFDNgmubma6+95p
                                GHHvruOrzmKwlIKT+0bdu224QQFAorTExM8utDzyFeKjM4NEIqnkIiUaEC3QATKVQYEQYhYRCilUYiMIRECgFSIGTj3VgTiTAkSAESpJak4ik2dfUz/ugRDNPk0sv3NF3Jtu3bNm/e/CTwjXV4z7/4+te/PrBz584vOI4jqtUK09PTHDtyFPf
                                XWfo7ekg5SQwt0X5E5AaEFZ+w7FErVMgtLJONSsgL07A9RZYS82cXWc2t4uVr+AWXoOg1xS/WcIsVvFKVoOIR+SFSCVKxJD0tnRx98CBTE5MYhrEW1CKRSHzhiSceH3hdC+zevfu+3t7e9igKWViYZ2zsNAsHJ9nodNEaS2FqiXYjIjQ6VERB
                                hFvzWHFLjPzOpWy9dORls9+sWZye59j3n8U9kScZS2CYBhiCgIiycolaJNIU2KEgnUhhWAaGkqRjKdpEgp/99WP0fKaXtrY2oijCcZz21ta2+4APvCoGvvzlL++++uqrv5RIJGQ+v8L4+GmO/PRZ0ovQ29FNSyyNJUxECMoN8coeKytFyumQ/
                                R97GwMjm9ZlISEE8VSCRG8L2dGziGwEAbg1j3KXYs/tb+WSd+3jgqsvhHaLxWemMLWEhkvqIKR0dpmsWmXnpbsQQqCUIgzDnTfe+PbvP/jgQ4vrLHDJJZfc1dHRYfq+Rza7xPjoOPpEkfZUD0niGB4QRkRaEXgBBcfj4o+/md6tG5paXxu1ao
                                3jT73Aye8+gzUV0RFvQ8RShEZEMVXjuk/eQkt7GoCls4sc+spjdMtWvEAiDYnUmqSI0WalOPODo5y5eh9bL9hKEATE4zGztbX1LuCDzRi45557ujZt2nQrQKm0yvz8AudemKTFNUnLFLZnIMqKaDUgKLis5Irs/o9vpn944zrwWmtGXzjJdz7
                                8JSb/9FdkJhP0Gj0kVQuGaxKWFQPv2tYEv7yY4x8/+y0SOU1UiSgbAarfJlh1MT1JWiZJVCQHH/0pUkocx8G2beLx2K1f+9pXu5oEhoeHb+nt7U2EYUA+X2Budg51skirSpLwbWQFdCkiLHgUl0vYV3TQu7W/CXot/89MzPDYR79D51SSHtlH
                                K13EVRoziCN9C+Vq0v3tTcKHHn8aYyrA9GyKgcfeT1xPz1u2UlkuQzkiHti06gRnD7zE3OxZHCeG4zgkEslEV1fXLU0CO3bseLdpmnieS6GQZ2FshnhB0BImsKsGrEZ4eY/llRKd7x/hutvfgZSyCXzN9zdfsJlr/ufNhMrCjJJYYRIriGMFM
                                QzfxggsyrlSk8CN738HGz94KYvVEnvvvoHujb04qThusQqlEKsmSUUJYsuaI796DtM0sW0bx7GJx+O/BSA//aF74h0dHVdqNOVymWKxSHF0kVTFIe46iDK4RZ/ahRYX3vdWLnv3lUhDnqf99evIJdddxsifXU7Rr6J9ifRtDN9GBBahLygXKy
                                +nQNPk2g/8Btd/9T1svXgYgJVzWWRVQ1kjK4KE75B0HV488Ay+H5xfir/583/2+ZiM0u72zs7OVhVF1Go1VlbyqMkyCS+GXbWgpHFTirfddytb94w0gSulUEoxeXKCSqmyjsSu6y9h8+cvYtkvEfkC7ZlU3ZD472e48j1XvXLhZMu2QQDKhRL
                                HvvELYp6FrEhkRWDXTBJejOqRRZYWlxr7B5N4PNaabm3ZIYcu2HJRKpUiCHxc16WYW8Fa1jiujaxIKAvEZMTYL0+gtSZqAFeRYmVhmSc/+T1+8Jm/p5QvrQN20fW72PTn28gFRYp+FesjLez/8Jvra0FjeK6HV/OolquMHxnl+3d9k5ajgpgb
                                R1YNREVgVA0cz8Zc0ZybnUNKo7k5SiSTF5l9/X2DhmFQqQZ4nk+lUMKoCEzfROp6WktaDifv+gWJB1oY2LapXkkGIQe//GMGzvThTKd4svYE19x/A+nOdBPgzut2En1RM/3cDPt/f+868OVCie/9yXfwDxaxlCTmGbRrhzgtGEoiIoUONTIUW
                                L6BGQjm5841SwtpGFimOWimW9IZgMAPCMMAt1xDuhIRSFACTIEZmXQupnnujicwvnYTXZt7mDkxhXjIp1NvISZaSP7C5+B/Pshb/vwq0p0tL6/u111E144M+eIqXWY7pmlSypd47O5/oP3HCVrIUK9nFUIpUAodBRCGqEAhQoHwJdIQFJfzgK
                                jvsYVASJkxNSS1VoRRWF/pvAACUAp0KBBaIrSJo026x+McueMX9N8+QuHXOTJRP0ndgSkSWBrMJxP86jPP8Jb730SyLdkk0d/Xw/zCErnlPLYw+Ml/eZyOn7TRRgcWJlpHKO2jlI+KXKJQo8IIQoEOQIcgIhoE6tW60hqloqREa5TWRFHUTIs
                                qqj9Q30ZJRGRi+A4JP03PyR7cPyyQ+tsUbUEPRpiEwEYoh1jURuuBDD/5k6eplKvrYqKvt5soCHn4rkdoO9BOV7iRZNCJ46exgyRmEMcIHGRgIwITERp1As19AwRBUCfQiMEwDJFa68paVgGB6VhEWlF/NQgoA6lNjNAhFrTSFvTQGvRgqRaE
                                tkFYgI0QNlpYtFzQyvz8UnPCtbFhoI+rPnYVKmkjiINyEFEMI4xjrBEIbWRkIZSJ0CZaC0IUEYrWznZAE6kIP/DxfL8igyDIriVzKSXxdJIQhU9EpDVCG0hMBBYGNqaOYekkUsTQWChhooWBEoKSrCE/rbnqY3vp7cswOzdPGIbrSGzfP8LIA
                                8NkW/MEUqGRoC0M7SC1g1Q2UltIZSG0QaQhQBGiaOvqQClNEIR4nketWsvK2ZnZM2FUn0QakpaOVnwiAhESokBIhDAwpIWUNoZ0ENJES0lganwzxDUCimYZPuNz2Ue3Y1omiUScTFcHJ4+P43vrLTF4+SZG/nYzS305PDNCS4kQFoZwMISDFD
                                ZCWIBBhMYnxBcRvQP9RCrC8zyq1SqVUmXKnJk8e3y1tIoQAsMwaOvqIBiA2rxPIOoaktLGEGvgLXxDk28v4nzQIjEYwysHCCPkstt2YJiyaU2/5HPsc6dYfEuOaz++H8N6OY1uumQD5t+YnPjIBJmpLmKYSGwMHaII0Dok0B6+1rgE+N2wYdM
                                Avu9Tq9UolUqsrpRPmMmJ7lO5bK7Y1t7eahgGLekW4pd34v4gwBMBSkqksJDSwZAOoQHLFxW58GtDZIbaX7f7sHwuz1N3/pqBo0NEL8KhxHH2f2RXswwB6N/eg/mAwdHbR+k60UkcE4mDQYjSIVpX8HRIjQDnsg56e3spV0pUq1Xy+UIxdbb7
                                lPzdQ3e62Wzul1IKpCGJxWL07dlM1QioyYBIgmi4DsKkavoM3JNpgq8H//qRm1vhqdufp/vIAG26jy49gLo/wXPfPolW64un7qEu9n5jJ7n9y1QNDy0NDOkgpU0oBK4MqBkBl75zP45j1+u11VWKxeIvP/DTT7nSi4VifHTi0TAMMaSBbdts3
                                L6F2kBEVXp4MgJpIqWNMiQ126N3V72hPHpogkf/2xPUyu66PcHPPneYzmN9tJDBJomlE3SoHtx7LV54ePTl9ktjdAy0ccVXdpO/KU/N9BDSAmnhS0XV8Kj1h+x7635cz6W4ukp+JU9xefX7bktYL6fnns09sri4VDUaNUZ7RztdN2+iLF1c6a
                                OkQMt6ptEZgemYvPAPxzn9ezO0fLuLJz/7HOVCtVlat3a2ESeNgQMYCCQGDh26h9W74fhjE6+yWjrTwv6/2Iv7HhffDAkl1AyfknTZ+L7tbBncQqFYpFAosLi4WA1nze819wPvf+KPcjPTMw8LITBME8eJMXLlDsqbPEqyiisDQqER0iCRT3H
                                s/gkKf+TR52+mlW6ipyyys8tNC4QLqpF6JYJG7weBiUOn6iX7KY9TP5t6FQknYaPbFYEMcaVHSVYoDdS48X3vJIwCVpaXyeVyLGeX//fth+/NrRHQWirGnp/8y3w+HxqGgWVbtHd1sOH3trIiCqyKEr700UKQcJOY30jRoXoxRIJST4VLHxhk
                                cNfGuv/PrCCeNjAwz2v7NTY+CCwcusI+5u4oMXF4tvlEGIQ8/fVDBN/0iYgoiRIrMs+Fn9jD1uGtLDfAnzt7Liyerf6larS+mynh5ofuODZxeuJBIURz5zN8+QjRb0GWJVZFEV/4jfrOwRA2wUafnd/qY2BXNwCFxSLPf/4E7WEnJhai0XTUj
                                ddaL9PCIeP2MvGfssy+OM9qrsxPP/cU3hci4jpFhSpZllDvlvzGe99BpVZhcWmJ+YUF5s/OP/gHB//02Kv6QmZoMX146Z6u7vl3ZDKZdtM0cWIxdv/OHo7NH8E5kgQsUnTgEEdgIvIw/ldnGeuZxM3W8H4Y0l7JkCCNFBKNagJvdqmFBjQWNp
                                nVXiY/vIQfmyI2m8LUFlVdI6sXye3Nccvdv008EWfqzBTz8/NMn5nOB2eMe6zIbprV+Hj7fxUNxYgdpy4vHR48sJzp7XqnaZpCCIFpm7Rf0snU2DgiC4Y0MYSBAAxfYpw0EM8aOCcSpIN2YqQwsAFRrwVRDYnQRCDq71pHCDRW1cJZtRFaUNM
                                Vsnqe+eE5brz/JoaGhzg3f46ZmRkmxif0mbHZT93x8/t+vq65ex4BANpGN744OvTMBZ1dnbvWWiaxRIzu/d1Mzo2jzgaNDrNGABIDU1iYWBhYSGRD6xpQQASETQKKCE3YqG4CInw8XaWk8+TUOVb2LXHT/TcxfOEwC0sLzExPMzk1xemTp79z
                                y48/fm8qTOvXIrDmniLhJpnwJ39S7sxe29betkGI+gbCiTtsvnoT5+RZVo/mm55dP0fSLwer0OdpPGyAPf9zSIRPqF1cylQosqpzLKqzqNtCbr73ZjZs3tAAP8PU1BSjJ0efybwwctvepau88yYD0GJsMJDnE1iTf7rhrzOZa2KPbRncsmvtV
                                NE0TZLJJOdeOsfoF0dpGWslLdqJixSOiGHhIBt5X3C+YdfCWBEREuLj4VLVZVZVntUL8uz8wwvZd8MVIGF+cZ6zc2c5c+YMoyfHXjRebP3N9x/75FIDvD5fY2JsMDgf+Doij7/t292pK/XDg0Nb9p1/9JNMJnEsh8lnJhn/X+PETyVJiRZiIo
                                GNgyHMBhHRhK+ICHVIgIerq5T0KtXhCkMfGmTPjXto62xjtbTKwsIC8+fmmZmZYWz09DOx45lb3nf8zqVXAn8tAq+0AoB8eu/jqepbZ780eMGW96ZaUsKyLCzLIhZzSKdbScQSLE4uMvXLKRb/aQnjuIEjY1jYGKJefUY6IsDH0y7BSEDnDR0
                                MXTXE0O4hEqkE1WqV3HKOXDbLwuIiszOzemr8zINbjuy58+1Tv11+hebXkVgjwOtZARClZEH++NYHPjAw3Pc/unu62xzHwbIsHMfBcRySqSTpljS2aVNdrVJaLlErugSuT+AHxFNxnBaH1kwr6Y40pm3WD/qqFYqN8mBlZYWlxSVmpmcKS2dW
                                7r7t53/8rTa/Q70e8Ncj8M8S+cE13xqQF1Xv7d3Y89729nbjlYfWa7LWhDUaJ5ZrVWsYhvh+vf9Uq9WoVCqUSiVWVlaYn5+PFmeXHkyM9/z397145+xrgH4tEusIvCESSirx8PVf2RUfFp9o7279D+3t7Ynzz3hN0zzvrwSieVC3RiAIAlzXp
                                VKpaz+7lK2uLBUe0WdiX/zgc58+LrVUbwC4BhiZsrQAeB0r/LNEQIgDF3+3a2X79M0t3Yl3JVrib0qlUulYPIZpnnfsqiFSEUEQ4HleHXihuFouVg9Vc94/9k4MP/qusd/NNrqs+o2Cfz0C/xISzWuhJC9tfj5+bOvBETLBTrvF3Gw6ZkYIEk
                                orojCqBrUw65XCaZG1T1w8ddXo7nP7XCXUa4F95b3XBQ/wfwBqy5Ov7Ke+DAAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $IconHT_CTTPSMagenta
  #==============================================================================================================================================================================================
  #  Image: Folder Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_Folder = @{}
  $ImageHT_Folder.Name = 'Image_Folder'
  $ImageHT_Folder.Type = 'Bitmap'
  $ImageHT_Folder.Threshold  = 144
  $ImageHT_Folder.Dimensions = New-Object Drawing.Size(16, 16)
  $ImageHT_Folder.LDPI =  'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA9ElEQVRIx+2VMU7DQBBF30aR6BB2kwv4AmEstyjyJVzScAS4AigHMA0FJ0EcwEPaFJZc0liyzAEYGhwtKFIAZxvkqWZHo3mjv6u/MMWBcEMiIi/Ack/PRlXPRwFEZA1cJ0ny
                           GkXRm3POzMy1bXvWNM0CeFDVqzGAJ2BVVdXl94Y8z+/7vj8BFqra/hXwDFwcUfqdrPPPggFkWbY1MzdItNvCO+/L/VrXdad1XS9FZK2qN3MfW5bl3THWT9P0EUgBZgFf6Cw0gNAACw1wk0T/X6IvAAsw+933ogpYFUVxG8dx/6ub9Dxr8CJv5
                           o8+nFFuOsXB+AAgjGFeCOKqMwAAAABJRU5ErkJggg=='
  $ImageHT_Folder.HDPI =  'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABb0lEQVRo3u3YsUrDQBzH8W/FDn2AgKJLC7plOoqDQwn4BkIXwYKLOLg5KFYUXIS+gpA6iQh2cJbQB7gpm4YWBDFQunVQtD2XukhLb8sV/z/IcnDh/7n87wIHEolEkmVyfweU
                           UltACKxazO8Cd8CF1vozC8DChLFLy+IBisAx8KSUKmQBWJwwtgFQqVRqsyanaVpMkmR/OBxuAtfAjgstZADCMJwJGAwGtFqt5SiKzo0xBWBba/2Q9RcAwPd9qxeUSqX3Xq93H8fxLnCllHrUWn9luQcAGI1GVo/nedTr9Sifz78Ca8CeEy3kW
                           N6AW+BMa/1h1UKOZQU4Ar6BEytAuVyuuVJ9v99f73Q6p+NTzg4QBIEzy2+MeWk0Gkz6P00FVKtVl1rIjAE561NoXiIAAQhAAAIQgAAEIAABCEAAAhDAfwVMvZWI43i+Ac1m06U6f69TjA0gBZba7faNgwv+bLMHDscI19IFDpBIJBKn8gO6zn
                           3BFFDiGQAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_Folder
  #==============================================================================================================================================================================================
  #  Image: Gear Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_GearIcon = @{}
  $ImageHT_GearIcon.Name = 'Image_GearIcon'
  $ImageHT_GearIcon.Type = 'Bitmap'
  $ImageHT_GearIcon.Threshold  = 144
  $ImageHT_GearIcon.Dimensions = New-Object Drawing.Size(18, 18)
  $ImageHT_GearIcon.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAQAAAD8x0bcAAABhElEQVQoz33SPWtUYRAF4Od+LIiupWiIYCPii4VFTFKoCJEsiJ+5iF0arcUfYBQ0WGhtI2hnISpvimBCNqIgxMJNoaBcEbHRH6CYynuTtdh1UQKeZmDOzHA4ZzJ9FEPhSrgd
                            PpZfKY6GR2FX+Fyu9bikP9IwryWxpMCclg1LzsYK8v6h2qoWjnuMCSRW1T0yp2ioY7foqDXkTg7WOrFbJPJYJcWQBzreuOWgf/HOVeMOuZQUM26i1sC6D9poOSBDJcdMFu7YLZFh3V3Tnln2UNOoVCaR2JKFT4btkeK96fizVCp/hRWn7URt2
                            bU0vjJlGbStDfSsaYNFU3ElBV3/RVocEbXApOag3+z3TpgrDmfhiWN693bYFl6HKiRhu1mnpEjttS83b7RvQeayiU0WdC0kxbD7OjpmN5n51nXjRlxMBrGc8VTjr5HKubjQiyUnVhSJMTlqS1KTcrmxYjF2VfqSyY2A5y447wUY/fMjWa+UG+
                            Gl77aaiV/KKnyz3z034o8e+xs4G3lEk0DXXwAAAABJRU5ErkJggg=='
  $ImageHT_GearIcon.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAQAAABLCVATAAACh0lEQVRIx6WWTUhUURTHf2+0TS0ySIg+jSR4jUq1rCYDoSAQ44Zok7XTSSEoosBm0YcVRZ8b8WNlhFlGJ3IjRUjNGLSJoMbeJgKNIGwiCmkjRAufr3dn7ps32Vnd++ec/z3n
                            no97LYyiamhiN4fF8WE2t3nKkEyYLCwDSS1dxAAYliYfPkI9AGmSkg4lUr0kfNuYjLt4jJQP75EO3S6S59AXbXfJW13U8M/hHm3ltQacYAZYwg0NrZZM+B1NspbCMikVuVDEoDZCmAznQyaibCjRj4D0qx4+MSwfAFQbfYRLQvrd2lKskSNgg
                            arl+Vzk3GUmJzvB0slSDrAOgF3ywgKVcstv4ZKWnZbazJtAhSw3GZEMqCoaOMbyQE27xD4a6M8gdTLmTAM4007a7mY91QG63y2VIWqmkRZDjQ0SN2q/jNDIqDGoNqNBq7E4HtBa4mSdQXuMSvf+vc6SMROPM2svok6/aFrkupP1WkR1+hoUov
                            I+YFJV8c63bZfe3Mr+5lcPooGcZv1dqEUWJH+JlmkBbAoyUHqOSzUitUOluKwp7As8ukHbdauU2gZgKZsu9uepf6VCfhn8Wcykob7vcb6Uh9iGc8vp45AB7ze2STOrSuyVAS1SY1faT5xZvzf2AAcDAh4Ib9rHMgEqSgPHCzTtRgvUONv/f4x
                            EgAvzI50rnCva+DS3mHLXyflR28cUj+aq+R9H7RbqWSEd5ufoDGdDaE7J1WJekbJQf8qKe45UKFG8iN9IXjmc5CdQ7qVkTjbIR8xN50l9TmKvuQfs0Qq3WZtextBW69fqrZIFtExEkqCO+W/UkLzy8DTPvOFam/s7MqbfvalG9hLXvn5R7jDK
                            fXlrsvgD+fixns9v7n8AAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_GearIcon
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Font Color Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_FontColor = @{}
  $ImageHT_FontColor.Name = 'Image_FontColor'
  $ImageHT_FontColor.Type = 'Bitmap'
  $ImageHT_FontColor.Threshold  = 144
  $ImageHT_FontColor.Dimensions = New-Object Drawing.Size(23, 23)
  $ImageHT_FontColor.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAABUElEQVRIx+2UvUoDURBGT4IWabQRg2idF/hsAjHR1kJB7ETiH/sGYm+hjb6AhbaClYKliKJWGUwlVhZqqa2kiWtzhctmNytrFAQ/uNyZ2eEwzMxd+EHlogFJ08CpcyfN7CIr
                             PB8TW/PsoGeVSyoCT8AtMAyMAKNm9poF3hfx60A/cAgUgQ1gCdiNad8MMO7chpmdpMFXgRA4AoYcPIiDA8dp88t7lVSBEnBtZs9m1gTugZKkqRh4C1hxp5XWls9BViSFkbwAOI/EHoB9Z98lboukQWC+y2zmJI1FYi8JdkflC0ABuDKzicjgG
                             oCARWDb+xQm2B3wHXc3Y3IK7t6StAcMAMtAzcupSdoEDoBHM2vHTribJN0A5ZS0SzOrJb3Qbip/IaeatOdpmgXeXI9D4N1bjJw7YVb4OtD2IKH3gHzwWRZ45bt/xZ7pH/778L+rD4/2UJWZZczaAAAAAElFTkSuQmCC'
  $ImageHT_FontColor.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAC3ElEQVRo3u2YPWgUQRTHfzNZE0XERhBCQkyjYCBwzCVBEGtjLPxIKhHRxCtiI4SAnVZ+RbEyhWKbDw0qgqCdhU28G3KRWPhxuUiUYCfYJXs7NnswWXK5vbvk7gj7YGD2zds3
                             //3zPmYHIqmuiDBG8Xj8ijHmWUB9Wmv9tlbAZUi7oaDCGJOoa8ZjsdhRKeWXDZZyruu2zc/P/65LxoUQQwWWGhzHGazLUOno6GgUQly0VB+AP3YIDQwMNNQd8KampjPAASuuJ4QQM5ZJayaT6a074IEwcR3HeWmMmVrnQMpEXSVnLBZrk1Iu5
                             j9OCPEulUr1AkIp9RNozSep4ziHZmdnf4XZUCm1D7gGnAU6ffVn4BXwWGv9ryLGpZSD9rrnedP5iAGe20m6trY2GBL0EWASuAN0A7v90e3rJn2bsoFL4LL1vOp53mvrI6aCIRUySUeAPn8+DrT7Y9zX9fk25QGPx+MngRYL2Pt0Ov03/zw3N5
                             cCflivtGQymVMh9uu35mNa6yWt9RIwVsCmNODGmHW12woT22Y6wHqipsnZ09Nz0HXdZWBXib5yUsr2ZDK5vEmMPwGuWqGSZ3oUGPbnT7XWiZIZz+Vyl8oADdBgjCmWpA+t+TCQ9cdwAZvwwENsXlCMMYObJanW+msxH2FsAJxA7T4BHLZUn7T
                             WPUVK3KJfGQBastlsH/Cmqp1zgwPVixA+pmpx3JUWc/uFEP2BeJ8JcXqcCKh6u7q6WqvJ+AVgj8VcMp1OLxVzkEqlFoAF26fneUMbtXql1GiI7npdKbW3FOBDgZY/UwIBQdbXJalS6jzwDbgfwtcj4LtS6lzF/5yViFLqFnCzzNfvaa1vbFh7
                             txn0CHC7AhfHm5ubV1dWVj5WjXGlVCeQBBordOUCx7TWqXL+8suRB1sAOt9r7kY3SZFs14VQBclpttKf1lpUKzlre5MVAY+AR8Aj4BHwCHgEfCcAjySSnS7/ARBL4kQXCpDHAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $ImageHT_FontColor
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Select Color Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_SelectColor = @{}
  $ImageHT_SelectColor.Name = 'Image_SelectColor'
  $ImageHT_SelectColor.Type = 'Bitmap'
  $ImageHT_SelectColor.Threshold  = 144
  $ImageHT_SelectColor.Dimensions = New-Object Drawing.Size(23, 23)
  $ImageHT_SelectColor.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAAA5klEQVRIx+2UMQ4CIRBF326sbbyFlmNjYjyCnkHvYGnlQTyDWusJnFJLC2trs82KDSYEWcNCZ/wJyQx8/pAPDPwERMSIiMmNG8VzD+fmRYbQFBja9KSqO5/T8SuramzBrZcX
                               /v4yw4UKWNhRhQg5tpyBvk0vqjrwOWXGhd792N+fY4tpiNNsEZEe0AXmwMpbXgMb4KaqdYote+AaEMbOXYFjqi2jCM4k+M4j3vgMeFiPDfB0DlnYYVI/0RKoHRHj3J0rfPgQj8C4DblsaQvJ4rld8au4W6BVr25A208UVeBtb8kfAbwAR6RhK
                               AKidIwAAAAASUVORK5CYII='
  $ImageHT_SelectColor.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAABcElEQVRo3u2Yv0oDQRDGfwliZyuxtIpVms+3SCX6CoKgjRxBrBQLCUY7TeMr+KfyMaaxMl2w8QGsJTYrHIfH5fSyOY754GD/zO7Ozc7OfrPgcDQbrbwOSbN03cxay2zPot24
                               rZA0y/59ndZv+2mpy+FcoAusAYfADtALza/AM3BnZp+VRJW8U/1HpbvADdDPEXkBEjObFK0f28eTlNJjYDN849DWDzKFiK34Xqo8MrOpmU2BUY4MjYsqK3kdVfp2Cg/AfigPJP1YepCRKVy/FTmidIG3ArEtM5vUKqr8xkXydrpuUaUyuOKNv
                               fLDVX8AXBWIHgP3wHqovwdf/4quuKRd4BbozDnkAzgys6fSrlIVH5d0HmJzp8SwDeBR0nApPi4pAc7+McWJpNOoikvqAZcVTHUhaTumxa+B1YpoydBTJ8/yq6a1iyZTZZElW85Vmp4BucUXzlXc4mXDYTb3m/dd2y0eOwPyC8izfIfDEQXf3q
                               iNlpHY5ZYAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_SelectColor
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Toggle Names Off
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_NamesOff = @{}
  $ImageHT_NamesOff.Name = 'Image_NamesOff'
  $ImageHT_NamesOff.Type = 'Bitmap'
  $ImageHT_NamesOff.Threshold  = 144
  $ImageHT_NamesOff.Dimensions = New-Object Drawing.Size(23, 23)
  $ImageHT_NamesOff.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAAAcklEQVRIx2NgoCFgZGBgYDA2Nv5PTUPPnj3LCOcQY/jkyZP/E1K3fPlyFDVMtAwWmhrOgszB5W2UMCQhjljwGUJUhKGC/zgNx+YqXAYRo46FBFeRrI4+ETp58mSiIgmfujdv
                            3ozm0NEcOppDh1Y1NyQBAPhYWb6Fv9sFAAAAAElFTkSuQmCC'
  $ImageHT_NamesOff.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAAqUlEQVRo3u2XwQ2AIBAEV2NHtMmPBvhRDZ3QA75MfGgUvRjF2ReG5LJuLneMhJ7VsBycc/XNRnPOw/p7/Gri09GftSqEUCUpxnirXkqpSpL3fvP+s4ljHOO9G5/2Llrn+tH0
                            sN4T/SV+d54b1Kv/Svxsb7YmaVWv38Rf0OssIIyb9vjynrbS1XqllD4ThzlhTpgT4xiHOWFOmBPmhDlhThbQf4xDQAghW83mv2EGQAq1+QAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_NamesOff
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Toggle Names On
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_NamesOn = @{}
  $ImageHT_NamesOn.Name = 'Image_NamesOn'
  $ImageHT_NamesOn.Type = 'Bitmap'
  $ImageHT_NamesOn.Threshold  = 144
  $ImageHT_NamesOn.Dimensions = New-Object Drawing.Size(23, 23)
  $ImageHT_NamesOn.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAAAT0lEQVRIx2NgoCFgZGBgYDA2Nv5PTUPPnj3LCOcQY/jkyZP/E1K3fPlyFDVMtAyWUcNHDScesCCnY2I04FP35s2b0Rw6mhRHDR9a1dyQBAA2dilALEUFUwAAAABJRU5ErkJg
                           gg=='
  $ImageHT_NamesOn.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAAhklEQVRo3u3XsQ2AIBCF4YdxI9akY4HrmIZN2AErEgujUYkR/V8FIbl8XHUnkWfj2sF7X98MzTm79X0atePz0c/OJsZYJcnMbtVLKVVJCiFsvg/bceDAgQMHDhw4cODAd+bx
                           Nk/3ytV6pZRvdpydk52TnRM4cODAgQMHDhz4f+BsQISQvlkA6PowiC1FSV0AAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_NamesOn
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Clear Dialog Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ClearDialog = @{}
  $ImageHT_ClearDialog.Name = 'Image_ClearDialog'
  $ImageHT_ClearDialog.Type = 'Bitmap'
  $ImageHT_ClearDialog.Threshold  = 144
  $ImageHT_ClearDialog.Dimensions = New-Object Drawing.Size(23, 23)
  $ImageHT_ClearDialog.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAAABmJLR0QAMwAzADOGP0P2AAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH4wgXCwA0jFv8PwAAAMlJREFUSMftlUEOgyAQRR+mN3JtovEi7LvpgoN00fMo6Z6beAe6mSZA
                               UYnBVSWZjDN5fkfIV9W2LbWXcw6ARmpfM74DN8lDB0AFMUhfaa13OWNMJNYkN8xAL3Uv9ZAZoISLxC0wCniXPEqfA9zPtkzAA3hJnlbOrIhLxTvgCRjJ3Yp4EXcLrsO9s4AD3kFdwq1OPidCNjg8DnDR5CrzZjbT3+J8Vlxr7Uvct8UtyxJPI
                               W7ylb8Ayjl3OfRy6F849FwTyc9UVY7z1wctwYG+/2SZggAAAABJRU5ErkJggg=='
  $ImageHT_ClearDialog.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAACGklEQVRo3u2XvWtUQRTFf7t+NAYrCxf8A2zNaVIFU4gfEVIpFrK8lAEJCNsb+210IWihWcRKGz+IChYJCHaX/QssTJMUW0kKEc3a3MAjTHbnjc8vmAMP9r0775zL7LwzcyDj
                               z6Kx/0PS6F9u1Mwa5fvm/zrjRw95vg3Mm9kghkTSOWAdaBVFAUC/3/8lrk6n0wLodrvBcaEZfwe0gA+SrkYIXQA2/Z2NwJBUrrEINb4APAVOAC8kLY0RWvSZPgk8B64EhqVyVWvczL4BbeAucARYlXRPUrMk0pC0AjwGjgH3gRtm9jWgkcSVt
                               MbNbASsSPoMPASWgZakNrAHPAJuAj+AW2b2YIwb1MYV83Hui65J2gGeAdeAU16aA3aB62b2NtLOauOKskMnm3V3mPNrG5itIlQ3V6yPf/e/srxxpe4BtXA1IyzqMvAROON2twGcBja9Fo06uZoThBaBl8BUye4uucVNAa/HWdzv4jr045TUAO
                               74hVvUbTPb83ob+OT1VUlny/U6uCo3Lun4JIuaYHEH8SSFK2WpvHKhXWBhgkevAfPAF7e4N4FhqVyVG79Ysqj1CIt7D5wvWVzowJbCVbnxATATe5pzwQEw4+8eRCpXtTVuZtOJB/0tYLooilHgeQpXtcZ7vV6tSSiVbzgc1rJz5syZM2fOnDl
                               z5syZM2fOnDlz5syZM2fOnDlz5sz51zJnTkAZGRn14idXCCQgFwOq5AAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_ClearDialog
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Deselect Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_Unselect = @{}
  $ImageHT_Unselect.Name = 'Image_Unselect'
  $ImageHT_Unselect.Type = 'Bitmap'
  $ImageHT_Unselect.Threshold  = 144
  $ImageHT_Unselect.Dimensions = New-Object Drawing.Size(20, 20)
  $ImageHT_Unselect.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAABjElEQVQ4y62Uv2+NYRTHP+9NxUZFkHa2iYh8u4nELCEqEQSDpJMYCRMhMVCJ2cTgRgxIRGKRmNg+A4M/oS0RvYNFL63ludK8ve/b3LZn+j7n9/ecJ4ckK0lWADaD/8saxYiy
                            2fiNVUiye6PxnQaHH2U+h0dtsKolq4Bl4CiwH3hSTGeBV+qf9RJ2VresDnBffQqMAaeBF0A/ybX6OOqUx4YUGQd6SSbUBeA1UCU5CHwBZpMATKm2Uq5Vva3eHWLbBcwAD4rqPPBS7a+hvEoOAHeSbKsb1EV1trA7BTwHlhq3XIK+FnimafjqX
                            +B9ed5Lsh2go1YNMdNAt+X/TQC/gIfALfV3G2WANyVwqsE+B9xXr6vLrZQLpYHT1QaXi8CN0mn7lmsb/QnsU78n2Qn0gCPqpyQXgGfApDq/HmXUxQJnytB7wGXgY5JptQtcAuYGnVaDhOpQDBwCPhd8BXgM7AEWgOPquyTnyveZrEa4KDeBR+
                            pS0e0FvgEn1LdJjgEfqi06fyeBrrpjy2/qP//KuqM6q8VdAAAAAElFTkSuQmCC'
  $ImageHT_Unselect.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAADpElEQVRYw+2Y3YtUZRzHP7O7ZWFRZqt57A2D2mBiwy9Bhej6sht1ERUJUZlmb3TlRRf1b3Rr725CFkEYRsauq2XozdcuXN2ljbIlG7ESKkrFdLroN3A6rGd2Zs7sLtQPDofz
                            zHPmfJ/v7/n+Xp6SpCops10CmK3xrHUw101SNbuaufT9uc/g//af3oOSXpLUM5sEdtX5fREwJukA8Baww/ZvMwmwnorfAKrAPcBWoCJpm6Q+SaWZAFiaxh4ZAfqAU8DVqUV9C7wDvG17sl0AO+tNSJLkL+AR4AhwN3ASWBbXamBLkiQDSZJ0J
                            UkyXqlUzhXKYE1BF8uFkuYBPwDXAsttfyWpA7gX2AA8AcyP6b8CO4BB2/unq+KWcrHts8D2eHw2xi7Y3m/7BWApsBEYAq4Cnge+kHRU0suSFreVwVjl7cDRYCix/edF5vUAm+KqATsPjITIPrJ9rlAG4+Ux4EAwtD5n3rjtV4LVfuAD4AKwDn
                            gfmJT0qqTewlScWunTwJvAl7ZXNPDeNcCjwIvAnen1AIPAu7Z/KQLg5cCPEWrKto80kdYEPBXCWhjDZ4CPA+wnts//y8XTzcW2TwPvpcXSqPkf2wLcADwJDAOXxrbZCUxIeryVevC1uG+QdFmzyrR92vZ22+sitp6Nn/6IaNAcQNuHgEPhnoc
                            LqGS6I53OA8aBftsnW62oayw+VwC4YeCOALfa9ommRZL64ytDLPOB22xPtAtcUwza/j3iWwl4pp3gGlJxxrbGfZOkSxoAtwjYE+BGgVV54Jru6mwfjA8sBh6czYI1z15vNCaGQtcAh4EysE/SknYBHIwsMCDppjy3pisa2z9Fbh4FeoDPwvVT
                            A7Rdyqtkctg4BXwYi9ycI4ghYK+k65phstWThVpM3CypM0cQPcCnkhY2ymRHi33x58DXwPXA/Rlww8HOKDAG9AaIBRkm18acMjCcBdkSg7arWbGk3Fqupa/oXcaA5QFiwXTdXWr1XA/ojp6lE7gL2DZVEJa0FNgH3AIcBO5L99hTBPA1tistn
                            27Z/jlKpa6ouqcMwraPB1PHooLZJemKenuykOZb0gCwOx5HgbXZqiQ19+Zg8sa4P5DucbL7t6jzwSHgu3rggqljweRxYBWwM6p1UhX2maarmRwWHwP25IHLzL8V2AssCfYfCtHuBlYAE8DKGTlfqdPOjkRO3xXlfz/wPbDS9uSsAgyQ5Qjo3T
                            FUCXDfFOriFkH2hjCqQF+6Y/wbQPi50O61kpoAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_Unselect
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Remove Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_Remove = @{}
  $ImageHT_Remove.Name = 'Image_Remove'
  $ImageHT_Remove.Type = 'Bitmap'
  $ImageHT_Remove.Threshold  = 144
  $ImageHT_Remove.Dimensions = New-Object Drawing.Size(17, 17)
  $ImageHT_Remove.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABxElEQVRIx8WWPUsDQRCGnzubRJtAtDBdKjGCzbZapBSx9A+IoiktLAIKFoKNoo0GP9AfkNrC1n4aQUEbO68QwUaTytjshslyuYue4jR3vJl5Zm92dyYBCWaM2QYWgTKQAwKg
                          A7SBJ6ApIttJjKAP+ABYBfKkWws4EZH1gRIYY+6ACt+3exGZ8sXQgz978HdgD6gCRWDIPqtWf1e+FRsf/wUxKz8D6iLymrBHo8ANMNnvS4ZUzReU05aIbERR1EqAB8A+MOf9NFYqlQpRFF3rEq3qlYvITsrpCoFzYE3JD+q9ywvtUcyrmtdT4
                          AFwBCwp+RKYVXuSt1xCe86dNVJqHgDH3sovgWUReQEaSl90CcpKvPoh/DMmvuwS5JR4mwHux+dcAn3Z3jLA/fjAJegosZAB7sd3XIK2EqczwHviHTe0XdHZfAZ4N97ak0vQVGLNXv9vw40xRaCmpGZ3I4wxH+qyPQATyvECWElZOcaYU2DFtX
                          ARGdat4kT5TngrHwS+qeA9vKRu+gjM2BuaVJZdD97TTYOYeTDuzYOGvaG39pwX7GmZtzUfUf6RiJT+b6IBWKdDO2sHsRZwGAfvO/R/81/Fn9sXwWnCP/aOA9kAAAAASUVORK5CYII='
  $ImageHT_Remove.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAEZUlEQVRo3uWaTWhdRRTHf6kFLUQhIqVeMdHWr0AClZEopJiFSGptEGPiomIJSjapoohUiaSWVguCBkFfXWRTq2ZjLNZimki/ItaPwB8CCeLGQAv1SjbVWpUqRRdOw/Xmztz7
                          3pukRM/y3v+d+Z35OGfemQfL3GpCNGKMWQO0AS1AE7AWWA3UWsl5YA6YBWaASWBC0o+XzQFjzCpgC9AFbKywmTFgBBiW9PuSOGCMuQboA3rtSIewWWAI2Cvp3KI5YIx5HHgOWL9IS3oKGJT0XlAHjDER0A9sW6K9WQL2SPohT3hFAfi7gTeAx
                          5YwuLQAjVEUfR/H8ZmKZ8AYcx+wE9hQoNNTwDhwEpgGTgNn7bs6oB5oBlqBdqChQJtfADslHS3bATvyrxeAPwTsk3SgzP3UCfQAHQWceF7SN4UdsGt+CNjkafhru+E+rDKHdAMvAMYjGwV6s/bECscH/TnwJeCRauGtfWmXmM82Wab8GbChcr
                          +joT+B3ZJ2B8rgNwLHgFsKfrI1HWJrMpLUhCfO7wgIX2/h15WZJ9qSyS69hPo88KWA8A3A8TLhsWx9mXvAnm16PRt2TyD4myy87xjyju0zy3ot64IZ2OJpdLBIViwAf5sNizd7ZK9J6gMGHe/XWtYFDnS54nyIaGOMud2O/A058C8C2D4POXR
                          d/3LAnuddR+J9AeDvsPCRR/byJfgCfW+0zPMz0OY6HpSbYTPgGy389R7ZgKRd6Ye271OOb9qSDrQ4RONVwq8HPgfWeGQvSXrF837cc+Cbd6DJITpZBfydwBHgOofkL+BZSXnRzcXQBLAysbOzbLpCeAN8BlzrgX9G0lsFmpv2RKN5B1Y7RKcr
                          gL/Lwtd54J+WVCrYpIthdXIJ1TpEZ8uEbwWO5sBvKwPex1CbnIEQGXaDPfZe7ZBcBJ6U9G7In24rEnWbLKsrCH8vcDgH/okK4V0M55MOzDlE9QXg24BPPcvwItAjaX+Fg+ximEs6MOsQNefAt9uR98FvlfR+Fauk2VNLmndgxiFq9cA/AHwMr
                          HJI/gC6JQ1XucxdDDPJTTzpELU74B8EPgKu9MA/KulggH3a7ng+mZyBCYeowVYPkvCbc+Av2JE/GCCydXrKLxPzDtgq8ZhD2JOqIBzIge+S9EmgKNnjeD52qbKdzAMjjiN1hwWvAT7w5I7fgIckHQmUV7o9NaORrB80w55o9GoB+I6A8BH/FJ
                          Fd0Wd4gQO2Pj/k+OhWD/yvwGZJxwIm2H7gHse7oeRdQroqsdeWLoraz8D9ko4HPJIM4K6CT1nG7MqcrbcMFuzrJ6Bd0leB4Qc8ksH0BYirNvo2/ruAC8DDkg4HXPN59w8lSU+lH2beD0RRNAU02rWfZSuBdVEUnYvj+NsA0eZNoNMjGwW2x3H
                          8S/rFf7O8nuhk+V5wpGZiB/5y+2LYKLDLNfLePZC0OI7PRFF0ArjKU34JbSVgu6Tv8oT/j2vWlBPL96I75cjy/KuBw5nL9mePZW9/A6AEppZX1j/TAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $ImageHT_Remove
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Rename Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_Rename = @{}
  $ImageHT_Rename.Name = 'Image_Rename'
  $ImageHT_Rename.Type = 'Bitmap'
  $ImageHT_Rename.Threshold  = 144
  $ImageHT_Rename.Dimensions = New-Object Drawing.Size(17, 17)
  $ImageHT_Rename.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAABmJLR0QAMwAzADOGP0P2AAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH4wgXCCMMGLaNmQAAALhJREFUOMutk7ENgzAQRR+IDZghE/yGDrqMwARpyDykYQK2IB3NTZAZ
                          MoPTGMmKTIKB19hn333dt84ZK0i6AANQATNwM7NXLDdnnQGogatfh7XEXyIV0JjZE2h8nCwyA5OkGph8HCWT5DhIEezvwGhm7y2FkjqgXwLnD5KR1ElySydjcPHXnpllQV3P0TeR5HJOoIgpJ9iJi3wnbOE8O5LKZT5S7EgqQzst8Nhhpw1Fe
                          knsndhT/s4HtQtBJY0cQU4AAAAASUVORK5CYII='
  $ImageHT_Rename.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAABS0lEQVRYw+2XMW7DMAxFn9N26ZpMHnMFTp17gq4ZcoAayBIgdyjQLg3cA3gw0Dt0z8RDdPKSnKFd6EJV7AAWItdGQ0CQIBEk/UlK3wmBIiJLYAnc2dYOKFS1CLF3FRjEE/AM
                          zIEbG3PgIU3T26qqPrranAQisQE+gRUws7GyvY3pdJLrAEBqJy+qunX2tyIC8Go6RVREnJooG85KTydqIFEkJJCdzYuGs4WnE7VGCuAeWFtNlE4Qa0enkyQi8jXW1ESRptRkNr8DqOrhnA5F5NGW+SlEMnP+FuvLHdtZW41ED+IUMpOWaKOL7
                          8tFZNZUE+fqKlVNPLtTW+4H1TU/iPgR9yW1/1G/Nf/vZqWPrhkvIn1106VYh18j9d3/B2/NsBD5xUf6pAEOJznmIw5Z6ZMYHaUmdxVEZOrnMSZv9Wskj41MG3m+/Nf48g0N3mzW6JxfXQAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_Rename
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Folder Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_OpenFolder = @{}
  $ImageHT_OpenFolder.Name = 'Image_OpenFolder'
  $ImageHT_OpenFolder.Type = 'Bitmap'
  $ImageHT_OpenFolder.Threshold  = 144
  $ImageHT_OpenFolder.Dimensions = New-Object Drawing.Size(17, 17)
  $ImageHT_OpenFolder.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAA3UlEQVQ4y+2UMU7DUAxA3y+RsnXIghSxJRdoHYURVTkCS0bO0wPkGh3YUccO33RlyEwWpJ8cAMxCURaklIYNT7ZlP1u2bJhBHICIPAOrkf+oquupkCsR2QL3eZ53WZa9xnH8
                              3vd9nqbpTdd1j5M6EZEnYOO9vz05q6raD8MQA9eq+jYFsgfufjmOo6quI8AAyrJ8MTPnnDMzc99VRvZYDyEs27Zdicg2OgU3TfNwbhtFURyAYjHDhhdzQPiH/CHELmR8RIAHNnVd75IkGaZkmZkLISy/TP/TKzjrdj4B7/VPl5Mq55IAAAAAS
                              UVORK5CYII='
  $ImageHT_OpenFolder.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAB2UlEQVRYw+2XMWvbQBTH/3eqJRdVNchjK+rVWTzcF/Dn6GxopxiHdCjtZAqZigdnMe3S7t0KHfoZji6mQ1O8CApN7oRCLCGpli+L61yIEyjYosP94ThO94f3Q7z3eAcYXRcB
                              AMaYDeARAHqHNwNwxjkvdgHyN/A+gNlyufx521JK/QDwZgW9dd1b7YeWZZ23Wq23ZVne32SUUrL5fP6CUuoA6O8KxG02m+loNPoeRZG7yRiG4cl4PK4LIfYZY5855193AQLXdREEwSIIgnKTsdPp/KnX65+Gw+FemqbvALR2AhLHsTuZTJ4WR
                              WEDUDeymhCilModx8nTNH3CGPsI4ETLM6LZlXZW2r3+vQDwjXP+Ra+aC6XUgyzL7i4xQlCr1UAI2U6lUJoDeMY5/7D+I7Ztn3a73ed5nrsVtA2VZdnD6XR6tFgsXgK4Amk0Guj1ejSOY1pFA/N9/3e/38+FEI+v5YjneWi325U2U8/zIIRQek
                              ODUqrytq7HpPhPZEAMiAExIAbEgBgQA7KtgfifRjQt5npUTJIEYRgiiqJKIHzfR5IkN0CWUkp7MBjs3fbk3LYsy8qklM7qfbMGeV+W5cFsNhtWmheUAsBrHeQVgGO6uqlQJYBfAHAJ0HvAoXeYuVcAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_OpenFolder
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Exit Button
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_CloseDialog = @{}
  $ImageHT_CloseDialog.Name = 'Image_CloseDialog'
  $ImageHT_CloseDialog.Type = 'Bitmap'
  $ImageHT_CloseDialog.Threshold  = 144
  $ImageHT_CloseDialog.Dimensions = New-Object Drawing.Size(20, 20)
  $ImageHT_CloseDialog.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAABlElEQVQ4y82Uv2tTcRTFP+9pimA3i2AgCkUCTilcMtRQ2kylS8B06ZJBKZK/wv+iUyBLEnAQskiX2snBoZyhS0uHdM2SIEK0raUvHZonX7/mNx1807vn3nve+X7vfQf+p8fM
                               Ns2s6WKBG9Rqtf60ZL1ej2q1ShRFAN8kvQZ46BeWSqVgCmWLwHenf9XMmpLehHMcMwRaQ8QkzSwI57i6CvDUw74Ca5L64YzqVoB3LpZKpQA2JP0GmFXhvhdfFgoFJEUxEA5R8XyEunXgmQdvJxKJv4DQadit1+sAR2b2YgjnJy9uSvIV3xGaW
                               RrY63Q6DC78i5k9dj62DCw5fT+BnWEniRV+ABYc/CVw4MSfvb5yPIRxhC0vt2pmVTN7BLxy8BNJ9VFTCwEknQPpXC7n598Cx07cB4rj1uDPUCRF2WwW4D0QOTVp5/2jpLOpCB3iCrAF3Hipa6A8aVH/MYfYcbrdLo1GI3YT8vl8IpPJ/JhEGE
                               z41YqD/bsCnkj6NYnwwbhku90+TSaTFwO/O7xPZw6mrb0FDzZ7gDD+vZoAAAAASUVORK5CYII='
  $ImageHT_CloseDialog.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAC5ElEQVRYw+2YTUhUURTHf45hrzKkD1AUQiQShiDprDITIzcDEiQREWkwJYGVgQYSVAZtLApaBEEfFIoRZhMG2spNRBR4Fi2ihUU4fbgppkHCKUHbzMCo896747yZaeFZ3vN/
                               Z37vf+fec++DlcgsCvMNICI7ysvL101NTUVS5X15hhNgDAiJyJpUmlV2D/f3989nEy4SiRAKhZiengbYBFwHTv0XDkajUYaGhhJwiWgXkcPGDiaipaWlwONprQJeA6Up0ndF5J2qfsiLgyKyGXhhAwdQDAyKyNqcA4pIIfAU2OYi3Q7cyoeDF
                               4B6A91PYMT4P+iRe3XARQPpOHBIVT/nzEER2QAMGDSFAWB3MlyupvgasMVJ0NDQANCqqn9zug+KyE4g6KQJBALU1NSgqnM5bXUiUgDcdPmNK9XV1Y51sungEWCPQ/6eql5yK+LLknvFwFUHyRvgtEmtbDnYBVTY5H4AB1X1T8aAExMTiEhvmu
                               6VAGcdJO2q+s20ni3g5OQkIyMjAN1pQnYBG2xyfar6JJ0X9tm4cHR4eDh5qFtELhu4txHosEl/dciZA4rIfuDB3NySbanHwMlOoMQm16Gq0YwARWQfMOjQo22dFJH1Divzuao+W85qW+zgMWC1yzM9NpDHbdz7DZxZ7nawAFBVW+OQMwaQvYv
                               OenYQvaoa9gQwDtkH1JeVlbk9mzzdB4CqFJovwI1MNtSUq1hVx5ubm/H7/RhOd6dN/ryqzngOCFBUVERjYyPAfTdIYFeK8bfAo0xbkmMn8fl8qOoJ4CQwm0bdeeCcqs5nFTBpyu8AAeCXYd3HqvrKi6ZufFhQ1TGgDvjuIp01vH94CxiHfB+H
                               /Ogge6iqn7wCdL3VpfpGE4vFGB0dJRwOL1lYwWCwzbKstrw4mAjLsmhqaqKysnLBeG1tLZZleXqwzOi7i4hUAC/jm3QM2JrOWS/rJ+o4zF4gDNz2Gs7LO4hfREpZiZVIP/4BmKvdtvGdLO8AAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_CloseDialog
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Triforce Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_Triforce = @{}
  $ImageHT_Triforce.Name = 'Image_Triforce'
  $ImageHT_Triforce.Type = 'Bitmap'
  $ImageHT_Triforce.Threshold  = 144
  $ImageHT_Triforce.Dimensions = New-Object Drawing.Size(17, 17)
  $ImageHT_Triforce.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH4wgSBBYR50UqoAAAANJJREFUOMu9ki0OwkAQhb8WU7DQBIdAkKpaHHeYC6CQnIdwgyaQIVwBgcQ2CAQGQ0ASJGZLSLM/xXTc
                            5nv75k1moI0SkWVI0wkYzIF1lmW3sixPLl3kMUiAJ9AF3kBfVV82bewJsjEGAAlQ/JVERKbA0cJnqnpommTnaLBtNI6IrIChwzw13D2OiIyACzBW1aulgZXXk+zN2veOJFYe/3RZALl55uZNEx4ZQQ94mFVW9b2NEK+SFDVB/Ta8PBKRAXD3H
                            N0EOHt4GgcMCBjQ4H+L9QGqfECOTBUb0gAAAABJRU5ErkJggg=='
  $ImageHT_Triforce.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAACMklEQVRYw+3Xz2tUVxjG8c/ENCXUkIZAK1gEF5rEYIO0q2JBRBd24eJd2J1u2ioWAwUJglCEQqULKaUu/CverVA3rbuAIlHs+APcFUtBipRSao26OYVJmMnMvTOJm7y7e++5
                            3/uc5zm/Lpu1srb0C4iIozMzM7ubzeaDfjiNPkWM4m7p0J7M/Lsua6hPQ85jJ3bg3GtxJCJ24Q7eLLeeYS4z7220Iz+0iIAR/Lih0UTEpzjS5tGhiDi2IdFExBia2N6hye+Yzsyn6+3IhTVEwDZ8va6ORMQsbuGNLk2f48PMXBq4IxHRwOUeR
                            MAwLpd3Bh7NCRyo0H4/jg80moiYwD28UzH6J5jKzCeDcuTbGiJgEt8MxJGI+ACLfWyQL/BRZi7WFhIRQ2W1nM/M5ZqL3xZcwam1GN2iOYnT+KKPreBLfIbPazkSEZO4X3J+ipnMfFzRjXfLIH8bf5YV94+qjlwqImAcF2u4camIgAl8V8mRiN
                            iP66uev8TBzPy5Rzc+xi+9MhptAMO4gbk2/LvYl5n/dRExjJt4v1dGu2jmO4iAWZzpwZCvOojoyGis6sm2MrjG1/jIX2Xg/tbBjffKMWFrFcZQm1PXeJfejpVB2Km+7yKiLaPR0pNDuFZhRnySmVdXuXEYP9VhNApgBEuYrgB5iL2Z+W8L4za
                            m6jD+j2ahogjYhbMt1wsVRaxgNCJiB37FWzUWrH/KLFjulzFcTl11ADCKR33+pI2WSbJZm7VmvQLGp5kN7GygKAAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_Triforce
  #==============================================================================================================================================================================================
  #  Image: Combine Dialog - Triforce Glow Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_TriforceGold = @{}
  $ImageHT_TriforceGold.Name = 'Image_TriforceGold'
  $ImageHT_TriforceGold.Type = 'Bitmap'
  $ImageHT_TriforceGold.Threshold  = 144
  $ImageHT_TriforceGold.Dimensions = New-Object Drawing.Size(17, 17)
  $ImageHT_TriforceGold.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH4wgSBCABc+6rsQAAAM1JREFUOMu90qFOA0EYBODvrqZgoQkOgcBcUovjUciJSl4Gg1zbBBLCKyB4gjUIBJq0skFitoRc9nav
                                pmM2m5mdf/7scAzE4L6maSsGd3iIwaqkawoGc2xxgh+cdb3doUmekgHMsT4oSQxu8J7hb7ve29QkLyMDnietE4NHXIyYLxI/vk4MLvGJq673lRmQ5YdJXjFLZw5Zvv03ZYVlui6H3SjxTRKcYpO+co+/btT4fZL1QDDsRpFvYnCO70LprvFR4
                                BdtxUDFwIT3R8QvLME8DwlMPvQAAAAASUVORK5CYII='
  $ImageHT_TriforceGold.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAACH0lEQVRYw+3XzUsVURzG8c/VmyIlJkIJhdBCtJySqFUYRNiioJa1KyZ6gaIgCBGCCIKihUTkot38GUFtqp1ghDWWEbSLIpCQiOjFanOCm9y3mXu1jb/d3Dn3O895nt85c4bV
                                anKliSNp4nCjnEKDIjowi1Zsi2Jf8rJaGpzIFWxBH8b/iyNpoh8v0B5++o7hKDa30o7cKREBbbi7otGkiWM4WObWaJo4uiLRpIlOvMKmCkM+YDCKLSy3I9eqiIBeXF1WR9LEEJ5hTY2hP7E7is003ZE0UcBkHSKgiMnwn6ZHcwL7MowfwfGmR
                                pMmujGHDRmjn8dAFJtvliM3coiAHlxviiNpYhemwvskT/3Cnig2VaupqolowUm0R7HFnJtfK+6lielqjFrRnMU5nGngVXAep3A6VzRpogevQ84L2BrF3md0Y2No8vX4FHbcj1kdmQgioAs3c7gxEURAN25lciRNjODJkvu/sT+KParTjb14XC
                                +jUAZQxDSGy/BnsTOK/aghooin2FEvo1w0FyuIgCFcqMOQSxVEVGQUlsykNzRXV5WHfA6N+66CG5vDMWFdFkZLmVNXV43ZdoYmrFS3a4goyyiUzGQUDzOsiENR7P4SNw7gQR5GIQDaMIPBDJA32B7FvpUwnmMgD+NvNGMZRUA/Lpdcj2UU8Q+
                                jkCb68BJrc2xYX8MqWGyUUQynrjwA6MDbBj/SOsIiWa3Vqlp/AIpnhvomJWToAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $ImageHT_TriforceGold
  #==============================================================================================================================================================================================
  #  Image: Split Dialog - Clear CTT File
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ClearCTT = @{}
  $ImageHT_ClearCTT.Name = 'Image_ClearCTT'
  $ImageHT_ClearCTT.Type = 'Bitmap'
  $ImageHT_ClearCTT.Threshold  = 144
  $ImageHT_ClearCTT.Dimensions = New-Object Drawing.Size(17, 17)
  $ImageHT_ClearCTT.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABXElEQVRIx62WTWrDMBCF39MRnOY+PlgW3nvhZSGQ3EqlvUBOYLTLvC4qB3Xi2LKJQAis4Zt/j4CFJaATEI1MRpqRymcyMgrosGcJGAQkAcrQpZ1EDlvgUYCmXaFg2rEGfivh
                           AkYBvYBWQCMg5LMV0Bs5OiW3assFnAUcVgz6MPJr1ZMc8xJ+qvCWAj7nwiVg8MKptLwCHgRcHPi7TLwvxTLmh62WC7gKOJY5eZSwi32/Ex7yff+UCxeedhOcfMCzTPsUpqJDJaDZC89yTSFjk4LS3bAXPiW/lFv14EUpzsKXPEiFgvYfnKyGL
                           +UgFgr6CW4b4a+riOyKj2Nu/z3ww2wf+DC5jpSRlzV4ZpxnOzlfDi9+wdcauMiTq7JhzoLo4D8CjhVhOVfPBSNvTng0cnYeGLltHix48r6J5nKSLISqmWxbZrJT1BkZLYR0D8Hufwofrwoj970q3rl+Ae1iOSZ8LoaUAAAAAElFTkSuQmCC'
  $ImageHT_ClearCTT.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAEZUlEQVRo3uWaTWhdRRTHf6kFLUQhIqVeMdHWr0AClZEopJiFSGptEGPiomIJSjapoohUiaSWVguCBkFfXWRTq2ZjLNZimki/ItaPwB8CCeLGQAv1SjbVWpUqRRdOw/Xmztz7
                           3pukRM/y3v+d+Z35OGfemQfL3GpCNGKMWQO0AS1AE7AWWA3UWsl5YA6YBWaASWBC0o+XzQFjzCpgC9AFbKywmTFgBBiW9PuSOGCMuQboA3rtSIewWWAI2Cvp3KI5YIx5HHgOWL9IS3oKGJT0XlAHjDER0A9sW6K9WQL2SPohT3hFAfi7gTeAx
                           5YwuLQAjVEUfR/H8ZmKZ8AYcx+wE9hQoNNTwDhwEpgGTgNn7bs6oB5oBlqBdqChQJtfADslHS3bATvyrxeAPwTsk3SgzP3UCfQAHQWceF7SN4UdsGt+CNjkafhru+E+rDKHdAMvAMYjGwV6s/bECscH/TnwJeCRauGtfWmXmM82Wab8GbChcr
                           +joT+B3ZJ2B8rgNwLHgFsKfrI1HWJrMpLUhCfO7wgIX2/h15WZJ9qSyS69hPo88KWA8A3A8TLhsWx9mXvAnm16PRt2TyD4myy87xjyju0zy3ot64IZ2OJpdLBIViwAf5sNizd7ZK9J6gMGHe/XWtYFDnS54nyIaGOMud2O/A058C8C2D4POXR
                           d/3LAnuddR+J9AeDvsPCRR/byJfgCfW+0zPMz0OY6HpSbYTPgGy389R7ZgKRd6Ye271OOb9qSDrQ4RONVwq8HPgfWeGQvSXrF837cc+Cbd6DJITpZBfydwBHgOofkL+BZSXnRzcXQBLAysbOzbLpCeAN8BlzrgX9G0lsFmpv2RKN5B1Y7RKcr
                           gL/Lwtd54J+WVCrYpIthdXIJ1TpEZ8uEbwWO5sBvKwPex1CbnIEQGXaDPfZe7ZBcBJ6U9G7In24rEnWbLKsrCH8vcDgH/okK4V0M55MOzDlE9QXg24BPPcvwItAjaX+Fg+ximEs6MOsQNefAt9uR98FvlfR+Fauk2VNLmndgxiFq9cA/AHwMr
                           HJI/gC6JQ1XucxdDDPJTTzpELU74B8EPgKu9MA/KulggH3a7ng+mZyBCYeowVYPkvCbc+Av2JE/GCCydXrKLxPzDtgq8ZhD2JOqIBzIge+S9EmgKNnjeD52qbKdzAMjjiN1hwWvAT7w5I7fgIckHQmUV7o9NaORrB80w55o9GoB+I6A8BH/FJ
                           Fd0Wd4gQO2Pj/k+OhWD/yvwGZJxwIm2H7gHse7oeRdQroqsdeWLoraz8D9ko4HPJIM4K6CT1nG7MqcrbcMFuzrJ6Bd0leB4Qc8ksH0BYirNvo2/ruAC8DDkg4HXPN59w8lSU+lH2beD0RRNAU02rWfZSuBdVEUnYvj+NsA0eZNoNMjGwW2x3H
                           8S/rFf7O8nuhk+V5wpGZiB/5y+2LYKLDLNfLePZC0OI7PRFF0ArjKU34JbSVgu6Tv8oT/j2vWlBPL96I75cjy/KuBw5nL9mePZW9/A6AEppZX1j/TAAAAAElFTkSuQmCC'
  $ImageHT_ClearCTT.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADF0lEQVRo3uWau2tUQRSHv91uIaRZkBDxgYUPUDAoGyRi0AgiBoXAmsasRSoRsQ1orCz8AxbBXqwlEEJKTREQIU0qY5YUvhBf0QhxNf4svIHLZmfuzL2TNVkvnGb3zO9+Mzsz
                           58yZhW3+5EKICLqAfqAEHAb2ATuAjshlBXgP1IB54BnwJAfv/lnPBQXBqGBKoJQ2FWkUWgneKRgTLGYAb7TFSLNzs+FHBHMBwRttTjCyGeDdguomgjdaVdAdCr5XMNlC+HWbFPRmhR8QzDi+cEnwQFAR9AiKgnxkxeizSuSz5Kg5IxjIMvIu8
                           BOCoRT6Q1Fbl070ppnzSdNmVlAOMEXLgucO06nbR7TaqkUm2Om4JVd9tkqTSF0wHnB32yVY8FjYIy5ByrbPh4TfLXiZIk502kTHMv+EbvB7MkTyMVtus2hZsKHm/F5BLQHyfvROU9pRaCY8ahEsB4LfL3iVAH8vtjuZfEabiZuyyolA8AcEr1
                           3gY21McWJqQz5vER0KAH9Q8CYB/o4h2Jn8u+KOw6b0IAD8IcHbBPjblvamtGMYIB/5lQztpzPCHwWeEh+tjc+tHNy1fG9iKMVfNG3oZSUDfI/gg2XUfwtuOuhUDO2n406maNiTEv6Y4GMC/A2PgWimsRB3WjY4FVPAHxd8SoC/7qFXNOgsx53
                           WDE55T/g+y2Csw1/z1MwbtNaCdkBwUvDVAv9LcDXFL+rUgUxTSHBK8C0BvpJyPTlNodSLWNDvAH8l425mXMTrU6RmaH8kQfwcf8N6h8FlDajk4GGGcGJiqMU7MG9w6rPAnwceY66q1YFyDh5lDOYmhvnUqYTggmDVMm1+CC4FSgKtqYR3MicY
                           TIBfFVwMBO+WzLmm01GOXk+AHwx4cnNLp10ONILLgp8Wn++CswHhvQ80tiPlCwf4M4FrsX5HSodDvclWBKcDF5Or3od6x7JKo30RnAgMP566rOJQ2Irb58zV4+bw9dSFLY/S4moUyFp5/1D1FWxlcXc2aHF325fX2+KCoy2umNrikq8trlnb5
                           qJ7K/7V4P/9s8dWef4AjjeEvyEZHKQAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_ClearCTT
  #==============================================================================================================================================================================================
  #  Image: Process Selected - "No Preview" Image
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_NoPreview = @{}
  $ImageHT_NoPreview.Name = 'Image_NoPreview'
  $ImageHT_NoPreview.Type = 'Bitmap'
  $ImageHT_NoPreview.Threshold  = 96
  $ImageHT_NoPreview.Dimensions = New-Object Drawing.Size(280, 280)
  $ImageHT_NoPreview.Image = 'iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAYAAACHjumMAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAFXFJREFUeNrt3Xt4VdWdxvF3YyjqCPpMNVMrVgoKU60E6VCtSFV8FMRa2spDsYWa2pHxEsdaW3GEwUuZ8VGo
                              qKUCpkipF6hjESpq5VruaSVyxxLACwJKhBAJAUJC3vnDszP7sE9OzkmIwvD9PM9+cs7Za+2z19pn/87a+6y1IgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                              AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcGyxfbzT22
                              D7cxlsZ1qabUw7gsv/BWen1na17f22y2xvtl1s+wXb/2b7FD5VdXXbroG6HEgtHdvBJaMg00BwOWKDTCOCSyZ22v4Rn60GgwtB5lPQ4kjYiZqaGgVBEFtuvfVWHTx4UJLOlvTvDW1n3LhxsW2MGzfuiD8IlZWVKct/6NKmTRt16NBBeXl56tO
                              nj/Lz8zV06FBNmDBBy5YtU1VVlST9o6RJtofy8ZY+/vjjlHW5atUqKudYacFUV1dbUspl4cKF4TfNx7Zz07Vgxo4dG8s/duzYI74Fs2fPnnrLn81yzTXXeMWKFdFv56HH8GernW2Xl5enrKuVK1fSgjlWWjDp3Hfffdq7d68ktZE0gkNWv1de
                              eUVdunTRvHnzwpdG2O5LzYAAU4+5c+dqxowZ4dOf2O7CYUuvZ8+eWr9+ffj017ZbUisgwNTj9ttvV2lpabi/j3HYGvbQQw+ptrZWks6U9K1jtR5OPvlk2Y4tnTt35kNCgPlEaWmpJk6cGD691PZ1x8LBGTt2bNJJUVtbq+rqau3bt0/bt2/X3
                              Llz1atXr5R5J02apJKSkvDpFcfaBzsIgnclfbmBZIOCIHiWMHCMBxhJuueee/TWW2+FT0fabnU4t2/7FNs32f6j7Y2299iuiixbbb9he5Ttyz+jk0Y5OTk6/vjjlZubq8svv1xTpkxR376pb7OsW7cufHheoowD0/xcO9v2VNvbbR+ILNtsT7
                              F9aYo6+7ztO2y/bvu9RN+ccCm3XWL7D7bzbZ+YIv9vGvgJ+dw0x+ufEv2B6vN4Ez8PTS3bi2n2bUqK9F9poC7+NUWeX6RJ/5Ht447p6JbJr0jR5aabbnJNTU1Ygf8R2U6jf0VK7MODtiuy7G+y1Hb3JpY/7a9I0X233SKxr/9oO8/2UNu7bHv
                              p0qUp8z/88MNh/pUNBJdMfBANMrbvTJxomdpm+4Ysgku9QSaD4JKNgSm239SyvZhBnilZBJdYkGkguBwxQabF0RSQCgsLtWjRovDpvbZPb+IJfqakv0r6T0knVVVVqbi4WIWFhbrlllt0ySWX6LzzztMPf/hDDR8+XDNmzNB7770XZr9I0l9s
                              3/EptV5qgyDYHwRBWRAEK4Mg+C9JwyWpffv2KfPs3Lkz9tqqVatifUJ+9atfSZI+/PBDPfXUU+rXr586deqk66+/XhMnTtTmzZsl6QuSpthuafsZSY9KOnnfvn1aunSpHnvsMf34xz9WXl6errrqKt122216+umntWLFCtXU1EjS6ZJ+Z/tR2
                              0G4P1OnTk3ZTyWy74NSFO2HknL27t2rDh06xPJOm/Z/3yXZ9IM53GX77W9/G3vfyKX+lbZbRC9hd+7cmXJf33zzzTDPZZHd7SNJCxcujKX/zne+I9tcnzXUgpkwYULstR49enjPnj1hhJ7Y2BaM7TMTzVxXV1d75syZ7tGjR0YtqQceeMDvv/
                              9+9JvizuZuwdST/07b3r59e8r8999/f6wFs3Llyli6UaNG+f3333e3bt1Sbqd///6ura0NWzHPhBtdvHixr7zyygbra8CAAYf2z3k0bMHUt++vvvpqmHZz9KRNlHuFbS9atChl3o8++qjujTLtBxMGl8NUthfrq+trrrkmrEvbvijx3i/ZdlF
                              RUcr3mDRpUpj+/UT6NonLVz/88MOx9JMnT+YyKZMAs2bNGo8cOTL2+nPPPRcdl/Mv2QaYxPV1iW3v3r3bd999d9ad2tq3b+8lS5Y0Kcg04hLpBNun2/6G7Qds7w5PhlT5x48fH+YvShdghg0b5oEDB9Zb1pdeeil6meSDBw/697//fdZ19qc/
                              /SlaX3VN/OHDh8fS3nDDDdG0PSN1dn744pAhQ9IF1WwDzOjDXbb9+/e7ffv2sbRbt24N092fOK5ltj1u3LiU2x40aFB022fbvs62q6qq3LFjx1j6kpKSMO0EWjANBJjS0lK3bds26fXWrVv7gw8+CCtxUSMCzP/Y9t69e33rrbc2qffs4sWLw
                              +3XRE+Ewxxg6rVjxw5fe+21DbUCpqYLMA0tkRPCtj19+vRG19eCBQvCzey3/TfbLi4uTpn2nXfeSWqpJupslG2XlpamzFNcXBwNqhkFGNs9m6Fs1bY9atSoWLpZs2ZF9/FfbLu2ttZXX311vdsuKyuruw9je4Jtr1u3LmULv7q67vbUZ9494Y
                              i/B3Paaadp9OjRSa9VVFRowoS64Nw9y5O6h6R+kvTcc8/pySefjKXJz8/X8uXLVVlZqZqaGn300UeaNm2a2rZtG0v7/e9/X++++64kHSdpdOS6ujkCsmpqalRZWamtW7dq9uzZ6tevn15++eWU6b/2ta+FD9c39j0HDx6sL37xi3XP33333ZS
                              /Wg0YMEArV67Uvn37VF1drU2bNukXv/hFLF1BQUF4f6WVpGWSdP755+uyyy6LpV2yZEn48LpE6+04ST+QpL/+9a+x9D169ND5559fd8sui2IOa4ayzZekSy65JJZu8eLF4cNuknpK0vbt2/Xaa6/Vu4PvvPNO+PBySb0laeXKlbF0N9xwg3Jy
                              ciRpj6TZtGAaaMGELY1evXrVuz7xM2JGLZjEt7k3b96c8j2HDBnivXv3pmwtrF+/PtaakuS77747el197eFqwTRlGTFiRHTX8zJpwQwePNgbNmzwgQMHXF5e7gULFnjRokVJdfDII4/E8l199dXetWtXrL6qqqp85513xtK/+OKL0fFlu237h
                              RdeiKW77LLLot/GP7DdO/y2HzBgQCz9H/7whzBtRTZjkZqxbN69e3csTW5urvft2xeme922FyxYkPZ4/u53vwvTb6mrkB/8IJZu9erV4eoXuMmbYYCp7z5Dfn5+9APYYICxfaLtfbY9fvz4WNq2bdt6586d0aCVb/urth9LXAL55ZdfTrmvke
                              ve8Z91gOnatWu0HIuifWDqCzBt27b1jh076rsS25TuZI1cGpTZHmS7l+21tr1hw4ZY+p49e0aP2zjb/vDDD1Nue9WqVWG612w/b9sbN25MmXbbtm1h2qeyCDD5zVg22/awYcPSfbYrbXv06NFpj+nAgcm9DFLdHD/33HNdVVUVJrmeAJNFgDl
                              48KALCgpiaebMmZNNgLk4fL+uXbvG0j755JPR+yn/fMi+jrLtiooKt27dOpb3hRdeCPOu/SwDTPfu3b1p06ZwX/bZ7pRJgHniiSeiZe9j++7I8oRtL1++vKH7AzEHDx5M+etUJBj8W7oT8fHHH4/u117bnjhxYspWZMTXswgwzVm2ZbY9d+7c
                              WJpnn322bjs1NTW+6KKLktanarFH92XevHnp6qrKdpsj4Rw/WvrBlLRo0UJ33BHvcjJ06FBVVFRkup2zwuvdSN+COhdccEH48JUgCP5+yOrRknzSSSfpJz/5SSzv0qVLw4enf1aVNGLECE2dOjXsF7Nf0neCIMjo/kuXLnVjSGcGQfBqEASPh
                              Iuk08J7FKm0aVP/Z7lFixb6xje+EXt969at4cP2koolpbz/MXLkSFVWVob3uE44cOBAyvtm3/ve9+q6+gRB8LdsbvM1Y9nmhPeYDhUZwKtt27apqKgoaf0999wTy/P222+nuo9Tp3v3utuRc4Mg2E2Aydx9knT22WfrsceSxzoWFRXppZdeyn
                              Q7rSRp165dKVeeeuqpSR+MqCAItkr6e7gfh/r73+vi0cnNWRG5ubnq2rWr+vbtq4KCAo0cOVLTp0/X5s2bNXToUOXm5kpSZSK4vJ7NzfSEeSlWnyJJ5eXlKfPm5OSknSjriSeeiOVJDF6VpH+Q9JQk5eXlqUePHknptmzZknQzc+3atXrjjTe
                              S0nTt2jUaIAuzrNLmLptOPfVU3XLLLUlppkyZUpcuMvJdktS6dWtdeOGFys/PT3p9zZo1kqT9+/fHJlLLzc3VV77ylfDp1CPlxD2aevK+LkkDBw6M9VwtKCjQtm3bMt5QovdlzOc+Vzcr56Z6sr4tSSeeGBt6ouLi4sNe4EMHO9rW9u3bVVxc
                              rGnTpunXv/61fv7zn+vb3/62zjzzzLovN0ndswkuknTSSSc1VHbt3n34vhT3798fPjxR0vOS9rRs2VIFBQVpv+1nzZoVW//Tn/5UrVq1ClttjRq82Ixl2yhJffr0iaULx9b97W/JDa7bbrtNJ5xwgq666qqk12fOnPnJAdq0SVu2bElad8cdd
                              4Sfy1pJ0wkw2fuZpJrPf/7zdV3bQxUVFSosLMy4e3Tiwxhz4MCB8GGHerKeIymcACtJqqZyM6pNnEw7JJVImqtPprH4ZhAElwRBsDLbDUaCa2m29dYYiek9w9bhHkmTJcVaMNInU0+Ul5ersrIyduwl6dJL64ZIvRgEQXlj9qe5yhae7JEWVl
                              Lru7q6WpMmTUp6/eKLL5YkffWrX016/fnnn9euXbu0fPnydHWwJAiCUgJMloIgWCdprCT17t1b116b/Gvw/fffr8mTJze0mT2SdMopqSfe37FjR/jwihQ3ZNuGASZyOVSnU6dO4cOyZij+9CDZcUEQnBAEwWlBEHQKguCKIAjuDIJgYWPfoGX
                              Llkl1dOiXsvTJ3CqHuvLKK1POt9LQcv31sR85CiXp9NNPT3n/Ye3atVqzZk308qOu9fqlL30pfPrbxjQ4mrls0yTpjDPO0HXXJc8y8vTTT2vDhg3RaTUkqe5Sp0OH+Pfcpk2bksZahSLB6KUj6bw9qgY7Ju7F7Dz++OM1dGh8utmFCxs8v94L
                              7zd07NgxtjLyzdAn/PUl4k5JQUVFRewb55AWzDYdhYKgbrjP3hSrd0pSu3btYitmzZoV3oRtjIlBENyYeP83JK2Qkm7Y1pk/f360412d/v37hw9LgiCY34h9aO6yLZFUGgSB+vXrl5SgpKRE48cn92ro2LGjzjrrLIWX4nfddVfS+meeeUZ//
                              OMfk14bMmRINEASYJpwEuxKBBl9/etf189+9rNsN7FWUnVOTo5uvvnm2MpRo0aprKxMknIkvW77Btvn2h4t6Q5J+stf/pLyV6tIE3j+UR5gDqZYvUqSvvzl1PM3RW7Clksq0Ce/DA2XVJPuSkLSw4f0fK672Rv5RUSS9Pjjj2vMmDGxkzHSW7
                              mx426atWxBENRKellK6lld59CbxIMGDQpbk9WS9M1vfjNt+rClFe5uEATvCHWXHZn2gxkQyXOc7TW2/fbbbzfYLyRFT96Z9Y3jUCN78j744IPRZFdkUf4mjabOsq7T9oMpL6+b/qRdirwXhCvvuuuuWN5evXpFO/YlKSoq8qBBgzxmzBj/+c9
                              /9tq1a71z586w5/N+22dF3qdNYqIvT548ucFjW1hYGL7NgUP/40RjevI2V9lsfyv8nDc0Yn/mzJl1fUttu6SkpMF6KC0tDfPcR1RpYoBJ5LsyXPGb3/wm2wBzXdjdfMSIESnz3HjjjV6xYoUrKytdU1PjHTt2ePr06SlHxnbs2DE6GHBJluU/
                              KgJMIv9q2169enW9/zKlqKjIFRUVrqmpcXl5uefMmZOyzjp37uyPP/44FmAS7zPBtrdu3drgibVx48Zwn19Msb/ZBJhmLVvic15h24WFhWnL9N5774X79WA4JCHV+4TLzTffHI155xNVDkOASeT9k22XlZWlHLKeJsC0SIzAdnl5ufv379+kn
                              rNvvvlm9Fv0wv/HAeb6MMGYMWOaVGfz5s2Ljjo+NMBcGK5MN41Gfn5+dPxX7yYGmGYvW7o5YsKlW7du0RkbLw1HZP/yl7+sN8+MGTPC9BuJKIc3wJwTTrpT3/gg1T9dw5fDuU127NjRqCkbOnfuHA0utn1jI8p/1ASYxDZeDo9XqoGBmSxTpk
                              yJ1tm99bzPynQTMEny7Nmzo2PGWjQlwHwaZQvrv745YiT50UcfDfPutf258DJp1qxZ9b7nli11Yx9HElEOY4BJ5B8VHrTvfve7WZ2kiXlQP7DtAwcO+LXXXst4RruHHnooOh9No4LLURpgTrA9Nzxmc+bMiY2hqW/p27evly1bFq2zwkNnqou
                              8z23hcU21/dzcXO/evTvtfYdGBJhmLVtiUvl654iR5Pnz54f5ZybyPJBu5H9kpkHbvvhIPMdzjvIY9UtJP2rVqtVp9957bzZDBhQEwVuJCaKmt2zZ8pzevXurZ8+eWrt2rZYvX67ly5dr2bJlKisrU5cuXdSpUyddeOGFysvLi84LUyXpliAI
                              Jh4LXwhBEOyzfY2kV3Jyci7v2bOnZs+erXXr1umNN97QW2+9pU2bNmn16tXq2LGjOnfurLy8PF1wwQU677zzwnlKpE/6qwwOgqC+npHPSnqkVatWJ95+++2xcTrDhg1T69atpU86HD59NJQtCIJy2/MlXZFqjhhJOuecc8KHcyJ/h59xxhnq3
                              r17bPxRv379wl//PpRURJOlnhZMBgak2cbgDLdR37y2J9n+70b8V4H5tr/WxPJ/oSn73pgWTAbaZXjchodTDWThI9s3Zbi/EzPY3qtp8rdrzH8VaM6y2S7IcFvdEulbhr+qNWAc0aTxQWZABtsY3NQTNPET6Y8T/+tmfeIDFv3/QB8k/i/SSN
                              uXHMbyf6G5g0sWQaZdI/b95sQN9/WJOVNqIsvHttfZnmz7R6n+f1ATgsyrGeRvl01w+TTKlkGQ6XZI+oaCDMEFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                              AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+BT8LxYX
                              QIbMNNnyAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $ImageHT_NoPreview
  #==============================================================================================================================================================================================
  #  Image: Arrow - Small Up
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ArrowSmallUp = @{}
  $ImageHT_ArrowSmallUp.Name = 'Image_ArrowSmallUp'
  $ImageHT_ArrowSmallUp.Type = 'Bitmap'
  $ImageHT_ArrowSmallUp.Threshold  = 144
  $ImageHT_ArrowSmallUp.Dimensions = New-Object Drawing.Size(20, 20)
  $ImageHT_ArrowSmallUp.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAALhJREFUOMvt0zFKg0EQhuHHNEkZ0gq5gBCLz1owt8gt9AziCSzsDcklLO2EKSJ4AcED2NkoNilEkriJ7f91
                                szu87LvM0GVTksySzFp6jxpgY6zwhUlVve3q7/0B62GOIUa4X58dBsQlzn/UU1wdpJxkgif0f1194KyqXppfmGSA5QYYDLBI0t9H+RonO8xOcdOknGSKh4b//cRFVT1uBSYZ4RnHjSP6uh6l923Kt3vAYIy7bvW7/DPfq0QjUZfkscYAAAAAS
                                UVORK5CYII='
  $ImageHT_ArrowSmallUp.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAARxJREFUWMPtlDFOAzEQRd86TSiRUm2DlAsg8dNwACTgGrkGQpwBcQREBxVlSkqmSA6QgmYbJEoqBE2KCAXW
                                O5hNinmlZc182+MHQRAEQTEkTSVNS9asCoYT8AR8AsdmNt+ZgJJGwDNwsFpaAhMze/tr7VQg3AC4WwsHMAZuJaWtBwQugJMN6+fA5VafWNIZ8PjLQT+AUzOb9R5Q0ng1d/stW18BmdlLb08saQ94yAgHMALuJQ37nMFr4LDD/glw42k08MgYu
                                HL0Oqrretk0zeLfZnBNxkPnzb93lXjVIdx3GXvpJPGUGW6TjL10knjuJ/lJxl6yJV5l3F6bjL1kSbwqJGMvrRJPhWTspVXiqaCMvbglHgRBEARBsPt8AdiVSaNPgVN7AAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $ImageHT_ArrowSmallUp
  #==============================================================================================================================================================================================
  #  Image: Arrow - Small Left
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ArrowSmallLeft = @{}
  $ImageHT_ArrowSmallLeft.Name = 'Image_ArrowSmallLeft'
  $ImageHT_ArrowSmallLeft.Type = 'Bitmap'
  $ImageHT_ArrowSmallLeft.Threshold  = 144
  $ImageHT_ArrowSmallLeft.Dimensions = New-Object Drawing.Size(20, 20)
  $ImageHT_ArrowSmallLeft.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAALtJREFUOMvt0rFtwlAUheEPY4l0DMAISKR4aVPEW7BFoqwAHVMgBbZIkf42HiFb0CAap7Gw9WxIE+W0777/
                                  Hp17+HNKKc1TSoeu92Ig7Bk11l0zZSZohi1eMe2bLTNgS3zgMWd52QMq8IYNHnJjKTtgC+xRDT1acQW2boKvxrSguMf1ez9GxLE5wNfdHEbEN17wjtMQ4CSjNiscsGwtnYzKKiJqPGGH880OW26rpk6L0Q5bbj/xE8G/fkkXFvAmVk1Kks0AA
                                  AAASUVORK5CYII='
  $ImageHT_ArrowSmallLeft.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAR9JREFUWMPtmCFuAkEUhj+WFWu5AIILIH5Mk8oauAOKaxDSQyDBtRJsRSWi6oleoEk9ZyAYMASSsvvedtLO
                                  72fm2/dmvt1ZyMn5J5FUSVrdO65oCa4P7IBZcoCSngADRnXGl4FgBbAA5kC37jxlEFwPeAEmTecqA+CGwBYYeMxXOMNNgQ8vOLcKSqqAZZ1TGg54Usim7ikNbXFThYRV0EshIYCeCnEH9FaI6x6UNPNWSMQh6bT9FfRjQDNbA4/Ad7IVNLOzU
                                  t5TbTFmtgfGwDNwiAZstKckjYFXoHfHA3ZCK3ix2Nup5Z/JtPgK5BfwAKySa/ENVy6BKokWt6Ei90uTt4pCbnWeKgp/dV2q6Ff3YISKWvmzEK2inJycnL+cI8w7T25sIcgoAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $ImageHT_ArrowSmallLeft
  #==============================================================================================================================================================================================
  #  Image: Arrow - Small Down
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ArrowSmallDown = @{}
  $ImageHT_ArrowSmallDown.Name = 'Image_ArrowSmallDown'
  $ImageHT_ArrowSmallDown.Type = 'Bitmap'
  $ImageHT_ArrowSmallDown.Threshold  = 144
  $ImageHT_ArrowSmallDown.Dimensions = New-Object Drawing.Size(20, 20)
  $ImageHT_ArrowSmallDown.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAN1JREFUOMvtlD9KQ0EQxn95r0mVA4xHsEjxwCIH8A5iSG9hnSLkCGJqD/BqG1uLgF2+wkAuEJEpBEHSJEXE
                                  xsC6uO9Pp5Dpvm9mfsvuDAvH+HPRCUVRFCVw0ZJRSro8iCxKXgHrFrBX4Do0fgAlfQBDYN8A9gmMJL2HZh5XufvazHrAoAZ4I+kuNrNE8QR4roCtgGntUKIBnQILoBuldsCZpOVvfXkK6O5vZrYFzqPUWNJ9qi+readb4DHQc2DWeA8TVz8Bl
                                  t+H9yVVrlVeB3T3jZm9AA+Sno5/wT+MLwY4OoCFZmh1AAAAAElFTkSuQmCC'
  $ImageHT_ArrowSmallDown.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAATVJREFUWMPtlz1KA0EYhh83JxCsBkzhBQTX0sIzaCUpRWyCd4h4jL2GaTyAjW8RDxAwzUQQUmqj2Ewlye5M
                                  ZieFfG87P/vw8s0DCxaLxWKx5GRv00Jd1w1wvSOORtLNuoWq5dAYeNkB3Ay4S24wtDgEBBwUglsBp5Lmmza0NYikBXAFfBeA+wFGbXAAg65bvPdz51wFnPcMOJHUdG2qIi+7B6Y9wj0BD1mveM087odHc5QJ9xbm7iNmc2yDSFoBF8BnBtwXc
                                  BkLlwQYIGfAbQbgWJJSDgxSv+C9f3XOHQInW8h4kvq9atsmEiXeKuNeHkmGxDtlXKLBWIlHybjXGUyUeJSMizQYIfFoGReZwQ6JJ8m4OGCAPAaew51nqb4rMoN/5vHdObcEppIe7V/AYrFYLJb/kV/uV26RU88lYgAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_ArrowSmallDown
  #==============================================================================================================================================================================================
  #  Image: Arrow - Small Right
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ArrowSmallRight = @{}
  $ImageHT_ArrowSmallRight.Name = 'Image_ArrowSmallRight'
  $ImageHT_ArrowSmallRight.Type = 'Bitmap'
  $ImageHT_ArrowSmallRight.Threshold  = 144
  $ImageHT_ArrowSmallRight.Dimensions = New-Object Drawing.Size(20, 20)
  $ImageHT_ArrowSmallRight.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAKxJREFUOMvtkzsKwlAQRQ9R0M4FCG5A0OLaWphdRNBNZBtZRzYhKNgJThPIBoQswkZsXjp/z0wjeNphDhfu
                                   DPwskkpJo9i95MUsAypJSy8hwAQ4SCokDTyEAD0gB06Sph7CljlwlpRLSjyEAEOgAHaSxh7CljQUlnkJn+72v5QdgY2ZXbomvIbGV49ksQlrYG1mVdezuYVmF+9knyRsgK2Z7T1erwRmMbI/PtwB2uoqeZcswkcAAAAASUVORK5CYII='
  $ImageHT_ArrowSmallRight.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAQ5JREFUWMPtlaFOA0EURU+2K0A2qW/CDyAutrICUdOqakj4DOh3lCp+gRRT2aRmn+gPVFSTIFEEDNVkd+YN
                                   02SO3jd7Mm9zFgqFM0PSUtJlqvdVHWbugZ2kq1wFAa6BRtJtroIAfeBV0qOkXo6Cp/kn4E3SIEfBE+PflStXQYAhsJV0l6sgwAXwHDNFldO3HS1FlWMhoqTIUzBKirwFg1OUQjAoRSkFO6UotSDAd5uH68RyB2BqZvscb3AN3LSRSyX4BSyAi
                                   Zl9tB32XvE7MDezTdcDPAUbYGZmxxz/JCtgFCrncYOfwIOZvcQ6sP7PhKRccaeEpBAMSoj3ioMT4ikYJSFeK46WkEKhUCj8zQ/mGFb0dyvr5wAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_ArrowSmallRight
  #==============================================================================================================================================================================================
  #  Image: Arrow - Texture List - Up
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ArrowTexListUp = @{}
  $ImageHT_ArrowTexListUp.Name = 'Image_ArrowTexListUp'
  $ImageHT_ArrowTexListUp.Type = 'Bitmap'
  $ImageHT_ArrowTexListUp.Threshold  = 144
  $ImageHT_ArrowTexListUp.Dimensions = New-Object Drawing.Size(24, 24)
  $ImageHT_ArrowTexListUp.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAWklEQVRIx+2TsRWAMAgFczP9/Udgptj6fImCwdhwHQV3NLRWFFuR1CX1yA4R+Xk2M9ICs6s9Ed7KvRFW5J4Iq/KnCBnyuwhZ8lmETPkoQrb8GuELefQZi+JnDiFvKzvC6EMa
                                  AAAAAElFTkSuQmCC'
  $ImageHT_ArrowTexListUp.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAArElEQVRo3u2XsQ0CMRAET5qIFtzGpfQGIUV9P27jIyQS4P3vs8/STgM7E66ZEEIIIYQIwd2f7v6K3CBS3sweZnYvpdxqrdsyAR/yb8IiGCAfGsEg+bAIBsqHRDBYvnsEE+S7
                                  RjBJvlsEE+W7RDBZ/nIECeQvRZBE/nQEieRPRZBMvjmChPJNESSVPxxBYvlDESSX/xvBAvI/I1hE/msEC8mH31MhhBBCCCHa2AE3XXhGtPmSoQAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_ArrowTexListUp
  #==============================================================================================================================================================================================
  #  Image: Arrow - Texture List - Down
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_ArrowTexListDown = @{}
  $ImageHT_ArrowTexListDown.Name = 'Image_ArrowTexListDown'
  $ImageHT_ArrowTexListDown.Type = 'Bitmap'
  $ImageHT_ArrowTexListDown.Threshold  = 144
  $ImageHT_ArrowTexListDown.Dimensions = New-Object Drawing.Size(24, 24)
  $ImageHT_ArrowTexListDown.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAZ0lEQVRIx+3TsQ3AIAxEUXum23+Em4lURFFijElMEcnX0fwnF4jUajUVEQHQdsRJqvZHNkJSzwuykR5/ABnINW4CX5B7fAi8Qay4C6wgo/gUiCBePAR4yCweBiwkEl8egLbr
                                    19d+vAN1oys7tIdQKQAAAABJRU5ErkJggg=='
  $ImageHT_ArrowTexListDown.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAA1ElEQVRo3u3Puw3DMAyE4TOyhdbQCtkpbdx5rRQpNYdWSJnKQAxb1ou0JOSuIlj9H8BxHMdxHMdx3L9uWg9r7QPAMkj30zk3A8Bt/Xjv38aYD4D7KPEbwCCITfwO0DliF38I
                                    6BRxGB8EdIYIxp8COkGcxkcBjRHR+CRAI0RSfDLgYkRyfBbgIkRWfDZAGZEdXwRQQhTFFwOEEcXxVQAhRFV8NaASUR0vAihEiMSLATIRYvGigESEaLw4IIIQj1cBBBAq8WqAH8QE4KUVz3Ecx3Fc630B/xy1IzDbSngAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_ArrowTexListDown
  #==============================================================================================================================================================================================
  #  Image: Option Link Bar - "L" Shape (Enabled)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_OptionLinkOn = @{}
  $ImageHT_OptionLinkOn.Name = 'Image_OptionLinkOn'
  $ImageHT_OptionLinkOn.Type = 'Bitmap'
  $ImageHT_OptionLinkOn.Threshold  = 168
  $ImageHT_OptionLinkOn.Dimensions = New-Object Drawing.Size(10, 10)
  $ImageHT_OptionLinkOn.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAG0lEQVQY02NgYGD4z0AEYGIgEowqxAsYiQ1wAMkvAhD8kdX1AAAAAElFTkSuQmCC'
  $ImageHT_OptionLinkOn.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAKElEQVQ4y2NgYGD4D8VUAUwMVAajBo4aOGrgqIGjBkIAIzVLa5q4EACrdwMjbUk8sgAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_OptionLinkOn
  #==============================================================================================================================================================================================
  #  Image: Option Link Bar - "L" Shape (Disabled)
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_OptionLinkOff = @{}
  $ImageHT_OptionLinkOff.Name = 'Image_OptionLinkOff'
  $ImageHT_OptionLinkOff.Type = 'Bitmap'
  $ImageHT_OptionLinkOff.Threshold  = 168
  $ImageHT_OptionLinkOff.Dimensions = New-Object Drawing.Size(10, 10)
  $ImageHT_OptionLinkOff.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAHElEQVQY02NYsGDBfwYiABMDkWBUIV7ASGyAAwAPiwXQeyyf4wAAAABJRU5ErkJggg=='
  $ImageHT_OptionLinkOff.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAALElEQVQ4y2NYsGDB/wULFvxnoBJgYqAyGDVw1MBRA0cNHDUQAhipWVrTxIUAhO4IwzQ8JbwAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $ImageHT_OptionLinkOff
  #==============================================================================================================================================================================================
  #  Image: Weblink "Earth" Icon
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $ImageHT_WebLinkIcon = @{}
  $ImageHT_WebLinkIcon.Name = 'Image_WebLinkIcon'
  $ImageHT_WebLinkIcon.Type = 'Bitmap'
  $ImageHT_WebLinkIcon.Threshold  = 168
  $ImageHT_WebLinkIcon.Dimensions = New-Object Drawing.Size(14, 14)
  $ImageHT_WebLinkIcon.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAB6UlEQVQoz22R20tTcQDHP2eeraMbbidZ2kzdzDIshytasEGzMKKiCxHRk1EUXXwq6qWHIvoXhIIofEwDfajQ6Eol3ZxuyViuHF2mOZ3uyJyubfrrQQyMPs+fL9+Hj8Q/HDt1
                               UaiqisVk5GbHB7TQPYn/sampWQx/+Sq+/4iJkbGkiHxLiISWE/2hEeE9fk0seToAxdEoLrWcxWA18lstJDiqJz43Tt6c5f2nGFfPn6DCd1oAyADWlTbWV82TzfTiWCWRWncYo2mKG3eMFElrGOwOkUyXLj6s3rBLuFwuTPFeZgwgZyScxllq8
                               14Ouis5tNfGZN7CbEqm5cp1IY8lc4z+SpCsPMfGcAfvnJdp908Qm9GhRQTDH3NMRJKIhWluPxDoCnQZ+sLj+Pa3oW1JMRCG1ls5FkIRAtE4SsFPDBaV8pp6ihDI+bkMOjmFXJynrrGCbPYV834H1jNmzDqFk/vsdPWEEZNpAiKNjBaQTKV2UW
                               4vxu1tYOt2N9VHHnNhz26ajwZ5FG1ls0dC1QZ42/5QkgEyUzE+h/zoCxVePHmKZ5sT384AzwaHuNv5nBqbma77iyn+VqxqOCBq63woahnVVoFasgJFThDVB3nZFmLozWtp2WCJkrVNot6zg+mURFmmk+6evmXOH46nwWl79VTcAAAAAElFTkS
                               uQmCC'
  $ImageHT_WebLinkIcon.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGRklEQVRIx42WSWzcZxnGf//v+6+zeMbj8cSOt2arE6m0TqIqIlYhh96DhFKpJ8Qt0FQ+IA6gHDj0gMQFS4RNIHGpVIjEBVSVXggSRoVEJCpN4gxJvSTxeDz78t+XjwMSCrQU
                               3tv7Hn7P4ZWe59H4jNFOvrFyYjq5OjMlL5SKdrlSyslS3qHTGaVvv7/dJ/VuaMWFt9TmtTv/lfFpx1Or31g9szy9NjOdu1SYANMU2I6DYVroUifwY9qtPp6XkCiTziC8fvvhwfrm77+78Z8s/ROKi6+vn1k2Lr/+pTPm3Nwh0DQ0ITAsGzRJG
                               CtAYOoGoHD9mJ2njUvZ+xsXHzS+9mO1+aO1Z3ny2cV86evXThzJXXnl7Al5euV5Ds/NUJgskZsoY9oldDOPNHQKEwVm5qrkJwpEUcrIDYjTRE5OynNJYaXW3dp49xMC2uKl9c8fd668+oXzvPC5Uyw8V8Mp5YgMnVEiOegJOoMYLxoizYj8pE
                               mYhTx81KTTDZifP8zSXBV32Hz5XnOxwuDOewACQFu+vKqG+5dLRYPF+Qqzh8uYdgJyiGH0kYZHIDRcqZE4Hp4YsD8cs9sK2D5IaI8kUi+gCwuURMXpZW35yuozPxBrqJxZLFhUJwXFnEeWHqDFIRNmhp2bwZuawMSkkA/xxh4ffGSzs2vjjou
                               IOMB90GHYbbLfAuyyCWIN2NDFqSsrKo4vkZ+llHeYEGMsNFLGpPhYKsSSFrV8QiBt8rJA15T4rkHfNTlUNSDWaWwP2N3xaXQEesFhuZpdMhe/uaI7SeeqM2GQf36RspPHGW0jx3nCUoVQt1BpjEHCjBGAlkMyT15mvDgnma1IylXJaKzjDocM
                               6gX2XIOjecmLyyYKdVVX8eiCUHksKRBmDs200TAxgwjNcPDtORKmCVJFphJkZjN0IcpACYhjCHyJ62l0xwrXS9HyMVmqIaR2Qfc8v+xlGgdaG/fMPN6hs1DUKHduIzyDzvxJulqV7V5Iy/VJYw3P1Wm3M9yeQo01Rm2frY9d9htjiMY0kzH3H
                               toYpizrRJ4kkZAOafYCdtqKgplRkkOEYdGNJ6m7OW5sxfyu42PrGTKSZG2N1r6i8yiDJ2OIEogEVt5hEDn0d1NIUilFae47yjDAyNHrCj6uu5RLeyyd3kXOzvDUXWZz2+KdP4bsfOhx3BgyE3sMuwm7/Qj8EeCCTMmZGnkHHEuAilBE6EIaqS
                               CRipi9Wx32CFhc0Dl1LqWQZTzYGjDY0/lqJca3FDtuxKO24l5PIFKDC7MGxrTGk6ag1Y+xVQ6EieaBHqepniq7T+xOQQjlBPqCD+/l+OXbDplM+NXdh3zriwO+8toECJ2f/dbhnQ0FkcXhY3lWjhYxRYau2ri+j5OkpFGAR0ig0r6ujNINlPZ
                               lKTLsWkbuqE59VKT+6ykQVZi0MI0MDRelLPQ0T6UquHg0YXE+ZOqwIIgjqoMBx9IehaRLOByg/Jj2QNzQtJNvrGhpcNvIuuRyRQrlBaZqi1QPLbBwZIml40vk9ZSkWcftarTDZY4tWZw/e4BV2mfL3WO70+XJ4wS/3Wci2SHsD7h5q8if/26c
                               Fmrz2h2M3HVUhkp9ksRHipick5FzUhwrZOB7fPsPI773J5fp6YQTx2Mq0y6208APPqA//g1K/AXD2iRNt0jjDmnCdbX5/Tv/9KIsXVdRcNELR+bYF+i6jtAlY3fAdv0ucSp5AZ1Xzk+ystJksqbxZLBPs9Pi5t0GD1uPqEwEKM+kU0/p7drRb
                               ktb/5ddq/bNx1TPTatweC4NQyxTx7IsxuOAj+oNkrHLkVqO48+ZzM8laHJEs9Nl52mbB9tPeNxqYUQZ3iDh/qbF/c3qtfHmT376b3mgen97T59/tVa2/ZcrRZup0iTlYpHZ2hRzh8rMliWOkRIHMaOej9/1iAIPrBBDSLo7CY0HGo2DxR/G9Z
                               +/+amJlnX++q41s1opWOJ0zi5IwzARusA2MhwzJk1ier2QQWdM2O8SBAN8keD70Kir6P7dyrWo/os3/2fol15aW81b9pop00syG1AqWdRmZzCtPGEskMmQQraF0kY00xr7Y/N6qxGv9279YOP/ahXP1hY12rtaqxgX5o8eKVu5suy5GprbTYt
                               hvR/76Y26u/iW+xm15R9GkAsQoFJPWgAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $ImageHT_WebLinkIcon
  #==============================================================================================================================================================================================
  #  Help Dialog: Closed Book
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $HelpHT_BookClosed = @{}
  $HelpHT_BookClosed.Name = 'Help_BookClosed'
  $HelpHT_BookClosed.Type = 'Bitmap'
  $HelpHT_BookClosed.Threshold  = 168
  $HelpHT_BookClosed.Dimensions = New-Object Drawing.Size(16, 16)
  $HelpHT_BookClosed.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAl0lEQVQ4y52TWw7FIAgFRzdWlnaWRldGP+610T6kLYaQoGdCBGBu8fdbKxMhQnSxPAEMwt7uICUTZpACRCacQSqAub0FxABw88+Q2pJfIbVPvoG0f6vHiwyidiQiggqUYxeu
                             IEfh1SCd2mlumP1AkjAzlmVhXdc9fxphod2BkBQREe6+x2xHBkAvfrJcA6RVMBOWZJXTdxuuL3Thfek08QAAAABJRU5ErkJggg=='
  $HelpHT_BookClosed.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAABJlJREFUWMO912FInecVwPGfvtd4bTBrw40SMohJcSnVtLrclLAEnFq7WxHBmH5JvghtFxgyspaG0nyYgTLY
                             QkuZ+1ADA8u+dGNbjVJSZoVsmKV2SiULUo2LG2EaLkLCRtZ7o9d3H3KvM4lSFd2BF15ezvuc/znPOc95DuuTPLyEcYzhm/6P8jz+gnDJ8zfs3WzDcfTnjD7t6fBlL4dHHMlBTKNyPaH8OvkW3g4EL2VklClTo8Zuu+XLl5Hxmc/064fbaMKfN
                             wJgB17Hj7ClVKk6dZ70pIjIA4qh0LBhH/sY7uIo/rBegGL8AGdQvNVWCQn77LPFlhUXCoWuuuojH8E9nMBv1wKwBW14GzsCgRe9qEKFIkWr3tMvfelDH0IGJ/HLrwPIRyt+hrL7af68Zz2rWPG6snXKlA98IJucb+CdlXSDRCJxd3Jy8jgeP+
                             ywo47aZ59Chesulyc8Ya+9vvAFfC/r6KWVIhDC+53vu/3r29KD6Q2r2xkzunTNI4Kf41TOXk7ycy9P7X9K9elq0e9GNwxgp53atUeQwg/xKxQsC/DVna9Et0VVvVa1oRAxMaeciuLf2cr4Hf/L6gAdUHmzUuxATNE3isS+HTM7M2v+7/MbAhE
                             VdcCBwiuuzKIaR/B7pBcjkL6cNnpudNMiUazYaadj+CdqMIBY/lKlzYZ4zGPe9OYuzGR7y6X8h5U2E2LOnHHjgiDYCZWVlbsjyymmL6eNGlX1RpWix4tUvVZl1KjUpdS6jScl9et33XXbtm5z7NgxbW1tLZGVftgoiJSUESO5bqm2ttbx48c1
                             Nzf/pLS09NPFg+iMMwoeLFFQeLhwESL1r5TRd1cHsWDBlCkXXTRrVnl5uaamJidOnFBRUSEajW7Ny8v7T4BjKElLK1MmEDywUOZmxuzN2TWV6B13DBjwiU+kg7SWlhYnT57U1tamvLxcJBKRTCbz4vH4n/KyfX8A++PiXvDCsm13NZGYN2/Ch
                             B497rmnurpaIpHQ2tqa8/p+PiSTent7F6anpzO5dlyShah8znMaNKx5O2bMGDBg0qRYLKaxsVEikVBfX6+kpOR+PqRShoeH9fT0GBwcND8/P730PrAuiCs/vWLw8qABA6C+vl5NTY3GxsZHvO7v73fhwgU9PT3m5uZs3759JG+Za9iqtuOZ15
                             8xeXPSe+++Z+ofU/bs2aOhoUFdXZ3a2tpFr2FiYkJ3d7e+vj7Xrl0TBMF8JpN5Bz9e7kq2qkhcjF00NDskEolobm528OBBDQ0ND3idSqUMDg7q7OzU29ub+3UIr+CabJ9+9MygHgOf+7wSy0IMzQ6B9vZ2hw4desTrZDKpu7tbV1eXGzduCIL
                             gbiaTOYNfZK9rVgLIQdRlIfYvWFhxO1pbW8Xj8UWvYWRkxNmzZ/X19eU+/TGTybyK62s9QXfgKsK4ePiWt8IOHWGHjsWpaKncunUrPHfuXLhr164FhAUFBXfw/VXOH2uDeBhgbGwsbGpqWjqu/SabTxsij0DkDI2Pj4fnz58PY7FYiDAajc6g
                             ZTNmwxL89aGhdPGJRCIL6MwONpsmK0GM4TvrWfC/d0D6q8Sq4dIAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $HelpHT_BookClosed
  #==============================================================================================================================================================================================
  #  Help Dialog: Open Book
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $HelpHT_BookOpen = @{}
  $HelpHT_BookOpen.Name = 'Help_BookOpen'
  $HelpHT_BookOpen.Type = 'Bitmap'
  $HelpHT_BookOpen.Threshold  = 168
  $HelpHT_BookOpen.Dimensions = New-Object Drawing.Size(16, 16)
  $HelpHT_BookOpen.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QQbFyQgsLtgQgAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAA
                           uUlEQVQ4y82TXQ7EIAiEh6b3gpsJN+Nmsy9Lq/Zv+7aTkGiETzAjSIIk3J21fhMLAEQEzQwRQbzUKiJ0OJSKgrXWZE7s4f352iepKjITEYHW2lxUoLGD+SYzQ2ayIKMEgENECAAk5QBQ1YJMhfxGgCRCAiLC5f6JalRO+10PAF6Afgb8Xwe4B
                           oTETQebmWBmow9ISrkxJNDYcOLCzSOqejRSDyll5uaFs8JtSHJvc4Y8yeEjoCBvfuMHBy2OPOGWrXsAAAAASUVORK5CYII='
  $HelpHT_BookOpen.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAA3NJREFUWMPFl19IW1ccxz+5TSLBOKaFxEV6E/FPUNdIJ1EoGT12zBb2x7DMhz0M8rAxWnzoS7uHPnhCtwd9
                           2MNglD6VwWTqQ/846VOEa6E4HxRG14oGAiJ5kG1MWdqEdLn2wSREq7lJNfUXQu7ld3J+n9/vfH/nnmsiZ1LKt4DvgSEgAdyQUt6jymbKBXcDM8C7Rb4sEJZS/lJNgBNSyreBOaCzubmZcDiMy+VieXlZAS4KIe5pmvbX6waQUlqEEF9qmvbHv
                           gCpVCqRSCROeVUvqlXF974Pp9MJwNramgUICCFua5qWrTCwTQjxDTABhDVNi+w3zrywsNAAIP4WxE7F4PKOIxAIEI/HWV9f7wa+A66WGdgNfA18BTiNxiuFqz8BvYjMbCYYDKIoCsAVKWVXiaCKlPIjKeVvQBy4DjhbW1sNgc3FN9v69i5nQ0
                           MD/f39zM7OmoEfgQ+KgpqBAPAx8DngBrBarfj9fnw+Hw6Hg0gkUgFAdvuVAb29vSwuLrK5uXleSnkZeAZcBC4A9flxTU1N9PX10d7eTk1NTdlaKVmBfEYDAwNMTU0B/FTsc7vddHZ24vF4cDgce/65s2I3b/7DxsYGwN7JHwPXdwFwgM69Xi9
                           LS0tks1mGh4dRVRVVVbHb7YfZAk4DtwwrAKAoCtPT0wDMzMwcMF9eo092/V66tKOBkZERACKmnXuJBHhHMdJAte0QAF1FWeczflLCXwYAWY65Av9XUgGjjPf6jxzg2CtQBQ0cfwUyx6wBMm++C3bvhKlKNfDqzne4Jfhvm/Tz9JFlt7q6ClDy
                           6VgAeMELAEZrR8uEKL3G8XicyclJAEKhUEmAxwAaGtncVjhaO0rqWeq1M19ZWWF8fBxd1wkGg7S1tZUEOAf8/ohHzDFXgBizj1UMkU6niUajTExMoOs6g4ODdHd3G4rwX+BD4P5DHp63YuUsZ1FQGLOPcS15DVut7cAJMpkMW1tbxGIx5ufnS
                           SaT2Gw2QqEQLS0tZXdBEvgEuBMlesGKFT9+TJgKEHkzOuP19PQghCj7sFLchs+BT4FfH/DgMwsWznCmsBwHWV1dHY2NjXg8Hjo6Oqivr6/81WyPWYCfgS+GGKIr1+8aGgACcSQtmjsRcWIfnw7cBZqe8vQ9Fy5OchJP7nNUlk/IqDo/5E6z1f
                           wa2rfVBHgJEWpXVSqR7aIAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $HelpHT_BookOpen
  #==============================================================================================================================================================================================
  #  Help Dialog: Single Page
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $HelpHT_SinglePage = @{}
  $HelpHT_SinglePage.Name = 'Help_SinglePage'
  $HelpHT_SinglePage.Type = 'Bitmap'
  $HelpHT_SinglePage.Threshold  = 168
  $HelpHT_SinglePage.Dimensions = New-Object Drawing.Size(16, 16)
  $HelpHT_SinglePage.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QQbFyUyWhkgSwAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAA
                             qUlEQVQ4y52TWw6FIAxEzxj3re6srGzuh4+AFDV3kgmGNOUwRdkGYNu2/eNBy7Ko27SNbdZ19Vg4InzUUHvqz9FhqtUnQU/6jcA+ulx+JJBoXB8UEU110sDYNG6vx1uDnkCiyaLW3AdobKXFmeY7PoDkZNx5gynbtDXI4TUDXQR/ZuAB7jiTN
                             EQpH+2HDAyc99enDBqCUgoQQL3Wiv7VnL+zstk9yPtj4QddPLW+fTBKvAAAAABJRU5ErkJggg=='
  $HelpHT_SinglePage.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAARZJREFUWMPll10OgjAQhGcJZ9D4yBvHIB6Eq7AX07S38ASaeIn1oW0MTfqDUrE6yYbQNP0Zph9A8MTMgnW0
                             Z+Z7qlODcjox8y7ViUIOTNO0cD4zlNYKAKCUAoALgCMz3z7uQNd1ANADODPz4Y0FkFd+u5PYMhrH0bkYXUTJDGQ50aaHkEXtwzCEBuoBXP3cFXcgpTY33URxPIi467yf1jrqzOYONHkZEIggWuHTsx0J13LA7IQIWRXiwtc60KZfE2LTTQkuF
                             HsEmzkw32mKAz4PqnEgewEiZCuXB/VzYL4DIrH1PxyQhel+jRP1kJCSgZaf44BLsTkNz7Me50F1HAhmwH3LAcq1BO5DUnVkgBb8CBSZc3MHHr+Bhj3OI32FAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $HelpHT_SinglePage
  #==============================================================================================================================================================================================
  #  Help Dialog: Page Stack Closed
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $HelpHT_StackClosed = @{}
  $HelpHT_StackClosed.Name = 'Help_StackClosed'
  $HelpHT_StackClosed.Type = 'Bitmap'
  $HelpHT_StackClosed.Threshold  = 168
  $HelpHT_StackClosed.Dimensions = New-Object Drawing.Size(16, 16)
  $HelpHT_StackClosed.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAL5JREFUOMuFU8ENxCAMc04MVqmDFQY7KUzme0A5SBMaCQHCOLZbBAByzsRL5Zxld8i4QFVl1CTNm1KKRw9A
                              RyOrJFn4dV2BTkGt+iD5ROA2MM0cDWY7ySeguz6Ow4IkVPCVdQAASZCEqnoZSA+skZ/hh5URqiEggDIpeF49yY6r2GQgXYGYLPxyLLRLTYE4CkKC2YIHlr2CWuti4U5+VRBbIQD+3wTM/Hwbt9dkf7emRHvSuiTeSrfG3mM3wfwAaGiV8YSHB
                              i8AAAAASUVORK5CYII='
  $HelpHT_StackClosed.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAU5JREFUWMPVlk1ugzAQhWcQEjdole7YZcUZkHIIrsKOx71CBFfgEKnUJRdwF2AZu7GxI0LjkSyEf/HnN88w
                              LQFA0D7xCeDHt3NC+0cH4MO3M5sEmqYJXG+eouuuNI4jTdMkG74AfB9GIE1TKopiXXUDcNocZ2to29ZzaSzP3mw4E9EdgJPEKzRghpNEujV6B004SbyMgK8mkrCdrYtZL0MsZf6Iuq4pz/O1Jk6HaiDLMqqqykoi9Z9KBNWXZWmb6ExEd4nti
                              CzQzzxJwrLgj7rZ3esiZiJC6GSGYXhI5nACHj7AhsPpZ30JvjPZ5pRvS0BusX1KA6YW1HxDNARsZyg1wBu+EJiWEWSBvlOlAfbUQHwEbFnguzOOXAPSs21Z0DF7+kBsBADd+9W70EgoDfj6QUR3AT9KB6WJ3vD03unxKvr31gA/8RO469r/Tu
                              AXOnF1E5fa6wcAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $HelpHT_StackClosed
  #==============================================================================================================================================================================================
  #  Help Dialog: Page Stack Open
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $HelpHT_StackOpen = @{}
  $HelpHT_StackOpen.Name = 'Help_StackOpen'
  $HelpHT_StackOpen.Type = 'Bitmap'
  $HelpHT_StackOpen.Threshold  = 168
  $HelpHT_StackOpen.Dimensions = New-Object Drawing.Size(16, 16)
  $HelpHT_StackOpen.LDPI = 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAKxJREFUOMuVk1kOxCAMQ+1RD1apB4OLVUpP5vlgKTBsYykC1JC+GCAAeO+Fhbz3nH3UWJCZafSTT71kDBRj
                            2Oec65Ie9VLd+XmebRKHBDfrAABJkAQzQ+vZD8E1tJMAcoFMsiRIFGVLiaQhYCRg48VcR2vazfIEgi5pp8AombsEAf3tuSy63QIjQc+H9xS6BZ7niQnlWMqmreifMLM0zwRMN6y5tksR48ewtf8Lz6d2O5D+4iEAAAAASUVORK5CYII='
  $HelpHT_StackOpen.HDPI = 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAATBJREFUWMPdlkGOhCAQRasmJN5gJj07d7PyDCZ9CK/izn+wsYNX8BDTSS+9ALNQohAQTNu2+hMXFqSAl18F
                            TIMAKFpHXwAesZM/aH3VAD5jJ7NNoKqqhev1Ker6l9q2pa7r9MA3gPtmBIQQlGXZNHQDcHliA2x9dlxLDV+/ibIsKU1TIqIfIvoLbWJ1DyRJQkVRRJMQ/lRqUTzPc18iTcLpiVdUgU9OEiLobp7PelU9EaVMMk3T2GScJLYk4CQR9MB1cX/Uy
                            KQRBWCQ0BPfQWBdD9heGKukMcallM5q2SMBtjzAgb7wnPZIwDzp6AGO9MDxCSw9GZ/OA6bra+bIPnC+KmDLA7H9wH0XHIeAvsfHE/j+fZIH9cDkvt5Uu/IAWy8YFXjtnoPAXJtTW6z9dgL/JHZnr6MVFZ4AAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $HelpHT_StackOpen
  #==============================================================================================================================================================================================
  #  Metroid Prime II - No Preview Image A
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidNoPreviewAHT = @{}
  $MetroidNoPreviewAHT.Name = 'MetroidPreview97'
  $MetroidNoPreviewAHT.Type = 'Bitmap'
  $MetroidNoPreviewAHT.Threshold  = 96
  $MetroidNoPreviewAHT.Dimensions = New-Object Drawing.Size(128, 160)
  $MetroidNoPreviewAHT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAIAAAACgCAYAAADEkmT9AAAbMUlEQVR42u2deVRUV57Hv6/YNzdUDO64YFAwaoi2K9puUenoGG1HO3aM6UlmJiYxnmnjZOwk5mg6wTEq6WxGTRtbPRoixhAkoElAR1oQFUUFBBEBRdmroKqoeu87f9StsiCC
                               S+KC3s857yiv3n3v1bu/97u/+1tuARKJRCKRSCQSiUQikUgkEolEIpFIJBKJRCKRSCQSiUQikUgkEolEIpFIJBKJRCKRSCQSiUQikUgkEolEIpFIJBKJRCKRSCQSiUQiucco99sNkXQH0BmAe3OHic0KwARAD6BOURRNdumt4Xqfdb4CoCuAv
                               wHocQMBMAOoBJAD4EcAh0kWK4pikd3aQjWAEIB+mqbtcXFx6XO9Y/z8/NCvXz8MGDAAw4YN08aNG2fq3bt3MYDvAXwG4IwUghYKSYVkiKqqOU5q/obbxo0bNYvFconkepI9SOrk02yBQ8DtsnDhQsXFxSXgj3/845MA0gEkkPQB4OY0ZGhC4y
                               lO9oNeDCW+ALwAuDhpRQJQARgBVAMwKYqiCS3lBqC1aOfqdE6LuI4HALsQWgGUA6i5H22U+3EIeFTTtFjnISA5OVkbNWpUBclqVVVd6urqfM+dO9cmKirKdceOHY722dnZpr59+34L4CsA/yaMSYiOrHXqGA3AZQBJAEoB/AZAfwBthBDY21Q
                               BOAsgHsBBABVCUEIBPAXgCQDtRBsrgDIABgA9AXiK85QB+AjAXkVR9FLn3MYQ8OOPP9aS/F+So0hGkHyN5KHy8nJjeHi447j3339fI3mG5EuXL18utu+fN28er169qr711lsMCwvj/PnzmZiYWEfyO5Jni4qK9Bs2bFDnzZvHvn37MiQkhPPm
                               zePHH3+sFhYWGkhmkHyOZADJSSQTDAZDWUxMjHX+/PkcNGgQFy9ezH/+858WknXR0dGa/dppaWmVJP+dZGvZw7cpAD/88IOB5Osk25N0J9mB5AySJ7dv367ajwsKCmJ9fX0hyaWXL1++ZN8fGRnJP/3pTw3shq+++kolefX06dPWLl26NGlfd
                               OzYkVlZWWaScSR/S3JXeXm5ft68edc9/uuvv+aHH35IJwGoIvkfUgB+uQAsJdnO6biuJD8+duxYrfOxBQUFV0muLC0tLW3OcCwsLNTMZrP65JNPOoQnKyvLarFYyiorK2vXrFnjeItffvllkswnuVzTtPxly5Y1a5ROmjRJCsCdFABxbGuS/5
                               mXl1fufGxWVlYlyTWlpaVXG3fKxYsX681mc2lmZmYFySvp6ekO7bF161aNZAHJTSTTzp8/X2//zM/Pj6qqlpP8Kjc3t8b5vCtXrmRpaWmdyWS6eubMmfpZs2Y1EIb7XQBa8izACqDSzc3N6rzTaDQqTha4g9dee03r0qXLWQBfhoaGVgAIHDJ
                               kyL+SDBJeR6MwCAcB6KkoiuPZ6PV61NfXe3h6enbOysqyG3eIiIjAq6++avD29j4AIL1fv37TVqxYMWjXrl1uchp4d+69tcViafAd3N3d7W9fA4KCgmoBfAdgl7DuAwH4AJgFoFtpaann+fPnH8vPz3dNTU3VRUdHNz6FDoDPxYsXHcIVGRlJ
                               b2/vfAAfAsgGcDU4OLhr3759H8nJyZECcIeni94A+un1ek/nz3x9fVUxt28w5/bx8TECOCWmZQqAxwFMPXXqVNf169e7btiwAWgm/qAoigJAMRgMjqmzv7+/BqAYwHkxrTyhKIohPDwcUgDujM9CIekq3twQAMPz8vIcAtCxY0cEBgaaANSQ1
                               BppBotwyFgB+AOYcPbs2d6hoaEOdT1q1Cg8/fTTDA0NVf39/V0GDhyoOAkAAdDb29uhXcrLy3UAuoh5vwXAYJK+aWlp0hP4q/a87e1rD6CvUO/9Acw0Go39Nm3a5FDJS5YsoYeHh0F4+BoIgE6n02CLHGriTQ+MjY31sH++atUqLFmyxOju7l
                               4KoK60tLSXcBzZ0QDUdevWTbM7i2JjY5UXX3yxh7e3938COA5g6pkzZzq0lLe/xQiATqfzBDAfwHRN02A2m32Ki4vbff755+5xcXGO42bMmGEGkCW8cT8bOYR3z65NXPLz8x0fDh8+XHN3dy8BkAZgaElJSQNDTtO0egDFoaGhIXYXc0pKCqK
                               jo/2ee+65ia1atRp57ty51m+88cYD4V6/r6aBN7Nt2bJFI5lL8nmS/+LsCQTAioqKC8KT6E6yJ8mk9evXO6aBL7zwAktLS81ms7kiMzPT4jyXB8CqqqpSkqtJXnjzzTebvI8uXbowKChI+gHupgA4RQPXkexLclIzAuBGMpDkhqKiIn1YWNh1
                               zxkREcERI0Y4/s7Ly6sh+SXJxMrKSkPj+b59O3ToECMjIx1/p6enV93PruD7UV2xuQ/9/Pzw2GOPITQ0FEOHDlVHjx5t6tGjRzGARAAbAZQA6H6Da1QB+LZz584D4uPjQ2NiYry/+eYbpaSkBKNGjcKkSZPU8ePHm2NjY70OHTqkAEB6erp7U
                               FBQPYCf2rRp02Pz5s09Z86c6RIbG4vs7Gw8+eST+MMf/qA++uijOqvV6jAeXV1deaPvdK8t6/tteheEG2cE2Q26ctiidckAjojOVwCEA1iBa9FAALgIYJkw1lTYIn+jYIvq9RczC0V8VgbgKoBg2KJ/gC2aeAbAYGH1e6BhaNkCoNpqtbYPDg
                               52s9sXubm55b17914KYOf9GA28rzSAoigkeRHAv+PmcgItuJYTaHSK1x8H8CdcyweAOPYSAFVcpwq2cHA6ruUCoFGHejl5FT0BjMrKypoyYMAAx9QzOjpaWbBggauXl5eLXq9337dvn6uzcdmxY0czbPkEqhzkW7Z94ktybkVFxaWOHTvelG0
                               iwtOnSQ4n6SafYssWAHeSI0keS0pKUm/U+TNnzmRZWVkNyS0kuwnNJG2AljxDAdARwPMA5uXl5XX76aefvI4cOaI7ceIEioqK0K9fPzzxxBMcOXKkOnr06CofH5/jAFYDSFYUxfjQCwBJFwB+YnPOm7OPu7VivKwXrtebejNxl+oIxP13Esbj
                               GOGZbCeubTcI64QxmgFbpvJJALU3+30eWAEQPvweACYDiBBTNa9GlncGgL3iX8ONHtotzBquW0cA4JbrCETGsbcQYk9cSwp1nqHUC0GoAWC5Xzv/rgmAeGjdALxGclpaWlrn+Ph4tx9//FEpKSnB8OHDMXnyZG3y5MnVrVu3PgbgPQApN1Kbs
                               o6g5YyfPiRnkczeuHGj1pThFBkZybKysmqSn5MMvAuew4e+juBu+QE8APTOzc0NWLhwYZNaZ+/evdi2bZvfokWLwoSavSPcZh2BRah0vRjz/cQQ5lwXoImhRi+GMFVoKU8AjzTyS2hi6HNptK9OeCpN9/PQcasawJ/km/v27XMkcM6dO5elpa
                               WqxWIxHj9+3KEVhg0bRpInSPa5XQ2QnJyskryqado5i8Vyvrq6+urRo0ctc+bMaaAJsrOzjSR3kfw9yf0kz4oti+QRcR8nxb8JJBeRDCX5NMm/kTzgdEwmycMk/0HyBRGT8BCxh8dJJjqd/4xINf9J/JspzvN/JD8hOVU8M92DJADLDx8+rLc
                               //KVLl5KkkWSuxWJx5PfPnTuXJI/9EgG4Q3UEtSS/IPkZyTMFBQWGzZs3q88//zzDwsIYGRnJqKgoLSMjw6hpWoGY/w8TDqRRFRUVF+znHz58OC0Wi/XAgQPWJUuWaOHh4Zw6dSo//fRT7fLly3ohfM+SbHu/+g9uVQBak/wPvV5/efDgwY4O
                               2Lt3r2Y0Gk3r1693aID4+HireLN63q4A3Ik6gp07d5pJHtA0reTrr7/WmrMx3n33XdbV1ZWL6GEoyQhnAQgPD2dUVNR124aFhTEnJ6eeZIpwPLk/CALgSXIKydwDBw40eHgRERGO/69du1azWq3FJN8Unaf8AgH4tesIVJI1iYmJ2s0YmqtWr
                               aKqqhdIvkpymrMA3GgbP348a2pqyki+RbJ9S+98V5K9SK4geamiokJz7nSIJIr9+/dT07Q6MRZPJ9lPdFo74YC5bQFw0kK3VUdw8uTJSpI1NTU1qnMV0UsvvcS8vDyT2WwuvXLlSq1zSRhsySBmkrEihtBAAIKCgpicnKzW1tZWVldX18TExD
                               RoGxcXZyH5DcnuLbnzdSQ7k1xJ8vyBAwfUphIwjh49SpL1JC9rmnaS5D9J7hDJFG1/BQHwITm3sLCwwZsuEjbWNhaAhIQEVRhn/0XyFZIJSUlJ9c6quqKioo5kEsklJLepqlr22muvOc7xzjvvkOQpks81FoDY2FiNZJ6wVT4jeWnVqlWOz5c
                               tW6aRPEqy953sozttZXoAGAJg+p49e7qPGzdOl5mZib59++Lbb7/F66+/7jhw1qxZyMvLc7106VKHiRMnDvjrX/8avm/fvmkA+qFhcuYvmfLebh1BAgBDbm6u43k988wzbNu27QUA0QC2AFir0+kypk2b5ihU2b59O9AwpOxg4MCBtQC+Fc6o
                               jwCkjhgxwuGQOnjwoNJU25bkB/AB8HhRUVHn6dOnO8bzb775Rg0ODi4fO3Zsq9raWs/o6Gjk5+djwYIFyuTJk5WkpCQkJSUpW7Zscfs17vFXqCNoB4CVlZWO7xAQEKABuABbQkqFmM9ntWnTZoT9nk+fPg2LxaK4uf08Euzl5WUSbulS4Vc42
                               7p16/F2X8Hx48ftL6jSkgXADUBARkaGPasGb7/9NoKDgysAfOXt7T1g5cqVQ2pra302bdqElJQUpKSkALDl+E+YMKFePAQXksotOkZ+zToCAtDat2/vuP6VK1fs7u2+QgC6AQipqqpyWO2DBg2Cm5vbde+5pqbGOyAgYBCAH0Q/9DQajY624e
                               HhdscQW/IQoABwEQ8LAGAwGOyC4QvgkJ+fX8nq1avVqVOnNmi4fPlydOrUCbAVcfTCtQUXbnzRhnUEjwN4GsCSX1BHoAKo7t69u0O9b9myRamqquoBYBGAZwC8rGnakLi4OMdLNXv2bHt08GdRx9TUVC8AE2HLfnoRwKijR486VMXIkSObbNu
                               SjMBHSH6ckJBgamwA1dTUVFut1svFxcXmL7744rqG4ebNm7Xa2toKkjFiJqHcgifwCslzqqqeq6uru5Sbm2teunRpg/Pn5OQYxbkXNJFFPFr4EdqR/O/y8vIGM4iXX36Z+fn59lmA4aOPPmpgyR87dswkzv+vjY1APz8/JiQkaHq9vlqv11fH
                               xcU1aPv9999bSO4m2a0lC0A7kstqamquNp763ew2f/58rb6+/jDJRxu7Ru9SHYGbcOmOJ3ly9+7dN+UHWL16taZp2nnhPr4lP8DUqVNpMBiukvwfkv4tWQDsaVQp+fn55vHjxzf7xdevX8+SkhLrokWLHPtOnTpVL5Zy6X2zGgC/fh2BImoJ3
                               lVVtWj79u3NCkFUVJRmNBrLSG4mGdLYEyi023XbhoeH89y5c2YRJ/jNnfYE3mkj0CIs6U969uzJ3bt3h6SkpLQ+ePCgS2pqqlJQUIBBgwZhzJgxHDdunKl///5XAVyNiorqMnr06DY6nQ79+/cvALAbwNUmjMA7XkcgsoivAPi7TqdznzNnzt
                               Rhw4Z1SUlJ8UpOTtYdOXIEXbt2RUREBCdMmGAOCwu7rCjKTwA+BlAo7JgGTJs2jWfOnFG3b9/usnfvXiUwMBDTp0/nU089ZejQocNpABtgS0O/o7kKyl3QAjoArWDLvZ8AW159oDDqFGHk1ADIBZACW6n1SNiWYQNs+fnbABQ1TuG6W3UEiqJ
                               Y7V5Nce9DAYwW38lfGNN2oy0PwE/Cui8U+4dWVlZubdeuXTenWYSxQ4cOmcLH4SqOMwA4AWCPuL+qO7203B3PBxC5+tWwFV1mi/m4e6MZiIpruXpm8RAaLNd2vQdxt+oInK5nJVkkBCkFTecD1MCWB6g2lQ6uaVoNbAtLZDhPNXGX8wHuSkKI
                               +CL1wqlyM5hv4dz1Qmv8knurBZB/swItjq/9hY9FBXAFQJ6iKGbcI+SSqvfYTr7XNyAF4CHnntQGCmOqnTAOnWvyjAAuP2BZugRgbNu2bQ5J5yznYjHe31MtoNwjAWgvDLffwZZcaTe6jgNYpihK0QPT+00nhVpgCwTVPTDJn7fwUDqRjN66d
                               asZ11bo0Ej+eDOpYJIHxAawxWx+vvuBSISUNsAvuqdAkt5OAmovt3JttM8EWy2hm7AnnGv0LMKxUtXIkdMKtkhkY1+E/Rq1AKqd2uhgCye3dnJeOR/viYY1jiYAlxRFsTi1beV0nPOiEnXi/s33ahi4HwWgA4BXAIzAtRCwGTbPXHtcyw6qB3
                               AawH4xvo6Gbc0+V6c59kEAMSRzxMPvA2AKgOGw/TaRF35e1HkYwLeijQqb528cgEkAegthsx9/GTZPpD3fwSqcWK+TvCTajoHNA9oXNieY3ftZJo7dByCDZMW9+EGJ+1YDvPPOO6F/+ctfdACQn59PRVH67dmzxy0+Pl4xm82IjIzk3Llz+3f
                               q1GkMAO8jR46027Ztm1tycjKGDBmCmTNnqhMmTAhxcXHpDCBKPPw/W63WsQcPHuyQmJjompKSomRnZ2PAgAF44okn+Nvf/jYsIiLicVdX1/4AVolOXghg9unTp7vv2bPHPT4+XmnVqhVmzJjBmTNnmoxGo0dgYKAOABYsWMBNmzZVCMHtCuAF
                               ADOys7O7xcXFeSQlJSnFxcUIDw/HuHHjtIkTJz7evn37UQA+F4Ja/lAYhHYj8B//+Mf1jMAxJGNXrFjhyN9fu3Ztkyt5lZeXq9u3b7/u5+vWrdNI5oiQ70qLxVLy9ttvNxspXL58OS0WSwHJl0QoN3vv3r3Xjf5FRkYyMzPT8feCBQs0kc//O
                               MnFJPMaZ/s6byEhITx58qSFZJr4IQpPPAzcqgA0tzW1XJt9y8/PryT5Icm0pKQki33/Bx98oNXU1NSazeayrKwsq/OyLydOnKghuYHkgTNnzphwk78NIATgEMlpJH9ITU213Oj+w8LCeOXKlWqSa0kGSE9gE8TExNBgMBjq6upM7733nkNN7t
                               q1C0899RTOnTtnNZvNVRkZGQ3G0cLCQnfYVgTz++KLL1wAW4j42WefNfv5+R1zd3f/LiQkpGrx4sXXPDTFxW7C3nh0586djozksLAwpKamanV1dZWVlZWGL7/8kgkJCY1v1QNAX1VVe65Zs8YxxEZHR6O8vBwWiwVFRUVYsmQJACAzMxOJiYm
                               +sGVP+z0UM6Bb1QCLFy8myVJReLk/MzOzwVuZlpZmEfWE60gWL1y40LnAok6UaCWTLCNppY06UZCZb7Va6z/44ANHm5iYGBPJvSaTqdLPz8+x/7vvvlNJZpN8T9QJXnH+9RChATJJflBQUFABp/Qvo9FIZy5cuOBoN3v2bIqi0UFNFcE81Bpg
                               6NChKmyJJRsAfOvt7d0gEtezZ89qADsAxAAoENU7trmapimwrQyyA8BRAEaTycScnBzP+Pj4kDVr1vQYO3asm7MGIG3NKyoqXPT6a0v7DRgwwADgG2G0RQM4Om7cOGuj23UB4OO81rBer4eXlxcURXFs3btfy0HZuXMnTCaTO+5CHUBLmAX8D
                               F9fXytsuQRFADopitJgzT0vL69aAMfEtKxSrM7prErbAJheV1c3ZOfOnT7vvvuuIlb0dm3OQWU2mxuoYx8fHxNsi1Ffhi2nILt169ajr3MenclkuiVVbjKZXDw9Pe/6C9kiNICYH1cJ5449eeKaFLu6WsXnVgBW+xvsLCMkQ1etWtVuwYIF9s
                               7HK6+8gp07d2qZmZnqunXrrj0UnY4AKKqGHBgMBi8AA2BbKKorgEerq6uvl4jSoG14eDg0TSNJs8hWNpDUSEJsWps2bQzi+1FqgOujNvNw7AknTRVSKBcuXPBZuXKlY8fZs2e14ODgSiE4vocOHepo1xr2Xwfx9/dX/fz8YB8GTp065dOtW7d
                               poqO6kBycmJjY+BlqAOoCAgIcEc20tDRcuHCBPXr0KBGOqzCxOTu6zgnnlSo1wG3als19WFlZ6fiuw4YNQ3BwcC1sy8OUkvQ+duyY0shu8PLw8LAsXbrUcY7ly5fr0tPTe5tMpn+rqKiYsXnzZv/333+/8aXqARR3797dMH78eMfOt956S5ef
                               n9/FYrE8VVZWNmDdunUedntg9erV7sKFbL3bjqCHJiEkICDA8WalpqYiKSnJt76+/jfl5eWPbdiwwfezzz5zHGs0Gl0AtAVwbvbs2Sb7/oyMDISHh7t4eXm18/f391m4cKEyePDgxpcyA8hxc3MreuONNxzX/Pvf/45evXq5ubu7d+jQoYP3q
                               6++qtinpLNmzbLnKd719YQfFgHQAgMD9Z988onj7ZowYYLi4eHRqn379t4vvPCCMmfOHMfBBQUFLsJw/KFPnz6FcXFx130rX3zxRThrAGE8qiKmsHfMmDFFW7ZsafaN/v7777Xu3bufh60CufqhigVcx1i7GXV+OyrSAODg888/P6JXr16ddu
                               /e7ZqUlIRu3bph0qRJnDx5srVz584uO3bs0AHAxo0bsWjRIjc/P78SAMenTJnySGZmpl9MTAwSEhLwyCOP4Pe//z1/97vfaSdOnHDM2729ve02QCWArxRF6fjMM89MGzJkSOf9+/d7pqSkKEePHkX//v0xceJETpkyxRgUFHQewBewZRnf9eV
                               k78eMoGgAf0TDaGAVgO2w1eqHwpav38nplBdgiyDqAfx3o7bVwj9wELYVSkfDFj205+LXwpbm3RkN1yGwp3f3hi1C6eJk5FnEWK8kJCT4TJ48WQGAFStWaMuXL/8BthTzInHOCLH1gS0sbK8h0MNW+JEAW53ClcbT2wdZA1QB+FR0auOcwHLY
                               InHO+QD2n3KvBvB/AJ5Dw/SqeqF2tWba6oUvYZtoqzTq0Mb5AY8A+Muf//zngKioKMd4nZGRoevZs6ebqqquFy9eVD799FPHS9SnTx9N3KNV5AMUCuFLFALp0mhWYxRCVncvQsGSpjWUQrI7yb1bt2614iZrDgsKCmrEki8d5VNs+ULQkeTq6
                               urq8mefffaGnb979277j0PMFNlMLQKZe9e0AHjAVjP4uslkCk9JSWl7+PBh1/T0dCUrKwu+vr4YOHAghg8fro0dO9YUHBx8Uaj7jwGUtBSVLgWgmWEAtuBMCGwreQyBLeXMx+m52V3QubAtQZ8sOt8qNcCDIwj2hFN7UatLoympvbBVGnMSiU
                               QikUgkEolEIpFIJBKJRCKRSCQSiUQikUgkEolEIpFIJBKJRCKRSCQSiUQikUgkEolEIpFIJBKJRCKRSCQSiUQikUgkEolEIrkd/h+o/5w9B4ixMwAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidNoPreviewAHT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - No Preview Image B
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidNoPreviewBHT = @{}
  $MetroidNoPreviewBHT.Name = 'MetroidPreview98'
  $MetroidNoPreviewBHT.Type = 'Bitmap'
  $MetroidNoPreviewBHT.Threshold  = 96
  $MetroidNoPreviewBHT.Dimensions = New-Object Drawing.Size(240, 224)
  $MetroidNoPreviewBHT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAPAAAADgCAYAAAA9g+sJAAAc9klEQVR42u3deXRUdZo+8OdmJQkBZBeQTSQIJIoYpVEw0mwKaXEQ2oHWFrEHZ0ZU5Ewj449W8YCtMCrEcUPBRlo8aARExEhEJTDQLAECARJICJAEAtm3qkpV3ef3x71VVNJs
                                Ipv6fM6po1Tde6tSdd/73d8LiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIi
                                IiIiIiIiIiIiIiIiIiIiIiIiIiIiMglZOgruLxIhgFoDyDsbJvZDw8AJ4AqALWGYZj6BiVQiL6Cyxq8BoDrAPwvgM7nCGAXgDIA2QC+B7CJZIFhGG59k6IS+MoFcA/TNFcGBwffcLptoqOj0aNHD/Tu3Rv9+vUzBw0a5OzWrVsBgG8AvAdgn4
                                JY5AoFMMmeXq83O6CafM7HBx98YLrd7mMk55PsTDJI36aoCv0zMXHiRCM4OLjNH//4x3sAbAOQQjIKQGhAldu0a1RGQPu5yq6KNwYQASA4oNZFAF4ADgAVAJyGYZh2LSEUQFN7v5CAY7rt9wkH4LuIeACUAKhUG11V6F9DFfpG0zRXBFah169
                                fbw4YMKCUZIXX6w2ura1tfPDgwWZz5swJ+eSTT/z7Z2VlObt37/4lgM8A/BuszjDYgVgTEFgmgOMAUgEUAfgNgF4AmtlB7NunHMB+AGsAbABQagd6LID7ANwGoLm9jwdAMYBqAF0ANLKPUwzgLQCrDMOo0q8sv7oq9Pfff19D8n9IDiCZQPIZ
                                khtLSkoc8fHx/u1effVVk+Q+kk8cP368wPf8+PHjefLkSe8LL7zAuLg4Pvzww1y7dm0tya9I7s/Pz69asGCBd/z48ezevTt79uzJ8ePH8+233/YeOXKkmmQ6yUdJtiE5jGRKdXV1cXJysufhhx9mnz59OGXKFP7jH/9wk6xNSkoyfe+9devWM
                                pL/TrKpfmH5VQbwd999V03yWZItSYaRbEXyfpK7ly5d6vVt17VrV9bV1R0hOe348ePHfM8nJibyT3/6U71282effeYleXLv3r2eDh06nLF93bp1a2ZmZrpIrib5W5KflpSUVI0fP/6023/++ed88803GRDA5ST/QwEsv/YAnkayecB215F8e8
                                eOHTWB2+bl5Z0kOauoqKjobB1fR44cMV0ul/eee+7xB39mZqbH7XYXl5WV1bz22mv+UvTJJ58kyVySM0zTzJ0+ffpZO9WGDRumABYF8JkC2N62Kcn/zMnJKQncNjMzs4zka0VFRScbBtXRo0frXC5XUUZGRinJE9u2bfOX3kuWLDFJ5pFcSHL
                                roUOH6nyvRUdH0+v1lpD87MCBA5WBx501axaLiopqnU7nyX379tWNGTOmXjArgK8s9UJfvTwAykJDQz2BTzocDgOneoD9nnnmGbNDhw77AXwUGxtbCqBd3759/5VkV1izvhx2h1YfAF0Mw/D/9lVVVairqwtv1KhR+8zMTF/nFBISEvD0009X
                                R0ZGrgOwrUePHiNnzpzZ59NPPw3Vz6MAlnP/Nk3dbne93ygsLMxX+tXTtWvXGgBfAfgUVu9yOwBRAMYA6FhUVNTo0KFDN+fm5oZs3rw5KCkpqeEhggBEHT161H9xSExMZGRkZC6ANwFkATgZExNzXffu3a/Nzs7WL6QAljNVtQFEAuhRVVXVK
                                PC1xo0be2GN7dYbc42KinIA2ANrWMcAcCuAEXv27Llu/vz5IQsWLADOMv/aMAwDgFFdXe0fWmzRooUJoADAIVjDUrsMw6iOj4+HAlgBLA1iCIBBMsQuOXsC6J+Tk+MP4NatW6Ndu3ZOAJUkzQYlsxvWhAoPgBYAhuzfv79bbGysv7o7YMAAPP
                                DAA4yNjfW2aNEi+KabbjICApgAGBkZ6S/dS0pKggB0gDXu6wZwC8nGW7du1a+lAJYGpV9LAN3t6nEvAKMdDkePhQsX+qu0U6dOZXh4eDWsGVb1AjgoKMiEtXLJtEvaditWrAj3vT579mxMnTrVERYWVgSgtqio6HpYEz98TAC1HTt2NGFP9li
                                xYoXx+OOPd46MjPxPADsBjNi3b18rlb4KYKkffI0APAxglGmacLlcUQUFBc3ff//9sNWrV/u3u//++10AMmHNhvqnmjes2VW+0jw4NzfX/2L//v3NsLCwQgBbAdxeWFhYryPKNM06AAWxsbE9YU/RTEtLQ1JSUvSjjz46tEmTJncePHiw6XPP
                                PadzRn69bdsLWcwAgIsXLzZJHiD5GMl/CZyJBYClpaWH7ZlcYSS7kEydP3++fxhp0qRJLCoqcrlcrtKMjAx34FguAJaXlxeRnEvy8PPPP3/Gz9GhQwd27dpVw0iiAMaPX400j2R3ksPOEsChJNuRXJCfn18VFxd32mMmJCTwjjvu8P87Jyenk
                                uRHJNeWlZVVNxzv9T02btzIxMRE/7+3bdtWrqmUqkL/quL4bC9GR0fj5ptvRmxsLG6//XbvwIEDnZ07dy4AsBbABwAKAXQ6x3uUA/iyffv2vdesWRObnJwc+cUXXxiFhYUYMGAAhg0b5h08eLBrxYoVERs3bjQAYNu2bWFdu3atA/BDs2bNOi
                                9atKjL6NGjg1esWIGsrCzcc889+MMf/uC98cYbgzwej7/zKyQkhOf6m+QS9p/oK7i8JTCArjh3Rg5fh1QJrNVC6wFssYPXABAPYCZOrUYCgKMAptudTV5YK48GwFpV1AtWz7Zhv1YM4CSAGFirjwBrNdM+ALfA6nUOR/2liW4AFR6Pp2VMTEy
                                or3194MCBkm7duk0DsEyrkVQC/7KvloZBkkcB/DvOLyeWG6dyYjkC1uvuBPAnnFoPDHvbYwC89vuUw1pOuA2n1gKjQUBG4NSsrkYABmRmZt7bu3dv/9BVUlKSMWHChJCIiIjgqqqqsK+//joksHOsdevWLljrib36hUWuXO2gMclxpaWlx1q3
                                bn1ebXN7eeNekv1JanqlyBUM4DCSd5LckZqa6j1X8I4ePZrFxcWVJBeT7GjXDERtYLmC7fPWAB4DMD4nJ6fjDz/8ELFly5agXbt2IT8/Hz169MBtt93GO++80ztw4MDyqKionQDmAlhvGIZD36IC+OceBMEAou1HYN4oX7uzxm4v1tlTF8+rZ
                                MRlyiNtf/62sDq/7oI1M6y5/d6+Dq1aWJ1p6bAyZe4GUHO+f48ogK/W4A2B1bM8HEACrKGeCNTv+U0HsMr+b/W5Tvof0Wt92jzSAH50Hmk742WkfRFqhFNJ7XxMAHV2IFcCcCt4FcA/9+ANAtARwDMkR27durX9mjVrQr///nujsLAQ/fv3x/
                                Dhw83hw4dXNG3adAeAVwCknavaqTzSIpcngKNIjiGZ9cEHH5g4Q8dPYmIii4uLK0i+T7Ld+bRLlUdazkbjwBdHOIBuBw4caDNx4sQz1mpWrVqFjz/+OHry5MlxdjX1krjAPNJuu0pcZbd5o+0mQGBeaNOuqlfZTQCvXUtoBOBa1B+XNu2mQ3C
                                D52phzRRzquotV0sJ3ILk819//bU/Ad24ceNYVFTkdbvdjp07d/pL5X79+pHkLpI3XGgJvH79ei/Jk6ZpHnS73YcqKipObt++3f3ggw/WK4mzsrIcJD8l+XuS35Lcbz8ySW6xP8du+78pJCeTjCX5AMn/JbkuYJsMkptI/p3kJHtOdrg99/pW
                                kmsDjr/PTlX7g/3fDPs4/0fyHZIj7O9MNQO5agJ4xqZNm6p8wTNt2jSSdJA84Ha7/fmdx40bR5I7fkoAX6I80jUkPyT5Hsl9eXl51YsWLfI+9thjjIuLY2JiIufMmWOmp6c7TNPMs8d/+9kTQAaUlpYe9h2/f//+dLvdnnXr1nmmTp1qxsfHc
                                8SIEXz33XfN48ePV9kXj0dIXqPxY7kaArgpyf+oqqo6fsstt/gDaNWqVabD4XDOnz/fXwKvWbPGY5dsXS40gC9FHully5a5SK4zTbPw888/N8/Wxn755ZdZW1tbYq9eiiWZEBjA8fHxnDNnzmn3jYuLY3Z2dh3JNHviSJjOILnSAdyI5L0kD6
                                xbt67eyZ+QkOD//zfeeMP0eDwFJJ+3g8/4CQF8sfNIe0lWrl271jyfjrLZs2fT6/UeJvk0yZGBAXyux+DBg1lZWVlM8gWSLXUGyZUM3hCS15OcSfJYaWmpGRi0sBfBf/vttzRNs9Zui44i2cMOuub2BIoLDuCAWsAF5ZHevXt3GcnKyspKb+B
                                dHJ544gnm5OQ4XS5X0YkTJ2oCb6kCazG/i+QKew51vQDu2rUr169f762pqSmrqKioTE5Orrfv6tWr3SS/INlJZ5FcqeANItme5CySh9atW+c90wL67du3k2QdyeOmae4m+Q+Sn9iL4a+5CAEcRXLckSNH6pW09oL7NxoGcEpKitfuXPovkk+R
                                TElNTa0LrOqWlpbWkkwlOZXkx16vt/iZZ57xH+Oll14iyT0kH20YwCtWrDBJ5tht9fdIHps9e7b/9enTp5skt5PspjPpwqkX8KcJB9AXwKiVK1d2GjRoUFBGRga6d++OL7/8Es8++6x/wzFjxiAnJyfk2LFjrYYOHdr7r3/9a/zXX389EkAP1
                                E8ud6F+Sh7pFADVBw4c8J8PDz30EK+55prDAJIALAbwRlBQUPrIkSP9ieaXLl0K1F+S6HfTTTfVAPgS1mSStwBsvuOOO/wTSjZs2GCcaV/5cT+6XLgoALfm5+e3HzVqlL89+8UXX3hjYmJK7r777iY1NTWNkpKSkJubiwkTJhjDhw83UlNTkZ
                                qaaixevDj0YvwGFyGPdHMALCsr8/8Nbdq0MQEchpVQoBTWeG5ms2bN7vB95r1798Ltdhuhof+8kjAiIsIJa1pnEaxx5f1NmzYdDHuseOfOnb4CRL3QCuArJhRAm/T0dF9WC7z44ouIiYkpBfBZZGRk71mzZvWtqamJWrhwIdLS0pCWlgbAyvE
                                8ZMiQOvskDiZp/MiJDRczjzQBmC1btvS//4kTJ3zTQ7vbAdwRQM/y8nJ/r3GfPn0QGhp62s9cWVkZ2aZNmz4AvrPPsy4Oh8O/b3x8POyLiiZzqAp9xRgAgu2THQBQXV3tC+zGADZGR0cXzp071ztixIh6O86YMQNt27YFrCTs1+PUDbPP/ab1
                                80jfCuABAFN/Qh5pL4CKTp06+avHixcvNsrLyzsDmAzgIQBPmqbZd/Xq1f6L/tixY32rk/5p1dPmzZsjAAyFlX3kcQADtm/f7i+q77zzzjPuK3K5OrGuJfl2SkqKs2EHTmVlZYXH4zleUFDg+vDDD0/bsbVo0SKzpqamlGSy3ZNtnE8nlj0T6
                                wTJg16v92Btbe2xAwcOuKZNm1bv+NnZ2Q772BPOkMVyoD2O3Jzkf5eUlNTrwX7yySeZm5vr64Wufuutt+r1JO/YscNpH/9fG3ZiRUdHMyUlxayqqqqoqqqqWL16db19v/nmGzfJ5SQ76kySKxXAzUlOr6ysPNlw6Oh8Hw8//LBZV1e3ieSNDa
                                cWXqY80qH2lMjBJHcvX778vMaB586da5qmeciefvmjxoFHjBjB6urqkyT/H8kWOpPkSgWwLw1NWm5urmvw4MFnPXHnz5/PwsJCz+TJk/3P7dmzp47kVyS7nW8JjIufR9qwc0m/7PV685cuXXrWIJ4zZ47pcDiKSS4i2bPhTCy7dnHafePj43n
                                w4EGXPU/6N5qJpU6sK8kNqyf3nS5dunD58uU909LSmm7YsCF48+bNRl5eHvr06YO77rqLgwYNcvbq1eskgJNz5szpMHDgwGZBQUHo1atXHoDlAE6eoRPrkueRtrNYngDwt6CgoLAHH3xwRL9+/TqkpaVFrF+/PmjLli247rrrkJCQwCFDhrji
                                4uKOG4bxA4C3ARyx2/H1jBw5kvv27fMuXbo0eNWqVUa7du0watQo3nfffdWtWrXaC2ABrDS2Wqv8Ezth5KeVwkEAmsDKvTwEVl7ldnanlGF30lQCOAAgDdatOu8E4LuTwUkAHwPIb5gC53LlkTYMw2O/X4j92W8HMND+m1rYnZ2+TqccAD/A6
                                l0+Yj9/e1lZ2ZLmzZv727MnTpxwtGrVKgPWGHeIvV01gF0AVtqfr/zHpv0RlcAX9wpo5WqugHXTsCxY47FhqN/D78WpXFUu+yQODnjttCfy5cojHfB+HpL59oUgDWdeD1wJKw+W90zpZE3TrIR1Y/B0BAxVQeuBFcBXYRATVp6o4vPcxfUjjl
                                1nl9o/5bPVAMg93wuSvX3NT/xavABOAMgxDMOls+TS0DiwXNIWhr4CBbCIqAp9GYsdqzOoOazOrcB7EjkAHP+FZYkkAMc111yTTTIwy2aB3d5VKXwpm2/6Ci5JALeE1fH0O1jJ4QCr02gngOmGYeT/gv7WMyW1c8NayFCrzir5uZ3UbUkmLVm
                                yxGWXQJw0aZJJ8vvzSaUjojbw1VC9MU5bwTGUyE3UBv55f+ftSEYGXEB9tysJafCcE9a9lELt9nTgPYrcsCZGlDeYiNEE1kqohmPRvveoAVARsE8QrOWITXFq8kng9o1Q/x5PTgDHDMNwB+zbJGC7wJuC19qf36VqtAL4l6IVgKcA3IFTSwhd
                                sGZGtcSp7Bx1APYC+NZuXw4E0MH+zXxjrBsAJJPMtoPnBgD3AugP4DqcujdT4E3JNgH40t7HC2vm1SAAwwB0sy8Wvu2Pw5oJ5lvv7IE1CeVZksfsfe+CNQOtO6xJLL7ZZ8X2tl8DSCdZqllXCuBfTAn80ksvxf7lL38JAoDc3FwahtFj5cqVo
                                WvWrDFcLhcSExM5bty4Xm3btr0LQOSWLVuaf/zxx6Hr169H3759MXr0aO+QIUN6BgcHtwcwxw6eP3s8nrs3bNjQau3atSFpaWlGVlYWevfujdtuu42//e1v4xISEm4NCQnpBWC2HaQTAYzdu3dvp5UrV4atWbPGaNKkCe6//36OHj3a6XA4wt
                                u1axcEABMmTODChQtL7QvPdQAmAbg/Kyur4+rVq8NTU1ONgoICxMfHY9CgQebQoUNvbdmy5QAA79sXmhKVxHLV83Vi/f3vfz9dJ9ZdJFfMnDnTn7/5jTfeOO3KnYSEBJaUlHiXLl162tfnzZtnksy2lwzOcrvdhS+++OJZVyrNmDGDbrc7j+Q
                                T9lLArFWrVp129VFiYiIzMjL8/54wYYJp53O+leQUkjkNs00GPnr27Mndu3e7SW4lOYxkI50d8osL4LM9xowZc9bXc3Nzy0i+SXJramqq2/f866+/blZWVta4XK7izMxMT+vWrf377Nq1q5LkApLr9u3b5zzb8YcNG9YwgDeSHEnyu82bN7vP
                                9fnj4uJ44sSJCpJvkGyjs+PiUi/0VSI5OZnV1dXVtbW1zldeecVfzfz0009x33334eDBgx6Xy1Wenp5erx155MiRMADNAER/+OGHwYC1xPCRRx5xRUdH7wgLC/uqZ8+e5VOmTPHvU1BQEGq3t29ctmyZPyNmXFwcNm/ebNbW1paVlZVVf/TRR
                                0xJSWn4UcMBdPd6vV1ee+01fxMsKSkJJSUlcLvdyM/Px9SpUwEAGRkZWLt2bWNY2Tuj1QMvv7gSeMqUKSRZZN847NuMjIx6peLWrVvd9v2U5pEsmDhxYmCC9Fr7FifrSRaT9NBSa99QLNfj8dS9/vrr/n2Sk5OdJFc5nc6y6Oho//NfffWVl2
                                QWyVfs+ySdmD59esMSOIPk63l5eaUISJ/jcDgY6PDhw/79xo4dS/umZ33OlMReVAL/bN1+++1eWIkBFgD4MjIyst5KoC5dulQA+ARAMoA8++4JAADTNA0AZfbr2wE4nE4ns7OzG61Zs6bna6+91vnuu+8ODSyBSWv30tLS4KqqKv/zvXv3rgb
                                whd3plARg+6BBgzwNPm4wgKjCwkL/rKuqqipERETAMAz/o1OnUzkEli1bBqfTGQblgb4kPaJyhTVu3NgDay1xPoC2hmF4A1+PiIioAbAD1rBOWUhICFF/GmwzAKNqa2v7Llu2LOrll182srOzz/j7+iaYuFyuetXZqKgoJ4BM+32qAGQ1bdp0
                                4GmOE+R0On9UVdjpdAY3atRIwasS+JfHHh8thzU5w7f4/dRVNiTEY7/uAeDxlaCBMU4ydvbs2c0nTJjgC1489dRTWLZsmZmRkeGdN2/eqR89KIgAaN+1wa+6ujoCQG8AbWENE91YUVFxukQC9faNj4+HaZok6bKzZVaTNEnCfpjNmjWrtv8+D
                                SOpBP5F8p7l5PYlDDhTInTj8OHDUbNmzfI/sX//fjMmJqbMDvzGGzdubO0rte280kaLFi280dHR8FWj9+zZE9WxY8eRdqB1IHnL2rVrG54jJoDaNm3a+FdUbd26FYcPH2bnzp0LYU08ibMfgRNVDsKafOLVT60S+FfZN3a2F8vKyvy/Zb9+/R
                                ATE1MDYBuAIpKRO3bsMBq0myPCw8Pd06ZN8x9jxowZQdu2bevmdDr/rbS09P5Fixa1ePXVVxu+VR2Agk6dOlUPHjzY/+QLL7wQlJub28Htdt9XXFzce968eeG+9vDcuXPDYE3B9GgihwJYTqNNmzb+km3z5s1ITU1tXFdX95uSkpKbFyxY0Pi
                                9997zb+twOIIBXAPg4NixY52+59PT0xEfHx8cERHRvEWLFlETJ040brnlloZv5QKQHRoamv/cc8/53/Nvf/sbrr/++tCwsLBWrVq1inz66acNwBrSGjNmjC9Pl0pfBbCchtmuXbuqd955x1+6DRkyxAgPD2/SsmXLyEmTJhkPPvigf+O8vLxg
                                WB1f391www1HVq9efdpS8fHHH0dgCWx3fnlhzaleddddd+UvXrz4rCXqN998Y3bq1OkQrDsgVuinUhv451PnJS+kOnwhVcxqABsee+yxO66//vq2y5cvD0lNTUXHjh0xbNgwDh8+3NO+ffvgTz75JAgAPvjgA0yePDk0Ojq6EMDOe++999qMj
                                Izo5ORkpKSk4Nprr8Xvf/97/u53vzN37drlH7eNjIz0tYHLAHxmGEbrhx56aGTfvn3bf/vtt43S0tKM7du3o1evXhg6dCjvvfdeR9euXQ8B+BBWlkuHzoqLS7NiLk3gni0jRxKAP6L+aqRyAEth3as3Fla+5rYBhzwMawVTFYD/brBvBazx4Q
                                0AEmCtWroWp3Ix18BKE9se9e9D7EsP2w3WCqnggE4qt93WNVJSUqKGDx9uAMDMmTPNGTNmfAcrRW2+fcwE+3EDrGWFvhzSVbASt6fAylN9ouHwmKgEvlqVA3jXDsqGObFKYK0EClwP7LX3qQDwfwAeRf30NHV2tdU8y75VsMaSP7b3NRoEZMP
                                1wdcC+Muf//znNnPmzPG3V9PT04O6dOkS6vV6Q44ePWq8++67/ov8DTfcYNqf0WOvBz5iXzzW2heUwFlWXvvvrYSVVkdLCUUuUg3BINmJ5KolS5b4xp3P+cjLy6sk+T8kW+tbFLmyQdya5NyKioqSRx555JzBu3z5cpPkXpKj7WwiojawXMEA
                                Dod1z6RnnU5nfFpa2jWbNm0K2bZtm5GZmYnGjRvjpptuQv/+/c27777bGRMTc9SuLr8NoFBVYgWwXOFqNKzFBT0BDIW13K8DrBxXvvPCN4XzAIDvYXVGFfryaYkCWK58IPsS5vluyhbYEUWcujGbOqNERERERERERERERERERERERERERERER
                                ERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERE5Nfm/wNeSZw9NjrQZwAAAABJRU
                                5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidNoPreviewBHT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - No Preview Image C
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidNoPreviewCHT = @{}
  $MetroidNoPreviewCHT.Name = 'MetroidPreview99'
  $MetroidNoPreviewCHT.Type = 'Bitmap'
  $MetroidNoPreviewCHT.Threshold  = 96
  $MetroidNoPreviewCHT.Dimensions = New-Object Drawing.Size(208, 256)
  $MetroidNoPreviewCHT.Image = 'iVBORw0KGgoAAAANSUhEUgAAANAAAAEACAYAAADC7fjvAAAcy0lEQVR42u3de3RU9b028GfnShICyF1AbiJBIFHEKEVBpNwUUvVFrAeqFbFHzznFqqy3yPGlVVxgKxwV0lOrVLHUiguNgIgYiagEjpRLgECABBICJIFA7reZyczs5/1j/2aY
                                pFwVrcc8n7VmKTN775ns2d/53b8bEBERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERE
                                RERERERERERERERERERERERERERERERERERERERERGRHxhLp+DSkIwC0B1A1Pk2Mw8fADeAWgANlmXZOoM/LBE6BZcUPBaAqwD8N4DeFwggD4BKAHkAvgDwFcliy7K8OpMqgVpyAA2wbXtNeHj4NWfbJj4+HgMGDMDgwYMxbNgwe/To0e5+/f
                                oVA/gUwOsADiiIpMUGEMmBfr8/L6SadsHHG2+8YXu93hMkl5DsTTJMZ1NVOLlIM2bMsMLDw7v8/Oc/vwPADgDpJOMARIZU+WxTI7BC2k+1pirYGkAMgPCQWgMB+AG4AFQDcFuWZZtSMhJAW7NfRMgxveZ9ogEEgtgHoBxAjdpoqsJ9F1W4a23
                                bXh1ahdu0aZM9YsSICpLVfr8/vKGhofXhw4fbLVy4MOLdd98N7p+bm+vu37//RwDeB/CvpjMCJhDqQy5sG8BJABkASgH8CMAgAO1MEAX2qQJwEMB6AJsBVJhASwRwF4CbALQ3+/gAlAGoA9AHQCtznDIAfwSw1rKsWn3L8p1X4b744ot6kv9F
                                cgTJUSSfIrmlvLzclZycHNzuxRdftEkeIPnLkydPFgeenzZtGk+fPu1/9tlnmZSUxAcffJAbNmxoIPkxyYNFRUW1S5cu9U+bNo39+/fnwIEDOW3aNL766qv+Y8eO1ZHMIvkwyS4kx5NMr6urK0tLS/M9+OCDHDJkCJ988kn+/e9/95JsSE1Nt
                                QPvvX379kqS/0ayrb5h+acE0Oeff15H8mmSHUlGkexE8h6Se1esWOEPbNe3b182NjYeIzn75MmTJwLPp6Sk8Be/+EWTdtP777/vJ3l6//79vh49epyzfdW5c2fm5OR4SK4j+WOS75WXl9dOmzbtrNt/8MEH/MMf/sCQAKoi+e8KIPlnB9Bsku
                                1DtruK5Ku7du2qD922sLDwNMn5paWlpefreDh27Jjt8Xj8d9xxRzD4cnJyfF6vt6yysrL+pZdeCpYijz/+OEkWkJxr23bBnDlzztupMX78eAWQfH8DyGzbluR/5Ofnl4dum5OTU0nypdLS0tPNL+rjx483ejye0uzs7AqSp3bs2BEsvd5++22
                                bZCHJN0luP3LkSGPgtfj4ePr9/nKS7x86dKgm9Ljz589naWlpg9vtPn3gwIHGKVOmNAkmBZB64b6vfAAqIyMjfaFPulwuK6QHLOipp56ye/TocRDAXxMTEysAdBs6dOi/kOwLZ9aDy3QoDAHQx7Ks4HdXW1uLxsbG6FatWnXPyckJdA5g1KhR
                                eOKJJ+piY2M3AtgxYMCASfPmzRvy3nvvRerrUQD9bzi3bb1eb5NzHBUVFfj1b6Jv3771AD4G8J7pXesGIA7AFAA9S0tLWx05cuT6goKCiK1bt4alpqY2P0QYgLjjx48HgzMlJYWxsbEFAP4AIBfA6YSEhKv69+9/ZV5enr4hBdD3t6oHIBbAg
                                Nra2lahr7Vu3doPZ2ynyZhLXFycC8A+ON3KFoAbAUzct2/fVUuWLIlYunQpcJ75d5ZlWQCsurq64NBEhw4dbADFAI7A6RbfY1lWXXJyMhRACqDvGwuARTLClBwDAQzPz88PBlDnzp3RrVs3N4AaknazkskLZ0DTB6ADgLEHDx7sl5iYGKxujR
                                gxAvfeey8TExP9HTp0CL/uuuuskAAiAMbGxgZLt/Ly8jAAPeCM+3gB3ECy9fbt2/VtKYC+R5Hj/Pp3BNDfVM8GAZjscrkGvPnmm8Eq1axZsxgdHV0HZ4ZBkwAKCwuz4czctk1J02316tXRgdcXLFiAWbNmuaKiokoBNJSWll4NZ+A1wAbQ0LN
                                nTxtmsHX16tXWY4891js2NvY/AOwGMPHAgQOdVPoogL5XwsLCWgF4EMDdtm3D4/HEFRcXt//zn/8ctW7duuB299xzjwdADpzZAP9Q84MzuyBQmoUXFBQEXxw+fLgdFRVVAmA7gJtLSkqadATYtt0IoDgxMXEgzBShzMxMpKamxj/88MPj2rRp
                                c+vhw4fbPvPMM/rO5Z/Xtvk6k0kBcPny5TbJQyQfIfl/QmciAGBFRcVRM5MhimQfkhlLliwJdmM/+uijLC0t9Xg8nors7Gxv6FgOAFZVVZWSXETy6G9/+9tzfo4ePXqwb9++6saW/z0BFDIbezHJ/iTHnyeAIkl2I7m0qKioNikp6azHHDVqF
                                G+55Zbgv/Pz82tI/pXkhsrKyrrm4z2Bx5YtW5iSkhL8944dO6o0lUdVuO80js73Ynx8PK6//nokJibi5ptv9o8cOdLdu3fvYgAbALwBoARArwu8RxWAj7p37z54/fr1iWlpabEffvihVVJSghEjRmD8+PH+MWPGeFavXh2zZcsWCwB27NgR1b
                                dv30YAX7Zr1673smXL+kyePDl89erVyM3NxR133IGf/exn/muvvTbM5/MFOx8iIiJ4ob9Jzt9zJJdQAgHoiwuvSA10CJTDmS29CcA2EzwWgGQA83BmNjYAHAcwxzT2/XBmXo+AM6t6kOnZs8xrZQBOA0iAM/sacGZzHwBwg+l1i0bTpRFeANU
                                +n69jQkJCZKB9dejQofJ+/frNBrBSs7FVAn3bvW0keRzAv+HiciJ4cSYngitkvc5uAL/AmfVAMNueAOA371MFZznDDpxZC4RmARGDM7MaWgEYkZOTc+fgwYODXeepqanW9OnTI2JiYsJra2ujPvnkk4jQzonOnTt74Kwn8usblpZcOrYmObWi
                                ouJE586dL6ptZpZX7Cc5nKSm90iLDqAokreS3JWRkeG/UPBMnjyZZWVlNSSXk+xpSkZRG6hFt886A3gEwLT8/PyeX375Zcy2bdvC9uzZg6KiIgwYMAA33XQTb731Vv/IkSOr4uLidgNYBGCTZVkunUUF0De9CMMBxJtHaN6AQLuj3rQXGs3Um
                                YsqGfAd5ZEzn7+r6Xy4Dc7MiPbmvQMdCg2mMyMLTqagvQDqL/bvEQXQuS6+CDg9axMAjILT1RyDpj1fWQDWmv/WXeiiu4Reu7PmkQNwyXnkTMafWPMj0ApnkooE2AAaTSDVAPAqeBRA3zR4wgD0BPAUyUnbt2/vvn79+sgvvvjCKikpwfDhwz
                                FhwgR7woQJ1W3btt0F4PcAMi9U7VEeOWkpARRHcgrJ3DfeeMM+V8M7JSWFZWVl1ST/TLLbxbRLlEfuh03jQI5oAP0OHTrUZcaMGecsldeuXYt33nknfubMmUmmmvSt+Jp55LymSlZr2jzxpgoamhfONlXFWlMF9ZtSshWAK9F0XMo2VdfwZs8
                                1wJkp4VbVTwIlRQeSv/3kk0+CCUCmTp3K0tJSv9frde3evTtYKg0bNowk95C85uuWQJs2bfKTPG3b9mGv13ukurr69M6dO733339/k5IoNzfXRfI9kj8l+RnJg+aRQ3Kb+Rx7zX/TSc4kmUjyXpL/TXJjyDbZJL8i+TeSj5o5edFm7t2NJDeE
                                HP+ASZX1pflvtjnO/5D8E8mJ5pypZJRgAM396quvagMX7+zZs0nSRfKQ1+sN5nebOnUqSe76JgH0LeWRqyf5FsnXSR4oLCysW7Zsmf+RRx5hUlISU1JSuHDhQjsrK8tl23ahGf8ZZgZgR1RUVBwNHH/48OH0er2+jRs3+mbNmmUnJydz4sSJf
                                O211+yTJ0/WmuB9iOQVGj+SQAadf6+trT15ww03BC/gtWvX2i6Xy71kyZJgCbR+/Xqf+WXv83UD6NvII7dy5UoPyY22bZd88MEH9vnaWC+88AIbGhrKzeztRJKjQgMoOTmZCxcuPOu+SUlJzMvLaySZaQZuo3QFKYBakbyT5KGNGzc2ufhGjR
                                oV/P9XXnnF9vl8xSR/ay5+6xsE0OXOI+cnWbNhwwb7YjoqFixYQL/ff5TkEyQnhQbQhR5jxoxhTU1NGclnSXbUFdSygyeC5NUk55E8UVFRYYcGDcwitM8++4y2bTeYtsjdJAeYi769GcD82gEUUgp+rTxye/furSRZU1NT4w/NYvrLX/6S+fn
                                5bo/HU3rq1Kn60JS+cBbTeUiuNnPomgRQ3759uWnTJn99fX1ldXV1TVpaWpN9161b5yX5IcleuopabvCEkexOcj7JIxs3bvSfawHbzp07SbKR5EnbtveS/DvJd81itCsuQwDFkZx67NixJiWNWfD2SvMASk9P95vG/f8l+SuS6RkZGY2hVa2K
                                iooGkhkkZ5F8x+/3lz311FPBYzz//PMkuY/kw80DaPXq1TbJfNNWe53kiQULFgRfnzNnjk1yJ8l+Lfkaaum9KNEAhgK4e82aNb1Gjx4dlp2djf79++Ojjz7C008/HdxwypQpyM/Pjzhx4kSncePGDf7d736X/Mknn0wCMABNk3t8Xd8kj1w6g
                                LpDhw4Fv88HHniAV1xxxVEAqQCWA3glLCwsa9KkScFEjytWrACaLokIuu666+oBfARnMPePALbecsstwQHdzZs3W+fatyVp6eNAcQBuLCoq6n733XcH2zMffvihPyEhofz2229vU19f3yo1NRUFBQWYPn26NWHCBCsjIwMZGRnW8uXLIy/HOb
                                wMeeTaA2BlZWXwb+jSpYsN4CicBX0VcMZzctq1a3dL4DPv378fXq/Xioz8x5UMMTExbjjTikrhjCsdbNu27RiYsaLdu3cHfoAtBVDLFQmgS1ZWVmBVJ5577jkkJCRUAHg/NjZ28Pz584fW19fHvfnmm8jMzERmZiYAJ8fb2LFjG81FFE7SusS
                                BxcuZR44A7I4dOwbf/9SpU4HpSf1NAPUEMLCqqirYazZkyBBERkae9TPX1NTEdunSZQiAz8110sflcgX3TU5OhgnqFj2Y2tKrcBaAcHOxAQDq6uoCgdUawJb4+PiSRYsW+SdOnNhkx7lz56Jr166AkwTxapy5YdWF37RpHrkbAdwLYNY3yCPn
                                B1Ddq1evYPVs+fLlVlVVVW8AMwE8AOBx27aHrlu3Lvijed999wVmZ//DrO+tW7fGABgHZ/XtYwBG7Ny5M1hU3XrrrefcV1pOJ8KVJF9NT093N29A19TUVPt8vpPFxcWet95666wdC8uWLbPr6+srSKaZnjzrYjoRzEyEUyQP+/3+ww0NDScOH
                                TrkmT17dpPj5+Xlucyxp58ji89IM47UnuR/lpeXN+nBe/zxx1lQUBDohav74x//2KQnbdeuXW5z/H9p3okQHx/P9PR0u7a2trq2trZ63bp1Tfb99NNPvSRXkeypK6nlBlB7knNqampON++6vtjHgw8+aDc2Nn5F8trmU1u+ozxykWZKzhiSe1
                                etWnVR40CLFi2ybds+Yqb/XNI40MSJE1lXV3ea5P8j2UFXUssNoMAy6MyCggLPmDFjznvhLFmyhCUlJb6ZM2cGn9u3b1+juRVjv4stgXD588hZJpfcC36/v2jFihXnDaKFCxfaLperjOQykgObz0QwpetZ901OTubhw4c9Zp7cj1r6TISW3on
                                gNT1Zf+rTpw9XrVo1MDMzs+3mzZvDt27dahUWFmLIkCG47bbbOHr0aPegQYNOAzi9cOHCHiNHjmwXFhaGQYMGFQJYBeD0OToRvvU8ciaLzykAfwkLC4u6//77Jw4bNqxHZmZmzKZNm8K2bduGq666CqNGjeLYsWM9SUlJJy3L+hLAqwCOmXZc
                                E5MmTeKBAwf8K1asCF+7dq3VrVs33H333bzrrrvqOnXqtB/AUjhptFr0WqUWPxHQVLvawMm9NhZOXrVuplPAMo3kGgCHAGTCuVXIrXBuIw84+dneAVDUfAn2d5VHzrIsn3m/CPPZbwYw0vxNHUxnUaDRnw/gS9O7dsw8f3NlZeXb7du37xnSi
                                +fq1KlTNpwxrgizXR2APQDWmM9XdanLzlUC/dB+QZxcbdVwkrbnwhmPiWrWQ+nHmVwFHnMRNbnd/NkupO8qj1zI+/lIFplAzMS51wPVwMmD4D9XOivbtmvg3JgrCyFd5dB6IAXQ2S50OHkCyi5yF88lHLvRlFrf5LPVAyi42B8Es339Nzwtfg
                                CnAORbluXRVXJ2WhAluEDJKAogEVXhvsuOhQg488vaoGlOaheAkz+wLDkE4LriiivySIZmGSo27R2VQuerMusUnDWAOpqG/0/gJOcINNp3A5hjWVbRD+hvPVdSES+ciaQN6iyQS72oupJMffvttz04c4c4m+QXF7OUW9QGEgDOnM9/fFqJNER
                                toG92zrqRjA35AQqky41o9pwbTi7tSNOeCs1R7YUzMFnVbCC0DZyZ4M3HogLvUQ+gOmSfMDjLIdrizOBv6Pat0DTHtxvACcuyvCH7tgnZLvSmXA3m83tUjVMAXS6dAPwKwC04s4TBA2dmQEecWZ3aCGA/gM9M+2IkgB7mnAfGWDYDSCOZZy7e
                                awDcCWA4gKtwJjd3aFL4rwB8ZPbxw5l5MBrAeAD9TLAGtj8JZyZEYL2TD84g8NMkT5h9b4MzA6M/nEHkwOyLMrPtJwCySFa09FkHCqDLWAI9//zzib/5zW/CAKCgoICWZQ1Ys2ZN5Pr16y2Px4OUlBROnTp1UNeuXW8DELtt27b277zzTuSmT
                                ZswdOhQTJ482T927NiB4eHh3QEsNBfvr30+3+2bN2/utGHDhojMzEwrNzcXgwcPxk033cQf//jHSaNGjboxIiJiEIAFJkhmALhv//79vdasWRO1fv16q02bNrjnnns4efJkt8vliu7WrVsYAEyfPp1vvvlmhQn8qwA8CuCe3NzcnuvWrYvOyM
                                iwiouLkZycjNGjR9vjxo27sWPHjiMA/NkEerlKIrnoToS//e1vZ+tEuI3k6nnz5gXzt73yyivnvJN2eXm5f8WKFWd9ffHixTbJPLNkYb7X6y157rnnzjtTe+7cufR6vYUkf2mWIuSuXbv2rLOvU1JSmJ2dHfz39OnTbZPP7UaST5LMb55tJ/Q
                                xcOBA7t2710tyO8nxJFvp6pDLHkDne5zrdvOBR0FBQSXJP5DcnpGR4Q08//LLL9s1NTX1Ho+nLCcnxxd628Y9e/bUkFxKcuOBAwfc5zv++PHjmwfQFpKTSH6+detW74U+f1JSEk+dOlVN8hWSXXR1qBfuW5GWlsa6urq6hoYG9+9///tgNee9
                                997DXXfdhcOHD/s8Hk9VVlZWk3bEsWPHouDckTv+rbfeCgecJQ4PPfSQJz4+fldUVNTHAwcOrHryySeD+xQXF0ea9ta1K1euDGYESkpKwtatW+2GhobKysrKur/+9a9MT09v/lGjAfT3+/19XnrppWAVPjU1FeXl5fB6vSgqKsKsWbMAANnZ2
                                diwYUNrONmL4tUDKZe9BHryySdJstQkbv8sOzu7Samwfft2r8mnvZhk8YwZM0ITFDaYFLubSJaR9NHRYBK6F/h8vsaXX345uE9aWpqb5Fq3210ZHx8ffP7jjz/2k8wl+XuTJ/vUnDlzmpdA2SRfLiwsrEDI8m2Xy8VQR48eDe5333330SSdH3
                                KuJJIqgeRru/nmm/1wFuYtBfBRbGxsk5nQffr0qQbwLoA0AIUmeygAwLZtC86d6d4FsBOAy+12My8vr9X69esHvvTSS71vv/32yNASiHR2r6ioCK+trQ0+P3jw4DoAH5pGfyqAnaNHj/Y1+7jhAOJKSkqCsw5qa2sRExMDy7KCj169zqzhW7l
                                yJdxudxSUB069cN+G1q1b++CsJSoC0NWyLH/o6zExMfUAdsHpVq6MiIggmk6jagfg7oaGhqErV66Me+GFF6y8vLxzfj+BAV6Px9OkOhUXF+cGkGPepxZAbtu2bUee5Thhbrf7kqpibrc7vFWrVgoelUCXnxkfqYIzOBpYfHbmVyoiwmde9wHw
                                BUqQ0BgjmbhgwYL206dPDwQPfvWrX2HlypV2dna2f/HixWe+tLAwAqDJWhpUV1cXA2AwnBsNXwXg2urq6rMt5Guyb3JyMmzbJkmPyRZUR9ImCfOw27VrV2f+PnVjqwT6VvjPc3EFFuydKxGhdfTo0bj58+cHnzh48KCdkJBQaQKv9ZYtWzoHS
                                i2TV87q0KGDPz4+HoFq3L59++J69uw5yVzoPUjesGHDhubfsQ2goUuXLsEZ5du3b8fRo0fZu3fvEjgDv0nmETpQfBjO4K9fX7VKoH9K38T5XqysrAx+F8OGDUNCQkI9nNs7lpKM3bVrl9Ws3RQTHR3tnT17dvAYc+fODduxY0c/t9v9rxUVFf
                                csW7asw4svvtj8rRoBFPfq1atuzJgxwSefffbZsIKCgh5er/eusrKywYsXL44OtIcWLVoUBWcKkE8DqQqg76UuXboEf9m3bt2KjIyM1o2NjT8qLy+/funSpa1ff/314LYulyscwBUADt93333uwPNZWVlITk4Oj4mJad+hQ4e4GTNmWDfccEP
                                zt/IAyIuMjCx65plngu/5l7/8BVdffXVkVFRUp06dOsU+8cQTFuB0qU+ZMiWQp0GljwLoe8nu1q1b7Z/+9Kfgr/vYsWOt6OjoNh07dox99NFHrfvvvz+4cWFhYbjpePj8mmuuObZu3bqzlgqPPfYYQksg0/nghzOnbu1tt91WtHz58vOWKJ9+
                                +qndq1evI3DuAFGtr0ptoIuvc5Ffpzr2dao4dQA2P/LII7dcffXVXVetWhWRkZGBnj17Yvz48ZwwYYKve/fu4e+++24YALzxxhuYOXNmZHx8fAmA3XfeeeeV2dnZ8WlpaUhPT8eVV16Jn/70p/zJT35i79mzJzhuExsbG2gDVQJ437Kszg888
                                MCkoUOHdv/ss89aZWZmWjt37sSgQYMwbtw43nnnna6+ffseAfAWnCw/Ll0VzRqvOgVnDZzzrUhNBfBzNJ2NXQVgBZx79STCydfWNeSQR+HM4K4F8J/N9q2GMz60GcAoOLO2r8SZXGz1cNJUdUfT+xAF0lP1gzNDPDykk8Br2jpWenp63IQJEy
                                wAmDdvnj137tzP4aTIKjLHHGUe18BZ1hDIIVcLJ3FiOpw8daead8+LSqBzqQLwmgmK5jkRyuHMhA5dD+Q3+1QD+B8AD6Pp8uhGU22yz7NvLZyxpHfMvlazgGi+PuhKAL/59a9/3WXhwoXB9kpWVlZYnz59Iv1+f8Tx48et1157Lfgjec0119j
                                mM/rMeqBjJng3mIAOnWXgN39vDZxl3VrKID+YEtIi2Yvk2rfffjsw7nTBR2FhYY25ZWNnnUVp6UHUmeSi6urq8oceeuiCwbNq1Sqb5H6Sk81qWlEbqEUHUDScnNlPu93u5MzMzCu++uqriB07dlg5OTlo3bo1rrvuOgwfPty+/fbb3QkJCcdN
                                de1VACWqkimAWnw1Ds7kzoFw7iQ3FM6S8biQ7zUwhegQgC9MZ0BJIJ+CKIAUSE5y+DY4kxQ/tCOAOJMYX50BIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiI
                                iIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiF/b/AVY6nD1BCbmzAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $MetroidNoPreviewCHT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 00
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview00HT = @{}
  $MetroidPreview00HT.Name = 'MetroidPreview00'
  $MetroidPreview00HT.Type = 'Bitmap'
  $MetroidPreview00HT.Threshold  = 96
  $MetroidPreview00HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview00HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAADgElEQVR42u1cS27EIAydIJ9utj1O1z3ObHu96aapIgTm+YunLVKlKiEJ2M/m2Zg57u+P5+27fX68Hef/kuv9tdmz/TtG9yR9r9/p22jMo3e028Z2f388uUlo70meIY+J9JJd
                               afaKHLSvtc+skYcWtQP0mLy1UTbkJTaLCmXU/9rv6pd61LkKgNPYCinnwNB+iLCRfqkIsGjbo1+4APqPZ9iwtbXbH2+E2CkKq10a13CCHwRoB70b3pIllGOmtGMyqMZW/TzGfWiXDw0RyvT4s2/2cztmk0GFYGGCWQyUC4YOlE1lmYVG8Ki9s
                               6uA9sOcyaCDsXhxl2VQa3Mzfi2hplfNn+FxJvIOrQ1r/MUuHwAToZWH5YhSJL8vQYWRKC2iH0qKzr+UfEClaC4lFvjN7T8arAJFr2BI6geouoYiYo1yAvBAm/Yd5AUlDYSlGovgELRTsxVyhlRBs5mmohaAxFS0CZWr8LLQQVLJznaEJdc8TM
                               YLDU36Im8Yjjh8pm8gjXajnWRmTmAbD9DsAVqyyTOBlogFLOHs+YwWMeWpsGRiafmASqYi8VEjAVHUILOiSavDJAs0NfzByxzcYgGUyVkZXzbFhQWA2o51J6anuJkxA/cuinZa3ETLRYOZKTGvvb1y+QCOvVWsGSrBBNHNkpeLBTjt974BcVz
                               WypJyxdIe+UirWZGnhCNsH31W+w2IR6N8Gzk/gL4va7eZJPZmsctolqitMaaIwSCx+ooHjAYcYQ6U6dwqNpJM4pUmhpowlBZHcnNS4WiWwIhq9CZd0hAOf1Z7jarKuOveZqgqkkJOavXHUa6TkGolO6ni5gQ9SVNJJ2iF384SOInQG2JHlnw9
                               ytysQtEewaMoCXtte0UHRof0OIy2Rn91DUUGtxQi54z7ey16/bZuXXkglFOa6sjMrsmc/miV8JAQNVqxqxF0VlUcuwqvuOyTahns2d0ojaWJ9EbanL3LUm6D+JSGJhdmtvzq9cVNE3RwR2QsPH+HMJsm+vMc6Ciu2C4ATggcOmYFTwhL25Vra
                               FLteGtsFiKj98ODIY1n9uD1Wf6ApM7Ie+9Pyhm8BROeD/B4d6R/oGowndUbITGFhoHSKlSdTdT7kIPkV6UQZaBxAWm5dGQJrReSoKSo5Te6UGfFQRPNHUT5AvKAMBofWKvPImqNDi87zmBy0jzAzH+90g5XePsCyhc9W+OGmhUAAAAASUVORK
                               5CYII='
  CreateImageFromBase64 -ImageData $MetroidPreview00HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 01
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview01HT = @{}
  $MetroidPreview01HT.Name = 'MetroidPreview01'
  $MetroidPreview01HT.Type = 'Bitmap'
  $MetroidPreview01HT.Threshold  = 96
  $MetroidPreview01HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview01HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAADaUlEQVR42u1cSW4cMQzsHvB1vvo5Pvs5vvp5Ri7poCFoKZaKEjuJTsYMrYVrkZTmfPv4+jl+j+/P99f1t+fz8rPW/5Zz1L7z0N7XKUdtz7U5hhuIHG8fXz+9Q7DfedYzxUFK
                               zo4ke9cclHaGpve9KaTIblBxeGaf93lttcp7bBZlSo0eZZ6UAb1FR5pymQNKhzAboVuqATPSVtCFM6BcXGnDUSP9BqOHIXaKqtUuiTOY4I8GsJverd6qEGo7DoNKbESn2PfJhg8GCEXgANTxtoDQiRBFIcEoTRqBpSoDZtCU8jAs45EstBsFm
                               IWvRb1qp/Tis4I6V2L0UW2AqRPMSP84juNkbZhdcHVi5QJCI2n3gFIkvvdGGU8kk4W7++JKuogkazoZypTNLckFnjDYvf+12SBVEdqpirMHZCORPV29kTyjxyTLfkBVjbCpAWzJWqHCXhwQEVVsl2QzFFVCGMBIdmdIPDPZfy0hQp3blBP0cK
                               zVEfZ8FpUWMz7g5V1UjQ++P99faEy/aJVmZIx0o211NrQ9AghFxnePsFIAoRUQvMXM9FAYBWr/cwESdFnUBlWqrJxHmgyh4EOJANE5XLnAKOnwfrZTypQPYKAmcp+wdciLJkPOEOIERy2r1NngypLYrEalToeRg2YZKTaENkselwv0pF/6Bk8
                               jlaFLqQEIzFWZDYQEVXd31LavuDDdGidyIC/e7vXu0fmYej+DK2ylve2sL0icoHeRO+rz4oBa8sLkAluiwBPuCA8ZEJn8KGH27JwuJ+j1D6uKIawDhLPBuz22PLznnlBt85GhzpUMIZ3aGlC5XmR5CyXMxaYUTlBxhb6cY2U/YEkuoFbpiLqC
                               7Q5nu9Nli1T/lVoi6QvUbPK+wOo6Xq9HibxJRrTLmPK2BwdE1QO9YberAd7NIO91FGYyuo6v8DXWg5cedYswhwiMQDlBRN1GON37IgTRrhrw8gqke9uidxvDc1OjV/vbPagQ43mzl/05rTGOg30L9M/1BdA0Wn3xKQ0DRkwY/YaIGlTV1lvC9
                               Vb6zDjGmvnN9BaXZYNIZyjCDEZzpuwMtUyDbdy01H87A7xFlV7LjG2n2S5g0guRI3A2E3VKRGpRh/MkTMjGo7DEuUKiStOYBWQlnaledWT9FYo0YVCR/bEMf1Krbvn4Ba7OEr0l9TtIAAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $MetroidPreview01HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 02
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview02HT = @{}
  $MetroidPreview02HT.Name = 'MetroidPreview02'
  $MetroidPreview02HT.Type = 'Bitmap'
  $MetroidPreview02HT.Threshold  = 96
  $MetroidPreview02HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview02HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAAC0UlEQVR42u1bQXIEIQicneJ1ueY5Oec5ueZ7ySlVU0alwUadXboqh+zMKgICje7jOI7j7ePr5+jg+/P9UX52/U7t+fW91vNyjNqYrXks8/fmOLXF1wa0Tm6dYyZEszTiDZrm
                               W56g/R+Bcg6xWh8deMZi6B7gXXxpYVRRFoWyttK/GOB1o78/j6Is723jAaP7je0VLAXJ8SRAM1OJ83hxCLLv7hLRPdvjaTxAM1LruXjKy5kWa8lR+9wjs4zW8CMWQxbu5Qet8co1dRdYvmwVeLScRgmTZd7y+2KxLJMrIAqPrj9cZKhmkZ6n9
                               Kxm2XZROEuaa6GwLLqLWqzGMEcVYCIvjMorIqejsaEZA9BU2BKmdF1vdNfmj+ACZ839a5PcjeXBdYCF5+/A3qa1xHbu44VkgWSDNyM5aA9Sy1CmSnBHeouW4C0uILsv0BOke+91ucDMIIiyQVQ+L3MVtsXY5Co6ppyjwUjbY5bSekYMKos+Gd
                               Eey7JlxTnTM8SbPlAOb+H6K7bEORoD0AiuBbxVnWfRaCPDQ2qLHz33D60E2a0x1kIigqSgPJ3F/KzK8NQLZgWgjQ5mRRaRfYa5gCYwehzOPNv3NFh78avKBVCBWRXgTI6hKU1QgVct3nr1xppFxCMwuyVmNQAzPZ61gmTFbS1G4PMo6eXYoLs
                               jpOVj63vsStD7PUEFjmSDKytEQQUePaJa1fC4ylV7JrOjbqT1e3I2r8iMatmT3pgKRbZwtxDaoWpjHq9T6DBLYK2LG8ny0LGWng0iFJwdE0qiFBoDZlaOXq/d/mzQSoetLbynuSxt6WZdny3lAh73Ztck00+HLfHD+/skkwIsJIdpIZay0ZYc
                               nQvUFIcoc/SSM3qLDFYAurDdGCCLGsNXZdlbJaIe8Gyr21+S8jBAtQ5g3QXYQQlQFliVg2fSZiobnMXjd2/GJBKJRCKRSCQSiUQikUjcEr+klV0Z7vyEJAAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidPreview02HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 03
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview03HT = @{}
  $MetroidPreview03HT.Name = 'MetroidPreview03'
  $MetroidPreview03HT.Type = 'Bitmap'
  $MetroidPreview03HT.Threshold  = 96
  $MetroidPreview03HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview03HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAADAklEQVR42u1bSW7DMAy0Db6u1zyn5zyn1zyv6MlFoGgZkkNJTkSgh9a2THGdodV927bt6/vnd6vI43470r89P5O7/nxf6Xq6RmnNmn7nfcizuXccrc3nlNZsHjFw632e6y2R
                               lqeRaEAUy0VC63fru80G8HhDu5lZRJihmMvHmqE0Bq09k96rSQuTlx7323H+WHM2OrdDUsBiKK230Y7EWu8SeRopH28AQfJulooeURemj4BobCA12DiLZz0ArfWseDG8x7MWHKDhEYhDBW0xFoUZnmVE1fN70ndKr1BElO2Rdqlh1GQoF3o1K
                               FqjuZq0C8cBJ83VUFgG3dUiNysTLcH4nUFKRuCEWpRp9iKtCQpSI9LQZU5w2BH1MhHKhX/u5lEsr6QbDQpreH4ky5uCC8yu8OICEVzgCpS1GxeYNU8jZ4zT8PxSpY/uPsOKoIVcMbpPlQyxq/FINogiyINViM7r1qodCXZoXQD1mNazKeLsGR
                               libR8oh9dw/REpcXjzqBa26H2lr0xdU6BELxkR0mpvIwezElW9a3O4mTiDoDw9GpGNwBX/BkAHHVra7F1Tm4IW44pGYXT0bRmRe8GUdRArGoVZCJCd7560ElThUZtHv06hR3ReuIBFYfZIjGk0bXs9coCkR9sacSKMNhG6IhuEPo62whn9+KC
                               tKT2QYGldQRWOZIMjRVCFLd6/giFEGzLvJuItKJb2NpNBZYZRuBeLTNsGW9NZK2tknigZ+m1Qc5gpggeE14DodNFQYggIvYtojswdV9/YpblAVFvUrNf96zBy3t/DEbRRIp4TVr1ATqRjTFyAfdLL8h8jLCMJE65GeAoxJjqYpbfB3BzOYoTa
                               BrRr1nBADjhJ1NCBWbW90Vgb61NTQFPhexOr4kQoIjc95wNQIoWmXkuX3brhVlfQ9mxtNNGQYMm6COmwIkL0OI1l3Va0pOL6hjfyYAMSEYhuR2tzjA161mB9BQ7BASO9y5IdqbLM9jTbhHnvyb1nlI//5+klS5YsWbJkyZIlnyp/72yzp8G2i
                               VkAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $MetroidPreview03HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 04
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview04HT = @{}
  $MetroidPreview04HT.Name = 'MetroidPreview04'
  $MetroidPreview04HT.Type = 'Bitmap'
  $MetroidPreview04HT.Threshold  = 96
  $MetroidPreview04HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview04HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAADaklEQVR42uVcS5bcMAi0/TjdbHOcWec4s831JivndRwjUVAg3NGyjW0J8alCuPdt27aPz6/vDRy/fv7Yr7+dz7m75pXV5F7n/HpN+10bh2fxM6V9fH59z65H38Eaou2qRcMW
                               q/DKvu78qVDk+S4FsC1BW6xlIa8yGQunKYCtKI9C2yiAvVNW13uEBVQvbIkCrouJWkR5FugUD6rcbEkMYMtFFHpsDx0z5ViVtzPNefTS2S6d91rlWCOE51EgZEWRFjkWF5DKiMv2fWoQ9L40MtnrbqG7R1OAh+BYXAV1pyVAaGb6VxbmobIak
                               /OQpCV0OMuPWdS6BAix2RxqeW8FhTuRI/FAym7pLKK0FhYQKcre3YsoXjymaKW9EXqMWFkEP7SLAdX3S+YLmTEAIUlIem0bA1DlnWkTTa+ivSg7glsxA2u3NTlhmuPo+OpOrgNHaOEClXnfrYDswKdR4+z3ilWjkfNBdpXpbi5e7gCfDlui7O
                               jaKC6soMcSQVWeOt7IQlYwwtIgiCyeoQSLdYvlARkTmFWIIhjhEUgQ3VkEsLnZYAeTZ2UIq5xkkpkVR99WyzrlJHMildTZW6MYlsRmKdFTQlvdEPFPDEBZGRplV1qXRY7m41YmGFUWqzByykrWRFHL8pwTenoEhjGAXRrrfCY4rAh521w9TQ5
                               3slowXtIpivgUmoOzgiHifoIEtmh9YFT8rO4VuEWCKxoU2HEHlSttkbGa8SgGWHuDrHHoQGDkOw5ZnboqYsDofhnhfwYP6Ib9Q1wgcpqDFjGyzxX/ygLRykyEHEU6QyOb4a4HVJu0FzSF6gGekxmWO8wyknVh1kH/Gozpq8h7PU3bf1zAA2WR
                               3z09g1X1yCNr56+dopWLR1xvz7IAazxZjUKX9Oh7SmczgDZrxtA24bh7GOurzfM0uBMavM5H7ROsMkWU3nqbuLXrwghyTIDDcifrs4+rWaBNDJZr2kQ6uMahpSskPXoByygLlH0vMGJ4Ixye9Y1RtOfHVRBBlMDq6uxSfTq8QOhtSmJeKFy9c
                               6Piaahb/DT/GWLyvPwRR2OrAFAWYHIpoNOEqpXUvlma/SEXFASf4BZod8ttGkTKSFUszQK3GfMSFsBhWxL6Z0vWQss1e4mVbmYHq2i/0Gz+2u97h2pwVuDUlPI/Hf5Ox2/8SBkmvD3KGAAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidPreview04HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 05
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview05HT = @{}
  $MetroidPreview05HT.Name = 'MetroidPreview05'
  $MetroidPreview05HT.Type = 'Bitmap'
  $MetroidPreview05HT.Threshold  = 96
  $MetroidPreview05HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview05HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAADeUlEQVR42t1cu1LEMAxMMprh367lc6j5HFr+7TqqzBzBD+1qZTu446I727K80koK+7Zt2+Pj67mB4/vz/e362fk7pWesbE3udc2vz2qf18bBbL6ntMfH17P3PDqHaljtVD0a
                               9lgFK/t68qdCkd+nFKC2hNpmPRt5lcnYuEwBakUxCl1GAeqT8l69W1jA6I1NUcB1M1GLGO4FVsKDUddsCgao5SIKPbabjp5yvMrblebcmrR3Sud3vXKqsUfieTQQ8kaRHjkVF7CRiKu++1IQZCeNLPZ6WujpyRTAEBzPVUGv05RAqGf6VxbGU
                               Nkak2NI0hQ6nHWPVdR6SCCkZnOo5f2rUHglcmRMSLmaO4sobQkLiCRlS99FFG+MKXppb4QeI1YWiR+Ww4DR37fMCZUYgJAkxL0uiwGo8k63ibpXq02UjeDemEF12jU5U5pjq3xVkluBIyxxBUb6fVoB2cBXo8bZ85pXo5H6oDrLVFoLyx3g6r
                               AHZVvPWrgwgx5bJKpi8ngtC5nBCIeCILJ5hRI81m2eH8hYQC9DFIkRbhEJoieLBGw0G1zB5FUewitnmWRmRunba1mnnGUuZCR1ZnMUzZRYzyUyKbTZDRF/MABlZSjKzrQuj9yuWoiXCUaVpUqMnLKWtVDUspg6IdMj0MQAdWps5ZpgMyPEtrk
                               yTQ4l2RoYT+kURe4U6oOzwBC5foYAWzQ/0Ep+ju4VKEaCMxoU1LiDyg1tkfGacQsDvL1BXhw6kDDyPw6b7bpGYEDr+9aK/xU8YLXYP8QFItUcNImRXVf85QWimZlZ5ChyGL/yAUqCEd0MUxSJ5A0M0daIk+y113k3BnmBHpVFX2BClDU7t2BM
                               aqnnKRTByqh85BHZfBQbIu31Kk+0M5vvPUNb2WdeA2NCYfXpXJG/pGhWqb29GBo4ZLlH5ZuinkbtIgbcZZxldkWVaGc1Gw2Xa3IsMLJWs6Nt8cgiEHcZwR/EW4WvQKRKW/pbETRF8Gdf5U6jlle6QszbY9YTRkiKouMTsUIFPT9YknK3xAcUB
                               3gQveVfM09dPZerMIIqQVXJUb/BQnmBFd7sypzbMjYf6QitWc81qlNhjgsDrpOvUDdQVaah4mjmP0lRxA5Mr8PS7fJsDyAC3MbG/cwp1iK369ViehBYjmEj7nZGDB+lwX+4wCgleE6QtaZVXfbS4wfomETZsCXk8AAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidPreview05HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 06
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview06HT = @{}
  $MetroidPreview06HT.Name = 'MetroidPreview06'
  $MetroidPreview06HT.Type = 'Bitmap'
  $MetroidPreview06HT.Threshold  = 96
  $MetroidPreview06HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview06HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAACpElEQVR42u1bS07EMAxNK5+OLcdhzXHYcj1YVao6Tf38S5yRn4SEZoKT+O/YbO2Ej6+fv9Za+/3+3NoD0HVSmr01HI3j+ztw++49gk9EkXUojfMF7tajNLTY2mScpduT9JkJ
                               dxK9fs+tf2EAokI9oujmkkNxF0S1BNln51QsSgUPE7nSv/u8x0gP7FeOHT8tGaLOtLcFgXp9RFuWYgCqBRIm0MiQ460FHmaxnAlw0pXkH0s5QdQkrp9xd6HsTg25uPTSZgZIU9zeJazenEvSXBmAHlhyMUkxFeUItyyq30ujkc/MGqAhiJSvH
                               geMdsgmH2BVQYnzispRNg8HOCJsPu3ragLWuDqibPZkOCHlcFSdnwFkqaTeoRymFaQk0TKpj1ryPSBMA7KWw5zULeaxnAlwTJD2CFI4Qa+90IiWQgMkRZNGSOg6minZDHmD+3sAKllU7Z+6RC5OEE03JZtEStabtqgclqr0U1c3SzpNXvaM/K
                               3H5dxNQKPu0gaFx7vB9PeASDWdbgKWCQtL1uYZeaTr4GIoQ33g1cK/W0c9znhcPCK15mhK70Kaw1kmMrLVFSTJyLwYlamoIo16oV5b08+PyBhDiyFLjPeMPkNfhNCCBtWiCDVH15G3bWvoIZmnR2PWlAlGOqyZ0QNuXFqfpqUmIF2n9Sm7VYr
                               XmRzUL1iYeLdO61MIdVoZsjartFVhsBfmMvcEJYJcpjfIXYiLAD1BujyKImPuI9JkTVG3jzjETDpmHxDl3CJflcIZMOLA3gyCnOBMSfScVnRFOVwDJD0CSWjTjvCYO0OWDpK2bvAa0wuJAlGXP5vD+XeryS0zLR6VmKWdELHOByzFgJm1xBIz
                               QpGmkJ4BmlEa9f8MrewPIkfpCoVCoVAoFAqFQqFQKBTeCv/73xAWAXMSaAAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidPreview06HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 07
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview07HT = @{}
  $MetroidPreview07HT.Name = 'MetroidPreview07'
  $MetroidPreview07HT.Type = 'Bitmap'
  $MetroidPreview07HT.Threshold  = 96
  $MetroidPreview07HT.Dimensions = New-Object Drawing.Size(64, 80)
  $MetroidPreview07HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAYAAACpv3NFAAACiklEQVR42u1bSW7DMAykDb6u1z6n5zyn1z6v6MmAYVjWDEXaVMMBAgSJrFDcxKGURXb4+Pr+FRH5eX2ucgF0HDtnawwyxzbmiN7vNn+wNSE6Dp1jL/zZeFQOy3ciIos8jL11
                               W5beL+LMomff957ZoD0t9SY8fo6O671nYH1ORER7LnIVmx6WRxS1VyySKxisR01uL0mGKO9It1DWe64WjihtKgVEeKaOxtCTXnBUiEVB04VAK2FudQdrREUm/88hobMktd7CrcrQSIF7BdZIAebBUygFoAKj47yzujVklyyu3yqjWQ8whQBaz
                               7P0lZkvqrQOzQGjPMFjHx/F4hFrkYKjlh3yADRpMd0ib9ocBZgOZxE4lAvMVgm6K2BGGjzqdau8OdLT4ei8Uh6QIQk+6Xn6pGsz9UdUqOiTlmWERpXFKtW9H2Dh+SOe0irWUAKnLSuMEJXIzG2x9tU4ig6zLn3VnclSTq9e8dx7NmtprRZ3R6
                               20j/esROkWoTKzRLof4BEqdygEDbk1Mvaz8YZmHdC7dRG9ZVkX5nFAohbhrBeSolwaLa7O5FuZisy6/UWH0chJFcUG2cMKdrtkx7hVgqPat7o+s/tEeZGpI4TGHOpF0TvR5TU5hEV5ssHR/OLdtNGI5sNM5wMacfTEVpZMu9s7FwxZ6mybQ/O
                               C9Yjt9iTodfqLzj1SZFlkVcTK6AXlLFUg02xJfzYYLYdLUxS55u6xsPCbol6U1JtJRuUoswI8khvDE3qeNPR/gayx3btO55Ub9O6F3UGyUnsAc0ZgVSjzzJIhBNDLVCPkqOVN6a/IRB/JTXlbPA0ZymL5qZJgtv7B298RKgVIoVAoFAqFQqFQ
                               KBQKhULhvfAHESHCfNpsOTQAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $MetroidPreview07HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 08
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview08HT = @{}
  $MetroidPreview08HT.Name = 'MetroidPreview08'
  $MetroidPreview08HT.Type = 'Bitmap'
  $MetroidPreview08HT.Threshold  = 96
  $MetroidPreview08HT.Dimensions = New-Object Drawing.Size(120, 112)
  $MetroidPreview08HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAHgAAABwCAYAAADVN7S/AAAJ9klEQVR42u1dS27kOAw1A50u2zlO1nOcbOd6nMVMBS6XJPI9krIKHQEBusuyLYsU+fgRJcd/TQ+7Sec3dfSZ3SOOPo9+o3d5+0bv986T1V+AeVNw/l+e2R6dPr++hz3/+fuv
                               4bXHff/3Uc9gP7++zf6X5w5/Q/pG77fmqTcP5/6na6Pna28eZnN1fk7vmR+eQXua5xmfX98/A854547NOw/WHA36KzoeOY5DR9w6ESOoSNcCsTYaP/Qb+i4P4XrvPM9vZ76fvv163epviWiPrn0RIw6RrudJAfr3JgplRnjFOd8lTmwxVG+de
                               ZArEz0k3EPaXf/vYPBnEZ0thiYihhZrGzUd/I1WkfQYI4tBrdYiN/cGiYK1NyQuM2Y1RO0Biug1BF6km98KRI2IMLjvxQwC9O8yAm+5ygB7MU16eZj4Srjrs3rPZYmbRWAt7h9aXcUqQDJW/eR5GiHuiMDq/Rh08qomG7Grk8GNIsQn3i3RAT
                               YPAVYhvsAqUnCMEpUuCJjsmTbGeDWL0A1dAZui6DCnF4pyYcabZe+3K0cRD65G0YjOhoMmFnMbq3H71i4frQOvidwxOHBVwR4zQLxLYB6QaBXFSLO+H70X9aD8ymZ9HGhrWtfF8Rdm1J53Dw06TJhvONbGyP8ZAQw7znMNXVVRXa/gexRQOdm
                               ST9G5aI4JEmDQKKCQKtDk0PU6YuhOjPvpebMF4MAwGiHulVGthdCCk6vO+1A9pCQhQzp+9P9sYMU+l1GZLSBefjjKkc2BZE24HfqbIFo9HLHilRilB7K0o9itUNhP32wwtgrcPWKt3v9PxuliyitwimRqwCt48OLeB6rn2nHJOuitUi9aNsYT
                               BU8oyHqynVGd2CN6RFS7dbAhOrUHMrwihA2xsfrXKQEUZJQX23lCXMmYl6wVPBQvQMbkcufHyBxDJi0bZDnxCJqCG1oQzas7UPv2BlA0tZ8TV8tU3zIit9J6aAEHAWumyIoVjjAcmiIz0oGXd1MSL1tsfxiuLy/XmYg70L9yxUuk31XnZrt4M
                               yRey1wt1oCiiBNB3pFnkrHloS2MuHwHrtt7CLyRkyEyGbJAUnh/Tx9LWylCMlxzExswujHMHTRAgy2HP7VHZ9fBLJDjOA5phRxK92czTNiNYWDQAA2eDFF3z6SaMLAg3/+4tzKrUsj+TI5VmdcoICFMxguMxxvkyQVZligB+od0UVXuV9QjNz
                               GpEOllBnleto9uCp6sP695I7t9HCn+X8S9wQhCr+BicMXkVi1pGV6y6FYUNPDSCFRY7rliXadFWGL0HWoBtcrxeRmkHVxKjcuciN6zajdidLcgYyF4EyWi3/5h6D/XS4HAdS+xoEqXmt8R8YqRMeqn/mjAfwDSFCGwMi9GuGuFSHsw0PlvJJ1
                               GWRzWHl5UVPbeC65K8SLxqZl0LpLiyQycZHVIoP8qkOTxann0LpuoyDiV1EGfFwK/EOCSzfEyGZU1OqrQbpCRaL2bjCOujiATZNFFUrwo9yZUnC4RBno3lOwe9KdbDCnpGR3vWqMjIxDiDQvOTE+PF8si8ple2Rkdt+4uzE7eG5k4N0kSKA99
                               CLKOjYqkgJO5Iq6rgbRdiTLp2UXZI3Lv3i190YR9iviuZz5ty98N7UQE7f3Dep6Ba7r37pjR4d2QjqJ6ly0+yAmvlhTqkEjDfOzZOHdN2YHs02qgtso5E8USvXFun5MV3eleQHyosk72e9Hv2b1OVjSJTqtWWSKCL13lLUKABXWydNHqeIvWc
                               VFiZhJSTAytTBOpKD/aab+DuljoqIFclE8EBgnAVKYJ1dxYGFS/VQVUqKxGEmDZfiQirLZN7cxCYCcIgaNiD9WTzKkrs+jWSkxQbeumm2otg1iAf9TTH3ZcoD7i1YeCIIEJp3Rx45EWBTUd/+gR7U+495B9wdF9xEtFenRTessQB4wzgq2iM0
                               u/QYhRsTXmDtsYJrCTAHTKDqJT38k+zQSWM3qwOhghAKoj6ZPVMvQkU46R7BuJi1tMEkLR6Sk7N6NVz0RIwjNMIAkwjCQxWX8F75qyw2x5cRKJKvHrNfmSbHbY79Cbr4yUnW1ar5iKJf49B1IyzO99jmFCIYwoXhTt1iXVopo9Q2JxiDBbxDO
                               MOJQ+W8aDCUeEGohTDVAzK62oRUyTakqNpM+ONTqoHf5opb5KUFnNAHCluw1bqk2MJtZngUqWMTMdJCUB/2AJByq7P6FshJdgS8OFUTBYEvCP9ker5bxzq3ZnVgb8QzoVEKEoCCoFTYBEXFI/ZMuAv3fj9SpzLVO/es2bbB0c2d9qVYhDdaoQ
                               q4ECQSRoUg+D7rIhvgFggT5WhqgvtWUaDXBQla4OFY7ehwQbdpzMJaKacLxsA/4aO5k7IcZiVM+sSF3NBC5P1qKVGtpGiabgJBEMxihZErHCk1UtXjzFSyVwb4UIpTBK0WIQhGlawiRmeb4iJ4hVVBZgi85kSETUfPIdTukkQLo9iRZtIUUiX
                               fUnWERG2DnpMAmcW90YAmSCq4yj5VdV/dkhIaKzw1DdK9j7ASDBYMcFkeS20tERLSLDgkxlFh6T0YESDNWpUZC3TdWfwCkzaZUMWgJBKpwWy+3IKufLFo6Ouz8gK4+6cnwZWIEUxRIZBxMurDLMZdOVEt3LBNfjHiBoysfNhgvDhjnLLDcRP+
                               wDKB7HsH2cbvQW+EILiUUKj+3QIgeDZJuV8BjaQeRAseFC8ACqVavV/P7FuwpHElVpOzjphO53KIVQwkDoCWVZZhJrB9MrIHvF3RVeJE8jDfm6EUIjaLpFxONZvO6WHD65xlQJghk+6uvOcu+2HudZFdWuW0Qy6iwiHwKIxIzto7DjparC/XU
                               hoXnRM+JeY7URT5MZFgQlQkYZfDORMCtcaD1ncn0keVzRJC9xzQ+eVdC5FniZ1NtQdKuJQ4RP0WYEzQPhwuhuTaoQGkLcqUgeVdA5c6ZT36zcmxQ6MuDGBHp/KUPnqdqz8NysWPW0kPWAmaiSvVGwSIj6FNPQe7L3bLek20widruJQze/VHGf
                               ACXoxOwgAXSFWRYVu4z9+2ImoWmnxLUfuw9RAVH0aYnm6HGvq8xA1lJBgg0Rs4TSr4E8Lde7Mk4xu8PjBq/ggg/znsWrN01wRDTrHSvYQvomiiZWwpQ4V5EyGlzv94SVywArIe7JVGGIauNRtHNAyqI65IMCOU1ZCNbleEnwrKWAMReKZlZAp
                               FYUkdYiBcS1iIL4rjXQT5y/uxMjWbejnol6+jf6kVNdd5EQ3qyKrKLktH43fOhdCXW6Nv29w5Sj/k8oOiTaqjxRbH504j2a9L5Uc2lFGaXUEzV3NlMY+zMLK2Ql3W0xgWg6z8ZN0BUJYA5BGaodv23pquwBpyCIlBWitkJE7yC+q8fwe7Lbb/
                               ttv+23/bntX8Jb8NK0cEp0AAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $MetroidPreview08HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 09
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview09HT = @{}
  $MetroidPreview09HT.Name = 'MetroidPreview09'
  $MetroidPreview09HT.Type = 'Bitmap'
  $MetroidPreview09HT.Threshold  = 96
  $MetroidPreview09HT.Dimensions = New-Object Drawing.Size(120, 112)
  $MetroidPreview09HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAHgAAABwCAYAAADVN7S/AAAJ7klEQVR42u1dS5LkKAw1GZyutnOcWs9xajvX0yxmssKJAek9SZiMTiI6oiuNbYyE9PRBlOO/JofeSuc3MfSZ3VMMfZ79Ru+y9vXeb50nrX8B5k3A+b88sz47fX3/DHv+8/df
                               w2vP+/7vI5bBfn3/qP2b5w5/Q/p679fmqTcP5/6na6PnS28eZnN1fk7vmQ/LoC3N8oyv75/fAUe8c8dmnQdtjgb9BR1POY5DRtw6ESOoSJcEsTYaP/Qb+i4L4XrvPM9vZ75fvr29rvXXRLRF117EiEGky3lSgP69iUKZEV5xxncVI7YYqrfOP
                               JSWiZ4S7int2r8NDP4qoqPF0ETE0GJtoyaDf6NVVHqMEcWgWquem3uDRMHaGxKXGbMoovYARfQaAi/SzW8FokZEGNx3MYMA/buMwFuuMsBeDJNeFiZuCdc+q/dclrhRBJbk/q7VlawCSsSqnzxPPMQdEVisH4NOXtZkI3Z1MLgRhPjEu4t3gN
                               VCgFWIz7GKBBxj8UoXBEz2TBtlvBJF6IqugE1RtJvTE0V5YcYbZe/XlqOIB2ejaERnw0ETjbmV1bh9q81Hy8BrUu4YHLiqYI8ZIN6LYx6QaBXFSLO+j96LelB+ZdM+DrQ1tevF8M/NqD3vHhp0mDDfcKyVkf8zAih2nOUauqq8ul7A9wigcqI
                               ln6BzUQ0TVIBBo4CiZIEmg66XEUN3Ytwvz5stAAOGEQ9xW0bVFkJ1Tq4Y70P1kJCEdOn40d/RwIp9LqMyq0O8/HKUIZsDyZowO/Q3QbRyGGLFKzFKD2RJR7FrobDfvtFgbBW4e8ZarX9PxmliyhY4eTI14BU8eHHvA8Vy7WiyDnqr1IqWlfF4
                               wRMKsl5sZ1Qn9ojuEdVmHayITumBDKsIYUNsrP41SgABGeViO0+IWyLmJWoFD8ULkDG53PkxMseQSYsGWUY8gqbguhZEteoO1L69ARRN7efA1TLVt4zIzbQeqsNBwJopZcUKRxgOTZEZ6cDm3ZTEixbbD8X1ZeU6FXE7+meu+OLp1+rcaBdvh
                               MSrkatFG5AXcSLI2/NMMrY8tIURl+/AdXsPgTdyMngmoyyQFNbfw8dSV4qQCNfcxAb0bgwzBw3QYMtkfAXpA2aBHMdxlJrIoXR/NsOE3RgGBg2Y4IkMmPMCxCYMXJDvf96bmVVZyP5MjlWa18ghIaZmldWHbxhLWQayNFEC9Hfpoqzcr4ik9z
                               PS7jGcQXqpQZ7L9tFNwZP2z2relF0+ypPE0JMGCiMUegUngysmt+pWArH54Yy6QAMvlUCF6Z4r1nWahCVMuhXxV5PElZmTZUbg4hUZIDHN96zajejdLchYCEwgh/n2h6L/TJMDBK57iQVZulT9Do9XjIxRX/ozvvPmPkFQNJSGw4jNrDwngtO
                               tCf8lQlT23guuyMt9ljmvI0IpN1uyOoqj/yqQZPFqWfQum6jIOJXEQJ8LgS8EaLI5LpORWaMj2Rxh30Hr3WAM0TqCVJBFF0mxiuubUHG4RBjoXVeyu9OfrjFkCc/oeNcaHRGBEEtYcNDHmu9mclGe6RWd0XHr7sLo5L2RiXOTJKEAcA0gwN1o
                               OE0kK7ovzN5HTbMRkXv3bumLJuxTxHc982lr/m5oJyJo7x/a8xRc0713x4wO1D6Fi6mCcWBZICksyQCa/dwd564pO5B9mg3UVjtn2Pf0xrl9TpZ3p3sC8aHKOtHvRb9n9zpZ3iQ6yVplgQg+dZVXDwEW1MmSRavjLVrHRYmZSUgxMbQyjaei/
                               Gin/Q7qYqGjBnJRvhAYJABTmcZVc2MFyNlBBWSorEoSYNl+JGI7yDa1MxOBXUEI7BV7qJ5kTl2ZRbdWYoJsWzfcVKsRxAL8o5b+sOMC9RGvPhQECUwYpYsZj1QvqEGyC6z92UwH47O8+4iXinTvpvQaIQ4YZwRbRWdSrQ4iRsbWmDtsY5jARg
                               LQKTuITn0n+zQSWM7owepghACojqRPVovQk0w5RrKvJy6uMYkLRYen7NyMVi0TUQKeoQJJgGFKEJP1V/CuKTvMlhcjkagSv1aTL8hmh/0OvfmKSNnZpvWKqWji33IgJcP81ucoJhTCiMWKos26JFtUs2dILA4RRot4hhGH0mfLeDDhiBAFcYo
                               CamalFSWJaUJNqZH02bFGB7XDH63UlwkqsxkArnS3YQu1idHE+ihQyTJmpIMkJeDvLOFAZfcHlI2wEmxpuNALBlMC/t7+aLWcd27Z7szMgL9LpwIiFAVBqaAJkIhL6odsGfC3brxeZa5F6lereROtgz37W7UKcahOLcRqoEAQCZrEwqBWJspO
                               R6oAWKCPlSHqS22ZRsNUDrhblyPBhh0nc4moJsstbNEqO5k7IcZkVM+sSFnNBCZP1qKV6tpGiabgBBEMxihREjHDk5UtXizFS4vj3gwRSmGUpMVQEKapAZMY5fnynCCWUVmALToTIRFR88l2OKWRAOH2JFq0hRSJdNUfZxGZws5Jh0ng3OrKE
                               CASXEUcLb+q6s8OCRGWouIQyEKjHWAdKUEZYvbcRY4ObxEZFmQKs/CYjA6UYKhO9YK8bar+OE6ZCatkUAMIkuG0WG5HZjlftnB03P0BUXnUmeOLwAqkKC6ecTDhwizDvGy6Urx7meB63AMETfm42XCh2zBnmeUm4rt9AMnjGLbH6UZrgS+0kJ
                               in8NgOzXMwSLRZCY+hHkQOFBsuBA+gWrVa1e9fvKtwJFHNh2tddHDQCd3vUAohhYHQE8qizCTWDqZXQPSKuyu8SJ5G6vJ1I4RG0HT1iMezeN0tOXxyjakSBDO819cd5d6tPc7TKqq1W0Qi6iwiHwKIxIjto7DjJavCfbuQ0LzoGXHbWK3H06S
                               GBUGJEFEGX00kjAoXas+ZXB9JHlM0yUpc9YNnFXTaAi+TehuCbjUxiPAp2vSgeSBc6N2tSRVCQ4g7FcmjCjrtWT9GPRkq6sGDm3d0vFBRqaro0GndrIYRRsWqp4WsB8xElez1gkVC1IeYhtaTvZnj8KrlY43nEM306qWK+wQoiTIO7cMQAsgK
                               s8wrdhn792ImsWfoAdd+7T5EBXjRpyaanaeYLTMDWUsFCTZ4zBJKvzrytEzv8p5idpfHDV7BCR9mPYtXbppgj2iWO1awhvRVFE2shClxWpEyGlzv94CVywCrsPN7SRWGqDYeRRsHJCyqQz7IkdMUhWBNjpcAz1oIGDOhaGYFeGpFEWktJYG4G
                               lEQ37U4+hXj7+bESNbtKGeinv6PfuRU1zUSwppVEVWUnNbvig+9K6FO16a/d5hy1P8FRbtEW5Ynis2PDrxHgt4Xai6tKKMUeqLmzmYKY39GYYWopLstJhBN59m4FXRFApijoAxVj09buip7wMkJIssKUZshoncQ39lj+Jzs9mmf9mmf9ue2fw
                               EwjPft1kPQEgAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidPreview09HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 10
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview10HT = @{}
  $MetroidPreview10HT.Name = 'MetroidPreview10'
  $MetroidPreview10HT.Type = 'Bitmap'
  $MetroidPreview10HT.Threshold  = 96
  $MetroidPreview10HT.Dimensions = New-Object Drawing.Size(120, 112)
  $MetroidPreview10HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAHgAAABwCAYAAADVN7S/AAAJkUlEQVR42u1dS3LbMAwVPTxdtj1O1j1Otr0eu2jtkWWCwAMeKMoJZ7KoS0kkQPw/LNu/0TbfKMLvjTxPmuv5TiG9vwHwaUGYInB6GvX+8MfnF4TZP79/3T9ceou5v+//PHEc
                               5g0R0Xun4TuP9QzWjL5fhdnxWxb4jmBlhedx3DzI1Z7xLObj8+vxxx73dzLfrb0rYx/e0T4+v9rH51f7f+Ief8bf96da+9uk+cK3tsD7n/ZnmdeZIz0nwkaADzrfsjYzi7bKjZE8QVmWOL/DsouHJe7X2eEkzbonh9xsCfPdo85kWT3ZljSfL
                               iNR2adxTS980XVU9onpLcAAaPp89AB514MiDJDNbSkKnsyyzPOdCNsSEAZTOOPdWQhebZgPRLb2G+FABxFUzkRw+yYHx8shXBzII4fpCF7J/mMhLEHETCOA78KilxkoAUQJ5nQtepYzJwpQspmkvv/P71+aHLYjWHoI/X0iy6KbJRJAPazcan
                               4N4Fa2bWuDZ6BgQwFfUpgnN4tlaQg7AE8DKAKDQoIZBc51s7sktd9hloQ4NJIQVpz7aCCSPG7PBqxNnFu2f87uPZAeHwB+R+KmyKYjDhC2rH5aC+DaLJb5PXjuvG0qgjueubJt/8OFJEfC/s/yf8XwtwXmHxGnRWIeQN0jw6sgRhXLw/PN+sz
                               xu2wt2sO+s5+BA/6orEeQa51/F0mWdY+UuBsbuYdTZIphdp5Bv2OiBgtbvf91ANeMHAzleKI4uH/bsk8pYYJKwRIFWLVTKcIjfcf6XgOg0Pj0DLu8p9vA36ciWPGbNknBGgTkuxs1zO8CsUONxcqSlcOX5khBWXUWgmEKEDT0npa+OeZ7MkBc
                               MpXlpRMO0MPcOyB5PgUHKYA+gusJp9QgXkBlrSFW/fa+6Oz1KIe2sA6Ql4orIE8yk9CyR/Z6UMWrOd7vWne1nOyrx3hXGhFYekTczfug8owrh/dnmG1nOJrUCJkM34raUXg54IsEG8YUvNn8vMV7ihYYbI6CwsEFU8C7p8rgSOXe0lp0xKdsd
                               KwwlbvCNi/rwPPkzqbfFsjocMSPIQ3ZGC5ES2+0PcPBhtOT7pIyOjwBf+3gFHSdSOlN0PYtKgX36l8zPU/JGR1uxeTItTTgMsKFDtu3WRFdt4DfNiDDUArzUqRbIwUpbnbmycv6hvFgQjHzyhkdzaiRPriWIx6MaulIfXNo1KAGPCODI2wP7g
                               P+wkl3x4PR8J8y3xxEsCYD3BRqNAEvKRujAdSnAsPaK4SlDKKy1yES5kaTMrIx9nNBe7ApMl/kCqwcq8N6hzqE8P60+uCGAA9tj4DMN8jCAhwkKe2XrTSZNVzt/fT6YDSJzXqqvfOt2R4XGCFHDsWT9TOWd+iUMIITjfYrUt3UITl2ojCrJxj
                               tV4hCtchhTagutLpUX7JFawIwCnn+iqz09OrC4zol3aQygYHaeiuxbNDXnVVdWNhOnuphNxcczQBYyNedZEm8FAdICe9WvFQHu7mUkgVor6eKip5CNXCxuisbPPJxSSXLEV50ZbWg9VEMvwLCvqviAbI4v1meG9jTw2S5kqJidKyUwKG2NkId
                               pfOIeKoIy7CePGckJewcOJHl0i0DpKH6CMlVAvbZ5SYJGi2qUzQrgCfoGWUEpxExSlmVw1LLZOWKrtEa1kDJapk8THCqFiAdNjdDqZoORGb74TPWHcqqBIufGRkakIuUlOorPgc2F11q1KCi00CgWhqioDnEJXDYLAiL5HWzEO8WDZXFItD5I
                               65wpfqmrN6Wkar+I4LD3cU9ShdBMXrnQWnA8qBgB3KRG02680da+hXkG/PwAbZujEUjCgZqUlzMBLEEJ1Jt3D2nWy5lB13U7AYtTJ0CPChI1aYW9McRzOiXPNkdSWWTzPSkkdkGWB1hTlERpWcxdslmk20GwJ37LhEEoy0cUK3braVPbq9fsj
                               jDERYkf4EJFtWzueyLJSIcJYD8jDqrl2T73RpNOVdAw7axHezxDCW10n3hKIASFqJCMBaOevFOMcUe5aMjc+gE+fxSAHdYQ8+9ifxROM6JyDXvh5pVmWWCKG47SMb3emcYnDbb5u9661b6LLePa9zmNoN1RE+4RinIwenlE+9+e+IcPe6Fzs/
                               0M1h0leo9XWiviQiSrRmFmq35Lk3ahKpLKouemUnp+ZbFg3TVgZTBuhCMat1vVdpyteGSwajWjcqmkzT3txxShX8mS/O4Hn+omoHgg2uMTkWRDjMXrexfA8F7dZtxpalX7V9gtOT5pyD46WaPAXLDpSXOjMUpQJzhXz+TRT/ZqtZqNicLh+9P
                               6HznKc3Hmq8s/ZbcM9OtMzAORe3ZV9EsgkyqGrRH0gBaAk6YSM9Mb/F3YVKw68WLXucusXdWUh98z7Cj+JvOoiPNVtKurGEcoI64mXHXMbRer5JpeYbWTjhx0A/QyORiXpPXQ0avHzUBLuJgtRN+6zEZPtQWwxUl+e88mDqH5cJLthZtJn1mE
                               zDG/KuLDEvtslezrqBzQasPRpuAMea/CzcYXjJGKV0ZsRBja/sRIrSAwU9AIWG4Av6gRtkMsgXKM7riwZBaD2aLndsIUZ4PS94nJK/KY+uuqulHU5W8eNAo2GTgW9v1WRZIPMUrRXjC+WhRjlQJANIOw1MK6EDBaFG25aTi7BDhqSKjEgC0BB
                               tk1j5NcmjMQ3BW6eSqbHBSiLBnw3ps2rAdvGLpZKacmnWtXq9CEAosMDRt5ILos0e45qjjsMm6Vu/J7BulQ2VzzFB14dm2pNX+NlId9X6Kkd07QfN+lsFg+GxJs+TA+tBmaowLnE3wmFEGa7GD3RSVfecw4lw5S0M2+AMKeDDc82sSApZRyM6
                               4dkDSugctGZpCMO75NQFoGchNScRP2kM3DXlQ4zzUrjuHQuwscHh/27at1MmbT1GwAuwyKw3pCcn77n4jyu5F8HrN0Pb/7plS+/+/3N2F1qwKzTkxoZqi18hM1Y69yXfSXuuZiElU0Dz39c5g9Sncb7QfRrCBxdZLdDPEPcxovtbdV09uaxxo
                               VFv2EsVRqAstKy1OgMNNwo9rRPcEvHsjO4IQG7yg84vnA2Cv5+4zUl7woEkYUgLSgMumEBiIpkrQstDMng00kx7zPW69JmlxXgrpaH9RVuipB2ooRxoBeHCLuWfNYUcHRbZYkU6Wo1Ouc5Vk5nHPgQhQSo2UpmSZcqTRy6EU9mxWqM6MU2sx4
                               1W8etVrIw6Ab9WYpWzLK6TLdlmmJdd5iYUGeL/1mWIwRSIs+mf8jO8x/gKP/LYtFp5KCgAAAABJRU5ErkJggg=='

  CreateImageFromBase64 -ImageData $MetroidPreview10HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 11
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview11HT = @{}
  $MetroidPreview11HT.Name = 'MetroidPreview11'
  $MetroidPreview11HT.Type = 'Bitmap'
  $MetroidPreview11HT.Threshold  = 96
  $MetroidPreview11HT.Dimensions = New-Object Drawing.Size(120, 112)
  $MetroidPreview11HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAHgAAABwCAYAAADVN7S/AAAJkUlEQVR42u1dS5IbIQwFF6ebbY4z6xxntrkeWSR2tdsI9KQnoD1D1Szi0N0gof+HnP6NmmwjC79X8jxpruU7mfT+CsCnOmGKwOlplPvDH59fEGb//P51/3BuLeb+vv/zxHGa
                               10VE652K7zzW01kz+v4hzM7f0sC3BystPM/jZkHu6BnLYj4+vx5/7HF/J/Pdo3dF7MM66sfnV/34/Kr/T9zjT/n78VSP/pI0X/hWcrz/aX+aeY050nMibAT4oPM1a1OzaK3c6MkTlGWJ8xssO1tY4nGdDU5StXsyyM0aMN88ykyW1ZJtQfPpM
                               hKVfSOuaYUvuo7CPjGtBSgATZ+PHiDrelCEAbK5bkXBk1mWer4RYSkAYTCFM94dheDdhvpARGu/Hg50EkF5JYLrNzk4Vg5h4kAWOUxH8E72HwthASJmGgF8Fxa9zUAJwEswy7XoWc4cL0DJZtLw/X9+/xrJYT2CpYfQ3yeyLLpZIgHUwsq15l
                               cHbjmlVDvPQMGGDL4kM09uFMsaIewEvBFAERhkEswocC5J75Ic/Q6zJMShEYSwbNxHBZFkcXtWYG3i3Jz+ObuPQHp8APgdiZsim/Y4QNiy+mktgGsza+a34Hnwtg0R3PDM5ZT+hwtJjoTjn+b/suIvOeafETeKxDyAekSGVUH0Kpan56v2mfN
                               32Vq0hX1HPwMH/FFZjyBXO/8ukjTr7ilxNzZyT6dIFcNsPIN+R0UNGrZ6/2sArio5GMrxRHFw/7Zmn1LCBJWCJQrQaqdShEf6jva9CkCh8ekZdnlLt4G/T0XwwG9aJQWrE5BvblQxvwnEBjVmLUseHL4wRwrKqqMQDFOAoKG3tPRkmG/JADHJ
                               VJaXTjhAD3PvhOT5FOykAPpwrsedUoN4AQdrdbHqt/dFR69ncGgz6wBZqbgA8iQyCS16RK8HVbyq4f2mdRfNyb56jHen4YGlRcTdrA8OnjHl8P4Mte0MR5MqIZPhW1E7Ci8DfJFgQ5+Ck87Pm62naIPB5igoHEwwBbx7QxnsqdzbWov2+JSVj
                               hWmcpfZ5mXpeJ7M2fRpg4wOQ/wY0pCV4UK09Ga0ZzjYsDzpLiijwxLwHx2cjK4TKb1x2r55SMGt+tdIz1NwRodZMTlzrRFwGeFCg+1btYguyeG3dcgwlMKsFGnWSEGKm5158rK+bjyYUMy8c0ZHVWqkD65liAejWjpS3+waxakBz8jgcNuDx4
                               C/cNLN8WA0/DeYrw4iaJMBbgNqVAEvKBujAtQ3BIa2VwhLGURlr0EkzI0mRWRjHOeC9mAdyHyRK7ByrE7r7eoQwvvD6oMrAjy0PQIyXyELM3CQpLRfttKk1nBH76fXB6NJbNpTbZ2vzfa4wHA5ciierJ+xvUMnuxEcaLRfkeqmDsmx44VZWWC
                               0XyEKVT2HNaC6UOtSfckWLQHAyOT5O7LS5dWF53VKuklhAgO19XZi2aCvO6q6MLOdPMXCbi44qgKwkK87yJJ4KQ6QEt61eCkGdnMpJQvQXpeKipZC1XGxmisbLPJxSyXLEF40ZbWg9VEMvwLCvsvAA6RxfrM8N7Cnh8lyJUVF6VjJjkOtbYTa
                               S+cR8VQQlqE9ecZIits5sJDl0i0DpKF6D8lFAvbqcpMAjRbVKaoWwBP0jNyDU48YpazKbqllsHJF12gVa6BktUweKjgVDZBOm5uhVE0HIrP98Ip1u7IqweJnRoYG5CIlpfqKz4HNRbcaxanoVBComoYoaA5xdhw2DcI8ed0sxJtFQ2GxCHR+j
                               ytcqb4pqrelp6r/jGB3d3GL0kVQjN55UBqwPCjYgFzkRpPm/J6WfgX5xjx8gK3rY9GIgoGaFBczQTTBiVAb98jptkvZQRc1u0ELU6cADwpStTkK+uMIZvRLnuyOpLJJZnpSz2wDrA43pyiI0rMZu2SzyToD4MZ9Zw+C0RYOqNZt1tInt9fPUZ
                               zhDAuSv0AFi2LZXPTFEh6O4kB+RJ3VS7L9YY2qnCugYVvfDrZ4hoJa6b5wFEAJc1EhGAtHvXhLTLFH+WjPHFogn18K4E5raLk3kT8Kx1mIXPV+qFmVUSbIwG0HyfhW7wyF0yYle9dbs9KnuX18xG1uM1iH94SPKAU5OK184sNvT5yjxb3Q+ZF
                               +Bo2uUqynC+014UGyNqNwZGu+S5M2oeqSyqJnZlJavqXxIF11IGWwJgSjWvdblbZcbZhkMKp1o7Jpkeb+lkOq8I9kaRbX4w9VMxB8co3RqcjTYeailf17IPiobjOuNLWq/RuMGjx/CYKfbvboINddWmLMWJwCxBn+9ZUs+slW1VazGVk4fH9C
                               4ztPaT7afGXpt+CemWadgXEoSsu+8mYRRFJVpz3SCKDZ4YTx9My0Fn9nJgWbXrzpde4Se2cl9cH3DBuKv+ks2tNsJezKGsYBaoibGXcdQ+u1KpmaZ2jthAMH/QD1TC7mNXktZLT6URPgIg5WO+G3HpPhQ20xXFCS/86DqXNoLrxka9Fq0mc2A
                               WPMv7rI0NQuWzXrAjoXRvXBaBMwxvx34QbdS8YopSs9FqJsbd9DxChg8BNQCBimgD+oUVaFbIHyjK54MKTWg9Fi59ZDlOXDkvcJyauy2Lq7avreVCUrHkYUrDLwte36NAsknuKdIjzufDQvRyoEAI0Ow1MKaEfBqF62ZaTi6BDhUpFRCADagg
                               0ya58mOTTmITiqdHJXNjgpRNiyYS02rdsO3rF0MlJOzbpWr1UhCAUWGJo2ckH06uGuOWo4bKKu1Xsy+3rpUNEc01VduNqW1NrfSqqj3k/Rs3snaN7PMhgMn21plpxYH9pMjXGBswoeM8pgNXawmaKi7xxGnCurNGSFPyCDB8M8vwQhYBuFbMW
                               1A5LW3WnJUAcEY55fAoAWgdyQRPygPTTTkDs1zl3tunEoxM4Cp/fXlFIukzcfomA52GVUGtITko/d/XqU3YrgtZqhHf/dMqWO/3+5uwu1WRUj58SEaopWI7OhdmxNvpP2WlYiJlBBs9zXO4PVh3C/3n4YwQYWW8/ezRD3MKP5WnNfLbk94kC9
                               2rKXKM6AutCy0mwEONwk/LxGdE/AuxPZEYTY4Bmdny0fAHs9N5+R8oI7TcKQEpAKXDaFwEA0VZyWxcjsSaCZ9JhvcetVSYuzUkhD+/OyQks9UEU5Ug/AnVvMLWt2OzooskWLdLIcnXKdqyQzz3t2RIBCaqQKCOisQZjWFBg9Z7zTb4lV0HJsr
                               PQbQGZS72ZMh8YsZVteIV22yTI1uc47LHREwZZ290jfKu+lyj/jZ3yf8Rc//LYtEmNRZwAAAABJRU5ErkJggg=='
  CreateImageFromBase64 -ImageData $MetroidPreview11HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 12
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview12HT = @{}
  $MetroidPreview12HT.Name = 'MetroidPreview12'
  $MetroidPreview12HT.Type = 'Bitmap'
  $MetroidPreview12HT.Threshold  = 96
  $MetroidPreview12HT.Dimensions = New-Object Drawing.Size(104, 128)
  $MetroidPreview12HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAGgAAACACAYAAADnCyxOAAAI6klEQVR42u1dSW7jOhAVDZ4u2z5O1jlOtrke/+LDaYmu6dUgyQ0WEKDbpiWq5npFUm37n8amU5v+P4TvuHHSWMsctHsh89qA61jmMoxjB/J5f37x8fnNXvnn6w/5+cfn9/O7
                               IQnxee1p7MvkpDlI86Dut7tX8yoOwBNx/vO8J36Inz8sjJHo4/Nb/P3+u+dYanxkDtR1lOsNYu4j477Z1EENPTwIMf5FY/djOM2hxlvGBixtb2WHf3uv5xkLC8gaTxRTfgqJHWt0Qdb4MxQG7d0vqVy7f49o7KKe1/msf11clinP3yFjvS6UG
                               NOejKB+i4ylXDPnFiXLibi/7v0hF+CiY9+FJrfYtm0blJCiz9qD82yOlHS8ixCk7NVZIsDpfFRAo2hsWdANxjv2OTyWYvlNBxjZvBNKdGmuQHuC8kFK9vP1x1wzdQsjz9RiKdE425oQxTLMrWnxijKG2yQJklbdze0Sz4RatXl89xSTBUmCRa
                               tSNd4yFrAKT5gYlut17ke7NPIsn98i2mx1z8DYFrHg+R5UsWpx312DWk6k4RQo4tMh/w/M7QX0pdy6B1F4QZ8JqUpmKUHl8FirUkwF4imKo1hd2/PPgP6/PDPnrTrodxvwOTIWjh8U3I8oIjI+o8Yh+NosXqM748AAf2duomkJi4SXUS5aQwM
                               Q9BxNYqzjpXEPhpn7P9bkJ9BwSBpBjEUttSW5q5E4LrOIbZoFDWuqPTfhLJqwz54qCk4qW0MLYe3Zra0EY9PQpHTdU7UDdZPUqxmJVqElI2UQ0RwPkZTfXKg+H0Zgsrp2gEgjkeZeSoFq6fFzMccTg4hn+03jhSShoQKCGKk14SwBnasV3oQ0
                               9ESqtZrLgjyMfNeGXSQGOWCtMPUgI9MadhYlqEowEvE7aM0bLCAH0ytxuJJU2xODkMCPxEOvgK4gK1Q0ggKzKl8zxpRyyOkuAhJRA7AdMhBLCkJc5XQbAZ0UIyIMH1cI7kwBlcU0IEYgc2gUvFVRx6ECGhdqtjfBMMcIRyd1cOm4Y4F+TEDZj
                               MyGPa6KEVws1Ho/aRaEtoyNDL80+7FYRwV4y3WkvffoG94yRhgd6usXuF5Ld9hlUXMaz6D3PqinWJMhRlTuHToxnlJK7+LxY8dE6Y9jvNqo2/tr4ncuF3Al3PPz9YdyY1wKvv+LJQkg/M5tbTRbB6Fd6Lq4q4rHQ0thShQ8WJy4HOARMfWnNg
                               lmP2atE4TewL+7wFKSt9A+H5oldgf08dLcmzTI09yzJAHaerXThAbExGG9FldXoQ27quaeu/tq2Gl+WtrOPZ919zpVV7VtWqwoXMA9VoHe0eseNFRZaClqt7ZoEEjvG6Bo22bryr4iCcVdUpMrQ68byejADQJwAqEIh1PkpiUJSBCuCtjadbX
                               0H7mH9V6WEmQYajmo4H7bdgMSMwNWAsdGqpQgEoF/X0DG5CPsIr0rk6xr5f5ZAVVsec+MjUjcvYuARuZ1HFtVMgSpMhxA+90CSt/j6WDISLqeuO3EwTRPMR2qzdwNO2tnEm3YRXZWW0+4EtLeyPOObOH8CiijYSfVBBaNK+6+hoTjVdoM1D2r
                               YRct8g5zYBCI5rQ2LmZBz1K5fNmygcuDHJt6QcB47l4vn6OamXgYhljUzqh9RsGsJQlqf8cIVA6kUDNY80APHySum42EW1NqKFb1CCMFd5SZeYUCL7cbMDNOeGIhgWCTaH0LBFJkpaVlXcLIEgpSM4FItqlDKoCfL+g7kriMj8/v3zix+zcXR
                               zQAERn7e/95Dsw8tg0DMD1rLtxWIsz78FzPMfNzzy4OOscTwbYqWwWUtTOuuaEWl+liufhJWRI1/34GI73pJhoHM6r/AC+09gd3uogYx09p2BnGorD+MD7gaRuZqftYts9oMeh2+4OUdF5kOpURZbQLMgtTZVtnOxWLq8LXqjc9VyACjAAGct
                               IIdNM7rASt3PTsEKDHTWInjQiMbEUTbYmMuetxzwOce04MQqryaAV/xVrsTJe4TwSkpWgUbNZRRiL9dU8vPsmKo3XOJdZJCa+DjESAypSDYs/IEhMFqiodGtO7g5FV8SjFHWZYcXKWpy5O3ISVuOgGrsiRL62CkV4r9tzrCm/QAWGohR9XJBr
                               rgxE9QrJinUNRLDTTQzPzxIJUQ5KtXV30c9TibrUvqW9JbyXxvMzJeXIvvPkXcE3eOZRZWkddQGUxFz1RKsgo1xwsrj4tBmVYhffhAkoysqwt802UWQlF6nlxxqVbI8kdmU7hJaxNFVoE5cj2Rqmvp7nDOaSWORhdpKfeS0ccznyHXZpVBLT3
                               MkDVq7iPE+coLtAIvOYSSn8rD1cH0veQBV1xHFnZay6NinPluQuikvaTmSFNplUqi+P45fQyQnlWvqOKthCsnwOwyR2bbZGFmWx9xcRTVoAomp3x/qDSGqQK+YjgfJYXu3MWbd3d0KZAj67QDK3iTHRD6u6ECmWw9IPSzB5cnnv43Sa/k8i8R
                               Bj4nJsf+7lzDuryY3AZ86lp9jC4AwRFvhLN9szX7OIp/vRM8z2h9oBRZLB3FEGpo6fii3WQdTPT4W2HuweNblExb2oCUWQkqRmO65en7o8NPHfAW39oi86ZjVbDcy9jrIAzsivaMlQ/qOrVZZTmHoQzCwldwms5kNxiCdTCdssOiooM7UFNKE
                               s4yLmnxhhxCMCMcNRT5tHntNY6u3GpL3iiToUKW5Fl2ztw8J0oWG0BOrKprCBpiVtQshWZj1sxVOcjIhzntviNuw7nQitj0x5JiLwpREsMWCgIhVCUmLNPAH7d4ZOJ2YxMOFlERVf6xDB4Gz6ncUZ/fNizqeFVEcwMGSO9iNAICr+cG+HF8h7
                               KzTxW1EBtagJeldqnmdxUaC0CiAiYUAa1H8RYkSdhKBufwMSmWXNCQrQFnqdBFbV2HDJ4FPLZVPlaM63OKuULij7flaxoe0RIpYdjdIPptUItfHdqb3+Dm7m4pViLFi1atGjRokWLFi1atGjRokWLFi1atGjRokWLFi1atGjRokWLFi1atGjR
                               okWLFi1atGjR3eg/6wg9uZFqlHoAAAAASUVORK5CYII='
  CreateImageFromBase64 -ImageData $MetroidPreview12HT
  #==============================================================================================================================================================================================
  #  Metroid Prime II - Preview Image 13
  #----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  $MetroidPreview13HT = @{}
  $MetroidPreview13HT.Name = 'MetroidPreview13'
  $MetroidPreview13HT.Type = 'Bitmap'
  $MetroidPreview13HT.Threshold  = 96
  $MetroidPreview13HT.Dimensions = New-Object Drawing.Size(104, 128)
  $MetroidPreview13HT.Image = 'iVBORw0KGgoAAAANSUhEUgAAAGgAAACACAYAAADnCyxOAAAKAklEQVR42u1dy47cOAy0Gv66ueZz5pzPmWt+jznsduL2SGIVWZTdQAwMsOuoZYmkSnyJatt/j22xpw3eG9CGfZg+2e/P2htBCwPpA491fzb4+PyiqPXr549n5633sY/Pr2cb
                               dHDuhA59mteeaGveeD3aHH/3bMvMffbtPcKcWafsAE/tDWES2D/cNjJ/xYOOzz4+v+zj88v+J9CfP/D9keCzv+53j3122hn4twG/mwmKO06QDiPaRL77dwUNYMbA95sHk53VYWfJOfz3yyo6SVk7EKInfR4jGtDWELhdtYJ29ccAOGSZSSkRY
                               L+hMVwBhQ91h79+/nj5izCzSkhWjEH97EX9NkRFPTNQRRim36q2d2eQqZlZJSTFbe/HoIBU2fZejyXbtjusoCpmbu8y3l5bxHYrZ9AVOF0k6fdREkacZd8vUBJshaRnJD+ySjwGNYfIKQxVbbooIR3bJtK2BeYiZRDqMfDelzwkIc2R4BZoey
                               kdWsdtMnKnzN4zk8gKxLZSQAL0ie57rVJJYOBwFaTaQiYqaVbm6mE9ztuGeZsj7dEYFzveLC3o+Uh9cR+fXy9EOf+/s/kjjIQ1vVM7Y8asUO+f/Z76N2f+9zJUz4OcbdpsoO7ZDozsquy1YXT2FOFto/GWMqinynqbY6eN9RSKSbtvCgUSZzq
                               3ZQQAFY6eNsr2r2IQFV9JxPhnATtJPGgm6RnXEMiYb998qGGqED6kY7hLPOi8gpEV5IWCKZhj4itVUCuO8Rg7lkmfzetvRwYXkKhMzERls8hjPCgdRkpC5HlEJdn5DWRLDFTR2z2zuY4Uo+d8AvvQtxWE+KVgaX+3GA/qDmN9fGc6HH4fCti1
                               u0mmSrMUtW0ihtJpxZ6S0LJEB1aUXDjU8aAAAxv7fcRQZfOqVRu0EYxzA4AF8aBQUiayypA571F3SqWkz3K+1XsFsipUSZkjI9yDONadsnyfIhhZGv1E4JuBV8T9A51uQFYUk79ArFBK0hcoADB8g3kb5ml3dwrYlSkRZ+hOQrkJx+7ObU+ov
                               Qj8VYWrLwmDX2Hj7UEpOMc9hp7fgPRCsXqmXzAMEtoHlzJoYv0OtReBSj5UaVVu/ypPQsKx2qiPO1pSI6DF0/O9wdogGpoaA6AFtgic9rKbQIUrxiDAPcEMgGqbGO80HUxAMHoegB3UQhB3pb1DHnUM2VMVG34geTKtJEC4eWW+8iIXFGvTlA
                               g4FLAjDctl9s1ipqYUn+h3woYqq/HddEUh6j2SvjwleMZTs9+YYCuYMLWtZu8BRUBiHuzRTt5tD1ppaM5y49gxZQN2t99zSG/4bbTDEYPcwkIJS9mKGGcRL4BYcMJZQR6d9ygUKIJthD8uA1srVm4oZxAZ4363/UJ91DEI3bfZ23ZHAr4VFqp
                               SDlYE8ZR515G5pCAOTIqoUgqWBfEIJslgKxOu2IkJVcMGE4SzCBOfhPKUoESqc3TF+wwKxDvQoJ2hEwODcEzmjDkS/wLho5MGgn05LLzRmqUvv0Elkj31ppBwwkv+59+OkBRN2U2gw/cVlK1ZmlXNR5LqMbFI4+xBUkt8O1XAcA9YxZcfM1xg
                               5yg9KEziI68kBIzUbs1RRJMqKJNZBUVhJYWF6p39QULjW9I2yxzFOVtHoKig4R7R07PuHHFOtszHl4GiKoFiD3AxGl9V2xCjM8Yn4wGo8mY3hZStahuxzMXnbJlMpDSDyjc8cduXFe9phkXxIKtYLSE76CbZna50D5Icy+JBq8oLhH1xd4C6m
                               Xum2E5CmOFGABBG0oYqg/9VbQmGplKeRIZtqg4ec7kGChnVbSkpTKQ8KU6Jp6tG7mJpWdWW/g2jqCggWXWZCFtMaVRBkKlWyPy+9z4zhmnQkakoojSAWYhTJfcZo3hEkgbRPojVCGt8Cjhe7oubSQcZmriqEnwTt8vsSxjErc7yEdcPzcC3Be
                               BUWZjWV7OzEsNA0FHNLky2D5cbG3mzxTBLqdlKuPDKnmSqRMnvc2AMdrWQKNTsFHQpITOb5IjCuQpqI/1kj59EiyU1dAI9yVXc5zBywla5g6IO2/Dxk0icZ6CCfyPMQOM7Jk963mzvSKIppXwrTODfN9JfxfrMRrluiG0zSTS85CaWBENTeXG
                               MvypT1KHMVlBomLP3qusCoiuofLMbpGhd+TAeZlMoFCV5cWJJbSqJJsdsBas1pfIz6nuomFLBsfxozASqFYdqUJWeiyh0RoopVW3EUUmfvq+63ZidV9nxkyBx2xa4Ho1NGmRdSQImtKqVAjFIEfOYqM6GELfYzdIyxM9CuuoYfpktgbh7Fhc7
                               ZwuNt2BbzQpyPlx1f2r13oXur5L7h2aqc9gXB+rqFdLcEgQtDTB6MMu0LT2jWjHxVaeto0JWmQkbYtAV1r238SMh8uJ7IpT3D6V8cY2EJfrDCUKamJBXPKHc9yODQrXPAqtOceHGWz6Z3Pds8rytnMxiD8AtoH5J8jxKyAIt8lZlN8OGKltbp
                               oiQ6aTB1YWUgkhCn1FlXOeVhKzyfLM18JZBMjKeR1DaZ3+jdt77WbJgKiGwIowgcFeN6JAyVL0MHQ9KbPa7mfdgxe1gxIpfVcmRX0HevaeH9zaCGoGUMycposjAvodWxC1cPRnNjzmQhaymycor29gvZZDn+Mti86A6VRZ6u+96kOo5acEMKN
                               uSR1WiDFpWH4BlcvZK5t5q88wJMBO2LV1BCUhRBuxaFdORe8UjtUdLGHShm6SpVxiDDkyq14lZtE3p/XZ/FzeJiMFQ/MmDS0LjtEmfkAG9T7h8ZwbBrptZIdlI9g+7QrOX4V56VXTWtYJeJjtYRZE7XtO3F7NzmMWD7E4rSXFV5gROLOAZQRC
                               n601hrrjuxoNExp1yc0/F9Z3rREflpd2y00HEoQT+kYEY8abuuUmiLpV2IuLQBzgS1In7auaCGjl6qRPie8/wWrwHZdOGo1Jr3n5wPnkedS2dv8GkLu8beVoto+V4XgDPe00IkCHzGjCnnWH1ygT8x7kDYC+YQUz030q0PM87MJByG60wlAlK
                               BHqQBETxU1pto2jyzfEKSPx7KlcPHIhjTic4hZXCZZNZA9OpoGIjLa/zvkXGyF550LWDBq4I+C7QgIGpTPvNHCs5q/DNea8cG7aCJrnTsKHISMWCsirsMf1WQVwlxLlMeBKVCVmvwG00wDa4NyjiKmoiIYL6g+vFXZGssZKxiIaXDQRG5t29u
                               2HiK7LMcfnF9d8u/a4S4hrhwMsclzfGUBUqDxY9VKxa4YqchOhmyJyMuGrDjYQVoLbq8HyvvwbaKMPj88C+5X0j44szYnMffbORQthEbWNqtne4VrFRAlkvTbESZvNijmESc5ejBFQnQand3SVa68SIbqUkuFKgLjZ7AwOQCgBeycT9DYhZpT
                               21dxAmhaUc0fbeOaXr3/Pv+fv8BkEJVtVfIyE9AAAAAElFTkSuQmCC'
  CreateImageFromBase64 -ImageData $MetroidPreview13HT
}

#==============================================================================================================================================================================================
#  BASE64: EXPORT FILE FUNCTION
#==============================================================================================================================================================================================
#  Creates a file from a Base64 string.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateFileFromB64([string]$Base64String, [string]$OutputFile)
{
  # Crop out any spaces in the string.
  $Base64String = [regex]::Replace($Base64String,'\s','')

  # Create the output folder for the executable.
  CreatePath -LiteralPath $TempFolder -NoReturn 

  # Write the Base64 string to a file.
  [System.IO.File]::WriteAllBytes($OutputFile, [Convert]::FromBase64String($Base64String))
}
#==============================================================================================================================================================================================
#  BASE64: FILES AS BASE64 STRINGS
#==============================================================================================================================================================================================
#  Cold Steel III PKA File List INI packed in ZIP file as Base64 string
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UnpackCS3PKABase64ZIP([string]$OutputFile)
{
  # This is the base64 string that is the ZIP file that contains the INI file.
  $B64 =  'UEsDBBQAAAAIAFtgnlL9BQCELTIAAGnHAQAVAAAAQ29sZFN0ZWVsM1BLR0xpc3QuaW5pbJa7jhVBEENzJH4FdT27O2V5JSSASDckIOH/IzQBQfkQ2mLs47qjYV9eX758W2u9+/P719s3/9Tr+x8GJ8R5WYvO66cXg2t0Xj98outw2JlwShwm
          f/wpBiG/fFfn62d1vstTonA0w9E42xTOAGeAM6D4VEBxoDh+PwecK5wDzgHngIupABeAC/zQAbhQuABcAC4Al1MBLgGXQElFSaAkUBIoNRVQCiiFH7EAVwpXgCvAFeB6KsA14BoorSgNlAZKA2VPBZQNlA2UrSgbKBsoGyhnKqAcoBygHEU5Q
          DlAOUC5UwHlAuU+bw8cg+NwJAeTrk66mHQx6eokW1M9k+DEdJ5JcAyOiyMDbMkAWzrAlg4w/J9hC5NEYZJhkj2T4BidB1lNh8PwhFNwejq4F8txL8O9DPcy3Munwr0c9/LnXnAMzjOCrsORdD6l0x3THdMd0x3TYypMD0yPZzoco/Mgq+lwgs
          7/Hkw4NR2cjDE4WeBkgZMFTlZT4WSFk9VzMjgGx+EUnJ4OZpfOLswuzC7MLszuqTC7gdKK0kBpoDSK91Qo3rj3BspWlA2UDZQNlDMVUA5+6AOUoygHKAcoByh3KqBcXOUC7gLuKtwF3AXcVThfUymcL0XxpSi+BMWXovhCsSgU21MMx+D4dAB
          nCmeAM8D5VIBz1LjWOGocNTEVagI3CBSHFgeK8fH0AEpOBZREcWpxojhRnCiuqVBcuEEBpRSlgFJAKaD0VEBpoDReyQZcK1wDroGypwLKBsr+9zcMXIcT4uApRd5A3kA+UwH5oOZozUHNQc2dCjUXNVdrLmrwpYw1ldYEvouxtDiWFMfS4sB3
          MUSh2FBjWmOoMdT4VKjxZx8cmw5QXFEcKA6UmAooAZRAcWhxoDhQnFOhOJ9iOkhO4KTiJB8CTk0FnEJNaU2hplCzp0LNRs3Wmo2aOxVCL0Kvhl6GKnuuqTQ0l4QmfqwUpd/HNISahhpD9fuRPtXz3sBhlQPH+W8Ux4ETU6E8UBOoCa0J1ORUi
          EiNSETUVIgojShE9FSIaI1oROypELE1YiPiTIWIoxFHI2pNpRG1JKIWI/Q9LJ8Koa6hjtCcChGpEYmInkpfyGqEtoY2Qs9UTygceQI1R2vOUwPHxZErt0+lNa1Xbly5Yypd04HQ0NBAaE6FiNSIRERNhYjSiEJET4VpjdDW0EbongqhG6FbQz
          dCz1QIPQg9GooXaK+pNHQvDd1LQvdCqE+FUEeoa6gjNKdCRGpEIqKnQkRrRCPiL5v2jixFDARRdEv1UZUkm4DAwOEREHjsfxfQY82txDyZrZK6GZp5wKFkxJkj5iP3e6lnBBOOCDPq9eZgwi3ChqQPSvqkpF/U8wssSTGRGUXJXZXMKJnR1Oz
          dKOmH5n24y4qgpE9K+kVJX5T0TT0nlsSZyIxNSX8o6S81+zBK+iHpg5I+oUXJ1QU1hDtNgwIqqKENHQjPahnk1Dx5GcQuoIQWVFBDGzrU/GwV7qUNciihghraEHbYBiW0oII2dKBLPfcoCe7lGMQuoIQWVFBDB8IJr0MJbehA901pBgWU0IIK
          aup5dpK4JNztQJeaE51yKKCEipK5DR0IZwqDHApq7hIJFSVXN7ShA+GEaZBDC2roQPMtn4ldVkFy+tXQhg6EuWVQUfNM1dTs26CAElpQQxvC6bdBDgWU0IIKamhDB8KzOwY5NZ/NCUg+rWdR0jcl/aGev2Vjoivm++Ia9N4tM4hdvKnNqHGSl
          v+a2fINum3oOSkTWRGU7BGyIilZkbJiUdIX9W9iMpEVTc3ejZJ+SPqgpE9K+kVJX5T0TUm/KekPND/D7Zea68Mo6YekD0r6pKRflPRFSd+U9JuS/lDS4/mlUfPqpAJaUEEbutTcZRn1+gGdyedfDGTE0OzLIHYBJbSgghra1Pzg1oHwSNoghx
          IqqCHM3A4ltKCCNnQg7HAMciighApq6EDY727oQPdN2wxy6vmVkYTXBLSgghra0KXmvk4FlFBBDR0Ie4ZBDiU0X2QbL7JjBs3fonddavZl1OsrApNPZkx0Bl8Dt5ySoS4jfI4IShbEXJCU7JkyImXE+JfMWwsqSgbWGCjf25/k6w8mTT2PWxK
          XJJjIUTb1TJXEJQkmOlXu51DPPpK4JGOVTL2UTL1zRRs1T95D0gcl/fy4dUKLmgfuomR8U9rP7fe7jlFz+yPP49gYiPf0F/4Y8EpckpAkJVmSlCQtyZ6JmyQuSUhSkrQksleYJC6J7FUmiUuiq1KSJUlJ0pJsSY4kdyZtkrgkIUlJ0pLIebZJ
          4pLMvX7b66PMj+pv+UPut17yBCZJSrIkKUm2JAeJ/++MLmd0ueQ5oyQpyZKkJNmS4Ixu0PtpP3//aWZ/vg1/wAU1tN/lBjmEKWGQQwFhXRrkEK5cBjmEK58vMMPfhj9grG6D0G1/JsEfcDw9HSP4mOYFCS2ooIY29ecHfKD7rmOQQ8/90B9wQ
          gsqqKG/bNtJqhBBEIThK+VYw1ZREJxQEHfe/xaiNL73Z7j8MjqyqltFFN0QbncNcuqXMf5zQfobnFBR49mmnt92OeF1FrSh80puBjkUr+UGOZTUuKH7hg50XysMciighApqaEEbOhDukgY5dCD0yiCn5repgBKqVwoz6tnEiWNCJYTdYZBDAS
          VUUP/6OPwNXtCGDnRfKw1yKCDcrgySL1byxWroaXCizwQmQ7PRBjF73U0zyKGAEmpoQRu6r+UGOZRQQU09X40TblvQhg6EG4ZRz0mcuExCJimTwsQh9tllr6EFbehAeMs0yKGAEiqooUXNL5cbOhBuVwY5FFBCBTWE27VRz105cZmETBITNgJ
          KqKCm5DaLGnmZQwElVFBD67XcIIcCSqighjZ0oPtagdOTciighApa0IYOhLuUQQ4FlFBBDS1oQwfCXdog3GUZxCyghBpa0IZws+NQQAk1hDe6Bjk1fqbfSwWUUEENLWhTz698Tv6d9P7DdzOD/v4xHpMhyYOSPCnJi5K8KckXJfmmJD+U5Jea
          uRsl+ZDkQUmelORFSd6U5IuSfFOSH0ryS808jJJ8SPKgJE9K8qJe55++fDYz6tdb08loyI4h2eGyw2VHULIjZEfIjqSeHZy4TEImY4+cU5ScU9JoShotN2vZsahnBycuk+BEtm5K8kM9p3IyGrLjUjN3o+YZbtIYkoZLI6inwcloyI6kZEdKo
          yhplDSakkbLPVt2LEp2LGlsSvJDycYjjUs9DU5GY+4IoyQfmmeESyMoaYQ0kpJGSqMoaZQ0mpJGS2NR0ljS2NTT4GQ0ZMehZMeRHUd2XEp23NlIo2YjTRpD0nBpBCWNkEZST4OT0ZAdRUnelJzR0liU5JuSjVsah5L8UrLxzkYZNRtl0hiSPK
          hnIycuk9GSrUlJXpScWtJoSvJFycYljU1JY0vjUJJfSjbe2WijJB+aG9ulEZQ0QhpJSSOlUZTkTUm+KMk3JfmhJL/UzJdR842XSWNIGi6NoKQR0khKGimNoiRvSvJFyYlLGpuS/FCSX0pOvLOxjZJ8SPKgJE9K8qIkb0ryRUm+KckPJfmF5It
          u+aLHKMmHJA9K8qQkL0rypiRflOSbkvxQkl9q5tcePZJ8SPKgJE9K8qIkb0ryRUm+KckPNXI3oyQfkjyokacZ9evtnEhjSBoujaAkT0o2pjSKkrwpyRcl+abkRlsah5LGkcalpHFno42SfEjyoCRPSvKiJG9q5GVGST4keVCSJ6X5r3c/MChq
          FtooyYeeH8Ix0dbzT+ZkqI+FTv5XTJ3IY3qN+UhQo3CvUZIHJXlSf74CJ9Io6mlw4jIJTmRrU5IvSvJNSX4oyS/1Ov/89e3Pe1//08hvX96YQc//ZJyTkEly8nw9Trjn+THF5N0PToZkq8sOlx1BPTs4cZmMlpwTck5S0khpFCWNkkZDi5L+m
          n03SH5s/flxGxN5xk0m+kzIJGVSc3K3TI5MLifzvd3kvYOS947nvTnRZ0ImyYncJeQuScldUu6SsjVla1GytWRHzR1h1NwRNm8WJjuGZIdLIyhphJwaLzve/Xr33r6YGelkkEkWuchNHvKCbqSTQSZZZJOL3OQhLxhGOhlkkkU2uchNHvKCaa
          STQSZZZJOL3OQhL1hGOhlkkkU2uchNHvKCbaSTQSZZZJOL3OQhL7iMdDLIJItscpGbPOQFt5FOBplkkU0ucpOHvOAx0skgkyyyyfVC/2JmpJNBJllkk4vc5CEv6EY6GWSSRTa5yE0e8oJhpJNBJllkk4vc5CEvmEY6GWSSRTa5yE0e8oJlpJN
          B5gvzi5mRTgaZZJFNLnKTh7ygG+lkkEkW2eQiN3nIC4aRTgaZZL2w+NmLn30xXZoGmWSRTS5yk4e8oBvpZJBJFtnkIjd5yAuGkU4GmWSRTS5yk4e8YBrpZLxwfzEz0skgkyyyyUVu8pAXdCOdjBcevsLhK9yXV3j/939emhn4/P2DjEJHKaM2
          HbmOQkfNkQ/qnVxLMail0FIOaim1VINaKi1Naqm1tAa1tLS0B7W0tXQGtXS0dAefEkdtOuIet8FnzxjFGOkeH9Q9rntcruiuq2NQV4euDt2Tg7ondU/qnknd07qndc8i96Cu3brjguGDsiNiUH4EIgf1Cf0mUYNaanIP6k23nnLB8kEpVJJ68
          ZWkPrHP4Hy1e/HEz3v/8Tdb95LbVBAEUHRL9evf0BhHhCQEnIAEE+9/F/wccN2uGeemqtN+PIHEgHx+/C4imZppmf6X9xd/fzmcj19fsv88JRbbim8lttK20rcytjK3slhUtqIoj/efTlWzonnRAu3l8flViqZFs6J50aJorWi9aOOmHQ+Pp0
          /vD+eUnj7f8uv55fn2609fvh7Orz9EiqZFs6J50aJorWi9aKNos2hrbypF06JZ0bxoUbRWtF60UbRZtLU3k6Jp0axoXrQoWitaL9oo2izauml/k27FtuJbia20rfStjK3Mt3L4dicikqiZlumZkdkye+bInJkrUSVTMy3TMyOzZfbMkTkzV6J
          JpmZapmdGZsvsiV1uqQZqpieGJjbLTMMmmmmZGI7Mecsp8o/vDq+vj6d/un84XT6LyBYuT4fzA6tuoRyzLVRjKlsox5QB3/T5+eHyev/rQ8me/u++Ph7fHUVkC5fGpAzG4AzB0Bg6w2CYDAtBhUEZjMEZGkNnGAyTYSGYMhiDMwRDY+gMg2Ey
          LAQXBkUI3NT4gHp+HqejiGzh0vbUmZTBGJwhGBpDZxgMk2EhqDAogzE4Q2PoDINhMiwEUwZjcIZgaAydYTBMhoXgwqAIYQgdFzM+Mb5nTy8PymApnPkmvv0bGaLKFj5u5YHl90lSRS2iShXLSauiM9oW3q7DaIzOyQ9H2YMyGIMzBENj6AyDY
          TIsBBUGZTAGZ2gMnWEwTIaFYMrgDMHQGAbDSuEsIgiaQ3oxEbWIukWr1h3x7ii7Lw1FYYMdDrjBHR7whFe2CqywwQ43uMMDnvDKNoUdDrjBA17JXSR5rfT1M34H8YfjtanQHxkeGK7vCpvuTdmMvp7FxjnH3P2nu+d3h+Pt1a7vLIIyGIMzBE
          Nj6AyDYTIsBBUGZTAGZ2gMnWEwTIaFYMrgDMHQGAbDugmffwVRBmNwhmBoDJ1hMEyGhaDCoAzG4AzB0G7Cy1FE6EvbSkdR2GCHA25whwc84ZWtAitssMMN7vCAJ7yyTWCFDXY44AZ3eMATXtkusMIGO305iqAFXcw0eMAr2afR25k+gy5mOl3
          MTHqb6dlPsvu6w6Zom4s9LfaMLvas2HP6usemRbOiOVrQxfmNrmaKO3S62OvVXnH3AU+6OHsWZ69sFXo/R5UuZoy+zrApmtPFXtDFTKOrmeL7d7rYG/Cki51FVzP7fUxgpfdzzOhixuliJuhiptHFTKeLmUFXM8XzmXSxN4u9Re97vrmYUbqY
          MbqYcfo6w6ZoATe6OGfQxcyi95nYXMwobPR1h02Lxt2gi7Ma3OliZ9DFzIQXve80Wulix+hixuliJuAGd3jAE17ZXej9Dl3pYsboYsbpYibgBne6OGPAE170fsagFTbY4YAb3OEBT3jBxZ0nrbDBDgfc4A4PeMIrewmssMEBN7jDA57JKgIrb
          MkuQl+OW1O6mDHY6WIn4AZ3eNDFmZMuZha9zzTaYIcDbskhAitssMOR3QRW+vqZ2Cy1tWiHA+7wgCe8bn0WEZp/n55Fhf7I8MBw/bRsujeVqr0rYrVsRXM0o6+XY+OcF3ORbQIrbFe//dg3v8hWdCv7lm8lttJuykVEMjXTMj0zMnFyzxyZM3
          MlqmRqpmV6ZmS2zJ45MmfmSjTJ1EzL9My45d1FRBiUwRicIRgaQ2cYDJNhIagwKIMxOEMwNIbOMBgmw0IwYVAGY3CGYMBN1QzBAyGwMkUYBoIKgzIYQzBMBFOGzjAY1r/weDqcf+d/4dv9i4iAtMIGOxxwgzs84AmvbBVYYYMdDrjBHR7whFe
          2CaywwQ4H3OAOD3jCK9sFVthghwNucIcHPOGVHQIrbLDDATe4wwOe8MpuAitssMMBN7jDA57wyu4CK2ywwwE3uMMDnvDKHgIrbLDDATe4wwOe8MqeAitssMMBN7jDA57wyl4CK2ywwwE3uMMDnvBKVhFYYYMDbnCHBzzhla0CK2y3VhGBFTbY
          4YAb3OEBT3hlq8AKG+xwwA3u8IAnvLJNYIUNdjje/Of/67mcnt5dZE+6J9uT7yn21PbU9zT2NN/S+9PT879ffz0fPr2e3ni6k9fDVxFYYYMdDrjBHR7whFe2CqywwQ4H3OAOp/sdv4vAeuu7exFYYYMdDrjBHR7whFe2CqywwZH8KAIrbLDDA
          Te4wwOe8MpWgRU22OGAG9zhAaf7vXwQgRU22OGWbQIrbLDDATe4Z7vAChvscMAN7sk/ybab1DpiKIjCW6q6P5J6mIAhgQRC/HDw/jcSgwfte97wo1vUGWiqXxJsOOCEC+5pCzYccMIFN7zhA1/T4eHfEmw44IQLbnjBGz7wNW3BHv4jwYYDTr
          jghhe84QNf0xZsOOCEC254wbPvrwQbDjjhgsf+44cEGw444YIbXvCGD3xNW/Doe/spwYYDTrjg0f/vmwQbDjjhghte8IYPfE1bsOGA87YfkgwnXHDDC97wga9pCzYccMIFNzz6LAlueMFn2oINB1xwwwvGXiRc8IYPfE0n+jrhgtG3EsbeLnj
          BB0bf2fCB8f8VcMI1bAk2HHDDa9qGC254wXs6BNd0CcZ+F9zwgrG/8nY8JAmO2/n6/irB/uL7/G3DASdccMML3vCBr2kLNhxwwgU3vOADoydGz/eHaMMBJ1xww6Pv5U2CDQc89l7fJdi36yFJsOG43bhfjfvVj5dnB5y3171/23DACRfc8II3
          fOBr2oINB5y394cl2HDACRfc8II3fOBr2oINB5xwwX37fFiCDQeccMENL3jDB75uX7Pv8wEk7WHje8AJF9zwgjd84Gvagg0HnHDDC97wgdEThgNOuOB+sofRF+hJwYYDTrie7OGvfW//ybiT3KpiIICiW6rO9vtTIJAgQJESxux/F4xojt7wX
          Mnl8gb88ef7y4+Ie8lbqVvpW5lbWbeyb+XcyvWv3H6e+vzy7f3pr55fvjz/ent9evr0p3z9/hoRKNUHWKjRoIU2Oujxn94iUpZsOXLJLY+8pGtkyJQlW450coVMWbLlyCW3PPKSbtUhE07IlCVbjlxyywNXyJQlG+6QKUu2HHhCpix4hUxZsu
          EjZErOZoRMWbJhhkxZsuXIBStkwg6ZsmTLkUtueeQlH3BCslVFyIQZMmXJliOX3LBCpizZcuSSG3bIlCVbjlxywwmZsmTLgStkyoI7ZMqSDU/IlCVbDrxCMmoiZMIMmbJkwwqZsmTDDpmy4IRMWXCFTFmy5cAdMuEJmbJky5FLbniFTPhIyb0
          rQqYsmCETVsiUJVuOXJL37giZsmTLkUtueWCGTFmwQqYs2XLkkht2yJQlW45ccssDf9N1L6lSwFAQhnck5+SdoS9E8IHaIo6y/12Ig1bL/DWsL9WVDqJ35m2hMTUWjVWj3ttDY2osGnVqhMbUWCTO0Jgai0a9aIXGlLhDY2qU5RmhMSVmaEyN
          +9+4IjSmxqKxamwau8ahcWpcGrfETI1NY9c4NOpFJTSmxqZxaJwal8YtsYbG1Ng0do1D49So97bQmBqLxqqxaezP+PFd5In4J1aN67x++fWNwLuXH98KfPv57fH2o9Dj++Pz1/cvP0QwJ3P5y+fbj/fPzefvds0/+dvjy9fHiYhL7k65pF7SL
          umXjEvmJeuS/b9kXJKXlEvqJe2Sfsm4ZF6yLtn/S4lL8pJySb2kXdIvGZfMS9Yl+3+p8ZRPnx9vz6vHkf/sTnWTlmA97Mnq2of7BbWiNtSOOlAXK3/nypqsZqOwmnZlde2Txl8Hf6KxHtOWnevEfKqzurZ5w2Q1K5sV23UVVvPauhrrMW3ZuU
          7Mpwara59kt3cPuZvOeHGxnmC39y+8//dPugijzy08STpxapfSLhVWu1TsUmV9LuFJ2pNiT/iexmpv76y+b7/tYLVLwy/Zd0/UxWpvXvbmzXpwJ426ezNZj2nbncLq++69WVntUmO1/c7q+/abDla7NFEX6wl2u75Zfd+9qwRqsrr9Ulh93//
          rXCqr3Wqstt9Zj2nbncFq+5PV9+2f2WK1S0uWrhPz8s3qbqlGbT9Zbb+w2n5ltX37c7A21M5q9yer7W9W129GbT9ZD7cL63MdT9Ke8FpjtXd01MEqK9eJefVkdW17x0LdrG6lsyarXSmstl9Zbb+hdtbDGwN1oi5Ws7xZuT2Mmrb9uzaS1fYL
          q+1XVttvqJ3VvHaw2jsn6kLdrG57siZqQa2oDbWjDtT5gnShblT76mX0OE/jBT1ZTxh3fV43esJ4spv1ynqC3aw31hPsZqWznjCexgv6YDXrE3WhbtIdqIlaUBtqZz2BPlhNe6Iu0F982ktKBEEQhOEr5ateSx0QXQl6gLr/LQR3wx852y+is
          rOhd11uJtWlhtA003ofTeJa235ovbqdWtvppbWZPrQ27am1aS+t7eZba9s/Wrv+aPRqD61NO6WW1CG0zLRe7S41pKbUUjpM6+3cG4/GU7prvdZ413+Y9cnts2D28/1uZq27cjet9+H2dl+G3ofv116F/clok7zWZ83EuKa97T9Mn6jbuSsPu6
          a963dPDt2P23k0ntLxxv9XAxQ5KUhJKtIkLdImHZAbKUhJKtIgTdImHVAYyUlBKtIkLdImHVA6KUhFGqRJWqRNOqCKZ/r/rU9yUpCSVKRBmqRF2qQDciM5KUhJGqRJWqRNOqBwUpKKNEiLdEBlJCcFKQVdJxZpgoaRNmgmaYEWlg0zkpOClKQ
          iDdIEuZGcFKQkYYlpRnJSkJJUpEGaIDeSk4KUpCINUDgJX84Zzwc/vn4/zUhOClKSijRIk7RIm3RAbiQnBSlJRRqkSVqkTTqgMJKTgpSkeqY/uurcBqEgCIJoSnPu4fMlkBBCJED+WeCz1e4rjdHO7udxvW5/f9RRQpaUpWRpWYYsU5Yly1bF
          TRaXJWRJWVoWuSdSllalXJbU5SuvBl3Rw3C/nm8zA3OwAEuwAmuwATbBFtg+zQ3MwQIswQqswQbYBFtgsCMNzMECLMEKrMEG2ARbYLCjDMzBAizBYEcbmIMFWIIVWIMNsAm2TpsG5mABlmAF1qctA3OwAEuwAmuwcdo2MAcLsAQrsD7sx0W9o
          1QAxUAA3VJy/7cUtRD84dv/XqwEc8ozM10gl1/39vz1+SjJx9PbZw1eX57e/5Lvn9dHRFTmf2YEtG6444EnXnjjg291wsD2DXc88MQLb3zwrW4wcGL3HQ88q5nXdUbihjseeOKFNz74VmfgxA13PPDEC2988K1ugRM33PHAs7hF4oY7HnjihT
          c++FZn4MQNdzzwxAtvfPCt5h4jEjfc8cATL7zxwbc6AyduuOOBJ15444NvdQucuOGOB5544Y1P8S9bd5ITZxAEUfhKkVnjv6Q9SNhYRtiy5FXd/xYeFqjzRbP7HpElxBaJHgo44QZ3eMATXvCGr+oQHHDCDe7wgGfxVMAJN7jDA57wgjd8VYf
          ggBNucIfHvVOqjMqsbJW9Ei/PynXPJlVGZVa2yl45Kmflqtz37FJlVGZlq+yVo3JWrsp9zyFVRmVWtspeOSpn5arc95xSZVRmZavslaNyVq7KXXkVDlVGZVa2yl457rmkyqjMylbZK/HyrFyVu/IqDFVGZVa2yl45KmflqtyVV2GqMiqzst1z
          S6DOoxSeEimO5CmY/DCP5CmY/LAdyVMw+WE/kqdg8sNxJE/B5IfzSJ6CyQ/XkTwFkx/uI3kKJj+8juQpmOwwQNk7EZ7SU/PUPQ1P09PytD1dlhKUL8JTemqeuqfhaXpanrany1ID5YvwlJ7awxRI3VfdV8NX09PytB+mQPLfQgfli/CUnpqlU
          TkrV+WuvApDIB1wwg3u8IAnvOANX9UBCg444QZ3eMATXvCGr+oUHHDCDe7wuPclqTrgrA7s/369+9fzj/MkSaV8eFxuno7iUUzEtOe6lWlle0mUkKxslJSsBEvapj8qN09HwZhiafJy8+RvTfFyszRZSSs9WKasYPNZEkpYSZZvCi+bJWXFNk
          1WbNNlxTaTm1BauVhSLP2Sl5uno6gxFbhsKZaeKF2Sl5uno2Ds9fItu1Aay0/JSnoJFnsn9KgcBWLarLOkrNhV06NyFIh+2K1Mli6W6+6dt0+v39/+/beMp9dz+/q4nu8vH/Gdj0+/3+eIvv7/56QH6X7548Pb08cv73r+9vry6bw+vf18/vD
          y6T3//0xQCQ44i0OCA+a+wZ0+Ck/piQ8NeMIL3vBVHYIDTrjBnT4KT+mJDw14wgve8FWdoo/CU3pqSAFncUr0UXjiFScJN7jDA57woo/CU3pqnrqn4Wl6Wp42En1Vh+CAE25wp48CacATXvCGr+oUHHDCDe7wgCe84A1f1U1wwAk3+oSVetMk
          +ig88YqThBvc4QFPeMEbvqpDcMBJH4Wn9NQ8dSROOjzgCS940/6zXvRReEpPzVP3NDxNT8vT9nRZ+kPWvePWEcMAFN0SvxK5ACcwEKcwnHr2v4vAxQPMy/JcSBwM1Es8LKMVNtjhgBM+8IUL7uEQoR/RnWwnR1LYYKf3hwJO+MAXLrinVWCFD
          XY44IQPfOlHdCfbyZGK3oNqD+ppE1hhgx0OOOEDX7jgHk4Rmn+Z23uJ0Y/oTlzlcMAJH/jCRT+iO9lOvlMgNf2I7mRMa7YKrMNHBFbYYKeftSXovSThA1/6Ed3JdnKkovegnlaBFbbhKwIrbMMlQj+iK2FXz13d/eL3ncjP5/cLSq8y717+ev
          /68zbw/vFbZBVdxVbxVWKVXOWsclepVZpFZRVdxVbxVYKle5SPt7//Rnh+ff643/rr+zxEQFphgx0OOOEDX7jgnlaBFTbY4YATPvCFC+5pE1hhgx0OOOEDX7jgnnaBFTbY4YATPvCFC+7pEFhhgx0OOOEDX7jgnk6BFTbY4YATPvCFC+7pI7D
          CBjsccMIHvnDBPX0FVthghwNO+MAXLrinS2CFDXY44IQPfOGCe7oFVthghwNO+MAXLriHVQRW2GCHA074wBcuuKdVYIUNdjjghA984YJ72gRW2GB/+T8ZdHIDUQgDQTSlbi8s0fz8sxjNjYLjKwOy+FPSxU8+S0ikLz7ng8yLz/k6mRJpMsgk
          i2xykPNkSeDzD3UzyCSLbHKQk1zkPtkSaTLIJItscoDcakukD1oSaTLIJItscpCTXOQGLdJkkEnWSUukySCTLLLJQU5ykRu0SF/89JZguZhknQyJNBlkkkU2OchJLnJf/GQUizQZZF58XiuyyUFi85RIX/z0lnhKsgSZZJFNDnKS62RJpMkg8
          +InPyWekixFNjnISS5ygxbpky2RJoNMssgmBznJBXLnIZEmg8yDYYkMMski+2RIpMkgkyyyyUFOcpEbtEiTQSZZJ1MiTQaZZJFNDnKSi9ygRZoMMsk6WdLFT35KsJgMMskimxzkJNfFT35KsOyLz5V9X+Fnti6aDDJPDok0GWSSRTY5DqYk0m
          SQSRbZ5CAnuch98ZOfEigWaTLIJItscpCTXOQGQ6TJONiSSJNBJllkk4Oc5CI3aJEGQ6TJIJMssslxcEsiN2iRnIZITlMkpyWS08bUumgyyDwZvPvj0s6R4IaBGIpeCUA3KTH0vpdd3lLf/xZOPJ5Phq9QQpPNVOOkyXVtujct6j+//PsPGvA
          TZlI7TIQooolJXEAEDKDdBAqGRJgIUUQTg5jERdzEAizCRP7DkggTATAnkokimhjEfODl9qivdmSDiRBFNDGAFmEiRBFNsG2KMBGiiCbYdoswEQJtlggTIYpoYhCTuIj7iUiEiQDRBgNmEqKIJgbQIkyEKKKBKcJEiCKaGMQEbhEmQhTRxCBQ
          XRJhIkQBEWEiQJtgMkUYwKreSAZMREARg5gGLiY3sQCLMBECQ99KG/yEd+SJ4JsvOmBgiUBiCbiJBUTETSygRJi4iQW0CBM3sYCJb6wNJkIsICIMtAgTIYpAdXiCkggTIYpoICJMBGgRJkIU0cQgJsDLtbRhABZhICKYlAgTAVqEH/guSYCJB
          USEgUZiESF6AwoiAdlgYgEtwkSIeqIkwsQCIqA3mAhRRANTBOa0BGTDAnCCn9IGEyGKaGIQk7iIm1iARZgIEBEmimhiEJO4gBaBakuEiRBFNBARJkIU0UCLMBECBZE2GDCTEEU0MYhJXABvWtpgIkQBEWEiRBENtAgTIQoYJkI0MEUYuJG0Np
          gIUUQTg5jERdxPLIkwEBHP5LckwkSIIpoYQAQ0EBGc0xJhIkQRTQxiAnlUf/3zQnr99fvmry8/6rQP53Ad7sPj8Dx8Hb4Pr93WYR/O7mh3HV7r4VfYB2z4/ddfW/75wzsY+4N9OIfrcB8ehyf87fNPaTfn5XEf+sxzuA734XF4Hr7gN7+38+W
          xP9qHc7gO9+EBf/jxrx82/OnL1y1/vB/twzlchxv+28WdJW1Ow1AY3pKPJDvJJc0MxVDQTFfsfxcMJYjOe9NVj5MvcWR5yPB3t79ZcMAJF7zhA1/w7dZ6nciHRLyqt5sFx3C3p1lwwAkXvOEDX/ANP24tWHDACRe84QNf8A0/7ljD3R5mwTHc
          +WwWHHDCNdz9wSw44IRruPuDWXAM93hmFhxwwvX6dD6bBQeccMF7uPPfLDjghAve8IEv+IYft9Zw55dZcAx/+0nnw+tNa7jzxyw4hjs/zBpGPhzkw93taxYccA73/GTWcLevWXDACRe84QNf8A0/wx0/s+CAEy54wwe+4Ns98k29nnILDjjhg
          jd84Gv4808+rjX9q7v7g1nDnc9mwQEnXPCGz3C3p1lwwAkXvOEDX/ANP24tWHAMf/z85w74KBhXFJ0hbsEx7D00ekUOf0CBaO4QcNL8QcEbPjQPcNFjh05Lt+AY7jQ1Cw444RruNDQLDjjhgjd84Au+4cetBQvO130b5BYccMIFb/jAF3wPd9
          KaBQeccMEbPvBFf0DBDT/DSLC+z3ELDjjhgjd84Au+h5EQfR/jFhxwwgVv+MAXfA/7vBN93wR/QIHggBMu97NgwQHncI9AZg33wtAsOOAc7oQyCw444RruhDQLDvdesOCAc7gXptOblvtZsOCAEy54v+4bHbfgGO6ENMdwJ6hZcMAJF7zhA1/
          wDT9urWHk60F+nh8+gN8swQEnXPCGz3Cnh1lwvO77GLfgGO7mMwsOOOGC93A3v1lwwAkXvOEDX/ANP24tWHDAOYz06Psot+CAEy54wwe+4Bt+3Fqw4IATLnesYeTr7fmavUp3Cw444XJruTctOIY7P82CA87hv4eLvWAN9/Q0vWnBASdc8IbP
          cOejWXDACRe84QNf8A0/bi1Y7hmvXoC7BYc7sf+e7vHPLDjghMutBQsOOOGCN3zga7jz2Sw44IQL3sM9PZoFx3Dnn1lwwAkXvOELvuHHrQULjteFfOv1t1twDHd7mAUHnHDBGz7DHW+z4IATLnjDB77gG35e9/LSLTiHP//4qe2P+PdzYrfgg
          BMueA/3fGbW8M/f/vFu/3xlx7+9DvyYv+j3xLDce2zv+eZ1H88sOOCEC97wgS/4hh+3Fiz3uJ5+rjrc66t2P0cd7us1B5xwDf/4yTxf9PndgsOtBes12if8vfp3a3346du1YA13fcyCA0644A0f+Bru+reXOl/bK+CEq/tvex1cz/Hj93N+WH
          AM9/HMgmO488csONxasIZ//s3O3/FwC45h1D9Q/8LxCvsX9u/55nVfr1nDHX+z4IBzuMdHs+CA073XsMczkA+B9gvkZ/b+bsEBp3uv18ivXF/+8v2iBcdwr/fNggPO4b4+s+CAEy54u/eCBQeccMEbPvAF3/DjPgsWHHDCBW/4wBd8w4/7WrD
          ggBMueMMHvuAbfl7/M79pwXInthetYe+ffT8GC47XGN8yvD/3/QIsOOCEaxj1LZ9ve30PCw443Vqw4Bju6zULDjjdWrDgGEY8C/Hs8dstOOB0a8Fyx4I13O1jFhzmef7658PJL/oXVhJW0kG2grEHVk3lq6af1vrww+9rwXLnguWuNdyzillw
          wdutBQsOOOGCN3yGO2unRQsO9/MMd1ZOixYccLpjwYI3fNz3cj/T/dLFLDjgHP742/fz+nrV59Zwx8csOOB0P2u4e7lZcAx3fc163aOKW8N+PiF/+q4NDjhf9yzzuvNlOmjBAaf7WcNdf7PggBMueMMHvl73XZNbw54/KsQX7RGr34K0A+3Rq
          2hYcLifBQuOYY9n/NMfptEf+i08LHeM7eX50W/Bh3vVO60Fyx3Y/kz//NWPa9qvJ3s8d8drxL+fgsNyB7ZvWnDACZf7WcPdXma97vZxC47XyNdelcByC9v3NOpXqN/xfOiniMNdH7PggBMueA97/mU/5XALDjjhgg98wTf8DHf8zIIDTrjM8/
          qr+7N5D3f+uAWH+17DXv+K7n9mufW/f+6nbm7BQcudCxaccA13Pk4/z3DHb1q04HDHggUHnHDBGz7wBd/uXO6iBQeccMEbPvDl3gvW6/5s8nU/hW73ehjWcPd3s+CAEy54wwe+hvuthPsDCz5lwU8s+A0FonlM8RBB8xfBWsRnLPicBTxJ0jx
          J8iTJQxTNHTbNHQ58wTf8uMXoSywImLEUYynGUha6jz/9/Q8sOOD837u/iXcLDjjhgjd84Au+4cetBQsOOOGCN3zgC77hxx0LFhxwwgVv+MAXfMOPOxcsOOCEC97wcdeCBQeccMEbPvAF3/Dj3gsWHHDCBW/4wBd8w4/7LFhwwAkXvOHjvhcs
          OOCEC97wgS/4hh/3s2DBASdc8B7uVZxZw72KMwsOOOGCN3zgC77hx60Fyx0LFhxwwgVv+MAXfMOPOxcsOOCEC97wce8FCw444YI3fOALvuHHfRYsOOCEC97wcV8LFhxwwgVv+MAXfMOP+16w4Bj++2+YtWDBASdc8IYPfME3/LhjwYIDTrjgD
          R/4gm/4ceeCBQeccMEbPvAF3/DzCQs+sOBTFnzGgs+9oBYsONx7wRruW0Wz4IATLnjDh/6Aggu+4cetBQsOOOH6zx/7CzhYcMAJF7zhA1/wDT/DPUuaBQeccLlzuYsWHHC69xruL0zNASdc8IYPfME3/Li1YMEBJ1zwHu5nNWbB4d4L1ut+1m
          PetOCAc7j/Zw2z4IAT3vAZ7mdRZsEx3AOOWXDACRe84ePWcge8p/tda7u/MIQFB/0BBQmXey9YcMAJF7zhM9y3DWbBAedwD0jmgBMueMPHHQtOeMMHvty5YLlrwYIDTrjgA1/w7d4LFhxwwgVv+MDXcL8sMgsOOOGC93APkGbBMdwDoFlwwAk
          XvOHjtvhjwOxPxMyb1nAPcGbBASdc8IYPfLn3ggUHnHDB2/0sWHDAOdwvz8yCA0644O1+FqzX9elXNqD3y3u34IBzGONpv2x2C47hzhezhj1e/Yk6LDjgHO7+bhYccA53fzYLjmHvz/0xDiw44IQL3vCBL/iGn+FuD7PggBMueMMHvt1aw93+
          ZsEBp1sLFhxwwgVv+MAXfMPP615guQUHnHDBe7jz1Sw4hpGvPf6bRWu488csOOCEC97wgS/4hh+3Fqzhzjez4Hjd46dbcMAJF7zhA1/wDT/D3f5mwXu429ssOOCEC97wgS/4hh+3Fiw44IQL3vBbv+j5xq3hnv/McmvB2x30eY35KjD/9MeEb
          tEa7v5pFhxwwgVv+MAXfL/uj5XcGvb6ZLeHW3DA6d4LFhzD3b5mDXf9zYIDTriGu73NggNOuOANH/iCb/hxa8GCA0644A0f+HI/CxYcr7u/mPcw1mf9cSgsOOCEC97wgS/4du8FCw44h7u/mwUHnHDBGz7wNdx/YmgWHK97PeQWHHC694IFB5
          zD3f/MggNOuOANH/ga7nw1Cw44h5HPvX5zCw444YI3fOBruPNvetOCA064hnu9ZhYccMIFb/jAF3zDj1sLFhyvez3pFhxwDnf+mAXHcOeHWXDA+Xp3faf3NObHjf61u75mDXc+mwUHnMP9PMus4b5+s+AY7nw2Cw44h5GvG/l6Op5mufcaRnx
          Px9csOOCEC97D3V5mwTGM9jsdP7PgeH37/tXrP7fggNO9Fyw44IRruONvFhxwwgVv+Ax3+5oFB5xwwRs+8AXf8OPWggUHnHDBGz7wBd/w444Fa7jz2yw44IQL3vCBr+HuL2YN+3hWvV51Cw444YL3cPc/s+CAEy54wwe+4Bt+3FrumO7x1iz3
          qP+D8eVBPjyI/4P4P0Fbe/y6+vhuwQHncL8va/cLZDjghAve8Bn++NP3a8GCw60FCw444YI3fF4L9Qs422bBAefrwu8Lv9/YvrH9YPvx7bE++brzof3v+5kPKNAo6AxyC87X6jOY9TqwPdtmwfG6sP921+o/12yX2mbB8Tqwf9L++7M+/aTPP
          yw44IQL3vCBr9fq85sFx+vo/c2C43X2/mbB8bqwf2H/je0HvtpmDfv57vXx+2/Xeq22WXDA+Trw+/DfP0/3B7PggBMueMMHvoZ7BWhOuOANH/iCb/hxa8GCY7hnNLPggBMueMMHvoZ7hWMWHMM9o5oFx3DPiOaAE+7r+fnPn7/65LPPf/pHfw
          FQSwECPwAUAAAACABbYJ5S/QUAhC0yAABpxwEAFQAkAAAAAAAAACAAAAAAAAAAQ29sZFN0ZWVsM1BLR0xpc3QuaW5pCgAgAAAAAAABABgA5IF6Rto91wHkgXpG2j3XAcS1G6vZPdcBUEsFBgAAAAABAAEAZwAAAGAyAAAAAA=='

  # Set the paths to the ZIP file created from the B64 string.
  $TempZIPPath = CreatePath -LiteralPath ($TempFolder + '\CS3Zip')
  $TempZIPFile = $TempZIPPath + '\ColdSteel3PKGList.zip'
  $TempINIFile = $TempZIPPath + '\ColdSteel3PKGList.ini'

  # Create the zip file at the temporary folder.
  CreateFileFromB64 -Base64String $B64 -OutputFile $TempZIPFile

  # Extract the contents of the zip file to the current temp folder.
  ZipExtractArchive -ZipFilePath $TempZIPFile -OutputPath $TempZIPPath

  # Move the file to what I'm assuming will be the CTT-PS Data folder.
  Move-Item -LiteralPath $TempINIFile -Destination $OutputFile
}
#==============================================================================================================================================================================================
#  Cold Steel IV PKA File List INI packed in ZIP file as Base64 string
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UnpackCS4PKABase64ZIP([string]$OutputFile)
{
  # This is the base64 string that is the ZIP file that contains the INI file.
  $B64 =  'UEsDBBQAAAAIANCmnVLQI4eZDlIAADn3AgAVAAAAQ29sZFN0ZWVsNFBLR0xpc3QuaW5pbJa7jhRRDERzJH4FXdv31SnLKyEBRLohAQn/HyEHBFWHsI5m7FPuXs2+vL58+TbGePfn96+3b/6l1/c/AqSMvIxB8vrpJUCD5PXDJ9IEmSAL5HES
          AyRACmSC+C46f/wJMEAKZIIskANyjfDUX747+frZyfcXkhQSmvplACkleHh8wOHHChQIFAgUCBRITdBN6Cbe3USBRIH0AokCiQIJ3dIE3YJutRzIVALdct2CbkG3oDs1tS5IKYHuhNx0uQm5CbmJl2FCd2lqXZBS0i8DSDqJAVIgUwlqL6+9U
          Huh9kLJralLgpQSVNqQ2y63IbchtyF3NLUcSCmB3IHccbkDuQO5gxfmQPdqal2QUgLdC93ruhe6F7oXco+mlgMpJf02k7QgKAlnTSWc40UfFH1Q9PGiMTR1UZBS0rVAAiSdxABJJV1SSZcU0CWVeMnAb2+Mrg2iy0NTHwKklPQhQIKkSzhMEA
          6fIAtkO4kBkkpwZQriyoErB64cuHLgypb6yiClpK8MEiBdizRBMD0GCObAG7v8hIkTJk6YOGHihIkTlqY+IUgp6ROCBEmXcJggRfK/L06QBfI4iQGSICaAh0EdPIzCwyg8jMLDKDyMpakfBkgp6YcBEiAJskC2kxggqQTHWn6shWMtHGvhWAv
          HWjjW1oRjbdTe0N2uu6G7obshdzS1CkgpgdyB3HG5A7kDuQO5qwlyt18hkABJkFKCAtcLXBS4KHBR4NHUBUBKSVcCSSXQfVz3ge4D3cd1c2hqXSUtp6RVlLSKgFZRgsWWsDh6MUiApJMYSqAbrhvQDeimJugm5BKL0xcnFicWlyYsLtypoFJQ
          KVcpqOBnIgtyUxPkJlQmVKarTKhMqEyoLE1QWa1C8v/PtSRpizpMJfwivoR2C+0W2m1NsN79FjgJI5DbLrcht6FyNLUKSClpORAeuWmClBJ+y0sclDi48EGtq6lrgZQS6F7c/EL3uu6F7oXu7f85lHQBENV5NHUlkFKCSg8KPF7gQYEHBfDDU
          0OTyxV+eGq0ipJWEdAqSrDYEhZHLwYJJVAJVwmoBFRSE1QSKgmVhEq6SkIloVKaoFJQKagUVMpVCioFlakJKrNVSDB5Qme6zuSXoLM0QWf1cpJeDppK+BkXXBDEr0UtKB9NUD5YfHzxweJHE4Y+GPr40MeHzqGphyrpoUp6qAAMtdR3V4Kh4U
          ODQ/3uMzW1O0gp6RcDhDoJ5eRnXDmhnFT2V2WWJggWVAoq5SoFlYLK1ISh04dODF2a8AAW/w6bkviqxVU43NaE5Rtrtq/ZWLOx5mjC0ONDD4ZeTRhxfcT1EWto6hFKeoQAjvA3YP1ls0yOHIhhGJjSiLqo/BNz4Qm0n2iP0BRn1+XyhNLK0kL
          p8oSKlRULFccS3uOOX9Yi0JzUHGjak0pB4gQ0nZqWBqSc5N5PedKNnUjsRGIDKT7Tk+4HUk6gmamZ1OA2yxNus7RYJxCvFC+I8bvgbE8o3Vm6UXo8aWkgcQKak5oDzfWEFV2JVQxaTvhMyi/lWFx7wq0bmk5Np+Z+nnRHJ9KAxDMSO5HYAMV5
          v1ueMEphlIK4UlwQL0/QLJSuLF0sxW2OJ2gONCc1B5oDTXuCpvW2SCBvkhyHfzyd4/TnSeOATCcSO5HYgMROII4E8YB4QDxSPCAeEE9PEE+I4ytdBKPMHGVilIlRtieU7izdKL2e9B/nBKU3Sy9K25NWBDKdQNOpaWqwkOcJ4gfxg/il+EH8U
          vwi6YU7kcaJNAZS88oTKiorChXLEypWVixUXE/aKch0ouuDxDMY5eYoF6M8T6h4WfFQka9ufJ8nlTpRqQGVGomkFTnRv5UTaEZqBjWYvTxBU9BUagqa6Qm3mdKA8JlyglFmjrI84cDCgZz9bU+qcKIKA6i4nlBxs6I9aV9OtC+S/8/pFYMOEp
          0m5WmM37hw49TzpLlI1AwahM/48ur7PKnCCQ5ofiOR9FWTZJQTdJQnfD494fPlSfsB2UlGOUHr9oTlbLRudBxP+fmPzDo5jiAEggDoEmfD+u+YYn5K6pldNOcotL2pyB99J4tKtxJzDBX5VN+TU4iGpd6GFQ1bfX89Vr4v1UrMUSrmqO9uopJ
          jhpVYud7j5KMdFflVkf/Um4+mIn8U+VCRT7RUjN6oECedDQ20UaGDLuKuVkMdxT3shswGmmihjQoddNX7QW7OUg11NNU7U21U6CDWPA1NtNS75tnooIt+6pspKpz3NmQ20EQLbVToInb462iig5iFf9SzNTTQRAttVOq7u6j0qLjaRT/1zthV
          RwNNtFXMW+gi9jQa6uqddwwV+URbxehCB13EnmdDHS1U6CL/N3wVVlkbxe5XoYMu+qlvpqj0qIyozKhw2t3Uu87uKvKhIp8q8/cce6vo2O8b7FLRUW9HNTTQRAsVOoj3Ow11NNBEC21U6KCL+HpuQ119P8ysvLd1B4o3vktFXiryq2JH9+uIS
          o4ZVvxhOH8NdfS/dbWGOmJk7+i7OitDRT5V5EtFvtV3ZArRUCryo763sBIdV71buNHwU28+mvoe30p0PIp8qsgX2ipGH3QRZ5sNdTQQO1wNDbTUezuL/exCB7HXaqijgSZaaKNCF8V3Ueznj2w7yZEiiKEwfCWPEZFrBoHEIBohseP+t6BjV7
          /f8ntO21FZ2UkLxA5qXr0TamhB2ItfAtsM8hctM+r+KIzkgxWTe0okQ+8dI5GOoO73K0kxkRlJSUdKR1F360w8mMiMpt5nJBPpWNR7RzOZHW6U1IfuywiBNAQl9aSkXpTUm5L6oqS+qfkQyv+Yucn40FuGHup+25Kw46HmxDBK6kNSD0rqSUm
          9KKk3JfVFSX1TUj+U1HH/0qh5dVIBFdTU/CZzQw8195ZR89EqG49WmYwYmvU2ah64HQoooYIaWtCmZOeBcJOWQQ4l1NCCMHM7lFBBDW3oQNhwDHIooIQaWtCBHmre02dDB3rt3WaQU3euJLwmoIIaWtCGHmrudSqghBpa0IGwMwxyKCG+/m6C
          T51GzatzSOpBST2p+5pgcl8TCGREUTKi5oiSEU1JfVFS35TUDyX1h5r1Mmo+UeNlegMZMST1oKSelNSLknpTUl+U1Dcl9UPJLTrSgZveBgW0IGxaBjkUUEIFNbShA+HU2yCHAsJ2vDaPGeRQvOipQ91fIUfy8fNMfn9g8lCzo42aO+QP+pvID
          P5APO2UDHUZ4TLi/ZMEkiEZGjI05tCkZETKiJQR8w53QU3dP/QkSSaytOfS+QN8ky+/mSzqfm2SuCQhSTKRw23q7pHEJQlJkonukc98qLtZEpdkdMnUh5Kpz+xYRs2TryGpB6X18fWvhIqaB15NyfhFaX2u39CBcPe2UfNoW+7VpuRNsV07xv
          GOQbL0yNJjY8ST8xK8sj+Pvx66iUsSkqQkJUlLsiTZM3GTxCUJSVqSJYnsCpPEJZFdbZK4JNqVkpQkLcmSZEtyJHlmskwSlyQkaUmWJHKebZK4JHPXX7sP9314Gd6HF8m9RAKTJCUpSVqSLclB4nLGG8oZXS65Z5QkJSlJWpItCc7oBr2e9tO
          vP2b279vwG9zQgvar3CCHMCUMcigg9KVBDgWEvjLIIVx5f7sb/jb8Bvuo+6g3hLu3DHIooIYwZRt0z0O/wXHrdIzgbZoXJFRQQwva1L/f8IGeVx2DHLqfh36DEyqooQVt6FA8+8FpH4PuS4yJU/9G+X4g+g1OqKhxbVP3KJI4kgVt6LzIzSCH
          AkqoXuUGOZTUOL37hg70vCoMciighApqaEEbOhDOkgY5dCD0lUFOzXtTASVUUEMbwgnuq274DU6oqXnCXtCGsHc5FFBCBS0I93Yb5FBQ8+Q7Kak3tKAD4XMegxwKKKGCGlrQvt8g/AYfCKfDay2Mui85TVySQMJ6UjIxZWJBDW3oQM+rHFuCc
          iighArqe5/hN3hBGzoQzpoGORRQQgX1q8qoe98lcSRDt0MSvSaQDElHUrKjqFlvyiHsXgb5i9IMYi2ghOZ50wpqaEEbOpTMfV7lBjkU1JzkCRXU1O2VhNsWtKED4ROEUXeTJC5JSJKSlCQtyZJkz+TheR0KKCn5LAU1tKANHQjnSYMcCiihgh
          pa1PwcuaED4XRlkEMBJVRQQwva0IFwljbqfipJXJKQJCUpSRqJQwElVFBTcuJFjXqZQwElVFBD61VukEMBJVRQQxs60POqwPakHAoooYIWtKED4SxlkEMBJVRQQwva0IFwljYIZ1kGsRZQQg0taEM42XEooIQawid6DHJqPOnPkEMB5avcIIc
          CSqihBe1XpUHYUFRACRXUELYvgxyS+7awcxvkEK48uPKhHAoooYIaWtCm7ptaEm7Cv8F9/vrbzKj7V7ZIhqQelNSTknpRUm9K6ouS+qakfiipP9Ssu1FSH5J6UFJPSupFSb0pqS9K6puS+qGk/lCzHkZJfUjqQUk9KakXJfWmpL4oqW9K6oeS
          +kO91r///GFm1H2XSeKSBBOZOiRTXaa6zAhKZoTMCJmR1J0hiUsSkiQT2VOU7CnZUzKjKZnRMqNlxqLuDElckmAiUzclU7d0HOp2SOKSBBOZ+lAyVZ5uN2p2uEnH0O2QxJnIjKBkRsiMkBlJyYyUjqKko6SjqdshiUsSTGTqomTqko5N3Q5Nt
          EuSQ90uSUaHzHgomfHIDHnqwqg5I0w6hqTDpSMo6QjpSEo6UjqKko6Sjqako6VjUdKxpGNTt0MSlySYyNRDydQjU4/MeCiZ8cgMeXbSqDkjTTqGpMOlI6jbIYlLMrpkalIyNWVqyoyipN7U3SGJSxJMZOqipL4p2bql41BSfyiZKM9FGTU7yq
          RjSDpcOoK6HZK4JKNLpiYl9aJka0lHU9LR0rGo2yHJ6JAZm5IZW2ZsmXEoqT/U3SGJSxKSJJO5p42S+tA9hyTORGYEJTNCOpKSjpStKTOKkhklM0pmNCUzWjoWJR1LOjYlHVs6DiX1h5r1ZdTdyEQ6hqTDpSMo6QjpSEo6UjqKknpTUl+UbFz
          SsSnpwO+nSEci1xxKJh/peCjpkO99G4WO/2ycSw4UMRQDr/R+6els4QBI3P8wSE9CYNcsy045E2BYIOBvYgY2jLCRMEoJRsFoJfSjhP4o4cYD41Faw5NEUppg9aOE1Q+MVwnGC+MqwbhuvKG0hiQwjGAkjFKCUTBaCf0oYXFgHCUYB8ajtIYn
          iaQ0wepHCf2rtLciofX370lLiGNXCePXjRtKbtyAYYS+lNC3EvpRQn+U8IkPjEcJ/UcJ/atkfUYo7SeSBIYRjIRRSjDKjQwlNzJgGMFIGKUEo2C0EoyGMUowBsZRgnFgPEowHhgfJfSvEvqrhBuvGxVKblTAMIKRMEppDU/MwEYrYaOx0dgYJ
          WwMNgYbR2k3PDEDG4/SbniSTHbH02LCc0g+SvsJPEkm3EHyKmH5hXGVvO9QQm+EvpTQtxL6UUJ/lNA/Sug/Suiv0v6IemKGb0wo+cYEDCMYCaOU1vAkkZiF1VbCamO1sTFK2BgYRwn9o4T+o4T+VUJ/lbw/obQv8sQMbBihLyXcUTBaCf1RQv
          8oWV83lNAboS8l6ztCaV/sSSIpTbBqhNXEamKjlLBRMFoJRsMYJRgD4yjBODAepTU8MQMbHyVsfGC8Smt4YgY2rtJueGKGb2Qo7YYnZmDDCBuJjcRGKWGjYLQSjIYxSjDGjRNKbpyAYYS+lLBYMFoJRsMYJRgD4yit4YkZ2HiUrJ8Ipb1DEhh
          GMBJGKcEoGK3EXv8oYmKUXDghhGeegGG0BhJYf/89OUIeKybfxGby5VgGkv1wTCHzmB8pJReeUEKvtD9ESNZCmkxwjkkpWX9vKKEvIfqttO+RBMYoreFJIilNsHqU0D9K6D9K6F8l9Ffp//73rx8RIbT/WxOSQtKW/IxAkkjKkwwkiYRWIxlN
          /JX7ddfECO9OvCmxmlgtJazWrnqCM76Dmws3txJubmw0NkYJG4NPP1gdrB4lrJ5d9cTO4J6Dex4l3PPgngerj69mKPlqxq56gjMZSHimkDSS8eR+kLxIrib+7gy8u5Tw7tp3e8IzhaQ1wWcpfJZWwmdpfJbGamN1lLA62BjfqFDyjdpfHUjKk
          wwm3MLtRjByl5HwHJZLCcb+7HuSwYSm39UhBKNj77IkmZiFe0qohUYJn2F/50OCMxlMvm3xG9jDxF8woeTGBAwjGPnP+EMmndvGAUUxAGzpXf8KHcipSnD/XRhQsh44HBBkxK8/X7/jOyJkypItR2555JUPZsiUJVuOXHLLI698sEKmLNly5J
          JbHnnlgx0yZcmWI5fc8sgrH5yQKUu2HLnklkde+eAKmbJky5FLbnnklQ/ukClLthy55JZHXvngCZmyZMuRS2555JUP3pApS7YcueSWR1754AuZsj7M74iQKUu2HLnklkde+WCGTFmy5cgltzzyygcrZMqSLUcuueWRVz7YIVOWbDlyyS2PvPL
          BCZmyZMuRS2555JXvw/Lt/T9Tlmw5csktj7zywQyZsmTLkUtueeSVD1bIlCVbjlxyyyOvfB/Od0TIlCVbjlwfrp9lmLL+5Xvvw/3ThSlLthy55JZHXvlghkxZsuXIJbc88soHK2TKki1HLrnlkVc+2CFTlmw5cskNJ2TKki1HLrnlkVc+uEKm
          LFm/dMs2XiOX3PLIKx/c8eH5jgiZsmTLkUtueeSVD2bIlPXhXzbuZqeNIIii8Ct1VXX1z5JAEiGZOAqJlKx4/7cIGgusW2eW39H0Hdpmh8TSKyy9wtYrPLyzKU3pylB2ZSqHciqXcgutKU3pylB2ZSqHciqXcgu9Ke3OL/rRPb6zKU3pylB2Z
          SqHciqXcgutKU3pyrjz6biR0JSuDGVXpnIop3Ipt9Ca0u58ubZW6Mr44Mv3y7W5qN/07fiX2K014e0PREzOFEwdqW+kbEzG5EzJNDRZIS9jvIxx2gu549xx7kQhd4I7wZ1eyJ3Onc6dSu4kd5I7o5A7gzuDO7OQO5M7kzurkDuLO4s7u5A7m7
          /AGzvWCo8dJGeKkjhthcc0kjMFUjam1OSFx9uQnClK4nQUcjo4HZwOTldyOjmdnE5OD+Us5Jsm3zQ5uwux45V8wgvxBXsU8gl+mN4LeSgL+aMlZ2fhcQjJS+LOKjx2auobKZNpaNrCSCWvGbxmt0Ic6sZDXshDUcgnArMjlDw0goe6kl//XIX
          1ib3lib97f/Ln5V9rTWlKV8aNz2/x9Pbw6/HPq/q4Ui2OEigdJVEGykRZKLsWayiG4iiB0lESZaDMUi7PP77aSfOTFietl/Z6uf5uJ81Omp+0OGn/2bSTXCmCGIqiWwrb0Q4/BYi+hwGT3P8ukBKBvq/f8B5eRBYqSISgCxvCprD1zB5PH159
          evn0TZAn+/jlef789v3z8zMfv/58+vbjd2vCTJgLC2Fd2BA2hS1hW9ipZk2YCXNhIawLG8KmsCVsCzvVvAkzYS4shHVhQ9gUtoRtYadatGf2l6yIF4kivcgoMousIrvI+SdPv14//v7lr5K1TJbTc0bOnnPU62bOlXPnPCmtIa+HIs9kyHrI6
          iGvq6g0kGJRr545V86T0i3nyDlzrpwbWT6dn5QxkOVArJz5fLecnjNy9pwj50w5I+dKuTxnzzlT7pbTckbOnfOkPJYzfapu6WOsnp57xviXL55+/Pjw6n+9ff/q+tJaK3B9fPr2nmoF5MwLyFkUkLNeQM5GATmbBeRsFZCzXUDOTgE1s1ZAzq
          yAnHkBOYsCctYLyNkoIGezgJytAnK2C8jZKaBm3grImRWQMy+QZ58/v79+vP3x4VWrZP/px4fHi0drLUH6I5V4mWBrEuu2gBOC0AmjgPoAk7AIm3AA1gqIJ5kVUCsvoFZRQK1GAbWahEXYhEOoX7cXcEIQ7r/rE3sBtRoF1GreP3+F9fMvwi6
          gbjuAaAQrcD1aWTkhCKOAumcRDqA7YRAmYDTA7AT1Jc0FWE7ohEnYgN0IRgjCJhzAWRmMPxdvDWAjw+RiWrr0FV+nr9LrlHiZYGsS67aAE4LQCaOA+gCTsAibcADWCognmRVQKy+gVlFArUYBtZqERdiEQ6hftxfwAtejGTEKqFUvoFajgFrd
          r1PiIuwC6tgBRCMY4X6ZEp0QhFFA3bMIB9CdMAgTMBpgdoL6NuYCLCd0wiTsAuJJuxGMEIRNOICzMhgf660BzAgjQ+di4o76Dl6xE3z8/t4InuAbX9vpvyMAXaA1hU40ghOC0AmDcP+iJk6AtQLvirwvcl8t0ARaUyiXrjAUdqIXuD+jwhdKn
          RjifKifTjghnsMb/tn/Jv3ZT7xMsDWJdVvACUHohKGeNwmLsAkHYK2AeJJZAbXyAmoVBdRqFFCrSViEA3AjDML9hypxisf7IuwC6tgBxCDcrwniIhxAd8IgTMBcgOWETpiA3QhGCMImHMBZCdI7PqM1hXLpRK5MPcTqfeJVdmMAX+M9k/4RhH
          ZZVWvKypLt6EB39GCLJ0/0Qm/0yW2NfT2kOczY4pzVc7XFuWCLzWCrjXj+RC/0Rp/cbuhAd/RA368x2GTXn4sv9GaLMyd3DHb9fRELjTu6owd65p64bzm6o3F+N7ShA73RJ/dZqR0//4k+J53/hvdGev9l82rWhGHHu3jmfhUqs2qmrMOcfd8
          v7IVAhwUOv/30+vOLp8f7Z1Revnj7Ei8TbE1i3RZwQhA6YRRQH2ASFmEDrBUQF5sVUCsvoFZRQK1GAbWahEU4ADdCEDphEPj+TC/MhIuwC6hjBxCDcL82iYtwAN0JgzABcwGWEzphAnYjGCEIm3AS4C36/dFaY19W5NGOMrW0pqws2Y4OdEcP
          tnjyRC/0Rp/c1tj1GWZssXG22ARbbAZbbCZ6oTf6sPlNeUMb2tnXo3ETbLHpbLEZbG7SCwV2cbnQmy1uOrmjoY19PRo3jg62ONPZYjPYYrPQJ3dvaEcP9Mw9Zn3mdHRHi296rtyroR3d0RO92fWZu6ENHeiNPqn5prVm6PvXBizYdXNGasePu
          w30ZN93VrNk0Tf65B4DPXPPhvbc29DOLp8zdmeLzWSLzWaXTbeVezk6Uk+cn7bQG12fuWKi0x0fW2vs6yHNhDnM2OIuE3c5W5xzcS7Y97lqJsyFBayzxf1d3D/Y4twQ5yb7PlfNhDlsscVdm31vqpkwhx12vctKi42x70017pwtzrk4F2xxrr
          PFZrDvTTUT5rDJFnct9GaLM1s8/7DFuVPPeWPXc25ssXG22ARbbDpbbAZbbCZbbBb73lQzYQ7bbHHXFncdtjh36rlo7HoujC02zr431UyYw4It7gpxV0cP9n1PNRPmsMUWdx123fTSYmNssXH2valmwhzW2eKuwRabyVYb8ZkWW5xb4txGH/Z
          9TzUT5sIi22hoY9/Pq8ads8W5YKuNuLuzxbkuzg22ODfZYrPYYrPRJ/ds7HrHNLbYOFtsgi02HT3Qky3uWOx7U81gmy3OHXbdrNL3pprBSotzzhabQHf0YIs7JvveVDNhDltscddmi81h180uLTbGFhtni02gO1ucGWyxmex7U82EOWyhN1vc
          fdh1c0qLjaEd3dGDLe6c6IXeqf+wdScpVkRRFEWndKtXNS1RUBtWYCvmPwsLCMnY5zb34tyX/yfYNd2MLW+6ObvZBFs3Lt1snN1sgt1skt1sit1sBrvZTHazWeiNPmx9I6SbjbObTbDvDcxhyW7usrkrdnNXzd1g33cw3k32fQfzxgK22PdbM
          IdtdnN3np2GdnSgE13ogZ7ohT7s+zPD/GllbL0rZzebYN8bmDfG22Tfb8EcVuzmbqAneqE3+jx7GPv+mTCHsYPdvJPogZ6PTjP2/SbMGwuYs++3YNwFu7lLdrMpdrMZ7GYz2d2m+R6L3dxtdrdp3j7s5u7onRv7voPxTvq+g3EX7OYu2c2m2L
          oZ0s0m2M0m2c2m2M1msHWDf39lxpabMmc3m2A3m0TXs4ex9Y3h7D+bUHPcTbaj7+9Ee+7OCXSiCz3RC73R52V/NTP2/ZlgoebWmDfGW24CnehCD/bf3y1sPtvv7wXzzgoW9/u018DUYTS/qPDGQi2lm02gE13sF2/8+4/HxrzyUnGREEmREhn
          /5dO7V1//+n/4+fGbmb3MuqwTFwmRFCmRITJFlsgWORQ3ERcJkVS5zDvU2yEyRZbIFjkqzWcIE9FNqHRPpUo3K5VuNlS62RRZIlvkUNJEXCREUqREhsgSOZQyERcJkRQpkSEyRZbIpgwTCZESmSKbMkMkRUrlMhccIlNkiWzKMpFQucwFS2SK
          bJXmqW0iukmRIbJEtsihHBcJkRJZEDcTcZEQSZWrOSzKGZAwE3GREEmREhkik+Im4iIhkiIlMkQOJUzEIblVSmRCyl0kRFKkRIbIFFkiW+RQglfTTMRFQiRFSmSITIqbiIuESIqUyBCZIkvkUMJFhsgUWZRyyEoT0U2IpMgQmSJLZIscSpmIi
          5TIgJyBb+FmJqKbFBkUN5XLXDAoYZeboHcYDaZK93MzRFKkVOQnhu0NyX/fVNAbHHmZCVaHo8MJKTMRF4lLZ8M6dJXLBKeJ+C3//mbq9e7z68uUXCmUUqmUhtJUWkr7prc/vr768v3dne/e2/dXP8zQjg50ogs90BO90Bt9nu2GdnSgE13ogZ
          7ohd7o87Lf/DJD+8t+/9EM7ehAJ7rQAz3RC73R59luaEcHuh79yQzt6EAnutADPdELvdHn2W5oRwc60YUe6Ile6P2yv30wQzs60Ikezw5DOzrQiS70QM9np6EdHehEF3qg56M/maEdHehEF3o82w3t6EAnutADvdAbfZ79m607yY0iiIIwfKU
          35rDEYIERk3ADYuX73wKDZJXjTzYtfRGvsjPt2lZ1uPizGcw+4IQLbnjAE17wVrvBLv5mBrMPOOGCGx7whBe81W6wwwEnXHDDA57wEn83gx0OOOGCZT+3D2awwwEnXHDDA57wgrfaDZb9/Xwwg9kHnHDBsv9fb8xghwNOuOCGBzzhBW+1G+xw
          wHnZb2bmMPuCGx7whBe81W6wwwEnXHDDA57wgrc6DJb9uZnBDQ94qd1ghwMuuOEBL3UkXPCEF7zVGepOuOChHgkv9Sx4wJzf6jXhBWN+B5xwid0MdjjghofaHS644QFPeKnD4FKXwa7ughse8FSPvBw3MzM44Lycj78fzWCH45X/rQ87HHDCB
          Tc84AkveKvdYIcDTrjghge84K0Ogx0OOOGCZT93zwnscMAJF9ywnPf+pxnscMDyfY+/zWC/XP/uL5h9wAnX5cb93bi/+3Z/OuCEC254XB7/zgM7HHDCBTc84AkveKvdYIcDTnUY7HDACRfc8IQXvNVpsMMB5+X5bDPY4YATLrjhAU94wVvtBj
          sccMIF9+X1bDPY4YATLrjhAU94wfvyxv7e/M8OB5xwwQ2Pyy9vLlIfSdDHRNKY8CcTB5xwwQ0PeMJL7XbYxY7e0Qf6QJ/oE32jb/QD/YQ3rdcH9h8BJ43rC32hb/R99CEemB+Yn+gXjXmcPw32wy4O9AkXjesbPc5fWL8aHupRh108tZ8GFzx
          g/P0Wrl8OJ7zgLXZz8c3MHA44L7/7a4MdDjjhghse8Lz8+b3NJzcGziAYJINi0AwGg8lgMdgIwhg4g2CQDIpBM7h2+vPtj9vDFzM7Ej+SOJI8kjqSPpJxJPNI1pHsKzl+LfXv7/eamfB6Kx+iJz9Cx6WYCGUqS9nnckM5lUu5hW7gsbo7eE4E
          eE4keE40eE4M5VSuvx9nlBptEP+rABvEd8jL7jTiwlO5wHOVLcwGnz9Mo6ncwnJlKFPZyiEcqZzCGcpSDuEypStTuZRbuF0pu9rdrygPREgUR+R2RphyoXNpeSRBopLoeiAB0Z1mKWMPn27331/04eH9h6fHb/f3716Sh7dfvzwKnu7ev/jj5
          29mproTuihEKSpRi4ZoipZov5abyEXxSi6HeDTSlaFMZSlbOZVLuYVuSleGMpUlDFO6MpSpLGUrh3IqtzBN6cpQprBM6cpQprBdGUoMl7KVQzhM6cpQprKE05SuDGUqS9nCZUpXhjKVJdymdGUoU1nKVo7X/EP1nBsBDAMxEGvpXknuvzHHCJ
          FwlhkhU5ZsmCFTlmw58soHK2TKki1HHnnlgx0yZcmGEzJlyZYjVx555Qc3ZcmWA0/Kkg1vyJQlW6688IVMWbLlyJVHXvnkB7+QJVuOJKMiZMqWI1cemCFTlmw5cuWBFTJlyZYjVx7YIVOWbDly5YETMmXJliNXHnnlkx/ckClLthy58oMnZMu
          RKy+8IVOWbDly5ZFP+uiFTFmy5ciFX8iUJVuOZLkjZMqCmbJkwwqZsmTLkSuPvPLJD3bIlC2fdGpCthy58sgrH9yQKVuuvNLlm7Jky5EreTQRMmXJlgMzZMqSLUcu7JApS1755AcnZMqSLUcu3JApS7YceEKmLHhDpizZcuTKI6988oMvZMqS
          VG2ETFmy5ciVR175wQyZsmTLkSuPNKNCpizYKUu2HLnSqglZsuXIlR/ckClLthy58IRMWbLlyJVHXngTvpApS7YcScaJlCVXfrBSlmw5cuWRVz5pxk/XvSSnEQRBGL5SVj+nlxImFIQEhGEUtld1/1t44RAmVVnL/6umZ2iYDRsqOI2zcFbOx
          kl3NWGchbNyNs7OOTgn58a5KA2cxlk4K2fj7JyDc3JunIuygNM4C2flbJydc3BOTrqrtdZXfpwu7+fj5fPR18ev3uc3mAOc8NfnBZUXzJi8fjqMs1AaOI2zcFbOxtk5B+fk3DgXZQGncRbOytk4O+d4ys0PL7cfAfgEN397OR8J7n/u+/FMtH
          /u19vp5QOQTB8LT0xzeeLlAKf9TwNNDXJrM1rl91+n8yOvl9bh9uj7/vO2O4AgFqQEqUFakB5kBJlBtiDruxiCWJASpAZpQXqQEWQG2YKEey4IYkFKkBqkBelBRpAZZAsS7rniIb5f3v14foUgi1QjtUg90oy0vuhy3Y/78Te+tT23v+7+78+
          ptfoBK5sY8onrWZW6lFqieueSqGs3rY7ETXrR6gfo9VWrL+3pPk2rQ3u6T9dK68PEkc6ycxpas29Q2bTqK9dEPXOTnqgj8QPySXbtotWRuEmvWh2Jm/b0HTStDu35Pp6fRNfqSNy0p9eeWh2Jm/Sl1ZG4JV6UN0jtSvvI3ukoUptWh/bsiR9T
          6YRWX9KLVkfiJr1pdSRu0odWR+ImfdNKpxgmjnwmr2NI1JH4SvwA/Yqq1aE93yd90m11oX/5rpcbOGIYCKIpkfrrvIEw/yysORqu8vU10b0a2AbcUrQCfbF+q5okJH0c1Es6J+oiXYHaSE+iNlZ5Yz+DtUL89XhSnC3WCvFk1+311zZk0nhYK
          9h1/+j+yM3K17uxVognemetYMeWlZu1Av2g2jfbfaH+s/n++xwRrK/bk9SkWXK5LVl1PXW9sX5NmqQlNzRJTRomnfWthyapSbNEdgarrg9dn6zaNL1Jv+Ji1Y2lG0u/1WbVja1/Gg6rNh39tUd/7WWtYLftFPV7e3Uma4X4LzzhrsaqTU2bOq
          s2dX31YNWmyer3L0lNGiaLVTc26mGtYNf2oy+4rNp0rakF69fkSf0vS8+qeVbdsxqe1fSslmU3MElW/RqN1e/Lv15n1a7B6vf66slacq0LUxcWqzZtVr9/SWrSMDmsFeK/8CQ9kb7LqivXVnqwWlNPVr1vrH7/ktSE2zqrbnTdGKiT9evXJD2
          p0Kxhsll1/7La/RDV+2Qtudaexur3L0lNtO1y22DV9cmq94v1u/ekPEtMNmuF+C88SUsuJwf1sn7LmqQmTZNOyQzUZH0toUli0li1qT8F9XtdHqzaNLRpslaw68Ji1fvN6vf2d3ceVnnBZeXrJVrmv9DkcpKs2tRY9b6z6v1AnawV7Praxaq/
          ZmnTZtUm/TdtHVZtuqx2v0VL3HvsBVtUmxqr3ndWecFAnay6uVgrxH/hSWrSMNmsuvGSy8lh1abLavdHtMxTvLHrbrJWiNt9Y9fdxlohnuLSo7udtUI82WV3sFaIJ7v++slaIZ7ijV13F2uFeIq/fk1Sk+ZJhWfFjZu1gl1aDuvbDU9k47JWs
          tvGFdX7RG2oA3WyVoj/Ijyp/2WJ2WKVpo16QP/wce/IcQQxDIavRLIfMx1aEyjcsnUA3v8WLm/mwo9NP6BBaQKFygjWfkySrL7fz+GkWN1SGu3DbneStQ+73SnWPux2Z7D2Ybc7k7VN2+4s1jZtu7NZ27TtzoV6ox5Wt11GbT9Zbb9Y332XpE
          sOvxms9sawNyarXZp2abHapWWXNut7ySVpk8LkYrU3LnvjZrVLh3QEaqIW6kCdqAt1o16oh7XD+BMfkvZZUjKDtY276zNZ27TtTrG++zZpn6VN+NJgfd+3SfuM70/WDnZ7faFu1Av1Rj2kK1j7CZ+kS07YxL8pTLhfrB3Gk93+dgN1oW7QEcH
          az4ckbVKYJGsHu72d9naxdrDbC4PV9idrm7bdWaxt2nZns7Zp+x37pS9Wu3Sz+r69fFjt0nFLGazt/Amf8AWjHez2QtoLxdrBbi8M1jZtuzNZ27TdzjLaxu1OsbZp253BavuT1fYXq+1v0BnB2s6fsIl9lax2q1htf6BO0hWs7TyNl/GBbr/b
          StYO467/RPikfVY+S0w2a6K+r9tE3vx5fUVEh3HusxZrB7vZHqwd7GZloi7WDuNp/Al+sUkzWPvJ+NUfw/ThV8en0L8sm4wOn5nF6mB3ffftcrZxXqroYLf9J8IlyUmy2n51Gi/jg93+rOVuD6Pfr/ZJmsQ+8S+Kg59Xh03SJPaJe9FPhk++X
          z77+RD9+pT9/hDyvWLl8mDl8mSVr/Lvn4wEUCqV0lCaSktpK11Kt9IRylBKpVIaSlNpKW2lS+lWOkIVSqlUSkNpKi2lrXQp3UpHaIRSKpXSUJpKS2krXUq30hGaoZRKpTSUptJS2krX//T+Xx5AnYpApTSUptJS2kqX0q10gDoFM4CoR0S9Aq
          LeAKLeAqLeVrqUbqUDBAcKaChNpQVEBzYQ9S6lG4ieHqGxgODpDCVoldJQmkpLaQutUILWLbSH0iV0ldAdSqk0lJbSpXQrHaGTSvIJU//sVIRSKpXSUJpKS2kLZSilUikNJbk4s5SGkvz0+y+fdZLTQBAEUfRKOdawRQy2hBCCA/j+t2CN41d
          vX/x0Lyy12kzJlUIplUqplYaQm5IrhVIqlVIrDaUpFC5UQjNNCapQSqVWGkpTqEzJlUpJnrgb6Plt+H7/vZkpQRVKqVRKrTSUptJS2kJuSq4USqlUSq00lKbSUtpCYUquFEqpVEqtNJSm0lLa/+nn/vb1+vTZKEsclzwudVz6uIzjMo/LOi77
          tLidl4cft4vl4ioutrzY+rxcXM3TEut8lX3e6rzkaRm00Mvs9vb5bWZkj5cPYCfjNMg4TTJOi4zTJuN0kHE6yThdZJxuMkzdyDh1Mk6DjNMk47TIOG0yTgcZp5OM00XG6SbDNIyMUyfjNMgwTSPj1MECLMn4J4uM0ybjdIBNsAW2yfAxZWScF
          hmmbWBOxucBlmR8XmANNsAm2FKbBuZgAZZgBdZqy8AcLMASrMD4T10NNsCm2jYwJ8NH7yDjNMGKjM+bjFI3I+PUwYKMz5OM0yLjtMk4HWScTjJK/7i6l1QhYBiAoltK0v9Q8A0EFdH970UQRHOGJwRuaRfQxwX++fy2Tb59+vK9Dz4+f/r6d/
          Lj58eviOjM/5kRMHHhgSdeeOODL37dCQMnLjzwxAtvfPDFr7tg4MSFB554dbPetzMSFx544oU3Pvji152BExceeOKFNz744tddgRMXHnji1VyRuPDAEy+88cEXv+4MnLjwwBMvvPHBF79u3mNG4sIDT7zwxgdf/LozcOLCA0+88MYHX/y6K3D
          iwgNPvPDGB9/mFYkLDzzxwhsfbP91Z+DEhQeeeOHdvCNx4YEnXnjjgy9+3Rk4ceGBJ27nqwiYuPDAEy+88WkmR40YLVKUCGUkLjzwxAtvbO/i152BExceeOKFNz744tddgRMXHnjihTc++OLXPQInLjyaKxIXdn/ihTc++OLXnYETFx544oU3
          Pvji112BExceeOKFNz744tc9AicuPPDEq3lE4sIDT7zwxgdf/LozcOLCA0+88MYHX/y6K3DiwgNPvPBunpG48MATL7zxwRe/7gycuP75N1v3kVpXEAVheEt1Qqeh5YQTtuUAHvX+d+GA06k6kwf/p+p7GwQaCd6vDuqkHtSTelFv6lPbQW3UT
          h3UST2oJ/Wi3tSndqD0gFE7dVAn9aCe1It6U5/aBmqjduqgTupBPakXdblfADWtpteMmllz1Jw1V81yjQRqWk2vGTWz5qg5a66S9RoDqGk1vWbUzJqj5qy5StZrTKCm1fSaUTNrjpqz5qq5a56SAzWtpteMmlmz3GoBNa2m14yaWXPUnDVXzV
          3zlDTUtJpeM2pmzVFz1lw1d81T0lHTanrNcqsNUOJ2ZEquFER2ASVTcqUg8gsomZIrBVFcQMmUXCmI8gJKpuRKQTQuoGRKrhRE8wJKpuRKQbQuoGRKrhRE+wJKpuRKQXQuoGRKrhSVjBIXUAoiu4CSEbmuXFehq9BV6ip1NXQ1dDV1tZR2S0Z
          0dHVk5ZS4gJIRma68JSMKXYWuUldDaSqtloxo6+o0JAeDEnIoTMmVoiVTcqLUg6kHh66m0mrJiLaudrtyoiMHkxIXUDIi05UrhVIqDaWptJS20hEalNCFKblSKKXSUJpKS2krHaFJCVmsmrvmKWmg5DZqpw7qpB7Uk3pRb+pT2yhBbdROHdRJ
          Pagn9aLe1Ke2g9qonTqok3pQl/sdALWN2qmjtqH2Oedvf3316T4BgCJPe3lQurAOndABkhSZIlvFSQwQ2SQOiBiLyyY7eVC6MEYHSzTyoKTPmgDJZgmIuEgay4QIbV4AIDERFwmRVEmWIZvJ8g6mslkcIrIJiMgmISKbIZvJYnCRw+JgCZE8j
          TwoXVhFh4HEB0uKTJFtJOFgSSdJoJEHpQtjTFQZMGMZIotFfksTh0U2K1kOGnGWUTePliBxlWkkIZsJks9QcRVjSd4YOrkwQpdZsjhEnCUg0r0u9GCKTJYEyxCZIkvkuIpV+brxTz5+ef7p87uXjwL2Bx6ff3j/+PNrcp98uA9ver3v3z6jnz
          x78u33XFDXv/5dsqH/l5+ePj559vpvvXr34e3z++HJ4+dXT98+/8s/rgSA8sfHaeiaoKESLbxm1MyaQx83a66au6SBUh5nRqkLp9RFUOpiUOpi1lw1T0m3moPyxwctprzQV81NqQdOyRiUPz5QadWs59Nrjpqz5Fwll9fMmvXsRk2rGTV3zVP
          yrL/5449AXgAQMZXbo3cYgq5yYQ32y2Ds5MI6dMFUubAOvcPoMAWHyFS5sA5dcKlcWIcuuEWOyoV16IwGEVPpDjZyYR22y+gwOxyCIZIiemqKLJEtclgcKhfWoQuaykWL3mEI6kw3KTJEZneNJbJFjsqFdeiMARETcZULnYVKN0uVdtbddohM
          kSWyVbo3HpaESnMwG+lmrtLOLnQZKt3Z6M6myoV16B1Ghyk4VLq3TJV21l1mqXRnt8hhGVC5sA69wxA0lQtFV2ln3XtDJEWGyoV16IJTZKl0T9sq3eyoNLMJlW7WyEWLLqgSKt3TUmSoXFiH3mF0mB2ODmeHq8MtOFW6my+RLXJULqxDZ1wQM
          REXCZEUGSJTZIlskaNyYR0644aIbkJkiEyRJbJFDsuBiIm4SIikyBCZIkvlwgS3yCExQMREXCREUmSoXJjgFFkq3cEtclgMKhfWoXcYgibiIiGSKhfWoQsOkSmyVLrnb5HD4hAxkRBJkSEyVS5McP2W72zcOQ5TQRCE4Sv1dM8aIrEICQhYhI
          je/W8BAYhx/RW+T9Vd47FkJ5b/y4YcillVQXExSkIK0iGDctXdmMAJWZANORTT2APCTEIK0ilX3Y0JHJBJcdum27YgG3IoZv8ISKM8YTGBlIJ0yKC4xklxsUVxsQ05KjMgDZKQgnTKE81hOizggEzIorjS5Ur3Lef63vz58fPz9d2Xt28o158
          ufPv17fu7z/+evn/8/undy8PHzx8iIA2SkIJ0yIBMyIJsyFFpAWmQhBSkQwZkQhZkQ47KeZXP7778eIHn/dc3n/+/O3/e7oi4H/sTThokIQXpkAGZkAXZkKPSAtIgCSlIhwzIhCzIhhyVDEiDJKQgHTIgE7IgG3JUKiANkpCCdMiATMiCbMhR
          6QFpkIQUpEMGZEIWZEOOyghIgySkIB0yIBOyIBtyVGZAGiQhBemQAZmQBdmQo7IC0iAJKUiHDMiELMiGHJUdkAZJSEE6ZEAmZEE25KicgDRIQgrSIQMyIQuyIeeW+8eNfwMRCk0hAQ9DpdAVhsJUWABTtAEu9PDUR6AFgJsaIBVKoSsMgCmaC
          kthKxyBDMBVdFmqIYREKXSFoTAVlsJWOC/QIkKhAR5rKUYoha4wFKbCUtgKR6CFQlNIhVLoCkNhKiyFrXAEMhQa4AlnqQYogNnUFYbCVFiAJxqNJ9wKR6BCoQGecJZqgFLoCkNhKiyFDTDHOwI9FJpCKpRCVxgKU2EpbIUjMEKhKaRCKXSFoT
          ABvMWxFDbgmrosjZWxbmzQ5PMpI0KhKaRCAZ5oxpJmZ7uxAePZMYgpjiyFrXD4YlooNICZSoUCXFOXpTHMdoWhMAGmbgGu0GVprIx1Y0NtA67Sy5LG0gMwyw6XZSg0hQRwdRbgCl2WxjDbFYbCBFx1l6WxMtaNDWOudxnbxg6thbFmLI2Vsa6
          2FLbCATzRjKWxgvEqKxSaQiqUApYOhamwFDbgiWYsjZWxbmwYm8aWsW3s0FoaK2Pd2DA2jS1j29hRI/CSeyg0wBPOUg1QCl1hKEyAKZ+mfAGuwcvSWBnrahtgCrYpOIBr8LI0Vsa6sWFsGlvGtrFDa2GsGUtjZawbG8amsWVsi40A8OIHwYQS
          cIUuc7lSI5hlZZZ1hfECv9m6jyQ3YiCIolfKrCqA7KW8NyG71P1vIRuqj5KW7ycYHUTPdoIpaYaYIWeoGdYMe4bbP2F+gbQ0g2eIGXKGmmHNsGe4zXCf4RrBmsEzxAw5Q82wzhDSCP0TAmiewbhZtn8/+98W/4R5qCTNcI1gzTBPhGaYJ1Izz
          BOlGeaJpRnmia0ZxglLM3iGQLiWdNLkdTt0P3RR4NcXbx+/++rBXy+GJU7WyXXy9ptvfv/nP+GGueQJE0EkUcQmbkAIWAfcKBexG0siTASRRBGL2MSNuBMXYBEm4i8siTARAJ4TkokkiljEPvDt2ce/fmNZVBzKQ3VoH7r91cMHklpPThl6pA
          NxwEQQSRSxgBJhIogkiljAFmEiiDRQXBZwFxFENiwRQSRxB0KEiSCSKGI1QgLKRDYSF/IkJMCNpxJgRSMlwkQQ2SiJMBFEEkUsIATUgSCSKGIDW4QbSyKwbCxvtA6YuIAtwkQQ2bBEmAjiAlKEiQBKhIkgksBzQgZChIlFbKBMLGIDW4SJRWz
          g7kaqGiU1lmTAXIJYJx60lgSYCKKITdwbWyJMBJFEEYu4E9eJh60lAW7cJMJEACXCRBAJbBEmonGXCAMWwSVEcEkRXEoElks6YCIAizAQIrikCC4lgssSwWWLwIKr+iAdMHEBIcJAYbGIOGCgRGCJEGEiiAsoESaCSGCLMHDHkjpg4gJChIES
          YSKIJBawBOwDV6OC4LElIoDN5XbCRDTuPHYdiMYn6YCJJIpYxCZuxJ24AIswEUCIMJFEEYvYxI24n3jYKglwwxIRRBIFhAgTQSRRQIkwEUQ2QjpgwFyCSKKIRWziBoQaqQMmwkBiCREmgkiigBJhIogElokgiljAFmEigLsapQMmgkiiiEVs4
          kbcG0siTASRRBGL2I0tESaCSKIaN4kwEUQSRSxiN+5S4zphIET08kUSYSKIJIpYjZAaecJEEElcjZIIE0EkUcQiNmABccCNJRFXY0sAl7tEmIg/ePftgfT43QfR7x6+1LSHYziHa3gN7+Hb8H34Om0NeziGc7hOh07n8NXPf+PfF8bw+sUzeY
          YYoe/oEe4cNvz83WfuPz8P4x3BHo7hHK7hNbzh968/ScNuR3+f9txzuIbX8B6+wU++fJLgvq+2h2M4h2v64QgLfvHxfMCrB88k+s27w/0n0o7hHC64X3jbwzGcwzW8hvfwbfjezvHC88d90NV728MB9wtseziGc7iG1/Aevg3fh6/T38myk2S
          tQSgMoFvKvUCSNxT7vtdy5P53oVKluTkOz1fAI3Th/YkNB07ccMcD7/jAJ6Z/uRWv+cCBs3itVxw4ccO9eB1YOHDiVrzWOw6cxeuAwoFTT4KG++V9LWg9CQInbrjjUbx2BA6cuOGOB97xgU/8cHdsxWvF4cBZzIn5x0NH8VpROHAWrxWEo5gV
          s7NizjXBOPQkSNyK1zsLB87itQBw4MQNdzzwjg986knwULxGHAdO3HDHA+/4wCemf2XFlntcceDEDXc88I4PPUvw9NGXW4fWCileWwxH8doiOHDihjseeC9eE44DJ26444F3fOATP9wdGw6cl3MtCBz6EUFqCzRtga4nwdC2sGtbOPCJH4rXO
          YUDJ253x4YDJ6Z+bjhw4oY7HnjHBz7vHlvxOpdx4MQN9+K1q3HgxA13PPCOD3wWrxczDpy444H34nVK6UkQOHErXseQfmQwDR7/F6TJE4OnBs8Mnhu8MHhp8MrgtcEbg7cG7wzeG3ww+EgQOHHTjwwmQccD7/jA591jw4kb7sXruocDJ274ai
          /XyztwFq9Ts3idGnoShLZA4qat0PHAu7aBQ9cC6+jCgbN47WycuBevdYoDJ2544B0f+Lyc60KAAzfc8YHP4rUIcODEDXc88I4PPQnOy5zVuXalDpy46Ukw8IHPy33NCA6c+CheI64nQeDEDfe7HzYcxWvL4Cheb18cOHErXlsMJ+7Fa0Zx4Lx
          7bDhw4la8zuG7h467HzYcOHHDHY/L+1pQOIvXbbeY+dsZr309Hw6cl0/m+2Q+Tto77+21P++dUf27f2PDUfx7/kfHA+/F9/luaz3owIkHLu3vT788ru3xs06r47n8+fWPy0+38p5djj/ecODEDQ+8X26032iv8/eOVR4HTj0NHhs8IWi444FP
          /HB3bDhw4qYnQdcWGHjHBz4xT5AbDpy44a4nwcA7PvCJ6XDb9CQInLjhjgfe8XH54bbNn2bc/Kx8wCyO4nUMFa/6OHDihjseeMcHPvHD3bHh+OdY5RP34g/1p7tnua1jGl/12zV+xYETNzzwjg984oe7Y8OBs3i9BnHgxA13PPCOj+L12tSTI
          HDihjseeMcHPvHD3bHhwImbngQdD7xrGzj0NHhMcOpp8NjgicFTg2cGzw1eGLwkeNDT4LEB/cpNT4LAiZu2gY4H3vGBT/ygJ4EP3TYcOHHDvXh9M8aBE7fi9c8lDpy44V683jE4cOKGOx54xwc+9TR4bPCE4KF43X5x4MQN93/u5bVTPAni7r
          7hwHn32HBcXp+4qtf1v/rbl+r1k5MOnLjhXrzuJThw6mnwmKAVr+/YOHDihjseeMcHPvHD3fuGQ0+DxwSpp4E18glB0zbRtQWGtsCuLXDgU1uBkTw2PQ0eGzwhiOq378emp8FjgycGTw2eEYSeBo8Nnhg8NfCPpJ4ETU+DxwZPDOxF19PANgf
          e8YFPPQke9DSgC/ump4E1Qk8DaziBe2qbaNoCXVtg6GlAL89NTwNrhJ4G1kg9DayRTwyeEjQ9DR4b2GbX0+CxgU0MPQ0eG9jErqeBTRx6Gjw2eGLgcJ56Gtjmg54G1HjY9DSwRuhpYI3Utca6AOPAidvdY8OBU0+Chru2wih+P1/1TU+CwO3u
          seHQ0+CxwROCvPthw4ETt+J1B8ehJ0FeTu64yR03uePmy883r29gOnDidvn6ZnY5qld/9M/nn0u0uogDJ26444F3fOATP9wdW/HaWTiK15DqSRDaAnl5Z4T21SIOnMX3VTb4T23fVnt6Gjw2eEIQehrYRP71222bn15vG47itXJwFK8uXR7rI
          XEUr08duOGOB97xcXmnv2tSdNwdGw6cxetowImv/sQ16cWBs3j1HwfO4rUtcGDKx4aj+PP329/v9L/Tv7Vtq1d/cBSv+cCBE7fitalw4MSt+P58yfxkGf/iafC4BOuJ9TR4bPDE4GkJ1ijpafDY4AlBbTNXx3HgxA13PIoZh/XO0oETN9zxwD
          s+itdM47jc13jgwIkbHsU8/1q5OnDihjseeMcHPvHD3bEVr/HS8wr2NWA4cBYzIOvo1YETNz0NHhP04vUIOP65fLIrjuLnX99tGw6cl9eew6Phjgfe8YFP/HD3Hpevw7I4cN4dG6Z8bjj+uW9ri+D+z4PLxljjrRO34nXtxnGZw3us+dCBEzf
          c8cA7PvCJHy6PNR44cOJWvMYPR/EaLxw4ccMdj7tjw1G8ToDitR5x4nF3bDhw4oY7Hviav/1an8VRvMYbR/Hv9dePux8eitd44MCJG+54FK/1jgfe8YEf7o4NB07ccMcDH/jE9Cc3HDhxw/3yYL7XPxPVa75wFP8i696WZKWhAAy/UtbKAbg0
          dG/Ph1Kr9P2fRE2Vdvi8/P6ZhgABeujZe573l2N9NKYD5+bn+o61/3VsZn2N7298/1jzFQdOXHHDHY/Na3tw4Ny8xo8DJ6644Y4HPjb/+vOsBQdO/Fn/Wdb24rp5zR8cOHHFDXc88LF57V8cHzOfLq5/V1nzR09C4MQVN9w3rx2KQ09C4rp5P
          XjbvI4IDpy44ob75rXHceDUXxEqbrjjsXn9Mi0OnLjitnlNET0/IdjieGzxP9Pl5z9LwXy9FszXW9m8pggO3HB/OgI33PHYvGbQ06EDJ65PX9fmtT+fDh04cX06Cw6cuOPx9Mnyrs3rUbkOnLg+HQXz+qvgwIkrbrjjgY/Nv//x0z6+9dhBB0
          5cN7P/cu0/HDg3r/Hg+Lit8eHYvNaHA+fTl67/OTg/oqz14cT141z3mM1r/uN4OgsOnLh+zP6PtX914MQVN9zxwMfHbf3MhmMz+5fjmWV9rvIxxyPX/taB8+mr4MC5ee0/fDwdfP3SgXPz3/N7X34+7we55oeOp7NsZnntOf9yPeDevW7AT0f
          B8fRVNv/2zS9lN+tf75F1bF779+nQfH8WzNevgmMz4zuZTyfz6Vzjw/Gf67of6/yY+VrX/UzH08nXu05ccXv6KpvX9uD4ONf4cOD8uD2Pb13zScfTwdcT992MtzHeseb35uf1pq75pgMnrrjhjsfmdX5tXvsDB05cccMDH/jE1+a1P3HgxBU3
          3P9z4/rV1nzRgfPps2x+jret6xvext853zr3h77muw6cuH6cz/nV2d6erG+NXwfO//x4Jrf8XN9Y26MDJ6644Y4HPj5m/w3231Ge8//geBxreTr0JCSuuD0dgRNXzOuTAV4fn2zAyQ452SEXB/Rar9eBE1fccMcDH3puYW0ADpwfP2f4b+tXL
          HTg1PF0LThwxe3pVjb/vcNTB05cN68z7unrxNfmdQXAgRNX3HB/OgoOzPKz6EkIPQmJK26444EPfD5dCw6cuOKGGU8rOHDiihvumO3tBbO+UXDgxBU33PHABz4xM/ooOHDiihvueOADn5jxnQUHTlxxwx0PfOATM76r4Ni8nuJuXv80dPO6Z+
          LYvK7AehICJ6644Y4HPvRXhBNfT0fBDDgLDpy44o7ZgFpw4MQVN9wx6+tl83qsrafhZXgbfiWEngZfkXoabsPL8DZ8MbjWqqfhNriIpv2Grv2G8XSUafiVENPw6//CN5TU03AbXoa34YvBcVTtNzTs3qkFB05c8cDH063oabgNL8O+X37/9bd
          ScODEFbf/3Mv6r05x4MQVN9z1JAx84BNfT0fBgRNX3HDHAx/4xIwvCw6cuOKGOx74wCdmfLXgwKknoeKGO2bAreDAiStuuOOBD3xidlAvOHDiihvueOADn5jxjYIDJ6644Y4Z31Fw4Kan4Ta8DG/DF8PXhI4Z9Vlw4MQVN9zxwAc+MUfxKjhw
          4oob7pvXj+s4cOKKG+544AOf+Ho6K26444EPfGLWVwsOnHoSKm64YwbcCw6cuOKGOx74wCdmB42CAyeuuOGOGd9RcODEFTfc8cAHPjH74yw4cG7+/sefo+DAiStuuOOBD3zi6+ksOHDqSai44Y4HPvCJGXAtOHDiihvueOADn/j6yjANt+Fle
          D9DKzhwPt0LDpx6EqqeW1hPWXDgxBU33PHQk3DgE1+aBUTBgRNX3HDH4z+Psn6EwoHzY27NYz0X04ETVz0JDXc8Nq//P0pPQuhpuA0vQuppcBFVT8NtcKVNT4OL6HoafMXQ0+ArDj0NvuLU03AbXoRLT8NteBnezxBFT8O+zPUhHI6PY/3aqZ
          6G2/AyvAmxeZ2uOPQ03IaX4W34Yvja8I3hW8N3hu8NPxBST8NteBnehi+Grw3fGL41fGf43uCmVD0Nt+FleBu+GL42fGP41vCd4XuDm9L0NLgpXU/D/or1WYuehNCTkLjitnndtXDgxBU33PHABz7x9XQUHDhxxQ13PDDjy4IDJ6644Y4HPvC
          J2T+14MANdz0NN2HgA596EhhyKzj0JKSehKqn4Ta8CA13PPQ03AZXceBTTwI7rhccOPU03IYXoeppcBENdz0Nt+FleBu+EIaehtvwMrwNXwxfG74hHHoSTj0Nt8FxXpvXu3ocOHHFDXc89CQc+NTTcBteBLYxip6G2/AyvA1fDF8bviGEnoSO
          Bz7widnuWvQ03IaX4W34Qgg9CYmrnobb8DK8DV8MXxu+ITQ9CR0PPQmHngY37MSXZgmt4MCpJ6HqSWh6ErqehtvwIgzNInrRfMNZ9DTchNDT4CtST8P+ivWrS3puYT1Fw4ETV9xwx2Pz+sFaT8NteBnehi+Grwmhp+E2vAxvg2tNPQ234WVwJ
          VVPQsMdD3zoabgNDvLU03AbXMSlp+E2sIgoH+9/aW2ZnyPXH5XUiStuuOOBD3zi6+koOHDiihvueOADn5jxZcGBE1fccMcDH/jEjK8WHJvXu0acuOKGOx74wCe+no6CAyeuuOGOBz7wiRlfFhw4ccVt8/olWZy44oY7HvjAJ742c6PLdfnGiS
          tuH9d1vcGJK264b17PSHHquYX1ixI4N68LIE5cccMdj83rgopTT0LFDXc88IFPfD0dBQdOXPUkND0JHQ89DTfhwCdmG7PgwImrnoab0HDHAx/4xGxBLThw4oqbnoab0PHABz4xW9AKDpx6EipuuOOBD3xiBtwLDpy44oY7HnoabsKhJ+HU0+A
          i2ehRcOhpuAmJq56EpqfBVfTN600MTlxxwx0PfOATX09HwYETV9xwxwMf+MSMLwsOnLjihjseehIOPQknZgtqwYFz83qbhRNX3HDHAx+b1/MBnLjihjse+MAnvp6Osnm9rcOJK264/+vftz9buTlw4oob7njgA5/42rz+dCpuT9fydNOBE7P8
          XvQ03M8wip6E0NNwG16Gt+GL4WvDN4ZvDd8Zvt/C+qMGOHHFDXc88IFPfD0dBQdOXHHDffP6sB4Hzqd7wbF5fTT/dNehJyFx3bw+SsKBE1fc8cAHPvH1dBQcm9fjWRw4N6+rMU5cccMdj6ejPJ2446EDJ6644Y4HPvCJr6ePggMnrpvX357Hg
          fPpq3y8HlLqwKknoeL2dC84cOKKG+54bF7/OQMOnLhuXr9i+nTohjseT2fFfL0WHE+3ggMnbnjg8+lecODEFTfc8cDH5vXfweDAiStuuG9edwgcODevOwAOnLjihjseTz/2PzeI9dQQdx2b11NFHDhxxQ13PPDxdC84cMUNs76r4MCJ6+b1yR
          sOnLjihvvTV8Hxcbu/eVxg27rg4sCJ62aub209dMWJK26b13zBsfm5/6Ks8ePQk5C4bl4XABw4cd28TnAcODevEwoHTlxxwx0PfOATX5vXAcGJK26444HPp6NsXgccB05cn46CAyeuuOGOBz7wia+Pc01gHDhxxU1PQt+8JigOnB9zB4p1B8C
          hY/OaQDhw4oob7njgA5/4ejoKjs1rAuLA+XFbBxQHTlxxwx0PfOATX5vX8ceB++Z1vHHgxBU3fODz6Sg4cOKKG+54/Ocs63jh2LzucJivR8H96dTjY244yQ0ky9ofODav8wsHTlxxwx0PfOATXx/n+gkGx2bGm4yX60Et63jhwHx/Lzhwbl7H
          G8fmtT04cOKK2+Z1/HHgxBU33PHABz7x9XQUHDhxxQ13PDDjuwoOnB9z/iz3zTxTq+sNjw6cuOKGOx74fLoXHDhx3bzOfxw4ccUNdzzwsXk98sGB8+Nc5y8OnLg+3QsOnLhuXucbDpy44oY7HvjYvOYnDpy4bmb+rvdjOnDiihvueOBj85p/T
          3cdOHHFbfN6/4UDJ6644Y4HPvCJr6ej4MD58Xo/putmjn/nfOnM/879qDO/+5pvODav+YQDJ66b1xMiHJvX/MSxeV2vcOK6mfnQmQ9j7S8cOHF9upfN7N+x9i8OnLjihjsem9fxw4FzM8dzrPMTB86PT7b3XK/HgfM/t7L2Pw6cuD7dCw6cuO
          K2eb3/wg13PPCxeR1/HDhxxQ13PPCBT3w9HQUHTlxxwx0PfOATM74sODav+Y4DJ6644Y4HPjav8wfHx3xk2tb7OR04ccUN983r/MOBE1fccMcDH/jE19PB+HL3ul7jwPmfe1nXDxw4ccUNdzw2r+sdjs3rfMeBE1fcNq/5jdvmNf9w4MRVT0L
          T03ATup6EgQ986km4no6CAyeuehpuw8vwNnwhNNz1JAw9DY7qwKeehEtPA6vIoich9CQkrrjhridh4AOfmI2uRU/DbXgZ3oYvhq8JoafhNrwMrjX1NNwGl1lx09NwG16Gt8Gd0/Ghp+E2vAx/lXUnyXHDMBRArySA1LSMnHmOM2xz/1ukgkWE
          flm+LxK0SKol2a5qBz30ZfBkYE02zlxw6MvgyeAlQerLwBJpiYGnvgyeDCy5aktszfXWpi+DJ4OXBq/+C9LktcEbg7cG7/4L8r9kmLw3+GDw8b8g/0uGySeDzwZfDL4afDN4Jkg89GXwZPDSwKWZeMWbdswdH831VKwvgsCJB57N9ViMAycee
          OIVb3jHBz4fHQsOfREkHnjqXqAetHHgxPcA7Zu8mgMnHnjitbkepHHgxANPbP0N78314I2juR68m2vL6osgdG9QexSHtkPigSde8dZcWwIHTnyPt9cSLjhwNte7FA6czbUlcODEA0+84g3v+MDnbbbMXp9yOnDi0VxbCEdzbRgcOJtrfXHgxO
          Ofj3t9mwPnbebjqEtGR3OdL47mOl8cOPHAE694a675woHv8U7O92T9z/pbCL7r/Vru+W0OnHg013zgxCvemn88f14WHDgfHQtOPHAbf3scL5cX754fXP99eBFED2rGcODRXCtwO2pEHLeT46OMAyceeN6e1FvxVsaBEw88m5mvverjwNlM/6P
          642i2fX3iN7Me52O9seg3Pz93B8eD47V+OnDeZn3nUl//fDvKOHDq6w6SAkM/Fmy/3mwOnHg014TjwIlHc32k4cDZXB/xOHDi0fz84mXrvy1PL54XHTjxwBOveMP7beZ/Yz435mfj/Le6BejA2Vx/DseBE4/bUfOFA+ftrPY4cN4e1R6HvggS
          D906TEaYjLByfC/jwHn7eGx/1Ip1//j8YdGBE4/bUf1x4MQDT7zeTuon9QfHx+Px86gdjQNnc+14HDib64rQF0HgxKO5FggHTn0ZPBEMPPGKN7zjA5+PjgUHTjzwxCve8K4vggPzA+eiL4LAiQeeeMWbdsAdH9oOp6bBWLQNQtsgtQ2GtsHEq
          7bDhnd84FNTcC7aBoETD22BiVe84R0fmFNal+a64+JorkdOHDib66UTB0488MQr3vCOD3w+OhYc+jJ4Mnhp8MrgtcEbg7cG7wzeG3ww+NiCev++fdatCwdOPPGKN7w3160PDzzxijds/QOfj44FB87mutXiwIkHnnjFG96b606NA2dzXYo4mr
          mUznYpff/9/e2Ll6+e/+oPUEsBAj8AFAAAAAgA0KadUtAjh5kOUgAAOfcCABUAJAAAAAAAAAAgAAAAAAAAAENvbGRTdGVlbDRQS0dMaXN0LmluaQoAIAAAAAAAAQAYAFRjhWFbPdcBVGOFYVs91wHNLoJhWz3XAVBLBQYAAAAAAQABAGcAAAB
          BUgAAAAA='

  # Set the paths to the ZIP file created from the B64 string.
  $TempZIPPath = CreatePath -LiteralPath ($TempFolder + '\CS4Zip')
  $TempZIPFile = $TempZIPPath + '\ColdSteel4PKGList.zip'
  $TempINIFile = $TempZIPPath + '\ColdSteel4PKGList.ini'

  # Create the zip file at the temporary folder.
  CreateFileFromB64 -Base64String $B64 -OutputFile $TempZIPFile

  # Extract the contents of the zip file to the current temp folder.
  ZipExtractArchive -ZipFilePath $TempZIPFile -OutputPath $TempZIPPath

  # Move the file to what I'm assuming will be the CTT-PS Data folder.
  Move-Item -LiteralPath $TempINIFile -Destination $OutputFile
}
#==============================================================================================================================================================================================
#  CTT GUI: ULTIMATE DIALOG ACTIVATE
#==============================================================================================================================================================================================
#  Simply calls Dialog.Activate() with some other stuff to make sure it pops up.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ActivateDialog([object]$Dialog)
{
  # Do just about everything possible to make that window pop.
  $Dialog.Visible = $true
  $Dialog.WindowState = [Windows.Forms.FormWindowState]::Normal
  $Dialog.Activate()
  $Dialog.BringToFront()
}
#==============================================================================================================================================================================================
#  WIP: CTT GUI: DARK MODE
#==============================================================================================================================================================================================
#  By default, a combobox can not be colored. This manually redraws the groupbox to allow custom colors.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RepopulateComboBox([string]$BrushColor)
{
  # Get both the combobox and event handler.
  $ComboBox = $this
  $EventHandler = $_

  # Set the color of the brush to draw the text.
  if ($WinDarkModeEnabled) { $BrushColor = '#efefef' } else { $BrushColor = '#000000' }

  # Get the text of the current list item.
  $Text  = $ComboBox.Items[$EventHandler.Index].ToString()
  $Font  = $EventHandler.Font
  $Brush = New-Object System.Drawing.SolidBrush($BrushColor)
  $RectF = New-Object Drawing.RectangleF($EventHandler.Bounds.X, $EventHandler.Bounds.Y, $EventHandler.Bounds.Width, $EventHandler.Bounds.Height)
  $Prop  = [System.Drawing.StringFormat]::GenericDefault

  # Redraw the elements with the new colors.
  $EventHandler.DrawBackground()
  $EventHandler.Graphics.DrawString($Text, $Font, $Brush, $RectF, $Prop)
  $EventHandler.DrawFocusRectangle()
}
#==============================================================================================================================================================================================
function GetChildControls([Windows.Forms.Control]$Control, [string]$Type)
{
  # Check if the variable is null.
  if ($ChildControls -eq $null)
  {
    # Create the list of controls to return.
    $global:ChildControls = New-Object Collections.Generic.List[Windows.Forms.Control]
  }
  # Loop through all child controls on the control.
  foreach ($Child in $Control.Controls)
  {
    # Check to see if the control matches the type.
    if ($Child.GetType().ToString() -eq $Type)
    {
      # If it matches add it to the list.
      $ChildControls.Add($Child) | Out-Null
    }
    # Check to see if the child has more children.
    if ($Child.HasChildren)
    {
      # Get all children of the child.
      $Range = GetChildControls -Control $Child -Type $Type

      # Make sure there is actually things to get.
      if ($Grandchildren -ne $null)
      {
        # Loop through the grandchildren.
        foreach ($Grandchild in $Grandchildren)
        {
          # Throw it on the list.
          $ChildControls.Add($Grandchild) | Out-Null
        }
      }
    }
  }
  # Return the list of controls.
  return $ChildControls
}
#==============================================================================================================================================================================================
function SetControlColor([System.Object[]]$Controls, [string]$ControlType, [switch]$FlatStyle, [switch]$Border)
{
  switch ($ControlType)
  {
    "Major"
    {
      $BackColor  = [Drawing.ColorTranslator]::FromHtml('#2a2a2a')
      $ForeColor  = [Drawing.ColorTranslator]::FromHtml('#eeeeee')
    }
    "Minor"
    {
      $BackColor = [Drawing.ColorTranslator]::FromHtml('#434343')
      $ForeColor = [Drawing.ColorTranslator]::FromHtml('#ffffff')
    }
  }
  foreach ($Control in $Controls)
  {
    $Control.BackColor = $BackColor
    $Control.ForeColor = $ForeColor
    
    if ($FlatStyle)
    {
      $Control.FlatStyle = [Windows.Forms.FlatStyle]::Flat
    }
    
    if ($Border)
    {
      $Control.FlatAppearance.BorderColor = $ForeColor
      $Control.FlatAppearance.BorderSize  = 1
    }
  }
}
#==============================================================================================================================================================================================
#  WIP: Enables Dark Mode. Work in progress.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function EnableDarkMode()
{
  $MainDialogPanel.BackColor   = [Drawing.ColorTranslator]::FromHtml('#2a2a2a')
  $MainDialogPanel.ForeColor   = [Drawing.ColorTranslator]::FromHtml('#eeeeee')

  $MainCTTPSCombo.BackColor = [Drawing.ColorTranslator]::FromHtml('#434343')
  $MainCTTPSCombo.ForeColor = [Drawing.ColorTranslator]::FromHtml('#ffffff')

  return 

  # Enable dark mode variable.
  $global:WinDarkModeEnabled = $true

  # Get the controls from the main dialog.
  $Buttons    = GetChildControls -Control $MainDialog -Type 'System.Windows.Forms.Button'
  $CheckBoxes = GetChildControls -Control $MainDialog -Type 'System.Windows.Forms.CheckBox'
  $GroupBoxes = GetChildControls -Control $MainDialog -Type 'System.Windows.Forms.GroupBox'
  $AdvRTBoxes = GetChildControls -Control $MainDialog -Type 'AdvRichTextBox'
  $ComboBoxes = GetChildControls -Control $MainDialog -Type 'System.Windows.Forms.ComboBox'
  $TextBoxes  = GetChildControls -Control $MainDialog -Type 'System.Windows.Forms.TextBox'
  $Numerics   = GetChildControls -Control $MainDialog -Type 'System.Windows.Forms.NumericUpDown'

  # Set the colors of the dialog.
  SetControlColor -Controls $MainDialog -ControlType "Major"

  # Set the colors of the controls.
  SetControlColor -Controls $Buttons    -ControlType "Major" 
  SetControlColor -Controls $CheckBoxes -ControlType "Minor" -FlatStyle
  SetControlColor -Controls $TextBoxes  -ControlType "Minor" 
  SetControlColor -Controls $Numerics   -ControlType "Minor"
  SetControlColor -Controls $ComboBoxes -ControlType "Minor"
  SetControlColor -Controls $GroupBoxes -ControlType "Major" -FlatStyle
  SetControlColor -Controls $AdvRTBoxes -ControlType "Major"

  return

  # Panels on the main dialog. Takes care of many children. 
  $MainDialogPanel.BackColor   = $DialogBackColor
  $MainDialogPanel.ForeColor   = $DialogForeColor
  $MainDockedPanelA.BackColor  = $DialogBackColor
  $MainDockedPanelA.ForeColor  = $DialogForeColor
  $MainDockedPanelB.BackColor  = $DialogBackColor
  $MainDockedPanelB.ForeColor  = $DialogForeColor
  $MainDockedPanelC.BackColor  = $DialogBackColor
  $MainDockedPanelC.ForeColor  = $DialogForeColor

  # The CTT-PS Option Groupbox.
  $MainCTTPSGroup.ForeColor    = $DialogForeColor
  $MainCTTPSCombo.BackColor    = $ElementBackColor
  $MainCTTPSCombo.ForeColor    = $ElementForeColor
  $MainTexListCombo.BackColor  = $ElementBackColor
  $MainTexListCombo.ForeColor  = $ElementForeColor

  # Input/Output GroupBoxes and properties.
  $MainInputGroup.ForeColor    = $DialogForeColor
  $MainInputTextBox.BackColor  = $ElementBackColor
  $MainInputTextBox.ForeColor  = $ElementForeColor
  $MainOutputGroup.ForeColor   = $DialogForeColor
  $MainOutputTextBox.BackColor = $ElementBackColor
  $MainOutputTextBox.ForeColor = $ElementForeColor

  # Operation GroupBoxes and properties.
  $MainOperations.BackColor = $ElementBackColor
  $MainOperations.ForeColor = $ElementForeColor
  $MainOperationsGroup.ForeColor = $DialogForeColor
  foreach ($Group in $StaticGroupArray) { $GroupBox = Get-Variable -Name $Group -ValueOnly ; $GroupBox.ForeColor = $DialogForeColor }

  # Update the image format button tabs.
  $FormatDDSButton.BackColor = $DialogBackColor
  $FormatPNGButton.BackColor = $DialogBackColor
  $FormatJPGButton.BackColor = $DialogBackColor
  $FormatBMPButton.BackColor = $DialogBackColor
  $FormatTIFButton.BackColor = $DialogBackColor
}
#==============================================================================================================================================================================================
#  CTT GUI: CLOSE MENUS WITH ESCAPE
#==============================================================================================================================================================================================
#  Closes the current dialog with escape button. Used for add-button events. Works with any dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function EscapeCloseDialog()
{
  # Check for escape pressed.
  if ($_.KeyCode -eq "Escape")
  {
    # Close whatever dialog was fed to the parameter.
    $this.Close()
  }
  # Check for escape pressed.
  if ($_.KeyCode -eq "F1")
  {
    #EnableDarkMode
    #return

    # Close whatever dialog was fed to the parameter.
    $HotCodeDialog.Show()
  }
}
#==============================================================================================================================================================================================
#   CTT GUI: MOVE DIALOG TO CENTER SCREEN
#==============================================================================================================================================================================================
#  Centers a dialog window to the center of the screen.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CenterDialogWindow($Dialog)
{
  # Use the calculated dimensions (which will be the actual dimensions).
  [int]$NewPosX = ($Monitor.Width / 2) - ($Dialog.Width / 2)
  [int]$NewPosY = ($Monitor.Height / 2) - ($Dialog.Height / 2)

  # Move the dialog to the new location.
  $Dialog.Location = New-Object Drawing.Point($NewPosX, $NewPosY)
}
#==============================================================================================================================================================================================
#  CTT GUI: GET BORDER STYLE FOR FORMS
#==============================================================================================================================================================================================
#  Returns the border style that will be used depending on the version of Windows.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetFormBorderStyle()
{
  # Windows 7 is the only ornery one.
  if ($WindowsVersion -le 7)
  {
    # The window size is locked, but make it sizable anyway. This fixes a bug with this OS that tries to automatically determine the size.
    return [Windows.Forms.FormBorderStyle]::Sizable
  }
  # Windows 8 - 10 can use the fixed dialog and still retain the correct size.
  return [Windows.Forms.FormBorderStyle]::FixedDialog
}
#==============================================================================================================================================================================================
#  CTT GUI: CLEAR TEXT BOX WHEN ENTERING WITH SHIFT HELD
#==============================================================================================================================================================================================
#  Clears the text box if the control key is held when entering the text box.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ClearTextBox()
{
  # Set up the series of checks to remove flags in a variable array.
  $ClearTextCheck = New-Object bool[] 4
  $ClearTextCheck[0] = !$ClickClearText
  $ClearTextCheck[1] = ([System.Windows.Forms.Control]::ModifierKeys -eq [System.Windows.Forms.Keys]::Control)
  $ClearTextCheck[2] = ([System.Windows.Forms.Control]::ModifierKeys -eq [System.Windows.Forms.Keys]::Shift)
  $ClearTextCheck[3] = ([System.Windows.Forms.Control]::ModifierKeys -eq [System.Windows.Forms.Keys]::Alt)

  # Reset the textbox if any of the conditions match.
  if (TestBooleanArray -Or -Array $ClearTextCheck) { $this.Text = '' }
}
#==============================================================================================================================================================================================
#  CTT GUI: GET BORDER STYLE FOR FORMS
#==============================================================================================================================================================================================
#  Gets the dimensions that are needed for the preview windows and returns them as a hash table. 
#  Preview windows are used in the Basic Image Viewer, the Manual Rescale window, and the Process Selected feature.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetPreviewDimensions([int]$Width, [int]$Height, [int]$Square)
{
  # Multiple values need to be returned.
  $Dimensions = @{}

  # If the image is smaller than the window, do not resize it.
  if (($Width -le $Square) -and ($Height -le $Square))
  {
    $Dimensions.Width  = $Width
    $Dimensions.Height = $Height
  }
  # If it's bigger than the window it has to be resized to fit.
  else
  {
    # Calculate the dimensions for the preview so that scaling is correct.
    if ($Width -gt $Height)
    {
      # If width is greater than height, then we need to calculate the height.
      $Dimensions.Width  = $Square
      $Dimensions.Height = [int]($Height / ($Width / $Dimensions.Width))
    }
    else
    {
      # If height is greater than width, then we need to calculate the width.
      $Dimensions.Height = $Square
      $Dimensions.Width  = [int]($Width / ($Height / $Dimensions.Height))
    }
  }
  # Return the dimensions.
  return $Dimensions
}
#==============================================================================================================================================================================================
#  CTT GUI: MINIMIZE ALL ACTIVE DIALOGS 
#==============================================================================================================================================================================================
#  This function is added to all dialogs mentioned below through the "SizeChanged" event.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MinimizeAllDialogs()
{
  # Return if the user wants to minimize dialogs individually. This shouldn't run on every single dialog size change. To catch a dialog 
  # being minimized, just compare the current width of the dialog to a value that the dialog can not reach by resizing the borders.
  if (($MinimizeSingle) -or ($this.Width -gt 200)) { return }

  # Create an array to temporarily store all the dialogs.
  $DialogArray = New-Object Windows.Forms.Form[] 7

  # Throw in all the dialogs that will be minimized.
  $DialogArray[0] = $MainDialog
  $DialogArray[1] = $TexListDialog
  $DialogArray[2] = $HelpDialog
  $DialogArray[3] = $ImgViewDialog
  $DialogArray[4] = $ResourceDialog
  $DialogArray[5] = $OptionsDialog
  $DialogArray[6] = $CombineDialog

  # Loop through all the forms in the array.
  foreach ($Form in $DialogArray)
  {
    # Don't force minimize the window that was clicked. This will cause weird bugs.
    if (($this -ne $Form) -and ($Form.Visible))
    {
      # Force minimize all open dialogs.  
      $Form.WindowState = [Windows.Forms.FormWindowState]::Minimized
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: HIDE ALL ACTIVE DIALOGS 
#==============================================================================================================================================================================================
#  Hide's all visible dialogs. Really only useful for when shutting down the script so they all appear to "close" together.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function HideAllDialogs()
{
  $MainDialog.Hide()
  $TexListDialog.Hide()
  $HelpDialog.Hide()
  $ImgViewDialog.Hide()
  $ResourceDialog.Hide()
  $OptionsDialog.Hide()
  $CombineDialog.Hide()
}
#==============================================================================================================================================================================================
#  CTT GUI: FUNCTIONS TO GET A FILE OR FOLDER PATH
#==============================================================================================================================================================================================
#  Creates an "Open File" dialog that searches for a file name (or an array of file names) and returns the selected file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Get-FileName([string]$StartPath, [string[]]$FileName, [string[]]$Description)
{
  # Create the open file dialog.
  $OpenFileDialog = New-Object Windows.Forms.OpenFileDialog

  # Set the initial path it searches.
  $OpenFileDialog.InitialDirectory = $StartPath

  # If more than 1 application is provided, loop through all of them and add them to the string.
  for ($i = 0; $i -lt $FileName.Count; $i++)
  {
    # A string is sent to the filter. Add all programs and descriptions to the filter.
    $FilterString += $Description[$i] + '|' + $FileName[$i] + '|'
  }
  # Trim the last "|" from the string or we'll get an error message.
  $OpenFileDialog.Filter = $FilterString.TrimEnd('|')

  # Show the dialog to the user.
  $OpenFileDialog.ShowDialog() 2>&1>$null

  # Return the file that was selected.
  return $OpenFileDialog.FileName
}
#==============================================================================================================================================================================================
#  Creates a "Folder Browser" dialog that returns a selected path. Uses imported code.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Get-Folder([string]$StartPath)
{
  # Create the folder browser dialog.
  $FolderPath = ([FolderSelectDialog]::New($StartPath, "Select Folder", "")).GetPath()

  # Return the selected path.
  return $FolderPath
}
#==============================================================================================================================================================================================
#  CTT GUI: REFRESH FORMAT AND DDS LISTS
#==============================================================================================================================================================================================
function PopulateFormatLists([Windows.Forms.ComboBox]$Combobox, [string]$SelectedFormat)
{
  # Store which format the user had selected before repopulating the lists.
  $StoreSelected = $SelectedFormat

  # Remove all current formats from the list.
  $ComboBox.Items.Clear() | Out-Null

  # Always add PNG and DDS.
  $ComboBox.Items.Add('PNG') | Out-Null
  $ComboBox.Items.Add('DDS') | Out-Null

  # Add additional formats if in "Expert Mode".
  if (($CTTPSSelectedMode -eq 'Expert Mode') -or ($CTTPSSelectedMode -eq 'Database Mode'))
  {
    # These are hidden in Dolphin Mode since the emulator doesn't use them.
    $ComboBox.Items.Add('JPG')  | Out-Null
    $ComboBox.Items.Add('BMP')  | Out-Null
    $ComboBox.Items.Add('TGA')  | Out-Null
    $ComboBox.Items.Add('TIF')  | Out-Null
    $ComboBox.Items.Add('TIFF') | Out-Null

    # The combobox is the "Convert" combobox.
    if ($Combobox -eq $ConvertFormatCombo)
    {
      # Add the ability to generate icons.
      $ComboBox.Items.Add('ICO')  | Out-Null
    }
  }
  # Select the proper format based on the combobox fed to the function.
  if ($Combobox.Items -Contains $StoreSelected) { $Combobox.SelectedItem = $StoreSelected } else { $Combobox.SelectedItem = 'PNG' }
}
#==============================================================================================================================================================================================
#  Adds all DDS Tools to the menu that are not already added.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateDDSToolsList([Windows.Forms.ComboBox]$ComboBox)
{
  # Remove all current tools from the list.
  $ComboBox.Items.Clear() | Out-Null

  # Add the tools that have been found.
  if (TestPath -LiteralPath $Compressonator) { $ComboBox.Items.Add('Compressonator') | Out-Null }
  if (TestPath -LiteralPath $TexConvTool)    { $ComboBox.Items.Add('TexConv') | Out-Null }

  # ImageMagick should always be found.
  $ComboBox.Items.Add('ImageMagick') | Out-Null

  # If any tool is not found, then add the "Add Tool..." option to the list.
  $AddToolConditions = New-Object bool[] 2

  # Go through and store the result of each check into the array.
  $AddToolConditions[0] = (!(TestPath -LiteralPath $Compressonator))
  $AddToolConditions[1] = (!(TestPath -LiteralPath $TexConvTool))  

  # Test the array of conditions. If it fails, add the item to allow adding more tools.
  if (TestBooleanArray -Or -Array $AddToolConditions) { $ComboBox.Items.Add('Add Tool...') | Out-Null }

  # If the tool has been added to the list, and it's set to the selected tool, it should be safe to set the current selection to the previously selected tool.
  if ($ComboBox.Items.Contains($DDSCreatorTool)) { $ComboBox.SelectedItem = $DDSCreatorTool }

  # The tool has not been already added to the list, so default to ImageMagick and set the tool to ImageMagick.
  else { $ComboBox.SelectedItem = $global:DDSCreatorTool = 'ImageMagick' }
}
#==============================================================================================================================================================================================
#  Populates the DDS combo boxes with DDS format options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateDDSFormatList([Windows.Forms.ComboBox]$ComboBox)
{
  # This worked the last time, so let's try it again.
  switch ($CTTPSSelectedMode)
  {
    # Add the indexes of the formats we want to add via the script block array.
    'Dolphin Mode'  { $DDSFormatList = @(0,1,2,3,7,8,13,14) }
    'Expert Mode'   { $DDSFormatList = @(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14) }
    'Database Mode' { $DDSFormatList = @(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14) }
    'Phyre Mode'    { $DDSFormatList = @(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14) }
    'Metroid Prime' { $DDSFormatList = @(0,1,2,3,7,8,13,14) }
  }
  # Build a list of all possible operations that can be added to the list in a script block that stores data about the operation into arrays.
  $ScriptBlock = New-Object Collections.Generic.List[Management.Automation.ScriptBlock]

  # Use the script blocks to add specific DDS options to the list.
  $ScriptBlock.Add({ param($ComboBox) ; $ComboBox.Items.Add('BC1/BC3') | Out-Null })                            # Index 0
  $ScriptBlock.Add({ param($ComboBox) ; $ComboBox.Items.Add('BC1') | Out-Null })                                # Index 1
  $ScriptBlock.Add({ param($ComboBox) ; $ComboBox.Items.Add('BC2') | Out-Null })                                # Index 2
  $ScriptBlock.Add({ param($ComboBox) ; $ComboBox.Items.Add('BC3') | Out-Null })                                # Index 3
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('BC4') | Out-Null }})   # Index 4
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('BC5') | Out-Null }})   # Index 5
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('BC6') | Out-Null }})   # Index 6
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('BC7') | Out-Null }})   # Index 7
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('ARGB8') | Out-Null }}) # Index 8
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('RGBA8') | Out-Null }}) # Index 9
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('L8') | Out-Null }})    # Index 10
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('A8') | Out-Null }})    # Index 11
  $ScriptBlock.Add({ param($AddFormat,$ComboBox) ; if ($AddFormat) {$ComboBox.Items.Add('LA8') | Out-Null }})   # Index 12

  # Add *Search Flags* to the main format selection only, and not the fallback compression.
  $ScriptBlock.Add({ param($ComboBox) ; if ($ComboBox.Name -eq 'DDSBlkCompress') { $ComboBox.Items.Add('*Search Flags*') | Out-Null }}) # Index 13
  $ScriptBlock.Add({ param($ComboBox) ; if ($ComboBox.Name -eq 'DDSBlkCompress') { $ComboBox.Items.Add('*Passthrough*') | Out-Null }})  # Index 14

  # Remove all current operations in the list.
  $ComboBox.Items.Clear() | Out-Null

  # Used for comparison. These include DDS formats that should only be added when TexConv has been added to the script.
  $SpecialCases = @(4,5,6,7,8,9,10,11,12)

  # Run only the script blocks with operations we want to add to the list.
  foreach ($Index in $DDSFormatList)
  {
    # Index 6 is BC7 which should only be added if TexConv exists or it has been forced.
    if ($SpecialCases -contains $Index)
    {
      # Some formats are only added if TexConv is found, or the hack is enabled to force them.
      $AddFormat = ((TestPath -LiteralPath $TexConvTool) -or $ForceShowBC7Format)

      # Run the script block which builds the GroupBox arrays and Title arrays.
      Invoke-Command -ScriptBlock $ScriptBlock[$Index] -ArgumentList $AddFormat,$ComboBox
    }
    else
    {
      # Run the script block which builds the GroupBox arrays and Title arrays.
      Invoke-Command -ScriptBlock $ScriptBlock[$Index] -ArgumentList $ComboBox
    }
  }
  # Some stuff to do if the combo box is the main DDS selection box.
  if ($ComboBox -eq $MainDDSFormat)
  {
    # If a format was selected in a previous run and it was successfully added to the list.
    if ($ComboBox.Items.Contains($DDSBlkCompress))
    {
      # It should be safe to set the current selection to the previously selected tool.
      $ComboBox.SelectedItem = $DDSBlkCompress
    }
    # If set to a format that is not in the current list.
    else
    {
      # Set the selection to BC1/BC3 and update the variable.
      $ComboBox.SelectedItem = $global:DDSBlkCompress = 'BC1/BC3'
    }
  }
  # Some stuff to do if the combo box is the fallback DDS selection box.
  elseif ($ComboBox -eq $MainDDSFallback)
  {
    # If a format was selected in a previous run and it was successfully added to the list.
    if ($ComboBox.Items.Contains($DDSFallbackCompress))
    {
      # It should be safe to set the current selection to the previously selected tool.
      $ComboBox.SelectedItem = $DDSFallbackCompress
    }
    # If set to a format that is not in the current list.
    else
    {
      # Set the selection to BC1/BC3 and update the variable.
      $ComboBox.SelectedItem = $global:DDSFallbackCompress = 'BC1/BC3'
    }
  }
}
#==============================================================================================================================================================================================
#  Toggle the enabled state of the "DDS Fallback" combo box. Fired from the "DDS Format" combo box.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleFallbackVisibility([bool]$Condition)
{
  # Toggle the "DDS Fallback" option.
  $MainDDSFallback.Enabled = $Condition
  $MainDDSFallbackLabel.Enabled = $Condition
}
#==============================================================================================================================================================================================
#  Toggle the enabled state of the "Flag Removal" combo box. Fired from the "DDS Format" combo box.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleFlagRemoveVisibility([bool]$Condition)
{
  # Toggle the "Flag Removal" option.
  $MainDDSFlagLabel.Enabled = $Condition
  $MainDDSFlagRemoval.Enabled = $Condition
}
#==============================================================================================================================================================================================
#  Removes all DDS Tools and DDS Formats from the lists and repopulates them based on the CTT-PS Mode and available tools.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RefreshDDSLists([switch]$FormatOnly)
{
  # If specified to only refresh the format lists and not the tools list.
  if (!$FormatOnly) { PopulateDDSToolsList -ComboBox $MainDDSToolCombo }

  # Always refresh the tools list.
  PopulateDDSFormatList -ComboBox $MainDDSFormat
  PopulateDDSFormatList -ComboBox $MainDDSFallback

  # Some options need to be adjusted if it's not set to Phyre Mode.
  if ($MainCTTPSCombo.SelectedItem -ne 'Phyre Mode')
  {
    # Enable DDS options that Dolphin and Advanced Mode uses.
    $MainDDSFormat.Enabled = $true
    $MainDDSFormatLabel.Enabled = $true

    # Enable the DDS Fallback items if set to search for flags.
    ToggleFallbackVisibility -Condition (($MainDDSFormat.SelectedItem -eq '*Search Flags*') -or ($MainDDSFormat.SelectedItem -eq '*Passthrough*'))
    ToggleFlagRemoveVisibility -Condition ($MainDDSFormat.SelectedItem -eq '*Search Flags*')

    # Show these DDS options for both Dolphin and Advanced.
    $MainExternalDDSMipmap.Visible = $true
    $MainTopLevelMipmap.Visible = $true
  }
  # Disable DDS Options when selecting "Phyre Mode" since it uses its own set of options.
  else
  {
    # Disable DDS options that Phyre Mode does not use.
    $MainDDSFormat.Enabled = $false
    $MainDDSFormatLabel.Enabled = $false

    # Disable the DDS Fallback items.
    ToggleFallbackVisibility -Condition $false
    ToggleFlagRemoveVisibility -Condition $false

    # Hide these DDS options when in Phyre Mod.
    $MainExternalDDSMipmap.Visible = $false
    $MainExternalDDSMipmap.Checked = $false
    $MainTopLevelMipmap.Visible = $false
    $MainTopLevelMipmap.Checked = $false
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: ADD EXTERNAL FILES AND TOOLS TO CTT-PS
#==============================================================================================================================================================================================
#  Responsible for handling all tools that are imported into CTT-PS.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFile([Windows.Forms.TextBox]$TextBox=$null, [string]$ToolPathName, [string]$ToolPath)
{
  # Update the global variable that tracks the full path as a string.
  Set-Variable -Name $ToolPathName -Value $ToolPath -Scope 'Global'

  # All names are different enough that we only need a few characters to match.
  switch -wildcard ($ToolPathName)
  {
    # ImageMagick just needs its path find function.
    'ImageMagic*' {
                    $MainStartButton.Enabled      = $true
                    $MainProcessButton.Enabled    = $true
                    $TexListStartButton.Enabled   = $true
                    $TexListProcessButton.Enabled = $true
                  }
    # TexConv enables new DDS types so the DDS Format and DDS Fallback lists need to be updated.
    'TexConv*'    { RefreshDDSLists }

    # Compressonator simply repopulate the list.
    'Compress*'   { PopulateDDSToolsList -ComboBox $MainDDSToolCombo }

    # Dolphin TextureExtraction Tool has two places to update the path.
    'TexExtract*' {
                    $OptionsExtractTexTextBox.Text = $ToolPath
                    $TexExtractProgramTextBox.Text = $ToolPath
                  }
    # Ishiiruka Tool has two places to update the path: the Create Material Maps From Materials operation, and the paths menu.
    'Ishiiruka*'  {
                    $OptionsIshiirukaTextBox.Text  = $ToolPath
                    $MaterialIshiirukaTextBox.Text = $ToolPath
                    $MaterialCreateMapsCheck.Enabled = $true
                  }
    # PNG optimizer program path for OptiPNG or OxiPNG.
    'o*iPNG*'     { PopulateOptimizerList }

    # PNG optimizer program path for Pingo.
    'pingo*'      { PopulateOptimizerList }

    # PNG optimizer program path for Efficient Compression Tool.
    'ect*'        { PopulateOptimizerList }

    # xBRZ ScalerTest just needs the filter list updated.
    'ScalerTest*' { PopulateUpscaleFilterList }

    # Waifu2x: Store the name of the selected Waifu2x application (it will be 'waifu2x-caffe-cui.exe' or 'waifu2x-converter-cpp.exe').
    'Waifu2x*'    {
                    PopulateUpscaleFilterList
                    Waifu2x_UpdateAppSpecificOptions
                  }
    # 7-Zip: Just update the paths on the text boxes.
    '7ZipPath'    { $Options7ZipTextBox.Text = $7ZipPath }

    # The PKG Tool will now be known to exist.
    'PhyrePKG*'   {
                    $ToCSExtractPKGTextBox.Text = $PhyrePKGTool
                    $ToCSRepackPKGToolBox.Text  = $PhyrePKGTool
                    $OptionsPKGToolTextBox.Text = $PhyrePKGTool
                  }
    # When adding python, update the upscale filter list and superscaler models.
    'Python'      {
                    PopulateUpscaleFilterList
                    PopulateSuperScalerModels
                  }
  }
  # Check if a textbox was specified to update.
  if ($TextBox -ne $null)
  {
    # Update the text box with the new path.
    $TextBox.Text = $ToolPath
  }
}
#==============================================================================================================================================================================================
#  Adds a tool or file with a button from the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFile_Button([Windows.Forms.TextBox]$TextBox, [string[]]$FileName, [string[]]$Description )
{
  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $TextBox.Text

  # Display an "Open File" menu to get the path.
  $SelectedPath = Get-FileName -StartPath $GetFilePath -FileName $FileName -Description $Description 

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Add the selected tool to the script.
    LoadExternalFile -TextBox $TextBox -ToolPathName $this.Name -ToolPath $SelectedPath
  }
}
#==============================================================================================================================================================================================
#  This version of adding a tool with a button allows selecting all files and avoiding the dropdown menu. But the file now has to be checked after it was selected.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFile_ButtonX([Windows.Forms.TextBox]$TextBox, [string[]]$FileName, [string]$Description )
{
  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $TextBox.Text

  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-FileName -StartPath $GetFilePath -FileName '*.*' -Description $Description

  # Before going further make sure a path to a file was selected and it exists.
  if (($SelectedPath -eq '') -or (!(TestPath -LiteralPath $SelectedPath))) { return }

  # Get the file as an item to retrieve properties from it.
  $SelectedFile = Get-Item -LiteralPath $SelectedPath

  # Loop through the lists of filenames provided.
  for($i = 0 ; $i -lt $FileName.Length ; $i++)
  {
    # Some filenames may have a wildcard so try to match the selected file against the set.
    if ($SelectedFile.Name -like $FileName[$i])
    {
      # Add the selected tool to the script.
      LoadExternalFile -TextBox $TextBox -ToolPathName $this.Name -ToolPath $SelectedPath
    }
  }
}
#==============================================================================================================================================================================================
#  Add-on function to the DragAndDrop/TextBox functions that searches the path for the file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFile_FolderSearch($SearchPath)
{
  # Set up a path to also include the executable file.
  $PathWithExe = $SearchPath + '\' + $FileText

  # Make sure the file exists in the chosen path.
  if (TestPath -LiteralPath $PathWithExe)
  {
    # Finish doing everything that needs to be done.
    LoadExternalFile -TextBox $this -ToolPathName $this.Name -ToolPath $PathWithExe

    # We have the file so get out of here.
    return $true
  }
  # Returning false continues the loop.
  return $false
}
#==============================================================================================================================================================================================
#  Adds a tool or file with a drag and drop. Can drop a file, or a folder containing the file. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFile_DragAndDrop([string[]]$FileName, [Windows.Forms.TextBox]$TextBox = $null)
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

    # To support both waifu2x versions some trickery is needed. The parameter accepts an array, so both executables need to be tested.
    foreach ($FileText in $FileName)
    {
      # Make sure the path is a file (defined by type "leaf").
      if (TestPath -LiteralPath $DroppedPath -PathType 'Leaf')
      {
        # Get the name of the item.
        $DroppedName = (Get-Item -LiteralPath $DroppedPath).Name

        # If the $FileName parameter only contains a file extension, compare it to the extension of the dropped file.
        $DropExtension  = (Get-Item -LiteralPath $DroppedPath).Extension
        $CheckExtension = ExtractExtension -FilePath $FileName

        # Make sure the correct executable was chosen or the file extension matches.
        if (($FileText -eq $DroppedName) -or ($DropExtension -eq $CheckExtension))
        {
          # Send the textbox if the type was a textbox.
          if ($this.GetType() -eq [System.Windows.Forms.TextBox])
          {
            # Finish doing everything that needs to be done.
            LoadExternalFile -TextBox $this -ToolPathName $this.Name -ToolPath $DroppedPath
          }
          # Otherwise send the parameter.
          else
          {
            # Finish doing everything that needs to be done.
            LoadExternalFile -TextBox $TextBox -ToolPathName $this.Name -ToolPath $DroppedPath
          }
          # We have the file so get out of here.
          break
        }
      }
      # You know what? Let's set up a condition to check a path to see if the file is inside.
      elseif (TestPath -LiteralPath $DroppedPath -PathType 'Container')
      {
        # Try to search the dropped folder for the file. If it finds it, exit the loop.
        if (LoadExternalFile_FolderSearch -SearchPath $DroppedPath)
        {
          # We have the file so get out of here.
          break
        }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Adds a tool or file by editing its location using the textbox itself. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFile_TextBox([string[]]$FileName)
{
  # Get the current value of the variable by pulling it from textbox name.
  $CurrentPath = Get-Variable -Name $this.Name -ValueOnly
  $EnteredText = $this.Text

  # To avoid updating constantly, check to see if the text actually changed.
  if (($EnteredText -ne $CurrentPath) -and ($EnteredText -ne ''))
  {
    # To support both waifu2x versions some trickery is needed. The parameter accepts an array, so both executables need to be tested.
    foreach ($FileText in $FileName)
    {
      # Don't allow a final backslash in the path since it will be added manually.
      $EnteredText = PathTruncateSlash -Path $EnteredText

      # Make sure the path is a file.
      if (TestPath -LiteralPath $EnteredText -PathType 'Leaf')
      {
        # Get the name of the item.
        $EnteredName = (Get-Item -LiteralPath $EnteredText).Name

        # Make sure the correct executable was chosen.
        if ($EnteredName -like $FileText)
        {
          # Set the text to the entered text.
          $this.Text = $EnteredText

          # Finish doing everything that needs to be done.
          LoadExternalFile -TextBox $this -ToolPathName $this.Name -ToolPath $EnteredText

          # We have the file so get out of here.
          break
        }
      }
      # You know what? Let's set up a condition to check a path to see if the file is inside.
      elseif (TestPath -LiteralPath $EnteredText -PathType 'Container')
      {
        # Try to search the entered folder for the file. If it finds it, exit the loop.
        if (LoadExternalFile_FolderSearch -SearchPath $EnteredText) 
        {
          # Set the text to the entered text.
          $this.Text = $EnteredText

          # We have the file so get out of here.
          break
        }
      }
      # If the entered text was empty or invalid, set the textbox text back to what it was.
      $this.Text = $CurrentPath
    }
  }
  else
  {
    # If the entered text was empty or invalid, set the textbox text back to what it was.
    $this.Text = $CurrentPath
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: ADD EXTERNAL FOLDERS TO CTT-PS
#==============================================================================================================================================================================================
#  Finishes adding a folder to the script.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFolder_Finish([Windows.Forms.TextBox]$TextBox, [string]$UpdatePath)
{
  # Don't allow a final backslash in the path since it will be added manually.
  $UpdatePath = PathTruncateSlash -Path $UpdatePath

  # Update the value of the variable.
  Set-Variable -Name $TextBox.Name -Value $UpdatePath -Scope 'Global'

  # Update the text box with the new path.
  $TextBox.Text = $UpdatePath
}
#==============================================================================================================================================================================================
#  Loads a folder into the script with a drag and drop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFolder_DragDrop([Windows.Forms.TextBox]$TextBox, [string]$FileTest='')
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

    # Make sure the path is a folder.
    if ((TestPath -LiteralPath $DroppedPath -PathType 'Container'))
    {
      # A test to see if a file exists in the selected path.
      $FileTestPath = $DroppedPath + '\' + $FileTest

      # I love ugly one liners to escape functions.
      if ($FileTest -ne '') { if (!(TestPath -LiteralPath $FileTestPath)) { return } }

      # Finish setting up the folder.
      LoadExternalFolder_Finish -TextBox $TextBox -UpdatePath $DroppedPath
    }
  }
}
#==============================================================================================================================================================================================
#  Loads a folder into the script with the use of a button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFolder_Button([Windows.Forms.TextBox]$TextBox, [string]$Message, [string]$FileTest='')
{
  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $TextBox.Text

  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $GetFilePath

  # Check to see if a folder was selected and test if that it exists (for the sake of it).
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # A test to see if a file exists in the selected path.
    $FileTestPath = $SelectedPath + '\' + $FileTest

    # I love ugly one liners to escape functions.
    if ($FileTest -ne '') { if (!(TestPath -LiteralPath $FileTestPath)) { return } }

    # Finish setting the TempFolder.
    LoadExternalFolder_Finish -TextBox $TextBox -UpdatePath $SelectedPath
  }
}
#==============================================================================================================================================================================================
#  Loads a folder into the script via the text box.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadExternalFolder_TextBox([Windows.Forms.TextBox]$TextBox, [string]$FileTest='')
{
  # Get the current value of the variable.
  $CurrentPath = Get-Variable -Name $TextBox.Name -ValueOnly
  $EnteredText = $TextBox.Text

  # To avoid updating constantly, check to see if the text actually changed and that the path actually exists.
  if (($EnteredText -ne $CurrentPath) -and ($EnteredText -ne '') -and (TestPath -LiteralPath $EnteredText))
  {
    # A test to see if a file exists in the selected path.
    $FileTestPath = $EnteredText + '\' + $FileTest

    # I love ugly one liners to escape functions.
    if ($FileTest -ne '') { if (!(TestPath -LiteralPath $FileTestPath)) { return } }

    # Finish setting the TempFolder.
    LoadExternalFolder_Finish -TextBox $TextBox -UpdatePath $EnteredText

    # We're done here, get out.
    return
  }
  # Set the textbox text back to what it was.
  $TextBox.Text = $CurrentPath
}
#==============================================================================================================================================================================================
#  CTT GUI: MODIFY OPTION STATES
#==============================================================================================================================================================================================
#  Generic function that takes care of all check boxes that have their value toggled.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckBoxStateToggled()
{
  # Update the variable with the reversed state.
  Set-Variable -Name $this.Name -Value $this.Checked -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Generic function that takes care of almost all combo boxes that have their value changed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ComboBoxStateChanged($NewValue)
{
  # Update the variable with the new value that was fed to the parameter.
  Set-Variable -Name $this.Name -Value $NewValue -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Generic function that takes care of almost all numeric up/downs that have their value changed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function NumericUpDownModified([string]$TypeDefinition)
{
  # Convert the value into a decimal format and split the integer from the decimal.
  $ValueSplit = (FormatDecimal -Value $this.Value).Split('.', 2)

  # Keep only the whole number for integers, but keep two decimal places for decimals.
  switch ($TypeDefinition)
  {
    # Cast the value into the proper type of variable.
    'integer' { $NewValue = [int]$ValueSplit[0] }
    'decimal' { $NewValue = [decimal]($ValueSplit[0] + '.' + $ValueSplit[1]) }
  }
  # Update the variable with the new value.
  Set-Variable -Name $this.Name -Value $NewValue -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Specific function for Rescale Factor numeric up/down to transform 0.01 to 1.00 when clicking the up arrow.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RescaleUpDownModified([string]$TypeDefinition)
{
  # Get the previous rescale factor that was stored.
  $OldValue = Get-Variable -Name $this.Name -ValueOnly

  # Convert the value into a decimal format and split the integer from the decimal.
  $ValueSplit = (FormatDecimal -Value $this.Value).Split('.', 2)

  # Check to see if it was "0.01" specifically.
  if (($OldValue -eq "0.01") -and ($ValueSplit[0] -eq "1") -and ($ValueSplit[1] -eq "01"))
  {
    # An oddly specific fix but it works none-the less.
    $ValueSplit[1] = "00"
  }
  # Keep only the whole number for integers, but keep two decimal places for decimals.
  switch ($TypeDefinition)
  {
    # Cast the value into the proper type of variable.
    'integer' { $NewValue = [int]$ValueSplit[0] }
    'decimal' { $NewValue = [decimal]($ValueSplit[0] + '.' + $ValueSplit[1]) }
  }
  # Update the variable with the new value.
  Set-Variable -Name $this.Name -Value $NewValue -Scope 'Global'

  # Because the value may have changed, we need to force the box with the new value. This will cause a double update when the 
  # above event triggers (0.01 to 1.00), but not much can be done to avoid that. Fortunately, it will be invisible to the user.
  $this.Value = $NewValue
}
#==============================================================================================================================================================================================
#  Forces a numeric up/down to have an even number.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function NumericUpDownEnforceEven()
{
  # Get the minimum and maximum values from the numeric up/down.
  $Min = $this.Minimum
  $Max = $this.Maximum

  # Get the current value of the NumericUpDown.
  $Value = $this.Value

  # If the value is an odd number, add 1 to the value to make it even.
  if ($Value % 2 -eq 1 ) { $Value++ }

  # If the value is below the minimum, set it to the minimum value.
  if ($Value -lt $Min) { $Value = $Min }

  # If the value is below the maximum, set it to the maximum value.
  if ($Value -gt $Max) { $Value = $Max }

  # Update the numeric up/down with the new value.
  $this.Value = $Value
  
  # Update the variable with the new value.
  Set-Variable -Name $this.Name -Value $Value -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Enables/Disables many dialog options. Used when waiting for an operation to finish (resource pack, image viewer, etc.).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleDialogStates([bool]$State)
{
  # Toggle some groupboxes.
  $MainInputGroup.Enabled        = $State
  $MainOutputGroup.Enabled       = $State
  $MainOperationsGroup.Enabled   = $State
  $MainCTTPSGroup.Enabled        = $State
  $MainFormatTexGroup.Enabled    = $State
  $MainMipmapGroup.Enabled       = $State

  # Toggle buttons on the main dialog.
  $MainCloseButton.Enabled       = $State
  $MainNoSaveButton.Enabled      = $State
  $MainProcessButton.Enabled     = $State
  $MainOptionsButton.Enabled     = $State

  # Toggle buttons on the texture list.
  $TexListProcessButton.Enabled  = $State
  $TexListCancelButton.Enabled   = $State
  $TexListCloseButton.Enabled    = $State
  $TexListNoSaveButton.Enabled   = $State

  # The start buttons should only be enabled when ImageMagick is present.
  if ($State)
  {
    $MainStartButton.Enabled     = (TestPath -LiteralPath $ImageMagick)
    $TexListStartButton.Enabled  = (TestPath -LiteralPath $ImageMagick)
  }
  # But should always be disabled when called for.
  else
  {
    $MainStartButton.Enabled     = $false
    $TexListStartButton.Enabled  = $false
  }
  # Toggle some stuff on the resource pack dialog. 
  $ResOpGroupBox.Enabled         = $State
  $ResInfoGroupBox.Enabled       = $State
  $ResManagerGroupBox.Enabled    = $State
  $ResModPackGroupBox.Enabled    = $State
  $ResInputGroupBox.Enabled      = $State
  $ResOutputGroupBox.Enabled     = $State
  $ResStartButton.Enabled        = $State
  $ResImportButton.Enabled       = $State
  $ResResetButton.Enabled        = $State
  $ResTexFolderButton.Enabled    = $State
  $ResCancelButton.Enabled       = $State

  # Toggle some stuff on the combine textures dialog.
  foreach ($CButton in $CombineButton) { $CButton.Enabled = $State }

  # Toggle some shit on the SuperScaler folder.
  $SSSkipButton.Enabled          = $State
  $SSStartButton.Enabled         = $State

  # Loop through all operation groupboxes.
  foreach ($Group in $StaticGroupArray)
  {
    # Get the variable by searching for the name of the variable.
    $OperationGroup = Get-Variable -Name $Group -ValueOnly

    # Toggle the operation group.
    $OperationGroup.Enabled = $State
  }
}
#==============================================================================================================================================================================================
#  ZELDA BUTTON TOGGLE: USED IN COMBINE/SPLIT MULTIPLE TEXTURES
#==============================================================================================================================================================================================
#  Toggles the color of the Zelda button gray or gold if the specific options are enabled.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetZeldaTriforceButton()
{
  # If any of the options are enabled.
  if ($CombineAutoArrange -or $CombinePixelCrop -or $SplitZeldaRestore -or $CombineOverlapEnable -or $SplitOverlapEnable -or $SplitDefineBoundary)
  {
    # Return the gold triforce.
    return $Image_TriforceGold
  }
  # None of the options are enabled so return the regular triforce.
  return $Image_Triforce
}
#==============================================================================================================================================================================================
#  CREATE CTT FILE FUNCTIONS: USED IN COMBINE/SPLIT MULTIPLE TEXTURES 
#==============================================================================================================================================================================================
#  If a combined texture is created, a (.ctt) file is created to accompany it. This file holds some valuable information to re-split the texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateCTTFile([string]$OutputPath)
{
  # Some data is tied to the first image in the array, assuming all data is the same for all textures.
  $ImageItem = Get-Item -LiteralPath $TextureArray[1,1]
  $ImageInfo = GetImageInfo -ImageFile $TextureArray[1,1]

  # Set the path to generate a CTT file.
  $CTTFile = $OutputPath + '\' + $CombinedName + $CTT

  # If a CTT file already exists, remove it before starting to add data to it.
  RemovePath -LiteralPath $CTTFile

  #  Line 1: The name of the combined texture.
  Add-Content -LiteralPath $CTTFile -Value $CombinedName

  # If the user also wanted to backup the textures.
  switch ($CTTIncludeTextures)
  {
    # May as well do this now to avoid doing the check again later.
    $true   {
              #  Line 2: Create a relative path to the textures.
              Add-Content -LiteralPath $CTTFile -Value ('..\' + $CombinedName)

              # Create the folder so textures can be copied there.
              $BackupPath = CreatePath -LiteralPath ($OutputPath + '\' + $CombinedName)

              # Copy all textures from the array to the destination folder.
              foreach ($BackupImage in $TextureArray) { if ($BackupImage -ne $null) { Copy-Item -LiteralPath $BackupImage -Destination $BackupPath } }

              # The Zelda:OoT screen shake textures need to be handled a bit differently.
              foreach ($BackupImage in $ZeldaBonkArray)
              {
                # See if a texture exists in the array.
                if (($BackupImage -ne $null) -and (TestPath -LiteralPath $BackupImage))
                {
                  # Create the path to the textures.
                  $BackupPath = CreatePath -LiteralPath ($OutputPath + '\Screen Shake')

                  # Attempt to copy it into the destination.
                  Copy-Item -LiteralPath $BackupImage -Destination $BackupPath
                }
              }
            }
    #  Line 2: Original path to the textures (hopefully).
    $false  { Add-Content -LiteralPath $CTTFile -Value $ImageItem.DirectoryName }
  }
  #  Line 3: The dimensions of the segments (hopefully).
  Add-Content -LiteralPath $CTTFile -Value $ImageInfo.Dimensions

  #  Line 4: The number of columns.
  Add-Content -LiteralPath $CTTFile -Value $TextureCols

  #  Line 5: The number of rows.
  Add-Content -LiteralPath $CTTFile -Value $TextureRows

  #  Line 6: The number of overlapping pixels.
  Add-Content -LiteralPath $CTTFile -Value $CombineOverlapValue

  #  Line 7: The number of crop pixels.
  Add-Content -LiteralPath $CTTFile -Value ('' + $CombinePixelCropL + ':' + $CombinePixelCropT + ':' + $CombinePixelCropB + ':' + $CombinePixelCropR)

  #  Line 8: The button orientation.
  Add-Content -LiteralPath $CTTFile -Value ($CombineButtonSizeX.ToString() + 'x' + $CombineButtonSizeY.ToString())

  # Loop through all rows.
  for ($row = 1; $row -le [int]$TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le [int]$TextureCols; $col++)
    {
      # Get the texture as an item object.
      $TexItem = Get-Item -LiteralPath $TextureArray[$row,$col]

      #  Line 8+: The list of textures.
      Add-Content -LiteralPath $CTTFile -Value $TexItem.Name
    }
  }
  # Loop through the potential Zelda screen shake textures.
  for ($i = 0; $i -lt 6; $i++)
  {
    # Make sure it exists so its possible to get the name.
    if (TestPath -LiteralPath $ZeldaBonkArray[$i])
    {
      # Get the texture as an item object.
      $BonkItem = Get-Item -LiteralPath $ZeldaBonkArray[$i]

      # Add whether its a top texture or bottom texture.
      if ($i -lt 3) { $Pos = 't' ; $Num = $i + 1 } else { $Pos = 'b' ; $Num = $i - 2 }

      # Assemble the entire entry.
      $LineEntry = 'ss' + $Pos + $Num + '=' + $BonkItem.Name

      # Add the new entry to the CTT file.
      Add-Content -LiteralPath $CTTFile -Value $LineEntry
    }
  }
}
#==============================================================================================================================================================================================
#  LOAD CTT FILE FUNCTIONS: USED IN COMBINE/SPLIT MULTIPLE TEXTURES 
#==============================================================================================================================================================================================
#  Calculates the multiplied (upscaled) values that will be set in the "Add garbage pixels" by using the values in "Remove garbage pixels".
#==============================================================================================================================================================================================
function LoadCTTFile_PixelRestoreCalculate([int]$BaseAmount, [string]$Dimensions)
{
  # Since the texture info is null, just return the base value because calculations can not be done.
  if ($CombinedInfo -eq $null) { return $BaseAmount }    

  # Get the width from the dimensions.
  $SplitDims = $Dimensions.Split('x', 2)
  $BaseWidth = [int]$SplitDims[0]

  # Calculate the width that will be used to find the upscale value.
  $CalcWidth = (($BaseWidth - $CombinePixelCropL - $CombinePixelCropR) * $TextureCols)

  # Get the upscale integer used.
  $UpscaleSplit = (FormatDecimal -Value ($CombinedInfo.Width / $CalcWidth).ToString()).Split('.', 2)
  $global:SplitInteger = [int]$UpscaleSplit[0]

  # Multiply the base amount by the upscale value.
  return ($SplitInteger * $BaseAmount)
}
#==============================================================================================================================================================================================
#  Calculates how many overlapping pixels in the "Split" option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFile_SplitPixelCalculate([string]$Dimensions)
{
  # Test to see if the texture exists.
  if (($CombinedInfo -ne $null) -and (TestPath -LiteralPath $CombineSelected))
  {
    # Get the width and height from the dimensions.
    $SplitDims  = $Dimensions.Split('x', 2)
    $BaseWidth  = [int]$SplitDims[0]
    $BaseHeight = [int]$SplitDims[1]

    # Pixel overlap was not used.
    if ($CombineOverlapValue -eq 0)
    {
      # Getting the combined dimensions is as simple as (dimension * multiplier).
      $CalcWidth  = $BaseWidth * $TextureCols
      $CalcHeight = $BaseHeight * $TextureRows
    }
    # Pixel overlap was set to something.
    else
    {
      # Use this formula I came up with, which ironically I don't even know why it works (I'm bad at math, number plugging FTW).
      $CalcWidth  = ($BaseWidth * $TextureCols) - ($TextureCols * $CombineOverlapValue) + $CombineOverlapValue
      $CalcHeight = ($BaseHeight * $TextureRows) - ($TextureRows * $CombineOverlapValue) + $CombineOverlapValue
    }
    # If the actual dimensions are larger than the calculated dimensions.
    if (($CombinedInfo.Width -gt $CalcWidth) -or ($CombinedInfo.Height -gt $CalcHeight))
    {
      # It's probably an upscale of the original. Get the upscale factor using the width of the new and old textures.
      $UpscaleSplit   = (FormatDecimal -Value ($CombinedInfo.Width / $CalcWidth).ToString()).Split('.', 2)
      $UpscaleInteger = [int]$UpscaleSplit[0]

      # Finally the split pixel overlap can be calculated.
      return ($UpscaleInteger * $CombineOverlapValue)
    }
  }
  # Just set it to whatever was imported for the combine overlap.
  return $CombineOverlapValue
}
#==============================================================================================================================================================================================
#  This fills the texture arrays from the info found in the CTT file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFile_FillTextureArrays([int]$StartIndex, [string]$Path, [object[]]$Content)
{
   # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Get the value of the current line.
      $CurrentLine = $Content | Select-Object -Index $StartIndex

      # Check to see if a texture is to be cloned.
      if ($CurrentLine -like '*=*')
      {
        # The syntax is "TextureNameA=TextureNameB".
        $SplitLine = $CurrentLine.Split('=')

        # We only want the first texture for the main array, and the second texture will be stored in an alternate array.
        $CurrentLine   = $SplitLine[0]
        $AlternateLine = $SplitLine[1]
      }
      # Test both the full path provided, and test the path as if it has a relative identifier (..\).
      $ImportedTextureA = $Path + '\' + $CurrentLine
      $ImportedTextureB = $CTTPath + '\' + $Path.Replace('..\','') + '\' + $CurrentLine

      # Check each path to see if the file exists. If it does not, just store a blank string.
      if     (TestPath -LiteralPath $ImportedTextureA) { $global:TextureArray[$row,$col] = $ImportedTextureA }
      elseif (TestPath -LiteralPath $ImportedTextureB) { $global:TextureArray[$row,$col] = $ImportedTextureB }
      else                                             { $global:TextureArray[$row,$col] = '' }

      # Always fill the split array with the names.
      $global:CTTSplitArray[$row,$col] = $CurrentLine

      # If there was an alternate texture name, add it to the alternate split array.
      if ($AlternateLine -ne $null) { $global:AltSplitArray[$row,$col] = $AlternateLine }

      # Increment the index.
      $StartIndex++
    }
  }
  # If there is additional textures, they are used for Zelda:OoT "bonk" effects.
  if ($StartIndex -lt $Content.Count)
  {
    # Stores six extra zelda "bonk" screenshake textures that happen when link rolls and smacks into the wall.
    $global:ZeldaBonkArray  = New-Object 'string[]' 6
    $global:ZeldaSplitArray = New-Object 'string[]' 6

    # Loop through the six textures included in the CTT File.
    for ($i = $StartIndex ; $i -lt $Content.Count ; $i++)
    {
      # Get the value of the current line.
      $CurrentLine = $Content | Select-Object -Index $StartIndex

      # Split the line on the "=" sign.
      $LineSplit = $CurrentLine.Split('=')

      # The identifier determines whether its top or bottom texture.
      $Identifier = $LineSplit[0].Substring(2,1)
      $AnimsFrame = [int]$LineSplit[0].Substring(3,1)

      # If it's a bottom texture, add 3 to the determine the actual position in the array.
      if ($Identifier -eq 't') { $Position = $AnimsFrame - 1 } else { $Position = $AnimsFrame + 3 - 1 }

      # Test both the full path provided, and test the path as if it has a relative identifier (..\).
      $BonkTextureA = $Path + '\' + $LineSplit[1]
      $BonkTextureB = $CTTPath + '\' + $Path.Replace('..\','') + '\' + $LineSplit[1]
      $BonkTextureC = $CTTPath + '\' + $Path.Replace('..\','') + '\ScreenShake\' + $LineSplit[1]
      $BonkTextureD = $CTTPath + '\ScreenShake\' + $LineSplit[1]
      $BonkTextureE = $CTTPath + '\' + $Path.Replace('..\','') + '\Screen Shake\' + $LineSplit[1]
      $BonkTextureF = $CTTPath + '\Screen Shake\' + $LineSplit[1]

      # Check each path to see if the file exists. If it does not, just store a blank string.
      if     (TestPath -LiteralPath $BonkTextureA) { $global:ZeldaBonkArray[$Position] = $BonkTextureA }
      elseif (TestPath -LiteralPath $BonkTextureB) { $global:ZeldaBonkArray[$Position] = $BonkTextureB }
      elseif (TestPath -LiteralPath $BonkTextureC) { $global:ZeldaBonkArray[$Position] = $BonkTextureC }
      elseif (TestPath -LiteralPath $BonkTextureD) { $global:ZeldaBonkArray[$Position] = $BonkTextureD }
      elseif (TestPath -LiteralPath $BonkTextureE) { $global:ZeldaBonkArray[$Position] = $BonkTextureE }
      elseif (TestPath -LiteralPath $BonkTextureF) { $global:ZeldaBonkArray[$Position] = $BonkTextureF }
      else                                         { $global:ZeldaBonkArray[$Position] = '' }

      # Always fill the split array with the names.
      $global:ZeldaSplitArray[$Position] = $CurrentLine

      # Increment the index.
      $StartIndex++
    }
  }
}
#==============================================================================================================================================================================================
#  Populates buttons with images from the Texture Array when a CTT file is loaded.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFile_PopulateCombineButtons()
{
  # Set the starting button index.
  $Index = 0

  # Loop through all rows.
  for ($row = 1; $row -le [int]$TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le [int]$TextureCols; $col++)
    {
      # Test to see if the path to the texture is still valid.
      if (TestPath -LiteralPath $TextureArray[$row,$col])
      {
        # This function was not designed to be used this way, but I hacked it to make it work.
        CombineTextures_AddTextureButton -ImageFile $TextureArray[$row,$col] -OverrideButton $CombineButton[$Index]
      }
      # Increment the index.
      $Index++
    }
  }
}
#==============================================================================================================================================================================================
#  Updates the GUI when a CTT file is loaded.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFile_UpdateGUI()
{
  # Update the GUI combine values.
  $CombineColumnsNumBox.Value    = $TextureCols
  $CombineRowsNumBox.Value       = $TextureRows
  $CombineOverlapNumBox.Value    = $CombineOverlapValue
  $CombineRatioXNumBox.Value     = $CombineButtonSizeX
  $CombineRatioYNumBox.Value     = $CombineButtonSizeY
  $CombineNameTextBox.Text       = $CombinedName

  # Update the GUI split values.
  $SplitTextureTextBox.Text      = $CombineSelected
  $SplitTextureColsNumBox.Value  = $TextureCols
  $SplitTextureRowsNumBox.Value  = $TextureRows
  $SplitOverlapNumBox.Value      = $SplitPixelOverlap

  # Update the Zelda GUI combine values.
  $CombinePixelCropLNumBox.Value = $CombinePixelCropL
  $CombinePixelCropTNumBox.Value = $CombinePixelCropT
  $CombinePixelCropBNumBox.Value = $CombinePixelCropB
  $CombinePixelCropRNumBox.Value = $CombinePixelCropR

  # Update the Zelda GUI split values.
  $SplitZeldaRestoreL.Value      = $SplitPixelRestoreL
  $SplitZeldaRestoreT.Value      = $SplitPixelRestoreT
  $SplitZeldaRestoreB.Value      = $SplitPixelRestoreB
  $SplitZeldaRestoreR.Value      = $SplitPixelRestoreR

  # If there is a value for the overlap pixels.
  if ($CombineOverlapValue -gt 0)
  {
    # Uncheck the garbage pixel checkboxes if they are not checked.
    $CombinePixelCropCheckBox.Checked = $false
    $SplitZeldaResCheckBox.Checked    = $false

    # Check the overlap checkboxes if they are checked.
    $CombineZeldaOverlapCheckBox.Checked = $true
    $SplitZeldaOverlapCheckBox.Checked   = $true
  }
  # Check to see if there are any garbage pixel values.
  elseif (($CombinePixelCropL -gt 0) -or ($CombinePixelCropT -gt 0) -or ($CombinePixelCropB -gt 0) -or ($CombinePixelCropR -gt 0))
  {
    # Uncheck the overlap checkboxes if they are checked.
    $CombineZeldaOverlapCheckBox.Checked = $false
    $SplitZeldaOverlapCheckBox.Checked   = $false

    # Check the garbage pixel checkboxes if they are not checked.
    $CombinePixelCropCheckBox.Checked = $true
    $SplitZeldaResCheckBox.Checked    = $true
  }
  # Fill out the Zelda screen shake textures.
  if ($ZeldaBonkArray -ne $null)
  {
    $CombineZeldaSSBox01.Text = $ZeldaBonkArray[0]
    $CombineZeldaSSBox02.Text = $ZeldaBonkArray[1]
    $CombineZeldaSSBox03.Text = $ZeldaBonkArray[2]
    $CombineZeldaSSBox04.Text = $ZeldaBonkArray[3]
    $CombineZeldaSSBox05.Text = $ZeldaBonkArray[4]
    $CombineZeldaSSBox06.Text = $ZeldaBonkArray[5]
  }
  # Set the color of the zelda buttons if the CTT File imported any options that enable them.
  $CombineZeldaButton.Image = GetZeldaTriforceButton
  $SplitZeldaButton.Image   = GetZeldaTriforceButton
}
#==============================================================================================================================================================================================
#  Loads all values used to split the texture from a CTT file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFile([string]$CTTFile)
{
  # Disable the dialog states.
  ToggleDialogStates -State $false

  # Show a message that it is being imported.
  DebugMessage -Message '-----------------------------------------------------------------------------' 
  DebugMessage -Message '--Importing CTT File--' -FollowUp ' '

  # Set that a CTT File has been loaded.
  $global:CTTFileLoaded = $true

  # Get some information of the CTT file.
  $CTTItem = Get-Item -LiteralPath $CTTFile
  $CTTPath = $CTTItem.DirectoryName
  $CTTName = $CTTItem.BaseName

  # Get the content of the CTT file.
  $CTTContent = Get-Content -LiteralPath $CTTFile

  # The first line holds the name of the combined image
  $CTTFirstLine  = [string]($CTTContent | Select-Object -Index 0) ; DebugMessage -Message ('Line 1: ' + $CTTFirstLine)

  # Test the path to the CTT file + the name given in the CTT file.
  if (TestPath -LiteralPath ($CTTPath + '\' + $CTTFirstLine + $PNG))
  {
    # Set the name to the one in the CTT file using the path of the CTT file.
    $global:CombinedName    = $CTTFirstLine
    $global:CombineSelected = $CTTPath + '\' + $CombinedName + $PNG
  }
  # Test the path to the CTT file + the name of the CTT file.
  elseif (TestPath -LiteralPath ($CTTPath + '\' + $CTTName + $PNG))
  {
    # Set the name to the one in the CTT file using the path of the CTT file.
    $global:CombinedName    = $CTTName
    $global:CombineSelected = $CTTPath + '\' + $CombinedName + $PNG
  }
  # The texture can't be found.
  else
  {
    # There is no texture to be found so just default it out.
    $global:CombinedName    = 'CombinedTexture'
    $global:CombineSelected = 'Select or drag and drop a texture to split into multiple textures...'
  }
  # Get image info on the "Combined Texture" which is used in some child functions.
  if (TestPath -LiteralPath $CombineSelected) { $CombinedInfo = CreateTextureInfo -ImageFile $CombineSelected } else { $CombinedInfo = $null }

  # Fill out the rest of the variables based on what is found in the CTT file.
  $TextureSegmentPath         = [string]($CTTContent | Select-Object -Index 1) ; DebugMessage -Message ('Line 2: ' + $TextureSegmentPath)
  $global:TexSegDimensions    = [string]($CTTContent | Select-Object -Index 2) ; DebugMessage -Message ('Line 3: ' + $TexSegDimensions)
  $global:TextureCols         = [int]($CTTContent | Select-Object -Index 3)    ; DebugMessage -Message ('Line 4: ' + $TextureCols)
  $global:TextureRows         = [int]($CTTContent | Select-Object -Index 4)    ; DebugMessage -Message ('Line 5: ' + $TextureRows)
  $global:CombineOverlapValue = [int]($CTTContent | Select-Object -Index 5)    ; DebugMessage -Message ('Line 6: ' + $CombineOverlapValue)
  $GetCropPixelText           = [string]($CTTContent | Select-Object -Index 6) ; DebugMessage -Message ('Line 7: ' + $GetCropPixelText)
  $ButtonSizes                = [string]($CTTContent | Select-Object -Index 7) ; DebugMessage -Message ('Line 8: ' + $ButtonSizes) -FollowUp ' '

  # Get the crop pixels that were set.
  $GetCropPixelSplit = $GetCropPixelText.Split(':', 4)

  # Debug:Show a message to let me know what is going on.
  DebugMessage -Message '--Set Crop Garbage Pixels--' -FollowUp ' '

  # Store them into their appropriate combine zelda variables.
  $global:CombinePixelCropL = [int]$GetCropPixelSplit[0] ; DebugMessage -Message ('CombinePixelCropL: ' + $CombinePixelCropL)
  $global:CombinePixelCropT = [int]$GetCropPixelSplit[1] ; DebugMessage -Message ('CombinePixelCropT: ' + $CombinePixelCropT)
  $global:CombinePixelCropB = [int]$GetCropPixelSplit[2] ; DebugMessage -Message ('CombinePixelCropB: ' + $CombinePixelCropB)
  $global:CombinePixelCropR = [int]$GetCropPixelSplit[3] ; DebugMessage -Message ('CombinePixelCropR: ' + $CombinePixelCropR) -FollowUp ' '

  # Debug:Show a message to let me know whats going on.
  DebugMessage -Message '--Calculate Restore Garbage Pixels--' -FollowUp ' '

  # Also calculate the values used in the split zelda options.
  $global:SplitPixelRestoreL = $global:CTTSplitPixelRestoreL = LoadCTTFile_PixelRestoreCalculate -BaseAmount $CombinePixelCropL -Dimensions $TexSegDimensions ; DebugMessage -Message ('SplitPixelRestoreL: ' + $SplitPixelRestoreL)
  $global:SplitPixelRestoreT = $global:CTTSplitPixelRestoreT = LoadCTTFile_PixelRestoreCalculate -BaseAmount $CombinePixelCropT -Dimensions $TexSegDimensions ; DebugMessage -Message ('SplitPixelRestoreT: ' + $SplitPixelRestoreT)
  $global:SplitPixelRestoreB = $global:CTTSplitPixelRestoreB = LoadCTTFile_PixelRestoreCalculate -BaseAmount $CombinePixelCropB -Dimensions $TexSegDimensions ; DebugMessage -Message ('SplitPixelRestoreB: ' + $SplitPixelRestoreB)
  $global:SplitPixelRestoreR = $global:CTTSplitPixelRestoreR = LoadCTTFile_PixelRestoreCalculate -BaseAmount $CombinePixelCropR -Dimensions $TexSegDimensions ; DebugMessage -Message ('SplitPixelRestoreR: ' + $SplitPixelRestoreR) -FollowUp ' '

  # Debug:Show a message to let me know whats going on.
  DebugMessage -Message '--Get Button Sizes--' -FollowUp ' '

  # Split the value on the "x" to get the dimensions.
  $ButtonSizes = $ButtonSizes.Split('x', 2)

  # Set the values based on the values obtained.
  $global:CombineButtonSizeX = [int]$ButtonSizes[0] ; DebugMessage -Message ('Button Width : ' + $CombineButtonSizeX)
  $global:CombineButtonSizeY = [int]$ButtonSizes[1] ; DebugMessage -Message ('Button Height: ' + $CombineButtonSizeY) -FollowUp ' '

  # Debug:Show a message to let me know whats going on.
  DebugMessage -Message '--Get Split-Pixel Insert--' -FollowUp ' '

  # Get the pixel overlap for the "Split" option.
  $global:SplitPixelOverlap = $global:CTTSplitPixelOverlap = LoadCTTFile_SplitPixelCalculate -Dimensions $TexSegDimensions ; DebugMessage -Message ('SplitPixelOverlap : ' + $SplitPixelOverlap) -FollowUp '-----------------------------------------------------------------------------'

  # Recreate the texture array and also an array to reference just the texture names.
  $global:TextureArray  = New-Object 'string[,]' ($TextureRows+1),($TextureCols+1)
  $global:CTTSplitArray = New-Object 'string[,]' ($TextureRows+1),($TextureCols+1)
  $global:AltSplitArray = New-Object 'string[,]' ($TextureRows+1),($TextureCols+1)

  # Fill the texture arrays. "TextureArray" gets the full paths, and "CTTSplitArray" only gets names.
  LoadCTTFile_FillTextureArrays -StartIndex 8 -Path $TextureSegmentPath -Content $CTTContent

  # Destroy all images that may be attached to buttons.
  DisposeBitmapList -BitmapList $CombineImages

  # Clear all images from the array.
  $CombineImages.Clear()

  # Create the buttons so we can add the images to them.
  CombineTextures_CreateButtons

  # Add images to buttons found on the "combine" GUI.
  LoadCTTFile_PopulateCombineButtons

  # Update the GUI with the new values.
  LoadCTTFile_UpdateGUI

  # Disable the dialog states.
  ToggleDialogStates -State $true
  
  # Enable the button to clear a CTT file.
  $SplitClearCTTButton.Enabled = $true
}
#==============================================================================================================================================================================================
#  Loads a CTT file by dragging and dropping it onto the "Load CTT File" button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFileDragDrop()
{
  # Get the item that has been dropped onto the button.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Get the data of the item that has been dropped.
    $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))
    $DroppedItem = Get-Item -LiteralPath $DroppedPath

    # Probably don't need to test the path, but fuck it why not.
    if (TestPath -LiteralPath $DroppedPath)
    {
      # Make sure it's a CTT file.
      if ($DroppedItem.Extension -eq $CTT)
      {
        # Load the CTT file.
        LoadCTTFile -CTTFile $DroppedPath
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Loads a CTT file by clicking on the button and selecting it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadCTTFileButtonClick()
{
  # Load the selected CTT file.
  $CTTFile = Get-FileName -StartPath $BaseFolder -FileName '*.ctt' -Description 'CTT File'

  # Test the path to the CTT file.
  if (TestPath -LiteralPath $CTTFile)
  {
    # Load the CTT file.
    LoadCTTFile -CTTFile $CTTFile
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $CombineDialog           - Form           - Global
#  $CombineDoneButton       - PictureBox     - Global
#  $CombineClearButton      - Panel          - Global
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES DIALOG - ZELDA:OOT AUTO-ARRANGE FUNCTIONS
#==============================================================================================================================================================================================
#  Generates all the segments required when attempting to auto-arrange textures in RAM so they can be compared later.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_AutoArrangeSegments([string[]]$TextureDropList)
{
  # Get the width and height of the first image in the array.
  $BaseInfo = GetImageInfo -ImageFile $TextureDropList[0]

  # Set up the 3D array sizes. Use the largest dimension for the pixel count.
  $TexCount = $TextureDropList.Count
  $TexSides = 4
  $PixCount = [Math]::Max($BaseInfo.Width, $BaseInfo.Height)

  # Create the 3D array to store the texture name, number of sides, and the pixel count.
  $global:ZeldaImages = New-Object 'string[,,]' $TexCount,$TexSides,$PixCount

  # Loop through all textures in the dropped list.
  for ($SIndex = 0; $SIndex -lt $TextureDropList.Count ; $SIndex++)
  {
    # Get information about the image.
    $SegInfo = GetImageInfo -ImageFile $TextureDropList[$SIndex]
    $SegItem = Get-Item -LiteralPath $TextureDropList[$SIndex]

    # Get the image as a bitmap so pixels can be analyzed.
    $ImageFile  = [Drawing.Image]::FromFile($TextureDropList[$SIndex])
    $ImgBitmap = New-Object Drawing.Bitmap($ImageFile)

    # Build a pixel array for each side of the image.
    for ($Side = 0; $Side -lt 4 ; $Side++)
    {
      # Different settings are needed for each side.
      switch ($Side.ToString())
      {
        # Top / Bot / Left / Right
        '0' { $TotalPixels = $SegInfo.Width  ; $UglySwitch = 'X' ; $Offset = 0 }
        '1' { $TotalPixels = $SegInfo.Width  ; $UglySwitch = 'X' ; $Offset = $SegInfo.Height - 1 }
        '2' { $TotalPixels = $SegInfo.Height ; $UglySwitch = 'Y' ; $Offset = 0 }
        '3' { $TotalPixels = $SegInfo.Height ; $UglySwitch = 'Y' ; $Offset = $SegInfo.Width - 1 }      
      }
      # Loop through all the pixels that is needed.
      for ($Pixels = 0 ; $Pixels -lt $TotalPixels ; $Pixels++)
      {
        # This ugly switch swaps between going along the "X" axis or the "Y" axis.
        switch ($UglySwitch)
        {
          # Get the current pixel and store it in the array.
          'X' { $global:ZeldaImages[$SIndex,$Side,$Pixels] = '' + $SegItem.BaseName + ':' + ($ImgBitmap.GetPixel($Pixels,$Offset)).R + ':' + ($ImgBitmap.GetPixel($Pixels,$Offset)).G + ':' + ($ImgBitmap.GetPixel($Pixels,$Offset)).B }
          'Y' { $global:ZeldaImages[$SIndex,$Side,$Pixels] = '' + $SegItem.BaseName + ':' + ($ImgBitmap.GetPixel($Offset,$Pixels)).R + ':' + ($ImgBitmap.GetPixel($Offset,$Pixels)).G + ':' + ($ImgBitmap.GetPixel($Offset,$Pixels)).B }
        }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Finds the top left texture by removing textures from "TheChosenOne" list until only the TopLeft texture remains.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_AutoArrangeFindTopLeft([string[]]$TextureDropList, [string]$CompareType)
{
  # Loop through all textures in the dropped list.
  for ($SIndex = 0; $SIndex -lt $TextureDropList.Count ; $SIndex++)
  {
    # Get information about the image.
    $SegInfo = GetImageInfo -ImageFile $TextureDropList[$SIndex]
    $SegItem = Get-Item -LiteralPath $TextureDropList[$SIndex]

    # Sets up whether top and bottom or left and right are being compared.
    switch ($CompareType)
    {
      # Top = 0, Bot = 1, Left = 2, Right = 3
      'Width'   { $SideA = 0 ; $SideB = 1 ; $CDimension = $SegInfo.Width  }
      'Height'  { $SideA = 2 ; $SideB = 3 ; $CDimension = $SegInfo.Height }
    }
    # Create a second loop through all textures in the droplist.
    for ($CIndex = 0; $CIndex -lt $TextureDropList.Count ; $CIndex++)
    {
      # Get the comparison image as an item.
      $ComItem = Get-Item -LiteralPath $TextureDropList[$CIndex]
    
      # Don't bother comparing the texture to itself.
      if ($CIndex -eq $SIndex) { continue }

      # Tracks the number of consecutive matching pixels. Matches will equal width to fail being a "top-left" texture.
      $PixelMatches = 0

      # Compare top pixels of source image to bottom pixels of the compare image.
      for ($Pixels = 0 ; $Pixels -lt $CDimension ; $Pixels++)
      {
        # Crop the name from the pixels.
        $SegmentPixels = $ZeldaImages[$SIndex,$SideA,$Pixels].Replace(($SegItem.BaseName + ':'), '')
        $ComparePixels = $ZeldaImages[$CIndex,$SideB,$Pixels].Replace(($ComItem.BaseName + ':'), '')

        # If they match, reset the number of consecutive matches. Otherwise increase the number of consecutive matches.
        if ($SegmentPixels -eq $ComparePixels) { $PixelMatches++ } else { $PixelMatches = 0 }

        # If the total matches is equal to the width (the segments are identical), it's not a top left texture.
        if ($PixelMatches -eq $CDimension) { $global:TheChosenOne.Remove($TextureDropList[$SIndex]) | Out-Null }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Creates a hashtable for the current texture that holds the pixels to be compared and the index of the texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTexture_AutoArrangeGetPixels([string[]]$TextureDropList, [string]$Side)
{
  # Create a hash table to return multiple values.
  $AAHTable = @{}

  # Sets up whether top and bottom or left and right are being compared.
  switch ($Side)
  {
    # Top = 0, Bot = 1, Left = 2, Right = 3
    'Top'   { $PixelIndex = 0 ; $PixelCount = $MainSegInfo.Width }
    'Bot'   { $PixelIndex = 1 ; $PixelCount = $MainSegInfo.Width }
    'Left'  { $PixelIndex = 2 ; $PixelCount = $MainSegInfo.Height }
    'Right' { $PixelIndex = 3 ; $PixelCount = $MainSegInfo.Height }
  }
  # The name of the texture we are trying to find.
  $SearchName = '*' + $MainSegItem.BaseName + '*'

  # Loop through all main indexes of the zelda list.
  for ($Index = 0 ; $Index -lt $TextureDropList.Count ; $Index++)
  {
    # Find the results that match the texture name.
    if ($ZeldaImages[$Index,$PixelIndex,0] -like $SearchName)
    {
      # Keep track of the index that was found.
      $AAHTable.Index = $Index
    }
  }
  # Create an array to store the pixel values.
  $AAHTable.PixelArray = New-Object string[] $PixelCount

  # We now have the texture index. Get all the pixels.
  for ($Pixels = 0 ; $Pixels -lt $PixelCount ; $Pixels++)
  {
    # Store the result in the corresponding array index.
    $AAHTable.PixelArray[$Pixels] = $ZeldaImages[$AAHTable.Index,$PixelIndex,$Pixels].Replace(($MainSegItem.BaseName + ':'), '')
  }
  # Return the pixels that were found.
  return $AAHTable
}
#==============================================================================================================================================================================================
#  Finds the next texture in the list: whether it be the next one in the row, or the next column down.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_FindTexture([string[]]$TextureDropList, [hashtable]$IHashTable, [string]$CompareType)
{
  # Sets up whether top and bottom or left and right are being compared.
  switch ($CompareType)
  {
    # Top = 0, Bot = 1, Left = 2, Right = 3
    'Width'   { $Side = 0 ; $CDimension = $MainSegInfo.Width  }
    'Height'  { $Side = 2 ; $CDimension = $MainSegInfo.Height }
  }
  # We may find multiple matches, so create a list of them.
  $EdgeMatches = New-Object Collections.Generic.List[string]

  # Compare the left side pixels of all textures to the right side pixels of the current texture.
  for ($Index = 0 ; $Index -lt $TextureDropList.Count ; $Index++)
  {
    # Do not compare the texture against itself.
    if ($Index -ne $IHashTable.Index)
    {
      # Keeps track of the number of concurrent pixels that match.
      $PixelMatches = 0
    
      # Now we need to loop through all the pixels to compare.
      for ($Pixels = 0 ; $Pixels -lt $CDimension ; $Pixels++)
      {
        # Split the line so we can extract the name from the pixel values.
        $PixelLineSplit = $ZeldaImages[$Index,$Side,$Pixels].Split(':')

        # Store the image name and the value of the pixels.
        $PixelLineImage = $PixelLineSplit[0]
        $PixelLineValue = $PixelLineSplit[1] + ':' + $PixelLineSplit[2] + ':' + $PixelLineSplit[3]

        # If these pixels match the pixels from the current texture increment the match count. Otherwise reset the count.
        if ($PixelLineValue -eq $IHashTable.PixelArray[$Pixels]) { $PixelMatches++ } else { $PixelMatches = 0 }

        # When the concurrent matches is equal to the dimension it completely matches.
        if ($PixelMatches -eq $CDimension)
        {
          # Get the full path to the texture.
          $FullTexPath = $MainSegItem.DirectoryName + '\' + $PixelLineImage + $PNG

          # Keep track of the number of matches that are found.
          $EdgeMatches.Add($FullTexPath) | Out-Null
        }
      }
    }
  }
  # If there is only a single match for the edge just use it directly.
  if ($EdgeMatches.Count -eq 1)
  {
    # Easy peezy when there's only a single match.
    $UpdateTexture = $EdgeMatches[0]
  }
  # If there are multiple edges that match allow the user to select one of them.
  elseif ($EdgeMatches.Count -gt 1)
  {
    # Show a dialog that allows the user to select the texture.
    ShowAutoArrangeMultipleChoices -MatchList $EdgeMatches | Out-Null

    # Set the texture to whatever the user selected.
    $UpdateTexture = $AutoArrangeListBox.SelectedItem
  }
  # I think some junk might be getting through, so make sure this has a valid value.
  if (TestPath -LiteralPath $UpdateTexture)
  {
    # Update the current texture file to the matching texture.
    $global:CurTextFile = $UpdateTexture

    # Assume that all segments are in the same folder.
    $global:MainSegItem = Get-Item -LiteralPath $UpdateTexture
    $global:MainSegInfo = CreateTextureInfo -ImageFile $UpdateTexture

    # Add the texture to the arranged list.
    $global:ArrangedList.Add($UpdateTexture) | Out-Null
  }
}
#==============================================================================================================================================================================================
#  Finds the arrangement of textures for the arranged list that will be sent back to the main function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_AutoArrangeFindTextures([string[]]$TextureDropList)
{
  # The top left texture will be the first one added to the list.
  $global:ArrangedList = New-Object Collections.Generic.List[string]
  $global:ArrangedList.Add($TopLeftTexture) | Out-Null

  # Keeps track of some textures. Make them global since child functions also set them.
  $global:CurTextFile = $TopLeftTexture

  # Assume that all segments are in the same folder.
  $global:MainSegItem = Get-Item -LiteralPath $TopLeftTexture
  $global:MainSegInfo = CreateTextureInfo -ImageFile $TopLeftTexture

  # Start on the first row, but second column since the top-left texture is already known.
  $RowsLoop = 0
  $ColsLoop = 1

  # Loop until all rows have been resolved.
  while ($RowsLoop -lt $TextureRows)
  {
    # Get the bottom pixels of the current texture. These will be used when the next row down will be found.
    $BHashTable = CombineTexture_AutoArrangeGetPixels -TextureDropList $TextureDropList -Side 'Bot'

    # Loop until all cols have been resolved.
    while ($ColsLoop -lt $TextureCols)
    {
      # Get the rightmost pixels of the current texture. These will be used now to determine the next texture in the row.
      $RHashTable = CombineTexture_AutoArrangeGetPixels -TextureDropList $TextureDropList -Side 'Right'

      # Find all textures along the current row.
      CombineTextures_FindTexture -TextureDropList $TextureDropList -IHashTable $RHashTable -CompareType 'Height'

      # The texture was found for this column.
      $ColsLoop++
    }
    # Find the first texture of the next row down.
    CombineTextures_FindTexture -TextureDropList $TextureDropList -IHashTable $BHashTable -CompareType 'Width'

    # Reset the number of columns and increment the row.
    $ColsLoop = 1
    $RowsLoop++
  }
}
#==============================================================================================================================================================================================
#  Create the dialog to show the message that a top-left texture must be selected.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_TopLeftTexture()
{
  # Create the dialog and set up properties.
  $global:CombineTopLeftDialog = New-Object Windows.Forms.Form
  $CombineTopLeftDialog.Size = DPISize (New-Object Drawing.Size(300, 120))
  $CombineTopLeftDialog.MinimumSize = DPISize (New-Object Drawing.Size(300, 120))
  $CombineTopLeftDialog.MaximumSize = DPISize (New-Object Drawing.Size(300, 120))
  $CombineTopLeftDialog.Text = 'Select Top-Left Texture'
  $CombineTopLeftDialog.MinimizeBox = $false
  $CombineTopLeftDialog.MaximizeBox = $false
  $CombineTopLeftDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $CombineTopLeftDialog.FormBorderStyle = GetFormBorderStyle
  $CombineTopLeftDialog.StartPosition = "CenterScreen"
  $CombineTopLeftDialog.Topmost = !$DisableTopMost
  $CombineTopLeftDialog.KeyPreview = $true
  $CombineTopLeftDialog.Add_FormClosing({ $CombineTopLeftDialog.Hide() ; $_.Cancel = $true })
  $CombineTopLeftDialog.Icon = $Icon_CTTPSGreen

  # Create a panel to hold all the shit.
  $global:TopLeftTexturePanel = New-Object Windows.Forms.Panel
  $TopLeftTexturePanel.Size = DPISize (New-Object Drawing.Size(300, 120))
  $TopLeftTexturePanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $CombineTopLeftDialog.Controls.Add($TopLeftTexturePanel)

  # Create a label with a message.
  $global:TopLeftTextureLabel = New-Object Windows.Forms.Label
  $TopLeftTextureLabel.Size = DPISize (New-Object Drawing.Size(300, 14))
  $TopLeftTextureLabel.Location = DPISize (New-Object Drawing.Point(28, 13))
  $TopLeftTextureLabel.Text = 'Select the texture that will be the "top-left" texture.'
  $TopLeftTexturePanel.Controls.Add($TopLeftTextureLabel)

  # Create a button to close the window.
  $global:TopLeftButton = New-Object Windows.Forms.Button
  $TopLeftButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $TopLeftButton.Location = DPISize (New-Object Drawing.Point(102, 40))
  $TopLeftButton.Text = 'OK'
  $TopLeftButton.Add_Click({ $CombineTopLeftDialog.Hide() })
  $TopLeftTexturePanel.Controls.Add($TopLeftButton)
  $CombineTopLeftDialog.AcceptButton = $TopLeftButton
}
#==============================================================================================================================================================================================
#  A special method to figure out Zelda64 backgrounds that have overlapping pixels.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_AutoArrange([string[]]$TextureDropList)
{
  # "TheChosenOne" will eventually only hold the top-left image.
  $global:TheChosenOne = New-Object Collections.Generic.List[string]

  # Add each texture into the "TheChosenOne" array. As each non-match to top-left is found, it will be removed.
  foreach ($ListEntry in $TextureDropList) { $TheChosenOne.Add($ListEntry) | Out-Null }

  # Generate all the pixel segments required in RAM.
  CombineTextures_AutoArrangeSegments -TextureDropList $TextureDropList

  # Allow the user to force a "top-left" texture.
  if ($UserSpecifyTopLeft)
  {
    # Show the dialog that says the texture will have to be selected.
    $CombineTopLeftDialog.ShowDialog()

    # Guess the path the files are coming from.
    $DropPath = [string]((Get-Item -LiteralPath $TextureDropList[0]).DirectoryName)

    # Set the top-left texture to whatever the user set it as.
    $global:TopLeftTexture = Get-FileName -StartPath $DropPath -FileName '*.png' -Description 'PNG File'

    # As a fail-safe and prevent infinite loops down the line, make sure that the drop list actually contains
    # the "top-left" texture. This can happen if the user picks a texture that is not in the dropped list.
    if ($TextureDropList -notcontains $TopLeftTexture)
    {
      # While it's probably not really the top-left texture, it will prevent shit from breaking later on.
      $global:TopLeftTexture = $TextureDropList[0]
    }
  }
  # Calculate the top-left texture by comparing duplicate overlapping pixels.
  if (!(TestPath -LiteralPath $TopLeftTexture))
  {
    # Find the top-left by removing textures from "TheChosenOne" until only the top-left remains.
    CombineTextures_AutoArrangeFindTopLeft -TextureDropList $TextureDropList -CompareType 'Width'
    CombineTextures_AutoArrangeFindTopLeft -TextureDropList $TextureDropList -CompareType 'Height'

    # There should only be one texture remaining in "TheChosenOne" and that should be the top-left texture.
    $global:TopLeftTexture = $TheChosenOne[0]
  }
  # Create the arranged list of textures to send back to the main function.
  CombineTextures_AutoArrangeFindTextures -TextureDropList $TextureDropList

  # Clean up your room lad.
  $global:TheChosenOne    = $null
  $global:ZeldaImages     = $null
  $global:CurTextFile     = $null
  $global:MainSegItem     = $null
  $global:MainSegInfo     = $null
  $global:TopLeftTexture  = $null
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES DIALOG - SUPPORT FUNCTIONS
#==============================================================================================================================================================================================
#  Update values for texture rows or columns on both the combined and split texture options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateTextureArrayCells()
{
  # For some reason the value is always a decimal, but we want an integer.
  $IntValue = [int]$this.Value

  # Update the global variable pulled from $this.Name that holds the rows ($TextureRows) or columns ($TextureCols).
  Set-Variable -Name $this.Name -Value $IntValue -Scope 'Global'

  # Rows were modified.
  if ($this.Name -eq 'TextureRows')
  {
    # Update rows for both split and combine options.
    $CombineRowsNumBox.Value      = $TextureRows
    $SplitTextureRowsNumBox.Value = $TextureRows
  }
  # Columns were modified.
  else
  {
    # Update columns for both split and combine options.
    $CombineColumnsNumBox.Value   = $TextureCols
    $SplitTextureColsNumBox.Value = $TextureCols
  }
} 
#==============================================================================================================================================================================================
#  Sets the name of the output texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_UpdateName()
{
  # Make sure the input only contains letters, numbers, or spaces.
  if (($this.Text -eq '') -or ($this.Text -notmatch '^[a-zA-Z0-9 _,!(){}+=`,@$#%-/s\.]*$'))
  {
    # Clear the text since whatever was entered can't be used.
    $this.Text = $CombinedName
  }
  # If the check passed then update the name to be used.
  $global:CombinedName = $this.Text
}
#==============================================================================================================================================================================================
#  Creates a new texture array and optionally copies data from the old one if it exists.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_CreateArray([bool]$ClearData)
{
  # Create a new empty texture array using the current number of rows and columns.
  $NewTextureArray = New-Object 'string[,]' ($TextureRows+1),($TextureCols+1)

  # Used to track the button position.
  $Index = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # Loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Check to see if an array was already created and the current element holds a value.
      if ((!$ClearData) -and ($TextureArray -ne $null) -and ($TextureArray[$row,$col] -ne $null))
      {
        # If there was data in the old array then copy that data into the new array.
        $NewTextureArray[$row,$col] = $TextureArray[$row,$col]
      }
      # If the array did not exist, or the current element's value was empty.
      else
      {
        # Set the value to an empty string.
        $NewTextureArray[$row,$col] = ''
      }
      # If data is not to be copied, then reset the buttons.
      if ($ClearData)
      {
        # Make sure the button exists before trying to reset it.
        if ($CombineButton -ne $null)
        {
          # Update the button to remove the image and reset the (row,col) text.
          $CombineButton[$Index].Text = '' + $row + ',' + $col + ' [' + $Index + ']'
          $CombineButton[$Index].BackgroundImage = $null
        }
      }
      # Track the button position.
      $Index++
    }
  }
  # Set the new array to the current array.
  $global:TextureArray = $NewTextureArray

  # If the array to store zelda:oot "bonk" textures doesn't exist, or it's forced cleared, create it now.
  if ((!$ZeldaBonkArray) -or ($ClearData))
  {
    # This array stores extra textures that appear when smacking into the wall and creating a screen shake.
    $global:ZeldaBonkArray = New-Object 'string[]' 6
  }
}
#==============================================================================================================================================================================================
#  Selects a texture so it can be moved around on the grid.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_SelectTexture([int]$Row, [int]$Col, [int]$Index)
{
  # If there is a colon in the value, the texture was already set.
  if ($SelectedTexture -like '*;*')
  {
    # Split the value contained in SelectedTexture to grab the row, column, and index.
    $SelectedValues = $SelectedTexture.Split(';', 3)

    # Put some values in some variables and stuff.
    $SIndex = [int]$SelectedValues[2]

    # Check to see if the currently selected texture was clicked.
    if ($Index -eq $SIndex)
    {
      # Hide the glowing border from the texture.
      $CombineSelect[$Index].Visible = $false

      # The selected texture was the one that was clicked, so deselect it.
      $global:SelectedTexture = ''

      # Disable the selection panel.
      $CombineUpButtonBorder.Enabled  = $false
      $CombineButtonBorder.Enabled    = $false
      $CombineSelectionBorder.Enabled = $false

      # Don't want to do anything else so haul ass.
      return
    }
    # It's not the current texture so hide the currently selected highlight.
    $CombineSelect[$SIndex].Visible = $false
  }
  # Enable the selection panel.
  $CombineUpButtonBorder.Enabled  = $true
  $CombineButtonBorder.Enabled    = $true
  $CombineSelectionBorder.Enabled = $true

  # Highlight the new selected border.
  $CombineSelect[$Index].Visible = $true

  # Force the currently selected texture to the top.
  $CombineBorder[$Index].BringToFront()
  $CombineSelect[$Index].BringToFront()
  $CombineButton[$Index].BringToFront()

  # Set the selected texture to this one.
  $global:SelectedTexture = '' + $Row + ';' + $Col + ';' + $Index
}
#==============================================================================================================================================================================================
#  Because I need to capture both types of mouse clicks, the "MouseUp" event is used rather than "Click" event. This works well, but has an issue that is somewhat hard to explain. When the
#  "Open File" dialog pops up, and a texture is selected, the window can fade fast enough to click another button, which will detect this press and trigger the "MouseUp" event, which forces
#  showing another dialog for whatever button was accidentally pressed. To prevent false firings, a hidden cooldown prevents loading another texture for 0.5 seconds via a timer + global var.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_CooldownExpires()
{
  # Stop the timer when it expires.
  $AllowClicksTimer.Stop()

  # If this hack variable is true, then do not run this function.
  $global:CombineCooldown = $false
}
#==============================================================================================================================================================================================
#  Creates a new texture array and optionally copies data from the old one if it exists.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_AddTextureButton([string]$ImageFile, $OverrideButton = $null)
{
  # If this function is not launched from a button, a specific button needs to be supplied with the parameter.
  if ($OverrideButton -ne $null) { $TheButton = $OverrideButton } else { $TheButton = $this }

  # Split the button name to represent the row and column.
  $ButtonName   = $TheButton.Name.Split(';', 3)
  $CurrentRow   = [int]$ButtonName[0]
  $CurrentCol   = [int]$ButtonName[1]
  $CurrentIndex = [int]$ButtonName[2]

  # Set the image to the appropriate texture array.
  $global:TextureArray[$CurrentRow,$CurrentCol] = $ImageFile

  # Get the texture as an item object.
  $TextureItem = Get-Item -LiteralPath $ImageFile

  # Update the button with a preview of the image.
  $CombineImagePath = $TextureItem.FullName
  $CombineButton[$CurrentIndex].BackgroundImage = CombineTextures_SetButtonImage -ImageFile $CombineImagePath

  # If names are hidden, do not set the text. If they are shown, show the texture name.
  switch ($CombineHideNames)
  {
    $true  { $CombineButton[$CurrentIndex].Text = '' }
    $false { $CombineButton[$CurrentIndex].Text = $TextureItem.BaseName }
  }
  # Update the default path to where the last texture was selected.
  $global:CombineLastSelected = $TextureItem.DirectoryName
}
#==============================================================================================================================================================================================
#  Displays an "Open File" dialog that allows selecting a texture and adding it to the grid array.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_OpenFile([int]$Row, [int]$Col, [int]$Index)
{
  # Do not let this function run if the cooldown is in effect.
  if ($CombineCooldown) { return }

  # Don't let it get this far again for 0.25 seconds.
  $global:CombineCooldown = $true

  # Deselect any selected textures.
  $global:SelectedTexture = ''

  # Disable the selection panel.
  $CombineUpButtonBorder.Enabled  = $false
  $CombineButtonBorder.Enabled    = $false
  $CombineSelectionBorder.Enabled = $false

  # If any textures are selected, hide the glow.
  foreach ($Highlight in $CombineSelect) { $Highlight.Visible = $false } 

  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $CombineLastSelected

  # Create an open file dialog to grab a PNG image.
  $SelectedFile = Get-FileName -StartPath $GetFilePath -FileName '*.png' -Description 'PNG Image' 

  # Check if the image exists.
  if (TestPath -LiteralPath $SelectedFile)
  {
    # Add the texture to the array and update the button with a preview of the image.
    CombineTextures_AddTextureButton -ImageFile $SelectedFile

    # Select the texture and highlight it which allows it to be moved around the grid.
    CombineTextures_SelectTexture -Row $Row -Col $Col -Index $Index
  }
  # Create a timer that expires after 0.25 seconds and allows this function to run again.
  $global:AllowClicksTimer = New-Object Windows.Forms.Timer
  $AllowClicksTimer.Interval = 250
  $AllowClicksTimer.Add_Tick({ CombineTextures_CooldownExpires })
  $AllowClicksTimer.Start()
}
#==============================================================================================================================================================================================
#  Child function of "CombineTextures_ButtonSelect". Reacts to a left mouse button click.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_LeftMouseButton([int]$Row, [int]$Col, [int]$Index)
{
  # A texture already exists in the array.
  if (TestPath -LiteralPath $TextureArray[$Row,$Col])
  {
    # If the control key was held when clicking the texture.
    if ([System.Windows.Forms.Control]::ModifierKeys -eq [System.Windows.Forms.Keys]::Control)
    {
      # Hide the glowing border from the texture.
      $CombineSelect[$Index].Visible = $false

      # The selected texture was the one that was clicked, so deselect it.
      $global:SelectedTexture = ''

      # Disable the selection panel.
      $CombineUpButtonBorder.Enabled  = $false
      $CombineButtonBorder.Enabled    = $false
      $CombineSelectionBorder.Enabled = $false

      # Update the button to remove the image and reset the (row,col) text.
      $CombineButton[$Index].Text = '' + $Row + ',' + $Col + ' [' + $Index + ']'
      $CombineButton[$Index].BackgroundImage = $null

      # Clear the image from the texture array.
      $global:TextureArray[$Row,$Col] = ''
    }
    # The control key was not held.
    else
    {
      # If the shift key was held when clicking the texture.
      if ([System.Windows.Forms.Control]::ModifierKeys -eq [System.Windows.Forms.Keys]::Shift)
      {
        # Check to see if its the currently selected texture.
        if (($SelectedTexture -ne '') -and ($this.Name -eq $SelectedTexture))
        {
          # Allow renaming the texture.
          CombineTextures_RenameTexture
        }
      }
      # The shift key was not held.
      else
      {
        # Select the texture and highlight it which allows it to be moved around the grid.
        CombineTextures_SelectTexture -Row $Row -Col $Col -Index $Index
      }
    }
  }
  # A texture currently does not exist in the array.
  else
  {
    # Display an "Open File" dialog to allow selecting a texture to add to the grid.
    CombineTextures_OpenFile -Row $Row -Col $Col -Index $Index
  }
}
#==============================================================================================================================================================================================
#  Child function of "CombineTextures_ButtonSelect". Reacts to a right mouse button click.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_RightMouseButton([int]$Row, [int]$Col, [int]$Index, [string]$Value)
{
  # Check to see if a texture is already selected and that it's not the clicked button.
  if (($SelectedTexture -ne '') -and ($this.Name -ne $SelectedTexture))
  {
    # Split the value contained in SelectedTexture to grab the row, column, and path.
    $SelectedValues = $SelectedTexture.Split(';', 3)

    # Put some values in some variables and stuff.
    $NewRow   = [int]$SelectedValues[0]
    $NewCol   = [int]$SelectedValues[1]
    $NewIndex = [int]$SelectedValues[2]
    $NewValue = $TextureArray[$NewRow,$NewCol]

    # Reverse the textures in the array.
    $global:TextureArray[$Row,$Col]       = $NewValue
    $global:TextureArray[$NewRow,$NewCol] = $Value

    # Set the old button image. This ugly ass code saves me some lines.
    if     ($Value -eq '') { $CombineButton[$NewIndex].BackgroundImage = $null }
    elseif ($Value -ne '') { $CombineButton[$NewIndex].BackgroundImage = CombineTextures_SetButtonImage -ImageFile $Value }

    # Move the image to the new button.
    $CombineButton[$Index].BackgroundImage = CombineTextures_SetButtonImage -ImageFile $NewValue

    # Update the button names. 
    CombineTextures_SetButtonText -Row $Row -Col $Col -Index $Index
    CombineTextures_SetButtonText -Row $NewRow -Col $NewCol -Index $NewIndex

    # Update the selected texture.
    $global:SelectedTexture = '' + $Row + ';' + $Col + ';' + $Index

    # Remove the glow from the previously selected texture and add it to the new one.
    $CombineSelect[$NewIndex].Visible = $false
    $CombineSelect[$Index].Visible = $true

    # Force the currently selected texture to the top.
    $CombineBorder[$Index].BringToFront()
    $CombineSelect[$Index].BringToFront()
    $CombineButton[$Index].BringToFront()
  }
  # A texture is not selected or the selected texture is the button that was pressed.
  else
  {
    # Display an "Open File" dialog to allow selecting a texture to add to the grid.
    CombineTextures_OpenFile -Row $Row -Col $Col -Index $Index
  }
}
#==============================================================================================================================================================================================
#  When a button is pressed on the combine dialog grid, this determines what action is taken.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_ButtonSelect()
{
  # Split the button name to represent the row and column.
  $ButtonName = $this.Name.Split(';', 3)

  # Get the relevant data. This will be passed down the line.
  $CRow = [int]$ButtonName[0]
  $CCol = [int]$ButtonName[1]
  $CInd = [int]$ButtonName[2]
  $CVal = $TextureArray[$CRow,$CCol]

  # Check which mouse button was pressed to fire the event.
  switch ($_.Button)
  {
    # Depending on the button pressed, a different action may happen.
    'Left'  { CombineTextures_LeftMouseButton -Row $CRow -Col $CCol -Index $CInd }
    'Right' { CombineTextures_RightMouseButton -Row $CRow -Col $CCol -Index $CInd -Value $CVal }
  }
}
#==============================================================================================================================================================================================
#  Allows dragging and dropping an image onto a button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_DragDrop()
{
  # This is used a few times here, so may as well create a reference var.
  $TexCount = $TextureRows * $TextureCols

  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # This could take some time so disable the dialogs.
    ToggleDialogStates -State $false

    # Create a list of the data to select the first item from the list.
    $DroppedList = $_.Data.GetData([Windows.Forms.DataFormats]::FileDrop)

    # More than 1 file was dropped onto a button.
    if ($DroppedList.Count -gt 1)
    {
      # Only attempt the Zelda64 method if the debug option is set and the number of buttons match the number dropped.
      if (($CombineAutoArrange) -and ($TexCount -eq $DroppedList.Count))
      {
        # Create the arranged list which will hold the textures in the correct order.
        CombineTextures_AutoArrange -TextureDropList $DroppedList

        # Overwrite the list with one that has the textures automatically arranged.
        $DroppedList = $ArrangedList
      }
      # Keep track of the index.
      $Index = 0

      # Loop through the list of dropped files.
      foreach ($DroppedFile in $DroppedList)
      {
        # This function was not designed to be used this way, but I hacked it to make it work.
        CombineTextures_AddTextureButton -ImageFile $DroppedFile -OverrideButton $CombineButton[$Index]

        # Increment the loop index.
        $Index++

        # If we ran out of buttons, then exit the loop early.
        if (($Index + 1) -gt $TexCount) { break }
      }
    }
    # Only a single file was dropped onto a button.
    else
    {
      # Get the extension of the first item that was dropped from the list.
      $FileExtension = (Get-Item -LiteralPath $DroppedList[0]).Extension

      # Make sure the file is a PNG image.
      if ($FileExtension -eq $PNG)
      {
        # Add the texture to the array and update the button with a preview of the image.
        CombineTextures_AddTextureButton -ImageFile $DroppedList[0]
      }
    }
    # Done diddle, enable the dialog.
    ToggleDialogStates -State $true
  }
}
#==============================================================================================================================================================================================
#  Creates a bitmap from memory stream so the image does not get locked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_SetButtonImage([string]$ImageFile)
{
  # Get the image as a byte array, convert it to memory stream, convert that to image.
  $Bytes  = [IO.File]::ReadAllBytes($ImageFile)
  $Stream = [IO.MemoryStream]::New($Bytes)
  $Image  = [Drawing.Image]::FromStream($Stream)

  # A way to reference the images later to destroy them is needed.
  $global:CombineImages.Add($Image) | Out-Null

  # Return the image to the button.
  return $Image
}
#==============================================================================================================================================================================================
#  Adjust some dialog items based on width.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_AdjustDialog([int]$BorderX, [int]$BorderY)
{
  # Set the size of the dialog. Add extra pixels + calculate width of rows/cols - cols/rows to account for overlap + 1 because overlap happens 1 less time.
  $CombineDialogWidth  = (DPISize 26) + ($BorderX * $TextureCols) - $TextureCols + 1
  $CombineDialogHeight = (DPISize 106) + ($BorderY * $TextureRows) - $TextureRows + 1

  # Cap the minimum width so the buttons are always exposed.
  if ($CombineDialogWidth -lt (DPISize 260)) { $CombineDialogWidth = DPISize 260 }

  # Set the size of the dialog to the new size.
  $CombineDialog.Size = New-Object Drawing.Size($CombineDialogWidth, $CombineDialogHeight)
  $CombineDialog.MinimumSize = New-Object Drawing.Size($CombineDialogWidth, $CombineDialogHeight)
  $CombineDialog.MaximumSize = New-Object Drawing.Size($CombineDialogWidth, $CombineDialogHeight)

  # Calculate the position of the button panel and set it to the new location.
  $CombineButtonPanelX = ($CombineDialogWidth / 2) - ($CombineSelectPanel.Width / 2) - (DPISize 8)
  $CombineButtonPanelY = $CombineDialogHeight - (DPISize 95)
  $CombineSelectPanel.Location = New-Object Drawing.Point($CombineButtonPanelX, $CombineButtonPanelY)
}
#==============================================================================================================================================================================================
#  Creates buttons for the "Combine Textures" dialog and adds them to it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_CreateButtons()
{
  # Clear any existing buttons before creating new ones.
  if ($CombineButton -ne $null)
  {
    # Loop through all available buttons.
    for ($Index = 0; $Index -lt $CombineButton.Count; $Index++)
    {
      # Remove the button and border from the dialog.
      $CombineDialog.Controls.Remove($CombineBorder[$Index])
      $CombineDialog.Controls.Remove($CombineButton[$Index])
      $CombineDialog.Controls.Remove($CombineSelect[$Index])
    }
  }
  # Recreate the lists that will hold all the buttons and button borders.
  $global:CombineBorder = New-Object Collections.Generic.List[Windows.Forms.Panel]
  $global:CombineButton = New-Object Collections.Generic.List[Windows.Forms.Button]
  $global:CombineSelect = New-Object Collections.Generic.List[Windows.Forms.Panel]

  # Set up the size of the borders.
  $BorderSize_X = $CombineButtonSizeX + 2
  $BorderSize_Y = $CombineButtonSizeY + 2

  # Set up the offset of the first button.
  $BorderOffset_X = DPISize 5
  $BorderOffset_Y = DPISize 4

  # Perform a few workarounds because the dialog wants to be fucking stupid.
  CombineTextures_AdjustDialog -BorderX $BorderSize_X -BorderY $BorderSize_Y

  # Reference the index of the button.
  $Index = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # And loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Create a border for the button.
      $NewBorder = New-Object Windows.Forms.Panel
      $NewBorder.Size = New-Object Drawing.Size($BorderSize_X, $BorderSize_Y)
      $NewBorder.Location = New-Object Drawing.Point($BorderOffset_X, $BorderOffset_Y)
      $NewBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#7d7d7d')
      $CombineDialog.Controls.Add($NewBorder) | Out-Null

      # Create a selection border for the button.
      $NewSelect = New-Object Windows.Forms.Panel
      $NewSelect.Size = New-Object Drawing.Size($BorderSize_X, $BorderSize_Y)
      $NewSelect.Location = New-Object Drawing.Point(0, 0)
      $NewSelect.BackColor = [Drawing.ColorTranslator]::FromHtml($CombineTileColor)
      $NewSelect.Visible = $false
      $NewBorder.Controls.Add($NewSelect)

      # Create the current button and add it to the dialog.
      $NewButton = New-Object Windows.Forms.Button
      $NewButton.Name = '' + $row + ';' + $col + ';' + $Index
      $NewButton.Font = New-Object Drawing.Font('Arial', 7.25)
      $NewButton.Size = New-Object Drawing.Size($CombineButtonSizeX, $CombineButtonSizeY)
      $NewButton.Location = New-Object Drawing.Point(1, 1)
      $NewButton.ForeColor = [Drawing.ColorTranslator]::FromHtml($CombineFontColor)
      $NewButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
      $NewButton.FlatAppearance.BorderSize = 0
      $NewButton.BackgroundImageLayout = [Windows.Forms.ImageLayout]::Stretch
      $NewButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
      $NewButton.AllowDrop = $true
      $NewButton.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
      $NewButton.Add_DragDrop({ CombineTextures_DragDrop })
      $NewButton.Add_MouseUp({ CombineTextures_ButtonSelect })
      $NewBorder.Controls.Add($NewButton)

      # If a texture exists in the array then show the image on the current button.
      if ($TextureArray[$row,$col] -ne '')
      {
        # Update the button with a preview of the image.
        $DisplayImage = CombineTextures_SetButtonImage -ImageFile $TextureArray[$row,$col]
        $NewButton.BackgroundImage = $DisplayImage
      }
      # Add the button to the button list so it can be referenced later.
      $global:CombineBorder.Add($NewBorder) | Out-Null
      $global:CombineSelect.Add($NewSelect) | Out-Null
      $global:CombineButton.Add($NewButton) | Out-Null

      # Set the proper button text.
      CombineTextures_SetButtonText -Row $row -Col $col -Index $Index

      # Increment the X offset for columns.
      $BorderOffset_X = $BorderOffset_X + $BorderSize_X - 1

      # Increment the button index.
      $Index++
    }
    # Increment the Y offset on a new row and reset the X offset.
    $BorderOffset_X = DPISize 5
    $BorderOffset_Y = $BorderOffset_Y + $BorderSize_Y - 1
  }
}
#==============================================================================================================================================================================================
#  Creates a texture array, adjusts the dialog size, adds texture buttons, and displays the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_DialogDisplay()
{
  # Create a new texture array.
  CombineTextures_CreateArray -ClearData $false

  # Create the buttons and resize the dialog.
  CombineTextures_CreateButtons

  # Clear the selected texture if there is one.
  $global:SelectedTexture = ''

  # Disable the selection panel.
  $CombineUpButtonBorder.Enabled  = $false
  $CombineButtonBorder.Enabled    = $false
  $CombineSelectionBorder.Enabled = $false

  # If any textures are selected, hide the glow.
  foreach ($Highlight in $CombineSelect) { $Highlight.Visible = $false } 

  # After the dialog is fully created, show it to the user.
  $CombineDialog.ShowDialog() | Out-Null
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES DIALOG - DIALOG FUNCTIONS
#==============================================================================================================================================================================================
#  Detects key presses on the "Combine" dialog and moves a selected texture around with WASD.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_DialogKey()
{
  # Get the key that was pressed.
  switch ($_.KeyCode)
  {
    # If a texture is selected, move it around.
    'W'      { CombineTextures_DirectionButton -Direction 'Up' }
    'Up'     { CombineTextures_DirectionButton -Direction 'Up' }
    'A'      { CombineTextures_DirectionButton -Direction 'Left' }
    'Left'   { CombineTextures_DirectionButton -Direction 'Left' }
    'S'      { CombineTextures_DirectionButton -Direction 'Down' }
    'Down'   { CombineTextures_DirectionButton -Direction 'Down' }
    'D'      { CombineTextures_DirectionButton -Direction 'Right' }
    'Right'  { CombineTextures_DirectionButton -Direction 'Right' }

    # If escape was pressed, close the dialog.  
    'Escape' { $this.Close() }
  }
}
#==============================================================================================================================================================================================
#  Updates the names of the buttons on the grid array based on whether or not a texture exists in the current slot.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_SetButtonText([int]$Row, [int]$Col, [int]$Index)
{
  # Use a switch because I said so.
  switch ($CombineHideNames)
  {
    # If names are shown, set the text to a blank value.
    $true   { $CombineButton[$Index].Text = '' }

    # If names are hidden, the text will either be the button info or the texture name.
    $false  {
              # Check to see if the texture array holds a texture. 
              if ($TextureArray[$Row,$Col] -ne '')
              {
                # Update the button text with the name of the image.
                $CombineButton[$Index].Text = (Get-Item -LiteralPath $TextureArray[$Row,$Col]).BaseName
              }
              # It does not hold a texture name.
              else
              {
                # Set the button text to the row, column, and index.
                $CombineButton[$Index].Text = '' + $Row + ',' + $Col + ' [' + $Index + ']'
              }
            }
  }
}
#==============================================================================================================================================================================================
#  Sets the color of the dialog item (either the grid array font color, or the grid array selection border).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_SetDialogItemColor($DialogItem, [string]$ItemType, [Drawing.Color]$Color)
{
  # Used to track the button position.
  $Index = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # Loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Set the color for the dialog item.
      switch ($ItemType)
      {
        # Selection border gets "backcolor". Grid button font gets "forecolor".
        'BackColor' { $DialogItem[$Index].BackColor = $Color }
        'ForeColor' { $DialogItem[$Index].ForeColor = $Color }
      }
      # Increment the index.
      $Index++
    }
  }
}
#==============================================================================================================================================================================================
#  Fires when the "Font Color" button is pressed. Control key can be held to change selection color instead.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_ColorButtonPress()
{
  # Create and show a color dialog to the user.
  $ColorSelect = $ColorDialog.ShowDialog()

  # Check to see if the color selection passed when the dialog was closed.
  if ($ColorSelect -eq 'OK')
  {
    # Compile the color into HTML format by converting each value to hexadecimal.
    $HTMLColor = '#' + $ColorDialog.Color.R.ToString('X2') + $ColorDialog.Color.G.ToString('X2') + $ColorDialog.Color.B.ToString('X2')

    # If the control key was held, change the selection color instead.
    if ($this.Name -eq 'SelectColor')
    {
      # Set the selection color to the HTML notation.
      $global:CombineTileColor = $HTMLColor
      $SetColor = [Drawing.ColorTranslator]::FromHtml($CombineTileColor)

      # Set the new color for the selection borders.
      CombineTextures_SetDialogItemColor -DialogItem $CombineSelect -ItemType 'BackColor' -Color $SetColor
    }
    # Change the color of the grid array font.
    else
    {
      # Set the font color to the HTML notation.
      $global:CombineFontColor = $HTMLColor
      $SetColor = [Drawing.ColorTranslator]::FromHtml($CombineFontColor)

      # Set the new color for the button font.
      CombineTextures_SetDialogItemColor -DialogItem $CombineButton -ItemType 'ForeColor' -Color $SetColor
    }
  }
}
#==============================================================================================================================================================================================
#  Hides or shows the names on the buttons when the toggle is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_ToggleButtonText()
{
  # Inverse the output of the tracking variable.
  $global:CombineHideNames = !$CombineHideNames

  # When hiding the button names.
  if ($CombineHideNames)
  {
    # Update the button to show the names.
    $CombineHideNamesButton.Image = $Image_NamesOff
  }
  else
  {
    # Update the text on the button to hide the names.
    $CombineHideNamesButton.Image = $Image_NamesOn
  }
  # Used to track the button position.
  $Index = 0

  # Loop through all rows.
  for ($row = 1; $row -le $TextureRows; $row++)
  {
    # Loop through all columns.
    for ($col = 1; $col -le $TextureCols; $col++)
    {
      # Set the button name to whatever it should be.
      CombineTextures_SetButtonText -Row $row -Col $col -Index $Index

      # Increment the index.
      $Index++
    }
  }
}
#==============================================================================================================================================================================================
#  When the clear button is pressed, ask the user if they really want to clear the grid.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_ClearPressed()
{
  # Set the title and message of the Yes/No dialog.
  $Title   = 'Clear Grid Array'
  $Message = 'Really remove all textures from the Grid Array?'

  # Show the dialog to the user.
  if (ShowYesNoDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 20) -OffsetX (DPISize 34) -OffsetY (DPISize 18) -Message $Message)
  {
    # If they hit "Yes" then clear the texture array.
    CombineTextures_CreateArray -ClearData $true

    # Clear the selected texture if there is one.
    $global:SelectedTexture = ''

    # Disable the selection panel.
    $CombineUpButtonBorder.Enabled  = $false
    $CombineButtonBorder.Enabled    = $false
    $CombineSelectionBorder.Enabled = $false

    # If any textures are selected, hide the glow.
    foreach ($Highlight in $CombineSelect) { $Highlight.Visible = $false }

    # Destroy all images that may be attached to buttons.
    DisposeBitmapList -BitmapList $CombineImages

    # Clear all images from the array.
    $CombineImages.Clear()
  }
}
#==============================================================================================================================================================================================
#  Deselects the currently selected texture when pressing the "deselect" button on the selection bar.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_ForceUnselect()
{
  # If there is a colon in the value, the texture was already set.
  if ($SelectedTexture -notlike '*;*') { return }

  # Split the value contained in SelectedTexture to grab the row, column, and index.
  $SelectedValues = $SelectedTexture.Split(';', 3)

  # Get the relevant data.
  $Row   = [int]$SelectedValues[0]
  $Col   = [int]$SelectedValues[1]
  $Index = [int]$SelectedValues[2]

  # Hide the glowing border from the texture.
  $CombineSelect[$Index].Visible = $false

  # The selected texture was the one that was clicked, so deselect it.
  $global:SelectedTexture = ''

  # Disable the selection panel.
  $CombineUpButtonBorder.Enabled  = $false
  $CombineButtonBorder.Enabled    = $false
  $CombineSelectionBorder.Enabled = $false

  # Remove the texture completely if the control key was held when clicking the texture.
  if ($this.Name -eq 'Remove')
  {
    # Update the button to remove the image and reset the (row,col) text.
    $CombineButton[$Index].Text = '' + $Row + ',' + $Col + ' [' + $Index + ']'
    $CombineButton[$Index].BackgroundImage = $null

    # Clear the image from the texture array.
    $global:TextureArray[$Row,$Col] = ''
  }
}
#==============================================================================================================================================================================================
#  Allows replacing the selected texture with the "open file" button on the selection bar.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_ExtraButtonSelect()
{
  # Split the button name to represent the row and column.
  $SelectSplit = $SelectedTexture.Split(';', 3)

  # Get the relevant data.
  $Row   = [int]$SelectSplit[0]
  $Col   = [int]$SelectSplit[1]
  $Index = [int]$SelectSplit[2]

  # Simulate the button name so the following functions think its from the grid.
  $this.Name =  '' + $Row + ';' + $Col + ';' + $Index

  # Display an "Open File" dialog to allow selecting a texture to add to the grid.
  CombineTextures_OpenFile
}
#==============================================================================================================================================================================================
#  Allows renaming a texture on the grid.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_RenameTexture()
{
  # If there is a colon in the value, the texture was set.
  if ($SelectedTexture -notlike '*;*') { return }

  # Split the value contained in SelectedTexture to grab the row, column, and index.
  $SelectedValues = $SelectedTexture.Split(';', 3)

  # Get the relevant data.
  $Row   = [int]$SelectedValues[0]
  $Col   = [int]$SelectedValues[1]
  $Index = [int]$SelectedValues[2]

  # Reset the textbox and the variable that tracks the "confirm" button.
  $CombineRenameTextBox.Text = ''
  $global:RenameText = ''
  $global:CombineDoRename = $false

  # Show the dialog with the textbox.
  $CombineRenameDialog.ShowDialog()

  # Make sure a value was entered.
  if (($CombineDoRename) -and ($RenameText -ne ''))
  {
    # Get the selected texture as an object item and set the path to the new name.
    $RenameItem = Get-Item -LiteralPath $TextureArray[$Row,$Col]
    $RenameFile = $RenameItem.DirectoryName + '\' + $RenameText + $PNG

    # If the file name already exists.
    if (TestPath -LiteralPath $RenameFile)
    {
      # The file being renamed must first be named something unique.
      $TempRenameFile = $RenameItem.DirectoryName + '\' + 'Temp_Rename' + $PNG

      # Rename the file being renamed to something that won't conflict with the existing file.
      Move-Item -LiteralPath $TextureArray[$Row,$Col] -Destination $TempRenameFile -Force

      # The texture that will get the old name of the texture being renamed.
      $SwapNameFile = $RenameItem.DirectoryName + '\' + $RenameItem.BaseName + $PNG

      # Used to track the button position.
      $FIndex = 0

      # Loop through all rows.
      for ($FRow = 1; $FRow -le $TextureRows; $FRow++)
      {
        # Loop through all columns.
        for ($FCol = 1; $FCol -le $TextureCols; $FCol++)
        {
          # We have to find the texture that is being replaced.
          if ($RenameFile -eq $TextureArray[$FRow,$FCol])
          {
            # Rename the file being renamed to something that won't conflict with the existing file.
            Move-Item -LiteralPath $TextureArray[$FRow,$FCol] -Destination $SwapNameFile -Force

            # Update the button text.
            $CombineButton[$FIndex].Text = $RenameItem.Name

            # Update the array with the new name.
            $global:TextureArray[$FRow,$FCol] = $SwapNameFile
          }
          # Increment the index.
          $FIndex++
        }
      }
      # Now that the conflict was taken care of, rename the temporary renamed file to the name entered.
      Move-Item -LiteralPath $TempRenameFile -Destination $RenameFile -Force
    }
    # The file name did not already exist.
    else
    {
      # Rename the file to what was entered.
      Move-Item -LiteralPath $TextureArray[$Row,$Col] -Destination $RenameFile -Force
    }
    # Update the button text.
    $CombineButton[$Index].Text = $RenameText

    # Update the array with the new name.
    $global:TextureArray[$Row,$Col] = $RenameFile
  }
}
#==============================================================================================================================================================================================
#  Moves selected textures around the grid array using the arrow buttons.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CombineTextures_DirectionButton([string]$Direction)
{
  # Do not try to move anything if a texture is not selected.
  if ($SelectedTexture -eq '') { return }

  # Split the value contained in SelectedTexture to grab the row, column, and path.
  $SelectedValues = $SelectedTexture.Split(';', 3)

  # Put some values in some variables and stuff.
  $OldRow = $NewRow = [int]$SelectedValues[0]
  $OldCol = $NewCol = [int]$SelectedValues[1]
  $OldInd = $NewInd = [int]$SelectedValues[2]
  $OldVal = $TextureArray[$OldRow,$OldCol]

  # The name of the button acts as the triggering mechanism.
  switch ($Direction)
  {
    # Modify the rows or columns based on which button was pressed.
    'Up'    { if ($OldRow -gt 1)            { $NewRow = $OldRow - 1 ; $NewInd = $OldInd - $TextureCols } }
    'Left'  { if ($OldCol -gt 1)            { $NewCol = $OldCol - 1 ; $NewInd = $OldInd - 1 } }
    'Down'  { if ($OldRow -lt $TextureRows) { $NewRow = $OldRow + 1 ; $NewInd = $OldInd + $TextureCols } }
    'Right' { if ($OldCol -lt $TextureCols) { $NewCol = $OldCol + 1 ; $NewInd = $OldInd + 1 } }
  }
  # The new value can now be retrieved.
  $NewVal = $TextureArray[$NewRow,$NewCol]

  # If the index changed, something moved.
  if ($OldInd -ne $NewInd)
  {
    # Get the buttons.
    $OldButton = $CombineButton[$OldInd]
    $NewButton = $CombineButton[$NewInd]

    # If the node the image is moving to is empty.
    if ($NewVal -eq '')
    {
      # Erase the old texture from the array and update the new texture.
      $global:TextureArray[$OldRow,$OldCol] = ''
      $global:TextureArray[$NewRow,$NewCol] = $OldVal

      # Set the old button to have a name and clear the image.
      $OldButton.BackgroundImage = $null

      # Move the image to the new button and hide the image text.
      $NewButton.BackgroundImage = CombineTextures_SetButtonImage -ImageFile $OldVal
    }
    # The node were moving to has an image, so swap them.
    else
    {
      # Erase the old texture from the array and update the new texture.
      $global:TextureArray[$OldRow,$OldCol] = $NewVal
      $global:TextureArray[$NewRow,$NewCol] = $OldVal

      # Set the old button to have a name and clear the image.
      $OldButton.BackgroundImage = CombineTextures_SetButtonImage -ImageFile $NewVal

      # Move the image to the new button and hide the image text.
      $NewButton.BackgroundImage = CombineTextures_SetButtonImage -ImageFile $OldVal
    }
    # Update the button names. 
    CombineTextures_SetButtonText -Row $OldRow -Col $OldCol -Index $OldInd
    CombineTextures_SetButtonText -Row $NewRow -Col $NewCol -Index $NewInd

    # Update the selected texture.
    $global:SelectedTexture = '' + $NewRow + ';' + $NewCol + ';' + $NewInd

    # Remove the glow from the previously selected texture and add it to the new one.
    $CombineSelect[$OldInd].Visible = $false
    $CombineSelect[$NewInd].Visible = $true

    # Force the currently selected texture to the top.
    $CombineBorder[$NewInd].BringToFront()
    $CombineSelect[$NewInd].BringToFront()
    $CombineButton[$NewInd].BringToFront()
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES - RENAME WINDOW
#==============================================================================================================================================================================================
#  The action to fire when confirming renaming the texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RenameButtonOkay()
{
  # The boolean below tracks whether or not the "Confirm" button was pressed.
  $global:CombineDoRename = $true

  # Get whatever the user entered into the textbox.
  $global:RenameText = $CombineRenameTextBox.Text

  # Hide the dialog and do the rename.
  $CombineRenameDialog.Hide()
}
#==============================================================================================================================================================================================
#  Create the window that shows the rename window.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_CombineRename()
{
  # Create the dialog and set up properties.
  $global:CombineRenameDialog = New-Object Windows.Forms.Form
  $CombineRenameDialog.Size = DPISize (New-Object Drawing.Size(300, 128))
  $CombineRenameDialog.MinimumSize = DPISize (New-Object Drawing.Size(300, 128))
  $CombineRenameDialog.MaximumSize = DPISize (New-Object Drawing.Size(300, 128))
  $CombineRenameDialog.Text = 'Rename Image'
  $CombineRenameDialog.MinimizeBox = $false
  $CombineRenameDialog.MaximizeBox = $false
  $CombineRenameDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $CombineRenameDialog.FormBorderStyle = GetFormBorderStyle
  $CombineRenameDialog.StartPosition = "CenterScreen"
  $CombineRenameDialog.Topmost = !$DisableTopMost
  $CombineRenameDialog.KeyPreview = $true
  $CombineRenameDialog.Add_KeyDown({ EscapeCloseDialog })
  $CombineRenameDialog.Add_FormClosing({ $CombineRenameDialog.Hide() ; $_.Cancel = $true })
  $CombineRenameDialog.Icon = $Icon_CTTPSGreen

  # Create a panel to hold all the shit.
  $global:CombineRenamePanel = New-Object Windows.Forms.Panel
  $CombineRenamePanel.Size = DPISize (New-Object Drawing.Size(300, 200))
  $CombineRenamePanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $CombineRenameDialog.Controls.Add($CombineRenamePanel)

  # Create a label for the textbox.
  $global:CombineRenameLabel = New-Object Windows.Forms.Label
  $CombineRenameLabel.Size = DPISize (New-Object Drawing.Size(180, 14))
  $CombineRenameLabel.Location = DPISize (New-Object Drawing.Point(10, 8))
  $CombineRenameLabel.Text = 'Enter a new name for the image:'
  $CombineRenamePanel.Controls.Add($CombineRenameLabel)

  # Create a label that holds the texture path.
  $global:CombineRenameTextBox = New-Object Windows.Forms.TextBox
  $CombineRenameTextBox.Size = DPISize (New-Object Drawing.Size(264, 14))
  $CombineRenameTextBox.Location = DPISize (New-Object Drawing.Point(10, 26))
  $CombineRenameTextBox.Text = ''
  $CombineRenamePanel.Controls.Add($CombineRenameTextBox)

  # Create a confirmation button.
  $global:CombineRenameConfirm = New-Object Windows.Forms.Button
  $CombineRenameConfirm.Size = DPISize (New-Object Drawing.Size(80, 28))
  $CombineRenameConfirm.Location = DPISize (New-Object Drawing.Point(110, 54))
  $CombineRenameConfirm.Text = 'Confirm'
  $CombineRenameConfirm.Add_Click({ RenameButtonOkay })
  $CombineRenamePanel.Controls.Add($CombineRenameConfirm)
  
  # Create a button to close the window.
  $global:CombineRenameCancel = New-Object Windows.Forms.Button
  $CombineRenameCancel.Size = DPISize (New-Object Drawing.Size(80, 28))
  $CombineRenameCancel.Location = DPISize (New-Object Drawing.Point(195, 54))
  $CombineRenameCancel.Text = 'Cancel'
  $CombineRenameCancel.Add_Click({ $CombineRenameDialog.Hide() })
  $CombineRenamePanel.Controls.Add($CombineRenameCancel)
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES - ZELDA SCREEN SHAKE DIALOG
#==============================================================================================================================================================================================
#  Finishes loading a Zelda screen shake texture.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadZeldaSSImage([Windows.Forms.TextBox]$TextBox=$null, [int]$Index, [string]$TexturePath)
{
  # The array index always starts at zero so subtract 1 from it.
  $Array = $Index - 1

  # Update the global variable that tracks the full path as a string.
  $global:ZeldaBonkArray[$Array] = $TexturePath

  # Update the text box with the new path.
  $TextBox.Text = $TexturePath
}
#==============================================================================================================================================================================================
#  Loads a Zelda screen shake texture with a button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadZeldaSSImage_Button()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)

  # Get the button that was clicked.
  $ZeldaSSTextBox = Get-Variable ('CombineZeldaSSBox0' + $Index.ToString()) -ValueOnly

  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $ZeldaSSTextBox.Text 

  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-FileName -StartPath $GetFilePath -FileName '*.png' -Description 'Screen Shake Texture'

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Add the selected tool to the script. The name of the button should hold the triggering index.
    LoadZeldaSSImage -TextBox $ZeldaSSTextBox -Index $Index -TexturePath $SelectedPath 
  }
}
#==============================================================================================================================================================================================
#  Loads a Zelda screen shake texture with a drag and drop operation.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadZeldaSSImage_DragAndDrop()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)

  # Assume a textbox triggered this.
  $ZeldaSSTextBox = $this

  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedFile = $_.Data.GetData([Windows.Forms.DataFormats]::FileDrop)

    # Make sure the path is a file (defined by type "leaf").
    if ((TestPath -LiteralPath $DroppedFile -PathType 'Leaf') -and ($DroppedFile -like '*.png'))
    {
      # Add the selected tool to the script.
      LoadZeldaSSImage -TextBox $ZeldaSSTextBox -Index $Index -TexturePath $DroppedFile 
    }
  }
}
#==============================================================================================================================================================================================
#  Loads a Zelda screen shake texture using the textbox when inserting a path.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadZeldaSSImage_TextBox()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)
  $Array = $Index - 1

  # Get the current value of the variable by pulling it from textbox name.
  $EnteredText = $this.Text

  # To avoid updating constantly, check to see if the text actually changed.
  if ($EnteredText -ne '')
  {
    # Don't allow a final backslash in the path since it will be added manually.
    $EnteredText = PathTruncateSlash -Path $EnteredText

    # Make sure the path is a file.
    if ((TestPath -LiteralPath $EnteredText -PathType 'Leaf') -and ($EnteredText -like '*.png'))
    {
      # Add the selected tool to the script.
      LoadZeldaSSImage -TextBox $this -Index $Index -TexturePath $EnteredText 
    }
    else
    {
      # If the entered text was empty or invalid, set the textbox text back to what it was.
      $this.Text = $ZeldaBonkArray[$Array]
    }
  }
  # If the user wants to clear the textbox.
  else
  {
    # Reset the value in the variable.
    $global:ZeldaBonkArray[$Array] = ''
  }
}
#==============================================================================================================================================================================================
#  Loads a Zelda screen shake texture using the textbox when inserting a path.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ClearZeldaSSTextBox()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)
  $Array = $Index - 1

  # Get the button that was clicked.
  $ZeldaSSTextBox = Get-Variable ('CombineZeldaSSBox0' + $Index.ToString()) -ValueOnly

  # If the entered text was empty or invalid, set the textbox text back to what it was.
  $ZeldaSSTextBox.Text = ''

  # Reset the value in the variable.
  $global:ZeldaBonkArray[$Array] = ''
}
#==============================================================================================================================================================================================
#  Create the window that allows selecting the screen shake textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_CombineZeldaSS()
{
  # Create the dialog and set up properties.
  $global:CombineZeldaSSDialog = New-Object Windows.Forms.Form
  $CombineZeldaSSDialog.Size = DPISize (New-Object Drawing.Size(600, 462))
  $CombineZeldaSSDialog.MinimumSize = DPISize (New-Object Drawing.Size(600, 462))
  $CombineZeldaSSDialog.MaximumSize = DPISize (New-Object Drawing.Size(600, 462))
  $CombineZeldaSSDialog.Text = 'Zelda OoT: Screen Shake'
  $CombineZeldaSSDialog.MinimizeBox = $false
  $CombineZeldaSSDialog.MaximizeBox = $false
  $CombineZeldaSSDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $CombineZeldaSSDialog.FormBorderStyle = GetFormBorderStyle
  $CombineZeldaSSDialog.StartPosition = "CenterScreen"
  $CombineZeldaSSDialog.Topmost = !$DisableTopMost
  $CombineZeldaSSDialog.KeyPreview = $true
  $CombineZeldaSSDialog.Add_KeyDown({ EscapeCloseDialog })
  $CombineZeldaSSDialog.Add_FormClosing({ $CombineZeldaSSDialog.Hide() ; $_.Cancel = $true })
  $CombineZeldaSSDialog.Icon = $Icon_CTTPSGreen

  # Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:CombineZeldaSSMainTTBox = New-Object TransparentLabel
  $CombineZeldaSSMainTTBox.Size = DPISize (New-Object Drawing.Size(560, 82))
  $CombineZeldaSSMainTTBox.Location = DPISize (New-Object Drawing.Point(10, 10))
  $CombineZeldaSSMainTTBox.Text = ""
  $CombineZeldaSSDialog.Controls.Add($CombineZeldaSSMainTTBox)

  # Add a short description of this dialog.
  $global:CombineZeldaSSMainLabel = New-Object AdvRichTextBox
  $CombineZeldaSSMainLabel.Size = DPISize (New-Object Drawing.Size(562, 84))
  $CombineZeldaSSMainLabel.Location = DPISize (New-Object Drawing.Point(10, 9))
  $CombineZeldaSSMainLabel.Text = 'The Legend of Zelda: Ocarina of Time static background textures are usually made up of 40 tiles that are aligned vertically '
  $CombineZeldaSSMainLabel.Text += 'from top to bottom. These textures can be found inside houses, they make up the Temple of Time, basically anywhere the background '
  $CombineZeldaSSMainLabel.Text += 'is viewed from a static perspective. Along with the 40 textures that make up the image, up to 6 additional images will dump '
  $CombineZeldaSSMainLabel.Text += 'when Link rolls into something and causes a "screen shake". Those images can be selected here, and will be added to the generated '
  $CombineZeldaSSMainLabel.Text += '(.ctt) file. If this file is loaded when splitting the image, CTT-PS will create the screen shake textures from the '
  $CombineZeldaSSMainLabel.Text += 'combined image using the names provided here. '
  $CombineZeldaSSMainLabel.SelectionAlignment = [TextAlign]::Justify
  $CombineZeldaSSMainLabel.TabStop = $false
  $CombineZeldaSSMainLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $CombineZeldaSSMainLabel.ReadOnly = $true
  $CombineZeldaSSMainLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $CombineZeldaSSDialog.Controls.Add($CombineZeldaSSMainLabel)

  # HACK: See if DPI scaling is disabled as some fine tuning is required.
  if (!$DisableHighDPIMode)
  {
    # While my general purpose DPI scaling function works pretty well, this is one place some manual intervention is needed to line everything up.
    switch ($Monitor.DPI)
    {
      # Oddly enough, its really only these DPI sizes that have issues.
      '96'    { $LabSize = 160 ; $BoxSize = 332 ; $BoxX = 170 }
      '120'   { $LabSize = 150 ; $BoxSize = 344 ; $BoxX = 156 }

      # For 144 DPI and above, these values seem to work for everything.
      default { $LabSize = 156 ; $BoxSize = 334 ; $BoxX = 166 }
    }
  }
  # If DPI scaling is disabled, use these values for size and location of textboxes/labels.
  else { $LabSize = 160 ; $BoxSize = 332 ; $BoxX = 170 }

  # Create a groupbox to hold the top textures.
  $global:CombineZeldaSSTopGroupBox = New-Object Windows.Forms.GroupBox
  $CombineZeldaSSTopGroupBox.Size = DPISize (New-Object Drawing.Size(564, 140))
  $CombineZeldaSSTopGroupBox.Location = DPISize (New-Object Drawing.Point(10, 96))
  $CombineZeldaSSTopGroupBox.Text = ' Top Textures '
  $CombineZeldaSSDialog.Controls.Add($CombineZeldaSSTopGroupBox)

  # Create a tip for the groupbox.
  $CombineZeldaSSTopTip = New-Object Windows.Forms.ToolTip
  $CombineZeldaSSTopTip.InitialDelay = $ToolTipDelay
  $CombineZeldaSSTopTip.AutoPopDelay = $ToolTipDuration
  $CombineZeldaSSTopTipString = 'Path to the textures to include in the resource pack.'
  $CombineZeldaSSTopTip.SetToolTip($CombineZeldaSSTopGroupBox, $CombineZeldaSSTopTipString)

  # Create a label describing the first top texture.
  $global:CombineZeldaSSLabel01 = New-Object Windows.Forms.Label
  $CombineZeldaSSLabel01.Size = DPISize (New-Object Drawing.Size($LabSize, 28))
  $CombineZeldaSSLabel01.Location = DPISize (New-Object Drawing.Point(8, 24)) -AddY $DPIOffsetFix
  $CombineZeldaSSLabel01String =  'Animation Texture 1, 324x8,{0}'
  $CombineZeldaSSLabel01String += '5 rows usable, 3 rows garbage'
  $CombineZeldaSSLabel01.Text = [String]::Format($CombineZeldaSSLabel01String, [Environment]::NewLine)
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSLabel01)

  # Create a textbox that holds the first top texture.
  $global:CombineZeldaSSBox01 = New-Object Windows.Forms.TextBox
  $CombineZeldaSSBox01.Size = DPISize (New-Object Drawing.Size($BoxSize, 22))
  $CombineZeldaSSBox01.Location = DPISize (New-Object Drawing.Point($BoxX, 28)) -AddY $DPIOffsetFix
  $CombineZeldaSSBox01.Name = '1'
  $CombineZeldaSSBox01.Text = ''
  $CombineZeldaSSBox01.AllowDrop = $true
  $CombineZeldaSSBox01.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineZeldaSSBox01.Add_DragDrop({ LoadZeldaSSImage_DragAndDrop })
  $CombineZeldaSSBox01.Add_Click({ ClearTextBox })
  $CombineZeldaSSBox01.Add_Leave({ LoadZeldaSSImage_TextBox })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSBox01)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSClr01 = New-Object Windows.Forms.Button
  $CombineZeldaSSClr01.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSClr01.Location = DPISize (New-Object Drawing.Point(504, 27))
  $CombineZeldaSSClr01.Name = '1'
  $CombineZeldaSSClr01.Text = '-'
  $CombineZeldaSSClr01.Add_Click({ ClearZeldaSSTextBox })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSClr01)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSButt01 = New-Object Windows.Forms.Button
  $CombineZeldaSSButt01.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSButt01.Location = DPISize (New-Object Drawing.Point(530, 27))
  $CombineZeldaSSButt01.Name = '1'
  $CombineZeldaSSButt01.Text = '...'
  $CombineZeldaSSButt01.Add_Click({ LoadZeldaSSImage_Button })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSButt01)

  # Create a label describing the first top texture.
  $global:CombineZeldaSSLabel02 = New-Object Windows.Forms.Label
  $CombineZeldaSSLabel02.Size = DPISize (New-Object Drawing.Size($LabSize, 28))
  $CombineZeldaSSLabel02.Location = DPISize (New-Object Drawing.Point(8, 64)) -AddY $DPIOffsetFix
  $CombineZeldaSSLabel02String =  'Animation Texture 2, 324x4,{0}'
  $CombineZeldaSSLabel02String += '4 rows usable, 0 rows garbage'
  $CombineZeldaSSLabel02.Text = [String]::Format($CombineZeldaSSLabel02String, [Environment]::NewLine)
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSLabel02)

  # Create a textbox that holds the first top texture.
  $global:CombineZeldaSSBox02 = New-Object Windows.Forms.TextBox
  $CombineZeldaSSBox02.Size = DPISize (New-Object Drawing.Size($BoxSize, 22))
  $CombineZeldaSSBox02.Location = DPISize (New-Object Drawing.Point($BoxX, 68)) -AddY $DPIOffsetFix
  $CombineZeldaSSBox02.Name = '2'
  $CombineZeldaSSBox02.Text = ''
  $CombineZeldaSSBox02.AllowDrop = $true
  $CombineZeldaSSBox02.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineZeldaSSBox02.Add_DragDrop({ LoadZeldaSSImage_DragAndDrop })
  $CombineZeldaSSBox02.Add_Click({ ClearTextBox })
  $CombineZeldaSSBox02.Add_Leave({ LoadZeldaSSImage_TextBox })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSBox02)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSClr02 = New-Object Windows.Forms.Button
  $CombineZeldaSSClr02.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSClr02.Location = DPISize (New-Object Drawing.Point(504, 67))
  $CombineZeldaSSClr02.Name = '2'
  $CombineZeldaSSClr02.Text = '-'
  $CombineZeldaSSClr02.Add_Click({ ClearZeldaSSTextBox })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSClr02)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSButt02 = New-Object Windows.Forms.Button
  $CombineZeldaSSButt02.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSButt02.Location = DPISize (New-Object Drawing.Point(530, 67))
  $CombineZeldaSSButt02.Name = '2'
  $CombineZeldaSSButt02.Text = '...'
  $CombineZeldaSSButt02.Add_Click({ LoadZeldaSSImage_Button })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSButt02)

  # Create a label describing the first top texture.
  $global:CombineZeldaSSLabel03 = New-Object Windows.Forms.Label
  $CombineZeldaSSLabel03.Size = DPISize (New-Object Drawing.Size($LabSize, 28))
  $CombineZeldaSSLabel03.Location = DPISize (New-Object Drawing.Point(8, 104)) -AddY $DPIOffsetFix
  $CombineZeldaSSLabel03String =  'Animation Texture 3, 324x4,{0}'
  $CombineZeldaSSLabel03String += '3 rows usable, 1 rows garbage'
  $CombineZeldaSSLabel03.Text = [String]::Format($CombineZeldaSSLabel03String, [Environment]::NewLine)
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSLabel03)

  # Create a textbox that holds the first top texture.
  $global:CombineZeldaSSBox03 = New-Object Windows.Forms.TextBox
  $CombineZeldaSSBox03.Size = DPISize (New-Object Drawing.Size($BoxSize, 22))
  $CombineZeldaSSBox03.Location = DPISize (New-Object Drawing.Point($BoxX, 108)) -AddY $DPIOffsetFix
  $CombineZeldaSSBox03.Name = '3'
  $CombineZeldaSSBox03.Text = ''
  $CombineZeldaSSBox03.AllowDrop = $true
  $CombineZeldaSSBox03.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineZeldaSSBox03.Add_DragDrop({ LoadZeldaSSImage_DragAndDrop })
  $CombineZeldaSSBox03.Add_Click({ ClearTextBox })
  $CombineZeldaSSBox03.Add_Leave({ LoadZeldaSSImage_TextBox })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSBox03)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSClr03 = New-Object Windows.Forms.Button
  $CombineZeldaSSClr03.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSClr03.Location = DPISize (New-Object Drawing.Point(504, 107))
  $CombineZeldaSSClr03.Name = '3'
  $CombineZeldaSSClr03.Text = '-'
  $CombineZeldaSSClr03.Add_Click({ ClearZeldaSSTextBox })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSClr03)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSButt03 = New-Object Windows.Forms.Button
  $CombineZeldaSSButt03.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSButt03.Location = DPISize (New-Object Drawing.Point(530, 107))
  $CombineZeldaSSButt03.Name = '3'
  $CombineZeldaSSButt03.Text = '...'
  $CombineZeldaSSButt03.Add_Click({ LoadZeldaSSImage_Button })
  $CombineZeldaSSTopGroupBox.Controls.Add($CombineZeldaSSButt03)

  # Create a groupbox to hold the Bot textures.
  $global:CombineZeldaSSBotGroupBox = New-Object Windows.Forms.GroupBox
  $CombineZeldaSSBotGroupBox.Size = DPISize (New-Object Drawing.Size(564, 140))
  $CombineZeldaSSBotGroupBox.Location = DPISize (New-Object Drawing.Point(10, 244))
  $CombineZeldaSSBotGroupBox.Text = ' Bottom Textures '
  $CombineZeldaSSDialog.Controls.Add($CombineZeldaSSBotGroupBox)

  # Create a tip for the groupbox.
  $CombineZeldaSSBotTip = New-Object Windows.Forms.ToolTip
  $CombineZeldaSSBotTip.InitialDelay = $ToolTipDelay
  $CombineZeldaSSBotTip.AutoPopDelay = $ToolTipDuration
  $CombineZeldaSSBotTipString = 'Path to the textures to include in the resource pack.'
  $CombineZeldaSSBotTip.SetToolTip($CombineZeldaSSBotGroupBox, $CombineZeldaSSBotTipString)

  # Create a label describing the first Bot texture.
  $global:CombineZeldaSSLabel04 = New-Object Windows.Forms.Label
  $CombineZeldaSSLabel04.Size = DPISize (New-Object Drawing.Size($LabSize, 28))
  $CombineZeldaSSLabel04.Location = DPISize (New-Object Drawing.Point(8, 24)) -AddY $DPIOffsetFix
  $CombineZeldaSSLabel04String =  'Animation Texture 1, 324x8,{0}'
  $CombineZeldaSSLabel04String += '5 rows usable, 3 rows garbage'
  $CombineZeldaSSLabel04.Text = [String]::Format($CombineZeldaSSLabel04String, [Environment]::NewLine)
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSLabel04)

  # Create a textbox that holds the first Bot texture.
  $global:CombineZeldaSSBox04 = New-Object Windows.Forms.TextBox
  $CombineZeldaSSBox04.Size = DPISize (New-Object Drawing.Size($BoxSize, 22))
  $CombineZeldaSSBox04.Location = DPISize (New-Object Drawing.Point($BoxX, 28)) -AddY $DPIOffsetFix
  $CombineZeldaSSBox04.Name = '4'
  $CombineZeldaSSBox04.Text = ''
  $CombineZeldaSSBox04.AllowDrop = $true
  $CombineZeldaSSBox04.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineZeldaSSBox04.Add_DragDrop({ LoadZeldaSSImage_DragAndDrop })
  $CombineZeldaSSBox04.Add_Click({ ClearTextBox })
  $CombineZeldaSSBox04.Add_Leave({ LoadZeldaSSImage_TextBox })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSBox04)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSClr04 = New-Object Windows.Forms.Button
  $CombineZeldaSSClr04.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSClr04.Location = DPISize (New-Object Drawing.Point(504, 27))
  $CombineZeldaSSClr04.Name = '4'
  $CombineZeldaSSClr04.Text = '-'
  $CombineZeldaSSClr04.Add_Click({ ClearZeldaSSTextBox })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSClr04)

  # Create a button to select the first Bot texture.
  $global:CombineZeldaSSButt04 = New-Object Windows.Forms.Button
  $CombineZeldaSSButt04.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSButt04.Location = DPISize (New-Object Drawing.Point(530, 27))
  $CombineZeldaSSButt04.Name = '4'
  $CombineZeldaSSButt04.Text = '...'
  $CombineZeldaSSButt04.Add_Click({ LoadZeldaSSImage_Button })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSButt04)

  # Create a label describing the first Bot texture.
  $global:CombineZeldaSSLabel05 = New-Object Windows.Forms.Label
  $CombineZeldaSSLabel05.Size = DPISize (New-Object Drawing.Size($LabSize, 28))
  $CombineZeldaSSLabel05.Location = DPISize (New-Object Drawing.Point(8, 64)) -AddY $DPIOffsetFix
  $CombineZeldaSSLabel05String =  'Animation Texture 2, 324x4,{0}'
  $CombineZeldaSSLabel05String += '4 rows usable, 0 rows garbage'
  $CombineZeldaSSLabel05.Text = [String]::Format($CombineZeldaSSLabel05String, [Environment]::NewLine)
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSLabel05)

  # Create a textbox that holds the first Bot texture.
  $global:CombineZeldaSSBox05 = New-Object Windows.Forms.TextBox
  $CombineZeldaSSBox05.Size = DPISize (New-Object Drawing.Size($BoxSize, 22))
  $CombineZeldaSSBox05.Location = DPISize (New-Object Drawing.Point($BoxX, 68)) -AddY $DPIOffsetFix
  $CombineZeldaSSBox05.Name = '5'
  $CombineZeldaSSBox05.Text = ''
  $CombineZeldaSSBox05.AllowDrop = $true
  $CombineZeldaSSBox05.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineZeldaSSBox05.Add_DragDrop({ LoadZeldaSSImage_DragAndDrop })
  $CombineZeldaSSBox05.Add_Click({ ClearTextBox })
  $CombineZeldaSSBox05.Add_Leave({ LoadZeldaSSImage_TextBox })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSBox05)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSClr05 = New-Object Windows.Forms.Button
  $CombineZeldaSSClr05.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSClr05.Location = DPISize (New-Object Drawing.Point(505, 67))
  $CombineZeldaSSClr05.Name = '5'
  $CombineZeldaSSClr05.Text = '-'
  $CombineZeldaSSClr05.Add_Click({ ClearZeldaSSTextBox })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSClr05)

  # Create a button to select the first Bot texture.
  $global:CombineZeldaSSButt05 = New-Object Windows.Forms.Button
  $CombineZeldaSSButt05.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSButt05.Location = DPISize (New-Object Drawing.Point(530, 67))
  $CombineZeldaSSButt05.Name = '5'
  $CombineZeldaSSButt05.Text = '...'
  $CombineZeldaSSButt05.Add_Click({ LoadZeldaSSImage_Button })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSButt05)

  # Create a label describing the first Bot texture.
  $global:CombineZeldaSSLabel06 = New-Object Windows.Forms.Label
  $CombineZeldaSSLabel06.Size = DPISize (New-Object Drawing.Size($LabSize, 28))
  $CombineZeldaSSLabel06.Location = DPISize (New-Object Drawing.Point(8, 104)) -AddY $DPIOffsetFix
  $CombineZeldaSSLabel06String =  'Animation Texture 3, 324x4,{0}'
  $CombineZeldaSSLabel06String += '3 rows usable, 1 rows garbage'
  $CombineZeldaSSLabel06.Text = [String]::Format($CombineZeldaSSLabel06String, [Environment]::NewLine)
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSLabel06)

  # Create a textbox that holds the first Bot texture.
  $global:CombineZeldaSSBox06 = New-Object Windows.Forms.TextBox
  $CombineZeldaSSBox06.Size = DPISize (New-Object Drawing.Size($BoxSize, 22))
  $CombineZeldaSSBox06.Location = DPISize (New-Object Drawing.Point($BoxX, 108)) -AddY $DPIOffsetFix
  $CombineZeldaSSBox06.Name = '6'
  $CombineZeldaSSBox06.Text = ''
  $CombineZeldaSSBox06.AllowDrop = $true
  $CombineZeldaSSBox06.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineZeldaSSBox06.Add_DragDrop({ LoadZeldaSSImage_DragAndDrop })
  $CombineZeldaSSBox06.Add_Click({ ClearTextBox })
  $CombineZeldaSSBox06.Add_Leave({ LoadZeldaSSImage_TextBox })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSBox06)

  # Create a button to select the first top texture.
  $global:CombineZeldaSSClr06 = New-Object Windows.Forms.Button
  $CombineZeldaSSClr06.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSClr06.Location = DPISize (New-Object Drawing.Point(505, 107))
  $CombineZeldaSSClr06.Name = '6'
  $CombineZeldaSSClr06.Text = '-'
  $CombineZeldaSSClr06.Add_Click({ ClearZeldaSSTextBox })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSClr06)

  # Create a button to select the first Bot texture.
  $global:CombineZeldaSSButt06 = New-Object Windows.Forms.Button
  $CombineZeldaSSButt06.Size = DPISize (New-Object Drawing.Size(24, 22))
  $CombineZeldaSSButt06.Location = DPISize (New-Object Drawing.Point(530, 107))
  $CombineZeldaSSButt06.Name = '6'
  $CombineZeldaSSButt06.Text = '...'
  $CombineZeldaSSButt06.Add_Click({ LoadZeldaSSImage_Button })
  $CombineZeldaSSBotGroupBox.Controls.Add($CombineZeldaSSButt06)

  # Create a "Close" button.
  $global:CombineZeldaSSDoneButton = New-Object Windows.Forms.Button
  $CombineZeldaSSDoneButton.Size = DPISize (New-Object Drawing.Size(100, 28))
  $CombineZeldaSSDoneButton.Location = DPISize (New-Object Drawing.Size(475, 390))
  $CombineZeldaSSDoneButton.Text = 'Close'
  $CombineZeldaSSDoneButton.Add_Click({ $CombineZeldaSSDialog.Close() })
  $CombineZeldaSSDialog.Controls.Add($CombineZeldaSSDoneButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES DIALOG - CREATE DIALOG
#==============================================================================================================================================================================================
#  Create the "Combine Textures" dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_CombineTextures()
{
  # A list that holds any images that get added to the image buttons so they can be destroyed later.
  $global:CombineImages = New-Object Collections.Generic.List[Drawing.Image]

  # Create the dialog that is displayed.
  $global:CombineDialog = New-Object Windows.Forms.Form
  $CombineDialog.Text = "Combine Textures"
  $CombineDialog.Size = New-Object Drawing.Size(100, 100)
  $CombineDialog.MinimumSize = New-Object Drawing.Size(100, 100)
  $CombineDialog.MaximumSize = New-Object Drawing.Size(100, 100)
  $CombineDialog.MaximizeBox = $false
  $CombineDialog.MinimizeBox = $false
  $CombineDialog.FormBorderStyle = [Windows.Forms.FormBorderStyle]::FixedDialog
  $CombineDialog.StartPosition = "CenterScreen"
  $CombineDialog.KeyPreview = $true
  $CombineDialog.Add_KeyDown({ CombineTextures_DialogKey })
  $CombineDialog.Add_KeyDown({ EscapeCloseDialog })
  $CombineDialog.Add_Shown({ ActivateDialog -Dialog $CombineDialog })
  $CombineDialog.Icon = $Icon_CTTPSMagenta

  # Calculate the size of the buttons and the main panel
  $ButtonSize = DPISize (New-Object Drawing.Size(24, 24))
  $PanelSizeX = ($ButtonSize.Width * 8) + ((DPISize 5) * 3) + 12
  $PanelSizeY = ($ButtonSize.Height * 2) + 3

  # Create a panel for all of the bottom buttons.
  $global:CombineSelectPanel = New-Object Windows.Forms.Panel
  $CombineSelectPanel.Size = New-Object Drawing.Size($PanelSizeX, $PanelSizeY)
  $CombineSelectPanel.Location = New-Object Drawing.Point((DPISize -38), 0)
  $CombineDialog.Controls.Add($CombineSelectPanel)

  # Create a background panel for the main combine option buttons.
  $global:CombineOptionsBorder = New-Object Windows.Forms.Panel
  $CombineOptionsBorder.Size = New-Object Drawing.Size(($ButtonSize.Width * 2 + 3), ($ButtonSize.Height * 2 + 3))
  $CombineOptionsBorder.Location = New-Object Drawing.Point(0, 0)
  $CombineOptionsBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#7d7d7d')
  $CombineSelectPanel.Controls.Add($CombineOptionsBorder)

  # Create a "Font Color" button.
  $global:CombineFontColorButton = New-Object Windows.Forms.Button
  $CombineFontColorButton.Size = $ButtonSize
  $CombineFontColorButton.Location = New-Object Drawing.Point(1, 1)
  $CombineFontColorButton.Name = 'FontColor'
  $CombineFontColorButton.Image = $Image_FontColor
  $CombineFontColorButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineFontColorButton.FlatAppearance.BorderSize = 0
  $CombineFontColorButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineFontColorButton.Add_Click({ CombineTextures_ColorButtonPress })
  $CombineOptionsBorder.Controls.Add($CombineFontColorButton)

  # Create a tooltip for the button.
  $CombineFontColorTip = New-Object Windows.Forms.ToolTip
  $CombineFontColorTip.InitialDelay = $ToolTipDelay
  $CombineFontColorTip.AutoPopDelay = $ToolTipDuration
  $CombineFontColorTipString =  'Allows selecting the font color for all{0}'
  $CombineFontColorTipString += 'buttons on the grid to help visibility.'
  $CombineFontColorTipString = [String]::Format($CombineFontColorTipString, [Environment]::NewLine)
  $CombineFontColorTip.SetToolTip($CombineFontColorButton, $CombineFontColorTipString)

  # Create a "Selection Color" button.
  $global:CombineSelectColorButton = New-Object Windows.Forms.Button
  $CombineSelectColorButton.Size = $ButtonSize
  $CombineSelectColorButton.Location = New-Object Drawing.Point(($CombineFontColorButton.Right + 1), 1)
  $CombineSelectColorButton.Name = 'SelectColor'
  $CombineSelectColorButton.Image = $Image_SelectColor
  $CombineSelectColorButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineSelectColorButton.FlatAppearance.BorderSize = 0
  $CombineSelectColorButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineSelectColorButton.Add_Click({ CombineTextures_ColorButtonPress })
  $CombineOptionsBorder.Controls.Add($CombineSelectColorButton)

  # Create a tooltip for the button.
  $CombineSelectColorTip = New-Object Windows.Forms.ToolTip
  $CombineSelectColorTip.InitialDelay = $ToolTipDelay
  $CombineSelectColorTip.AutoPopDelay = $ToolTipDuration
  $CombineSelectColorTipString =  'Changes the image selection color.'
  $CombineSelectColorTip.SetToolTip($CombineSelectColorButton, $CombineSelectColorTipString)

  # Create a "Hide Text" button.
  $global:CombineHideNamesButton = New-Object Windows.Forms.Button
  $CombineHideNamesButton.Size = $ButtonSize
  $CombineHideNamesButton.Location = New-Object Drawing.Point(1, ($CombineFontColorButton.Bottom + 1))
  $CombineHideNamesButton.Name = 'ToggleNames'
  $CombineHideNamesButton.Image = $Image_NamesOn
  $CombineHideNamesButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineHideNamesButton.FlatAppearance.BorderSize = 0
  $CombineHideNamesButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineHideNamesButton.Add_Click({ CombineTextures_ToggleButtonText })
  $CombineOptionsBorder.Controls.Add($CombineHideNamesButton)

  # Create a tooltip for the button.
  $CombineHideNamesTip = New-Object Windows.Forms.ToolTip
  $CombineHideNamesTip.InitialDelay = $ToolTipDelay
  $CombineHideNamesTip.AutoPopDelay = $ToolTipDuration
  $CombineHideNamesTipString = 'Toggles showing the button names.'
  $CombineHideNamesTip.SetToolTip($CombineHideNamesButton, $CombineHideNamesTipString)

  # Create a "Clear" button.
  $global:CombineClearButton = New-Object Windows.Forms.Button
  $CombineClearButton.Size = $ButtonSize
  $CombineClearButton.Location = New-Object Drawing.Point(($CombineHideNamesButton.Right + 1), ($CombineSelectColorButton.Bottom + 1))
  $CombineClearButton.Name = 'Clear'
  $CombineClearButton.Image = $Image_ClearDialog
  $CombineClearButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineClearButton.FlatAppearance.BorderSize = 0
  $CombineClearButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineClearButton.Add_Click({ CombineTextures_ClearPressed })
  $CombineOptionsBorder.Controls.Add($CombineClearButton)

  # Create a tooltip for the "Clear" button.
  $CombineClearButtonTip = New-Object Windows.Forms.ToolTip
  $CombineClearButtonTip.InitialDelay = $ToolTipDelay
  $CombineClearButtonTip.AutoPopDelay = $ToolTipDuration
  $CombineClearButtonTipString = 'Clear all textures from the array.'
  $CombineClearButtonTip.SetToolTip($CombineClearButton, $CombineClearButtonTipString)

  # Create a background panel for the left, down, and right buttons.
  $global:CombineButtonBorder = New-Object Windows.Forms.Panel
  $CombineButtonBorder.Size = New-Object Drawing.Size(($ButtonSize.Width * 3 + 4), ($ButtonSize.Height + 2))
  $CombineButtonBorder.Location = New-Object Drawing.Point(($CombineOptionsBorder.Right + (DPISize 5)), ($ButtonSize.Height + 1))
  $CombineButtonBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#7d7d7d')
  $CombineButtonBorder.Enabled = $false
  $CombineSelectPanel.Controls.Add($CombineButtonBorder)

  # Create a "Left" button.
  $global:CombineLeftButton = New-Object Windows.Forms.Button
  $CombineLeftButton.Size = $ButtonSize
  $CombineLeftButton.Location = New-Object Drawing.Point(1, 1)
  $CombineLeftButton.Name = 'Left'
  $CombineLeftButton.Image = $Image_ArrowSmallLeft
  $CombineLeftButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineLeftButton.FlatAppearance.BorderSize = 0
  $CombineLeftButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineLeftButton.Add_Click({ CombineTextures_DirectionButton -Direction $this.Name })
  $CombineButtonBorder.Controls.Add($CombineLeftButton)

  # Create a tooltip for the "Left" button.
  $CombineLeftButtonTip = New-Object Windows.Forms.ToolTip
  $CombineLeftButtonTip.InitialDelay = $ToolTipDelay
  $CombineLeftButtonTip.AutoPopDelay = $ToolTipDuration
  $CombineLeftButtonTipString =  'Move a selected texture left in the grid. The{0}'
  $CombineLeftButtonTipString += 'keyboard keys "A" and "Left" will also work.'
  $CombineLeftButtonTipString = [String]::Format($CombineLeftButtonTipString, [Environment]::NewLine)
  $CombineLeftButtonTip.SetToolTip($CombineLeftButton, $CombineLeftButtonTipString)

  # Create a "Down" button.
  $global:CombineDownButton = New-Object Windows.Forms.Button
  $CombineDownButton.Size = $ButtonSize
  $CombineDownButton.Location = New-Object Drawing.Point(($CombineLeftButton.Right + 1), 1)
  $CombineDownButton.Name = 'Down'
  $CombineDownButton.Image = $Image_ArrowSmallDown
  $CombineDownButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineDownButton.FlatAppearance.BorderSize = 0
  $CombineDownButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineDownButton.Add_Click({ CombineTextures_DirectionButton -Direction $this.Name })
  $CombineButtonBorder.Controls.Add($CombineDownButton)

  # Create a tooltip for the "Down" button.
  $CombineDownButtonTip = New-Object Windows.Forms.ToolTip
  $CombineDownButtonTip.InitialDelay = $ToolTipDelay
  $CombineDownButtonTip.AutoPopDelay = $ToolTipDuration
  $CombineDownButtonTipString =  'Move a selected texture down in the grid. The{0}'
  $CombineDownButtonTipString += 'keyboard keys "S" and "Down" will also work.'
  $CombineDownButtonTipString = [String]::Format($CombineDownButtonTipString, [Environment]::NewLine)
  $CombineDownButtonTip.SetToolTip($CombineDownButton, $CombineDownButtonTipString)

  # Create a "Right" button.
  $global:CombineRightButton = New-Object Windows.Forms.Button
  $CombineRightButton.Size = $ButtonSize
  $CombineRightButton.Location = New-Object Drawing.Point(($CombineDownButton.Right + 1), 1)
  $CombineRightButton.Name = 'Right'
  $CombineRightButton.Image = $Image_ArrowSmallRight
  $CombineRightButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineRightButton.FlatAppearance.BorderSize = 0
  $CombineRightButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineRightButton.Add_Click({ CombineTextures_DirectionButton -Direction $this.Name })
  $CombineButtonBorder.Controls.Add($CombineRightButton)

  # Create a tooltip for the "Right" button.
  $CombineRightButtonTip = New-Object Windows.Forms.ToolTip
  $CombineRightButtonTip.InitialDelay = $ToolTipDelay
  $CombineRightButtonTip.AutoPopDelay = $ToolTipDuration
  $CombineRightButtonTipString =  'Move a selected texture right in the grid. The{0}'
  $CombineRightButtonTipString += 'keyboard keys "D" and "Right" will also work.'
  $CombineRightButtonTipString = [String]::Format($CombineRightButtonTipString, [Environment]::NewLine)
  $CombineRightButtonTip.SetToolTip($CombineRightButton, $CombineRightButtonTipString)

  # Create a background panel for the "Up" button.
  $global:CombineUpButtonBorder = New-Object Windows.Forms.Panel
  $CombineUpButtonBorder.Size = New-Object Drawing.Size(($ButtonSize.Width + 2), ($ButtonSize.Height + 2))
  $CombineUpButtonBorder.Location = New-Object Drawing.Point(($CombineButtonBorder.Left + $ButtonSize.Width + 1), 0)
  $CombineUpButtonBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#7d7d7d')
  $CombineUpButtonBorder.Enabled = $false
  $CombineSelectPanel.Controls.Add($CombineUpButtonBorder)

  # Create an "Up" button.
  $global:CombineUpButton = New-Object Windows.Forms.Button
  $CombineUpButton.Size = $ButtonSize
  $CombineUpButton.Location = New-Object Drawing.Point(1, 1)
  $CombineUpButton.Name = 'Up'
  $CombineUpButton.Image = $Image_ArrowSmallUp
  $CombineUpButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineUpButton.FlatAppearance.BorderSize = 0
  $CombineUpButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineUpButton.Add_Click({ CombineTextures_DirectionButton -Direction $this.Name })
  $CombineUpButtonBorder.Controls.Add($CombineUpButton)

  # Create a tooltip for the "Up" button.
  $CombineUpButtonTip = New-Object Windows.Forms.ToolTip
  $CombineUpButtonTip.InitialDelay = $ToolTipDelay
  $CombineUpButtonTip.AutoPopDelay = $ToolTipDuration
  $CombineUpButtonTipString =  'Move a selected texture up in the grid. The{0}'
  $CombineUpButtonTipString += 'keyboard keys "W" and "Up" will also work.'
  $CombineUpButtonTipString = [String]::Format($CombineUpButtonTipString, [Environment]::NewLine)
  $CombineUpButtonTip.SetToolTip($CombineUpButton, $CombineUpButtonTipString)

  # Create a background for the selection support buttons.
  $global:CombineSelectionBorder = New-Object Windows.Forms.Panel
  $CombineSelectionBorder.Size = New-Object Drawing.Size(($ButtonSize.Width * 2 + 3), ($ButtonSize.Height * 2 + 3))
  $CombineSelectionBorder.Location = New-Object Drawing.Point(($CombineButtonBorder.Right + (DPISize 5)), 0)
  $CombineSelectionBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#7d7d7d')
  $CombineSelectionBorder.Enabled = $false
  $CombineSelectPanel.Controls.Add($CombineSelectionBorder)

  # Create an "Unselect" button.
  $global:CombineUnselectButton = New-Object Windows.Forms.Button
  $CombineUnselectButton.Size = $ButtonSize
  $CombineUnselectButton.Location = New-Object Drawing.Point(1, 1)
  $CombineUnselectButton.Name = 'Unselect'
  $CombineUnselectButton.Image = $Image_Unselect
  $CombineUnselectButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineUnselectButton.FlatAppearance.BorderSize = 0
  $CombineUnselectButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineUnselectButton.Add_Click({ CombineTextures_ForceUnselect })
  $CombineSelectionBorder.Controls.Add($CombineUnselectButton)

  # Create a tooltip for the "Unselect" button.
  $CombineUnselectTip = New-Object Windows.Forms.ToolTip
  $CombineUnselectTip.InitialDelay = $ToolTipDelay
  $CombineUnselectTip.AutoPopDelay = $ToolTipDuration
  $CombineUnselectTipString =  'Unselects the currently selected image.{0}'
  $CombineUnselectTipString += '{0}'
  $CombineUnselectTipString += 'It is also possible to unselect images{0}'
  $CombineUnselectTipString += 'by clicking on them a second time.'
  $CombineUnselectTipString = [String]::Format($CombineUnselectTipString, [Environment]::NewLine)
  $CombineUnselectTip.SetToolTip($CombineUnselectButton, $CombineUnselectTipString)

  # Create a "Remove" button.
  $global:CombineRemoveButton = New-Object Windows.Forms.Button
  $CombineRemoveButton.Size = $ButtonSize
  $CombineRemoveButton.Location = New-Object Drawing.Point(($CombineUnselectButton.Right + 1), 1)
  $CombineRemoveButton.Name = 'Remove'
  $CombineRemoveButton.Image = $Image_Remove
  $CombineRemoveButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineRemoveButton.FlatAppearance.BorderSize = 0
  $CombineRemoveButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineRemoveButton.Add_Click({ CombineTextures_ForceUnselect })
  $CombineSelectionBorder.Controls.Add($CombineRemoveButton)

  # Create a tooltip for the "Remove" button.
  $CombineRemoveTip = New-Object Windows.Forms.ToolTip
  $CombineRemoveTip.InitialDelay = $ToolTipDelay
  $CombineRemoveTip.AutoPopDelay = $ToolTipDuration
  $CombineRemoveTipString =  'Removes the currently selected image.{0}'
  $CombineRemoveTipString += '{0}'
  $CombineRemoveTipString += 'It is also possible to hold the control{0}'
  $CombineRemoveTipString += 'key when clicking a texture to remove it.'
  $CombineRemoveTipString = [String]::Format($CombineRemoveTipString, [Environment]::NewLine)
  $CombineRemoveTip.SetToolTip($CombineRemoveButton, $CombineRemoveTipString)

  # Create the "Rename" button.
  $global:CombineRenameButton = New-Object Windows.Forms.Button
  $CombineRenameButton.Size = $ButtonSize
  $CombineRenameButton.Location = New-Object Drawing.Point(1, ($CombineRemoveButton.Bottom + 1))
  $CombineRenameButton.Name = 'Rename'
  $CombineRenameButton.Image = $Image_Rename
  $CombineRenameButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineRenameButton.FlatAppearance.BorderSize = 0
  $CombineRenameButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineRenameButton.Add_Click({ CombineTextures_RenameTexture })
  $CombineSelectionBorder.Controls.Add($CombineRenameButton)

  # Create a tooltip for the button.
  $CombineRenameTip = New-Object Windows.Forms.ToolTip
  $CombineRenameTip.InitialDelay = $ToolTipDelay
  $CombineRenameTip.AutoPopDelay = $ToolTipDuration
  $CombineRenameTipString =  'Renames the currently selected image.{0}'
  $CombineRenameTipString += '{0}'
  $CombineRenameTipString += 'It is also possible to rename images{0}'
  $CombineRenameTipString += 'by shift clicking an image button.'
  $CombineRenameTipString = [String]::Format($CombineRenameTipString, [Environment]::NewLine)
  $CombineRenameTip.SetToolTip($CombineRenameButton, $CombineRenameTipString)

  # Create the "Texture Open" button.
  $global:CombineOpenButton = New-Object Windows.Forms.Button
  $CombineOpenButton.Size = $ButtonSize
  $CombineOpenButton.Location = New-Object Drawing.Point(($CombineRenameButton.Right + 1), ($CombineRemoveButton.Bottom + 1))
  $CombineOpenButton.Name = 'Open'
  $CombineOpenButton.Image = $Image_OpenFolder
  $CombineOpenButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineOpenButton.FlatAppearance.BorderSize = 0
  $CombineOpenButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineOpenButton.Add_Click({ CombineTextures_ExtraButtonSelect })
  $CombineSelectionBorder.Controls.Add($CombineOpenButton)

  # Create a tooltip for the button.
  $CombineOpenTip = New-Object Windows.Forms.ToolTip
  $CombineOpenTip.InitialDelay = $ToolTipDelay
  $CombineOpenTip.AutoPopDelay = $ToolTipDuration
  $CombineOpenTipString =  'Replaces the currently selected image{0}'
  $CombineOpenTipString += 'by loading a new one over top of it.{0}'
  $CombineOpenTipString += '{0}'
  $CombineOpenTipString += 'It is also possible to load a new image{0}'
  $CombineOpenTipString += 'by right clicking the selected image.'
  $CombineOpenTipString = [String]::Format($CombineOpenTipString, [Environment]::NewLine)
  $CombineOpenTip.SetToolTip($CombineOpenButton, $CombineOpenTipString)

  # Create a background panel for the "Screen Shake" and "Done" buttons.
  $global:CombineLastBorder = New-Object Windows.Forms.Panel
  $CombineLastBorder.Size = New-Object Drawing.Size(($ButtonSize.Width + 2), ($ButtonSize.Height * 2 + 3))
  $CombineLastBorder.Location = New-Object Drawing.Point(($CombineSelectionBorder.Right + (DPISize 5)), 0)
  $CombineLastBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#7d7d7d')
  $CombineSelectPanel.Controls.Add($CombineLastBorder)

  # Create a "Screen Shake" button.
  $global:CombineSSButton = New-Object Windows.Forms.Button
  $CombineSSButton.Size = $ButtonSize
  $CombineSSButton.Location = New-Object Drawing.Point(1, 1)
  $CombineSSButton.Name = 'ScreenShake'
  $CombineSSButton.Image = $Image_Triforce
  $CombineSSButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineSSButton.FlatAppearance.BorderSize = 0
  $CombineSSButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineSSButton.Add_Click({ $CombineZeldaSSDialog.ShowDialog() })
  $CombineLastBorder.Controls.Add($CombineSSButton)

  # Create a tooltip for the button.
  $CombineSSTip = New-Object Windows.Forms.ToolTip
  $CombineSSTip.InitialDelay = $ToolTipDelay
  $CombineSSTip.AutoPopDelay = $ToolTipDuration
  $CombineSSTipString =  'Allows selecting the "screen shake"{0}'
  $CombineSSTipString += 'textures that are dumped from The{0}'
  $CombineSSTipString += 'Legend of Zelda: Ocarina of Time.{0}'
  $CombineSSTipString += '{0}'
  $CombineSSTipString += 'These textures will be cropped from{0}'
  $CombineSSTipString += 'the combined image when splitting.'
  $CombineSSTipString = [String]::Format($CombineSSTipString, [Environment]::NewLine)
  $CombineSSTip.SetToolTip($CombineSSButton, $CombineSSTipString)

  # Create a "Done" button.
  $global:CombineDoneButton = New-Object Windows.Forms.Button
  $CombineDoneButton.Size = $ButtonSize
  $CombineDoneButton.Location = New-Object Drawing.Point(1, ($CombineSSButton.Bottom + 1))
  $CombineDoneButton.Name = 'Done'
  $CombineDoneButton.Image = $Image_CloseDialog
  $CombineDoneButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineDoneButton.FlatAppearance.BorderSize = 0
  $CombineDoneButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineDoneButton.Add_Click({ $CombineDialog.Close() })
  $CombineLastBorder.Controls.Add($CombineDoneButton)

  # Create a tooltip for the button.
  $CombineDoneButtonTip = New-Object Windows.Forms.ToolTip
  $CombineDoneButtonTip.InitialDelay = $ToolTipDelay
  $CombineDoneButtonTip.AutoPopDelay = $ToolTipDuration
  $CombineDoneButtonTipString = 'Finish adding textures to the array.'
  $CombineDoneButtonTip.SetToolTip($CombineDoneButton, $CombineDoneButtonTipString)
}
#==============================================================================================================================================================================================
#  CTT GUI: COLOR DIALOG
#==============================================================================================================================================================================================
#  Create the color dialog. Not a whole lot going on here.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ColorDialog()
{
  # Create a color dialog that will be used in any instance a color is chosen.
  $global:ColorDialog = New-Object Windows.Forms.ColorDialog
}
#==============================================================================================================================================================================================
#  CTT GUI: YES/NO DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $YesNoDialog   - Form      - Global
#  $YesNoLabel    - Label     - Global
#  $YesButton     - Button    - Global
#  $NoButton      - Button    - Global
#==============================================================================================================================================================================================
#  Shows a question with the options of yes/no and returns the selected choice.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowYesNoDialog([string]$Title, [int]$SizeX=300, [int]$SizeY=30, [int]$OffsetX, [int]$OffsetY, [string]$Message, [bool]$PlayBeep=$true)
{
  # Set the title of the window.
  $YesNoDialog.Text = $Title

  # Show the message that was sent to the function.
  $YesNoLabel.Text = $Message

  # Temporarily adjust the size and position based on the parameters.
  $YesNoLabel.Size = New-Object Drawing.Size($SizeX, $SizeY)
  $YesNoLabel.Location = New-Object Drawing.Point($OffsetX, $OffsetY)

  # The parameter allows playing that annoying sound we all love. Plays by default.
  if ($PlayBeep) { [Media.SystemSounds]::Beep.Play() }

  # Present the user with some tough choices.
  $YesNoDialog.ShowDialog() | Out-Null

  # I didn't code old uses for variable sizes so restore defaults.
  $YesNoLabel.Size = New-Object Drawing.Size(300, 30)

  # Return the button choice.
  return $YesNoChoice
}
#==============================================================================================================================================================================================
#  CTT GUI: YES/NO DIALOG CREATION
#==============================================================================================================================================================================================
#  Create the yes/no dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_YesNoDialog()
{
  # Create the dialog and set up properties.
  $global:YesNoDialog          = New-Object Windows.Forms.Form
  $YesNoDialog.Font            = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $YesNoDialog.Size            = DPISize (New-Object Drawing.Size(320, 130))
  $YesNoDialog.MaximumSize     = DPISize (New-Object Drawing.Size(320, 130))
  $YesNoDialog.MinimumSize     = DPISize (New-Object Drawing.Size(320, 130))
  $YesNoDialog.MaximizeBox     = $false
  $YesNoDialog.MinimizeBox     = $false
  $YesNoDialog.AutoScaleMode   = [Windows.Forms.AutoScaleMode]::None
  $YesNoDialog.FormBorderStyle = GetFormBorderStyle
  $YesNoDialog.StartPosition   = "CenterScreen"
  $YesNoDialog.Topmost         = $true
  $YesNoDialog.Icon            = $Icon_CTTPSGreen
  $YesNoDialog.KeyPreview      = $true
  $YesNoDialog.Add_Shown({ ActivateDialog -Dialog $YesNoDialog  })

  # Add the label for the question to ask.
  $global:YesNoLabel  = New-Object Windows.Forms.Label
  $YesNoDialog.Controls.Add($YesNoLabel)

  # Create the "Yes" button.
  $global:YesButton   = New-Object Windows.Forms.Button
  $YesButton.Size     = DPISize (New-Object Drawing.Size(80, 28))
  $YesButton.Location = DPISize (New-Object Drawing.Point(52, 52))
  $YesButton.Text     = 'Yes'
  $YesButton.Add_Click({$global:YesNoChoice = $true ; $YesNoDialog.Close()})
  $YesNoDialog.Controls.Add($YesButton)

  # Create the "No" button.
  $global:NoButton    = New-Object Windows.Forms.Button
  $NoButton.Size      = DPISize (New-Object Drawing.Size(80, 28))
  $NoButton.Location  = DPISize (New-Object Drawing.Size(170, 52))
  $NoButton.Text      = 'No'
  $NoButton.Add_Click({$global:YesNoChoice = $false ; $YesNoDialog.Close()})
  $YesNoDialog.Controls.Add($NoButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: OK DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $OKDialog   - Form      - Global
#  $OKLabel    - Label     - Global
#  $OKButton   - Button    - Global
#  $OKTimer    - Timer     - Global
#==============================================================================================================================================================================================
#  Hides the "OK Dialog" after a set amount of time.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function OkDialogTimerTick()
{
  # Hide the dialog after the timer expires.
  $OKDialog.Hide()

  # Stop the timer so it doesn't repeat infinitely.
  $OkTimer.Stop()
}
#==============================================================================================================================================================================================
#  Shows a dialog with a short message and an OK button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowOKDialog([string]$Title, [int]$SizeX=300, [int]$SizeY=30, [int]$OffsetX, [int]$OffsetY, [int]$TimeOut=0, [string]$Message)
{
  # Set the title of the window.
  $OKDialog.Text = $Title

  # Show the message that was sent to the function.
  $OKLabel.Text = $Message

  # Temporarily adjust the size and position based on the parameters.
  $OKLabel.Size = New-Object Drawing.Size($SizeX, $SizeY)
  $OKLabel.Location = New-Object Drawing.Point($OffsetX, $OffsetY)

  # Always play the beep. 
  [Media.SystemSounds]::Beep.Play()

  # Check to see if the dialog has a timer attached.
  if ($TimeOut -gt 0)
  {
    # Create a new timer that will expire every second.
    $global:OkTimer = New-Object Windows.Forms.Timer
    $OkTimer.Interval = ($TimeOut * 1000)
    $OkTimer.Add_Tick({ OkDialogTimerTick })
    $OkTimer.Start()
  }
  # Let the user know what's up.
  $OKDialog.ShowDialog() | Out-Null

  # I didn't code old uses for variable sizes so restore defaults.
  $OKLabel.Size = DPISize (New-Object Drawing.Size(300, 30))
}
#==============================================================================================================================================================================================
#  CTT GUI: OK DIALOG CREATION
#==============================================================================================================================================================================================
#  Create the OK dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_OKDialog()
{
  # Create the dialog and set up properties.
  $global:OKDialog = New-Object Windows.Forms.Form
  $OKDialog.Font            = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $OKDialog.Size            = DPISize (New-Object Drawing.Size(320, 130))
  $OKDialog.MaximumSize     = DPISize (New-Object Drawing.Size(320, 130))
  $OKDialog.MinimumSize     = DPISize (New-Object Drawing.Size(320, 130))
  $OKDialog.MaximizeBox     = $false
  $OKDialog.MinimizeBox     = $false
  $OKDialog.AutoScaleMode   = [Windows.Forms.AutoScaleMode]::None
  $OKDialog.FormBorderStyle = GetFormBorderStyle
  $OKDialog.StartPosition   = "CenterScreen"
  $OKDialog.Topmost         = $true
  $OKDialog.Icon            = $Icon_CTTPSGreen
  $OKDialog.KeyPreview      = $true
  $OKDialog.Add_Shown({ ActivateDialog -Dialog $OKDialog })
  
  # Add the label for the message.
  $global:OKLabel    = New-Object Windows.Forms.Label
  $OKDialog.Controls.Add($OKLabel)

  # Create the "OK" button.
  $global:OKButton   = New-Object Windows.Forms.Button
  $OKButton.Size     = DPISize (New-Object Drawing.Size(80, 28))
  $OKButton.Location = DPISize (New-Object Drawing.Point(110, 52))
  $OKButton.Text     = 'OK'
  $OKButton.Add_Click({$OKDialog.Close()})
  $OKDialog.Controls.Add($OKButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST DIALOG
#==============================================================================================================================================================================================
#  The texture list was a massive undertaking to replace the PowerShell console for output. The advantage of a GUI is obviously complete control and customization. The disadvantage
#  is every facet of it has to be programmed, so just existing, it is already "slower" than using the PS Console directly. There are many values and controls that can be accessed or 
#  updated on the texture list dialog, so it has a lot of global variables to reference.
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $TexListDialog           - Form         - Global
#  $TexListWaitLabel        - Label        - Global
#  $TexListCatalog          - DataGridView - Global
#  $TexListOpPanelBG        - Panel        - Global
#  $TexListOpPanel          - Panel        - Global
#  $TexListOpLabel          - Label        - Global
#  $TexListOpValue          - Label        - Global
#  $TexListTexLabel         - Label        - Global
#  $TexListTexValue         - Label        - Global
#  $TexListProgLabel        - Label        - Global
#  $TexListProgBar          - ProgressBar  - Global
#  $TexListProgValue        - Label        - Global
#  $TexListTimerLabel       - Label        - Global
#  $TexListTimerValue       - Label        - Global
#  $TexListHideButton       - Button       - Global
#  $TexListHideTip          - ToolTip      - Global
#  $TexListStartButton      - Button       - Global
#  $TexListStartTip         - ToolTip      - Local
#  $TexListProcessButton    - Button       - Global
#  $TexListProcessTip       - ToolTip      - Local
#  $TexListCancelButton     - Button       - Global
#  $TexListAScrollCheck     - CheckBox     - Global
#  $TexListAScrollTip       - ToolTip      - Local
#  $TexListHelpButton       - Button       - Global
#  $TexListCloseButton      - ToolTip      - Local
#==============================================================================================================================================================================================
# Functions to update the texture list. Below is a brief explanation of what they do.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# TexList_AddTexture -TextureInfo            = Add a texture and all its properties + allow status update
# TexList_AddFile -File -Status -Message     = Add a file to the list without properties + allow status update
# TexList_AddString -Entry                   = Add a string without any properties + no status updates
# TexList_UpdateStatus -Status -Value        = Update various properties such as: operation, texture count, timer, progress bar, % label
# TexList_SetTextureStatus -Status -Message  = Sets the status and message for when "UpdateTexture" is called after the current job.
# TexList_UpdateTexture                      = Updates status with what was set in "SetTextureStatus".
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - COUNT NUMBER OF TEXTURES TO PROCESS
#==============================================================================================================================================================================================
#  Checks the progress of the count, and updates the variable and GUI when its finished.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TextureCount_TimerTick()
{
  # Get the status of the job before going into the loop.
  $JobStatus = (Get-Job -Name "CountTextures" -ErrorAction 'SilentlyContinue').State

  # See if the count is finally complete.
  if ($JobStatus -eq "Completed")
  {
    # Get anything that the job output.
    $JobFeedback = Receive-Job -Name "CountTextures"

    # Set the count to what was output by the job.
    $global:TotalFiles = [Convert]::ToInt32($JobFeedback)

    # Update the values that will be shown on the GUI.
    $TextureCountString = ($TextureCount.ToString() + '/' + $TotalFiles.ToString())

    # The count may finish before the first texture is even processed.
    if ($TextureCount -gt 0)
    {
      # Get the percentage progress of how far things are along.
      $SplitProgressPC = (FormatDecimal -Value (($TextureCount / $TotalFiles) * 100).ToString()).Split('.', 2)
      $ProgressPercent = $SplitProgressPC[0]
    }
    # No textures have been processed yet.
    else
    {
      # Just set it to zero since there wouldn't be progress yet anyway.
      $ProgressPercent = "0"
    }
    # Update the texture list with the new values.
    TexList_UpdateStatus -Status 'TextureCount' -Value $TextureCountString
    TexList_UpdateStatus -Status 'Progress'     -Value $ProgressPercent    -FontColor $FontColor

    # Stop the timer and destroy it when finished.
    $CountTimer.Stop()
    $CountTimer.Dispose()
    $global:CountTimer = $null

    # Now that the job is finished, remove it.
    Stop-Job   -Name "CountTextures" -ErrorAction 'SilentlyContinue'
    Remove-Job -Name "CountTextures"

    # Do not update the number of rows to the number of textures if it's less than a number that would be visible.
    if ($TotalFiles -ge 150)
    {
      # Update the datagridview with the number of lines we will need.
      $TexListCatalog.RowCount = $TotalFiles
    }
  }
}
#==============================================================================================================================================================================================
#  Counts the number of textures in a pack, which does not include the number of mipmaps or material maps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CountTexturesToProcess()
{
  # If using a process selected list we already have the count.
  if ($ProcessSelected) { return $ProcessMasterList.Count }

  #------------------------------------------------------------------------------------------------------------------------------
  # Part One: Get a list of all directories within the folder. Filter out any folders that have a tilde in their path.
  #------------------------------------------------------------------------------------------------------------------------------
  # Get the initial Input Path and all directories/sub-directories found within the Input Path.
  $InitDirectories = @($MasterInputPath)
  $InitDirectories += EnumerateFolders -LiteralPath $MasterInputPath -Recurse

  # Paths with tildes need to be filtered out.
  $Directories = New-Object Collections.Generic.List[string]

  # Loop through each path in the array.
  foreach ($Directory in $InitDirectories)
  {
    # Omit any folders that contain the tilde (~) symbol if the master path was not overwritten.
    if (($Directory -notlike '*~*') -or ($PathsNeedRestore))
    {
      # Add the directory to the array.
      $Directories.Add($Directory)
    }
  }
  #------------------------------------------------------------------------------------------------------------------------------
  # Part Two: Set up the filter that will be used to get the correct files depending on the operation.
  #------------------------------------------------------------------------------------------------------------------------------
  # Which file types to look for depends on the operation taking place.
  # Note: Also see (TexList_UpdateProgress) as this type of filtering takes place there too.
  switch ($MasterOperation)
  {
    # When batch splitting images, search for CTT files.
    'SplitMultiImage' { $EnumFilter = '*.ctt' }

    # For PKA files, we only count them during this one mode.
    'ExtractPKAFiles' { $EnumFilter = '*.pka' }
    
    # For PKG files, we only count them during this one mode.
    'ExtractPKGFiles' { $EnumFilter = '*.pkg' }

    # For phyre images, we only count them during this one mode.
    'ConvertPhyrePNG' { $EnumFilter = @('*.png.phyre','*.dds.phyre','*.bmp.phyre') }

    # When creating PKG files, search for the "asset_D3D11.xml" file.
    'PackIntoPKGFile' { $EnumFilter = '*asset*.xml' }

    # For every other operation, only look for image files (and possibly icons).
    default {
              # Create the filter array now so it can have stuff added as needed.
              $EnumFilter = New-Object Collections.Generic.List[string]

              # Dolphin Mode handles things a bit differently.
              if ($CTTPSSelectedMode -eq "Dolphin Mode")
              {
                # Add the tex1 prefix to the filter below so only Dolphin textures are passed.
                $TexFilter = '*tex1'

                # These fancy new "RGBA" images are a thing thanks to Venomalia.
                $EnumFilter.Add('*RGBA_*x*_*.png')
              }
              # When in any other mode.
              else
              {
                # Do not apply further filtering to the main image types.
                $TexFilter = ''
              }
              # PNG, DDS, and JPG will always be added no matter what.
              $EnumFilter.Add(($TexFilter + '*.png'))
              $EnumFilter.Add(($TexFilter + '*.dds'))
              $EnumFilter.Add(($TexFilter + '*.jpg'))

              # Converting alone can pass icon files.
              if ($MasterOperation -eq 'ConvertTextures') { $EnumFilter.Add('*.ico') }

              # Convert, Rescale, and Resize can accept other types of files but only while in "Expert Mode".
              if (($MasterOperation -eq 'ConvertTextures') -or ($MasterOperation -eq 'RescaleTextures') -or ($MasterOperation -eq 'ResolutionScale'))
              {
                # Add these file types to the mix.
                $EnumFilter.Add(($TexFilter + '*.bmp'))
                $EnumFilter.Add(($TexFilter + '*.tga'))
                $EnumFilter.Add(($TexFilter + '*.tif*'))
              }
            }
  }
  #------------------------------------------------------------------------------------------------------------------------------
  # Part Three: Create a generic list to store the collection of file arrays.
  #------------------------------------------------------------------------------------------------------------------------------
  # Create an array of arrays to store the file lists.
  $global:ImageStack = New-Object Collections.Generic.List[string[]]

  # Loop through all the stored directories.
  for ($i = 0 ; $i -lt $Directories.Count ; $i++)
  {
    # Get all the files within the current directory.
    $FileCollection = EnumerateFiles -LiteralPath $Directories[$i] -Filter $EnumFilter

    # Add the image stack to the master stack.
    $ImageStack.Add($FileCollection)
  }
  #------------------------------------------------------------------------------------------------------------------------------
  # Part Four: Add all the files into a final array while filtering to get the total count.
  #------------------------------------------------------------------------------------------------------------------------------
  # A block of code is needed to pass to the job.
  $JobCountTextures = {

    # Everything that is passed through needs to be copied over.
    Param ( [string]$MasterOperation, [string]$VRAMPackPath, [string]$PhyrePreviousPath, $Directories, $ImageStack, [bool]$TexExtractToolExists, [bool]$ScanTexturesOperation )

    # Lazily copy the entire function because its easy.
    function ValidateTilde([string]$InputPath)
    {
      # Check to see if the tilde character is in the path.
      if ($InputPath -like '*~*')
      {
        # Depending on the operation, when a tilde passes can change.
        switch ($MasterOperation)
        {
          'CalculatingVRAM' { $BypassTilde = (TestPath -LiteralPath $VRAMPackPath) }
          'ConvertPhyrePNG' { $BypassTilde = $PhyrePreviousPath }
          'CreateFromPhyre' { $BypassTilde = $PhyrePreviousPath }
          'PackIntoPKGFile' { $BypassTilde = $PhyrePreviousPath }
        }
        # If the tilde was not bypassed.
        if (!$BypassTilde) { return $false }
      }
      # There is no tilde or it was bypassed.
      return $true
    }
    # This is the last array that will be created, and is the one that is ultimately counted.
    $FinalArray = New-Object Collections.Generic.List[string]

    # RGBA images will be split automatically into two images so each one counts as 2x textures.
    $RGBA_Count = 0

    # Loop through all the items in the list.
    for ($i = 0 ; $i -lt $Directories.Count ; $i++)
    {
      # Do not attempt to add files to the array of the source array is empty.
      if ($ImageStack[$i].Count -gt 0)
      {
        # Loop through all images in the array.
        for($x = 0 ; $x -lt $ImageStack[$i].Count ; $x++)
        {
          # Most textures won't be RGBA so don't fail them based on that.
          $RGBA_AutoFail = $false
        
          # Make an easy variable to reference.
          $ImageFile = $ImageStack[$i][$x]

          # Also get the file as an item so we can check the name directly.
          $ImageName = (Get-Item -LiteralPath $ImageFile).Name

          # A check to see if the tilde character should pass.
          $TildeCheck = (($ImageFile -notlike '*~*') -or (ValidateTilde -InputPath $ImageFile))

          # A check to see if it's not a mipmap.
          $MMipsCheck = ($ImageName -notlike '*_mip*')

          # A check to see if it's not a material map.
          $MMapsCheck = ($ImageName -notlike '*tex1*.mat*')

          # A check to see if it's not a material texture
          $NMaterials = (($ImageName -notlike '*.nrm*') -and ($ImageName -notlike '*.bump*') -and ($ImageName -notlike '*.spec*') -and ($ImageName -notlike '*.lum*'))

          # Check for TextureExtraction Tool "RGBA_" images.
          if (($ImageName -like "RGBA_*x*_*.png") -and (!$ScanTexturesOperation))
          {
            # Fail these images from being added to the array so they aren't counted.
            $RGBA_AutoFail = $true 
          
            # TextureExtraction Tool is required to handle these textures directly.
            if ($TexExtractToolExists)
            {
              # Increment the count by two if RGBA texture is found.
              $RGBA_Count += 2
            }
          }
          # If all checks pass, add the image to the new array.
          if ($TildeCheck -and $MMipsCheck -and $MMapsCheck -and $NMaterials -and !$RGBA_AutoFail) { $FinalArray.Add($ImageFile) }
        }
      }
    }
    # Write the output so it can be retrieved.
    Write-Output ($FinalArray.Count + $RGBA_Count)
  }
  # TextureExtraction Tool is required to handle "RGBA_" textures. Because 2x textures are created, there is a special check for them to add +2 to the texture count. If the tool is missing, 
  # then these textures can not be handled so we don't want them counted. The simplest way to workaround this issue, was to add a check here to not add these textures to the count.
  $TexExtractToolExists = (TestPath -LiteralPath $TexExtractTool)

  # It gets even more fun yet. When scanning textures, we want "RGBA_" textures to actually be processed by the MasterLoop, it's only a +1 in this case.
  $ScanTexturesOperation = ($MasterOperation -eq 'ScanAllTextures')

  # Start the job to create the image.
  $Job = Start-Job -Name "CountTextures" -Scriptblock $JobCountTextures -ArgumentList $MasterOperation,$VRAMPackPath,$PhyrePreviousPath,$Directories,$ImageStack,$TexExtractToolExists,$ScanTexturesOperation

  # Create a timer that will check the status of the job.
  $global:CountTimer = New-Object Windows.Forms.Timer
  $CountTimer.Interval = 25
  $CountTimer.Add_Tick({ TextureCount_TimerTick })
  $CountTimer.Start()
}
#==============================================================================================================================================================================================
#  Automatically scrolls the list as it builds. This adds some slowdown but not too much.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_AutoScroll()
{
  # See if the user has auto-scrolling enabled.
  if ($TexListAutoScroll)
  {
    # The top row visible on the texture list.
    $FirstVisible = $TexListCatalog.FirstDisplayedScrollingRowIndex

    # The number of visible texture list rows.
    $RowsVisible = $TexListCatalog.DisplayedRowCount($true)

    # The row we want to lock onto.
    $TargetRow = $TexListPosition - $RowsVisible + 1

    # Don't start scrolling until the texture count exceeds the visible number of rows.
    if ($TexListPosition -gt $RowsVisible)
    {
      # Automatically scroll the list as it builds.
      $TexListCatalog.FirstDisplayedScrollingRowIndex = $TargetRow
    }
  }
}
#==============================================================================================================================================================================================
#  Updates the status of the Operation, TextureCount, Progress, or Timer fields.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateStatus([string]$Status, [string]$Value, $FontColor)
{
  # Select which status value on the GUI to update.
  switch ($Status)
  {
    # These ones are fairly simple, just need to set the proper dialog item.
    'Operation'     { $DialogItem = $TexListOpValue    }
    'TextureCount'  { $DialogItem = $TexListTexValue   }
    'Timer'         { $DialogItem = $TexListTimerValue }

    # Progress has a value and a bar, so do a bit more.
    'Progress'
    {
      # Set the proper dialog item.
      $DialogItem = $TexListProgValue

      # The string might not be an integer so check for that.
      if ($Value -as [int] -is [int])
      {
        # Update the progress bar if the value is an integer.
        $TexListProgBar.Value = [Convert]::ToInt32($Value)

        # Add the percent sign after the progress percentage.
        $BonusText = '%'
      }
    }
  }
  # Update the dialog item with the new value.
  if ($FontColor -eq $null) { $FontColor = [Drawing.Color]::Black }
  $DialogItem.Text = $Value + $BonusText
  $DialogItem.ForeColor = $FontColor
}
#==============================================================================================================================================================================================
#  Initiates the texture list. Needs to be ran at the start of the Master Loop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_Init()
{
  # Restore the progress label as it may have been changed.
  $TexListProgLabel.Text = 'Progress:'

  # Change the text of the button to pause (may be "Start" if started from main dialog).
  $TexListStartButton.Text = 'Pause'

  # Clear everything that may exist from a previous run.
  TexList_SetInitialState -Rows 150

  # Reset all the important variables.
  $global:TextureCount        = 0                             # The number of textures processed by the Master Loop.
  $global:TexListPosition     = 0                             # The number of lines displayed on the texture list.
  $global:TotalFiles          = 0                             # The number of textures in the pack that will run through the MasterLoop.
  $global:PreviousPath        = ''                            # Log file variable. Stores the texture path of a previous MasterLoop iteration to use in the current iteration.
  $global:TexSpaces           = 1                             # Tracks number of empty string added to the list. Increases string by one character each increment.
  $global:PauseMasterLoop     = $false                        # Tracks whether or not the MasterLoop is currently paused.
  $global:CancelMasterLoop    = $false                        # Tracks whether or not the MasterLoop will be canceled the next loop iteration.
  $global:ProcessingTexture   = $false                        # Tracks when a texture is being processed by the MasterLoop.
  $global:Duplicates          = @{}                           # Scan Textures - A hash table that keeps track of duplicate textures that were found.
  $global:CountIssues         = 0                             # Scan Textures - Count of how many textures had issues.
  $global:CountRepaired       = 0                             # Scan Textures - Count of how many textures with issues were repaired.
  $global:CountCopied         = 0                             # Scan Textures - Count of how many textures with issues were copied.
  $global:CountMipmapped      = 0                             # Generate New Mipmaps For Dolphin Textures - Count the number of textures that had mipmaps generated.
  $global:CountInvalidMips    = 0                             # Remove Invalid Mipmaps - Count the number of textures that had mipmaps generated.
  $global:CountSlicedAlpha    = 0                             # Remove Alpha From Opaque - Count the number of textures that had alpha channel removed.
  $global:CountOptimized      = 0                             # Optimize With Optimizer - Count the number of textures that had their filesize reduced.
  $global:CountRGBASplit      = 0                             # Counts the number of RGBA files created by Dolphin TextureExtraction Tool that were split.
  $global:OptimizedBytes      = 0                             # Optimize With Optimizer - The total amount of storage in bytes recovered with Optimizer program.

  # The path to the TextureExtraction Tool log file when splitting RGBA combined textures.
  $global:TexExtractLog       = ""

  # Used when calculating textures VRAM.
  [int64]$global:VRAMTotal    = 0
  [int64]$global:VRAMCountPNG = 0
  [int64]$global:VRAMCountDDS = 0
  [int64]$global:VRAMCountJPG = 0

  # Set visibility of the progress indicating shit.
  $TexListTexLabel.Visible   = $true
  $TexListTexValue.Visible   = $true
  $TexListProgLabel.Visible  = $true
  $TexListProgBar.Visible    = $true
  $TexListProgValue.Visible  = $true
  $TexListTimerLabel.Visible = $true
  $TexListTimerValue.Visible = $true

  # Creating a resource pack can move this timer, so make sure it's in the correct location.
  $TexListTimerLabel.Location = DPISize (New-Object Drawing.Point(740, 8))
  $TexListTimerValue.Location = DPISize (New-Object Drawing.Point(804, 8))

  # Enable the pause and cancel buttons.
  $TexListCancelButton.Enabled = $true
  $TexListHelpButton.Enabled = $true
  $TexListAScrollCheck.Enabled = $true
  $TexListStoreSizeCheck.Enabled = $true
  $TexListWaitLabel.Visible = $false

  # Disable the Dock/Exit buttons on the texture list.
  $TexListCloseButton.Enabled = $false
  $MainProcessButton.Enabled = $false
  $TexListProcessButton.Enabled = $false

  # Reset the progress bar.
  $TexListProgBar.Value = 0

  # Check to see if "Docked Mode" is enabled.
  if ($TextureListMode -eq 'Docked')
  {
    # Also disable all the panels containing options.
    $MainDockedPanelA.Enabled = $false
    $MainDockedPanelB.Enabled = $false
    $MainDockedPanelC.Enabled = $false
  }
  # Set the operation to whatever it is. The global that stores this is set in the initiate functions fired by "StartMasterLoop".
  TexList_UpdateStatus -Status 'TextureCount' -Value "0/(??)"
  TexList_UpdateStatus -Status 'Operation'    -Value $TexListOperation
  TexList_UpdateStatus -Status 'Progress'     -Value '(??)'
  TexList_UpdateStatus -Status 'Timer'        -Value '0'

  # Clear and null the list of textures if it existed in a previous process.
  if ($ProcessMasterList -ne $null)
  {
    $ProcessMasterList.Clear()
    $ProcessMasterList = $null
  }
  # Start the timer that tracks the amount of time the operation takes to complete.
  TexList_StartTimer

  # Start counting textures now. This is done asynchronously, and will update "$TotalFiles" when it is finished.
  CountTexturesToProcess
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - ADD TEXTURES TO THE LIST
#==============================================================================================================================================================================================
#  Adds a texture and various properties to the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateList([object[]]$Entry)
{
  # Check to see if the texture count doesn't exceed the number of rows.
  if ($TexListPosition -le $TexListCatalog.Rows.Count)
  {
    # Subtract 1 from the texture count.
    $i = $TexListPosition - 1

    # Add the array values to the grid.
    $TexListCatalog[0,$i].Value = $Entry[0]
    $TexListCatalog[1,$i].Value = $Entry[1]
    $TexListCatalog[2,$i].Value = $Entry[2]
    $TexListCatalog[3,$i].Value = $Entry[3]
    $TexListCatalog[4,$i].Value = $Entry[4]
    $TexListCatalog[5,$i].Value = $Entry[5]
    $TexListCatalog[6,$i].Value = $Entry[6]
  }
  # A new row will need to be created.
  else
  {
    # Add the full array to the texture list.
    $TexListCatalog.Rows.Add($Entry)
  }  
  # Perform "DoEvents" so the dialog refreshes itself.
  [Windows.Forms.Application]::DoEvents()
}
#==============================================================================================================================================================================================
#  Adds a texture and various properties to the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_AddTexture([hashtable]$TextureInfo)
{
  # Reset the Status and Message fields each iteration.
  $global:TexListStatus    = ''
  $global:TexListMessage   = ''
  $global:TexListStatusSet = $false

  # A condition to see if we're in a specific mode.
  $MainOpTypes = New-Object bool[] 3
  $MainOpTypes[0] = ($CTTPSSelectedMode -eq 'Dolphin Mode')
  $MainOpTypes[1] = ($CTTPSSelectedMode -eq 'Metroid Prime')
  $MainOpTypes[2] = ($CTTPSSelectedMode -eq 'Database Mode')

  # Splitting textures when batching CTT files is its own beast.
  if ($MasterOperation -eq 'SplitMultiImage')
  {
    # For neatness, store this in a var.
    $TexListEntry = $TextureInfo.Name + $PNG + ' / ' + $TextureInfo.FullName 

    # Create the array for the new list entry.
    $NewListEntry = @($TexListEntry, '-', '-', '-', '-', '-', $TextureInfo.Path)
  }
  # For most operations in Dolphin Mode we get the old/new dimensions and aspects, as well as the upscale value.
  elseif (TestBooleanArray -Or -Array $MainOpTypes)
  {
    # For neatness, store these in vars.
    $TexListEntry = $TextureInfo.FullName
    $TexOldAspect = $TextureInfo.OldAspect.ToString() + ':1'
    $TexCurAspect = $TextureInfo.Aspect.ToString() + ':1'

    # Add an asterisk to the filename if its in the database.
    if ($TextureInfo.DBTexture) { $TexListEntry = "**" + $TexListEntry }

    # Create the array for the new list entry.
    $NewListEntry = @($TexListEntry, $TextureInfo.OldDimensions, $TextureInfo.Dimensions, $TextureInfo.FullScale, $TexOldAspect, $TexCurAspect, $TextureInfo.Path)
  }
  # In Expert Mode, images have no properties to reference so show generic information.
  elseif ($CTTPSSelectedMode -eq 'Expert Mode')
  {
    # For neatness, store these in vars.
    $TexListEntry = $TextureInfo.FullName
    $TexCurAspect = $TextureInfo.Aspect.ToString() + ':1'

    # Add an asterisk to the filename if its in the database.
    if ($TextureInfo.DBTexture) { $TexListEntry = "**" + $TexListEntry }

    # Create the array for the new list entry.
    $NewListEntry = @($TexListEntry, $TextureInfo.Dimensions, $TextureInfo.Format, $TextureInfo.Mipmaps, $TexCurAspect, $TextureInfo.Alpha.ToString(), $TextureInfo.Path)
  }
  # Phyre Mode gets a bit more complicated since there are different types of files to add.
  elseif ($CTTPSSelectedMode -eq 'Phyre Mode')
  {
    # Convert Phyre Textures to PNG Textures
    if ($MasterOperation -eq 'ConvertPhyrePNG')
    {
      # If it's a header file, get both the PNG name and the HEADER name.
      if ($TextureInfo.RealName -like "*.header*")
      {
        $TexListEntry = $TextureInfo.RealName + ' / ' + $Texture.FullName
        $ExtensionText = ExtensionToText -Extension $Texture.Extension
      }
      # If it's an image file, just get the image name and extension.
      else
      {
        $TexListEntry = $TextureInfo.RealName
        $ExtensionText = ExtensionToText -Extension $TextureInfo.Extension
      }
      # More neatness variables.
      $TexColdSteel = 'CS' + $TextureInfo.ColdSteel + ' Texture'
      
      # Create the array for the new list entry.
      $NewListEntry = @($TexListEntry, $TextureInfo.Dimensions, $TexColdSteel, $TextureInfo.Format, $TextureInfo.Mipmaps, $ExtensionText, $TextureInfo.Path)
    }
    # Convert Phyre Textures to PNG Textures.
    elseif ($MasterOperation -eq 'CreateFromPhyre')
    {
      # Get the path to the header file.
      $HeaderPath = GetPhyreHeaderPath -TextureInfo $TextureInfo

      # Do not even add the texture to the list if it does not have a header.
      if (TestPath -LiteralPath $HeaderPath)
      {
        # Most "TextureInfo" will be useless since it's referencing the PNG. So pull data from the header.
        $PhyreInfo = CreatePhyreInfo -InputFile $HeaderPath

        # Because I never had a reason to store the "real" extension, get it now just for this.
        $PhyreExtension = ExtractExtension -FilePath $PhyreInfo.FilePath

        # Add the header name and the texture name to the list.
        $HeaderName    = $TextureInfo.Name + '.header'
        $TexListEntry  = $HeaderName + ' / ' + $TextureInfo.FullName
        $ExtensionText = ExtensionToText -Extension $PhyreExtension
        $TexColdSteel  = 'CS' + $PhyreInfo.ColdSteel + ' Texture'

        # Create the array for the new list entry.
        $NewListEntry = @($TexListEntry, $TextureInfo.Dimensions, $TexColdSteel, $PhyreInfo.Format, $PhyreInfo.Mipmaps, $ExtensionText, $PhyreInfo.Path)
      }
    }
    # The only other two options for Phyre mode deal with PKA and PKG files, so default to those.
    else
    {
      # Get the extension.
      $ExtensionText = ExtensionToText -Extension $TextureInfo.Extension

      # Default to a dash in case it's a PKA file or an unknown PKG type.
      $PKGType   = '-'
      $PKGFormat = '-'

      # If it's a PKG file, get the type of PKG file based on byte 85.
      if ($ExtensionText -eq 'PKG')
      {
        # Extracting PKG files gives a file to check. Repacking them does not, so make sure it exists.
        if (TestPath -LiteralPath $TextureInfo.FullPath)
        {
          # Get the file as a byte array.
          $ByteArray = [IO.File]::ReadAllBytes($TextureInfo.FullPath)

          # Set the PKG type based on the value of the byte.
          switch ($ByteArray[84])
          {
            '0' { $PKGType = '-'       ; $PKGFormat = 'Uncompressed' }
            '1' { $PKGType = 'CS1/CS2' ; $PKGFormat = 'LZ77'         }
            '4' { $PKGType = 'CS3/CS4' ; $PKGFormat = 'LZ4'          }
          }
        }
      }
      # Create the array for the new list entry.
      $NewListEntry = @($TextureInfo.FullName, '-', $PKGType, $PKGFormat, '-', $ExtensionText, $TextureInfo.Path)
    }
  }
  # See if the user has auto-scrolling enabled.
  TexList_AutoScroll

  # Increment the texture list position.
  $global:TexListPosition++

  # Add the data to the texture list.
  TexList_UpdateList -Entry $NewListEntry
}
#==============================================================================================================================================================================================
#   Adds a non-texture file to the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_AddFile($File, [string]$Status='', [string]$Message='')
{
  # Increment the texture list position.
  $global:TexListPosition++

  # Reset the Status and Message fields each iteration.
  $global:TexListStatus    = ''
  $global:TexListMessage   = ''
  $global:TexListStatusSet = $false

  # The full path to the file will need to be referenced.
  $FilePath = [string]$File.Directory

  # Create the array for the new list entry.
  $NewListEntry = @($File.Name, '-', '-', '-', '-', '-', $FilePath)

  # Add the data to the texture list.
  TexList_UpdateList -Entry $NewListEntry

  # See if the user has auto-scrolling enabled.
  TexList_AutoScroll

  # Force adding the data to the board.
  TexList_SetTextureStatus -Status $Status -Message $Message
  TexList_UpdateTexture -TextureInfo $null

  # Perform "DoEvents" so the dialog refreshes itself.
  [Windows.Forms.Application]::DoEvents() | Out-Null
}
#==============================================================================================================================================================================================
#   Adds a custom string to the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_AddString([string]$TexEntry)
{
  # Reset the Status and Message fields each iteration.
  $global:TexListStatus    = ''
  $global:TexListMessage   = ''
  $global:TexListStatusSet = $false

  # Increment the texture list position.
  $global:TexListPosition++

  # If the parameter is empty, send an empty string but extend it each loop iteration.
  if (($TexEntry -eq '') -or ($TexEntry -eq ' '))
  {
    # Extend the string by 1 space. Each new empty string will be one character longer than the last
    # using "TexSpaces". This is to ensure that every single entry added to the listview has a unique name.
    $TexEntry = ExtendString -InputString $TexEntry -Length $TexSpaces
    $global:TexSpaces += 1
  }
  # Create the array for the new list entry.
  $NewListEntry = @($TexEntry, ' ', ' ', ' ', ' ', ' ', ' ')

  # Add the data to the texture list.
  TexList_UpdateList -Entry $NewListEntry

  # See if the user has auto-scrolling enabled.
  TexList_AutoScroll

  # Perform "DoEvents" so the dialog refreshes itself.
  [Windows.Forms.Application]::DoEvents() | Out-Null
}
#==============================================================================================================================================================================================
#  Allows adding a file as a string. Combines the functionality of the above two functions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_AddFileString([string]$FilePath, [string]$Status='', [string]$Message='')
{
  # Reset the Status and Message fields each iteration.
  $global:TexListStatus    = ''
  $global:TexListMessage   = ''
  $global:TexListStatusSet = $false

  # Increment the texture list position.
  $global:TexListPosition++

  # Get the name of the file.
  $FileName = (Get-Item -LiteralPath $FilePath).Name

  # Create the array for the new list entry.
  $NewListEntry = @($FileName, '-', '-', '-', '-', '-', $FilePath)

  # Add the data to the texture list.
  TexList_UpdateList -Entry $NewListEntry

  # See if the user has auto-scrolling enabled.
  TexList_AutoScroll

  # Force adding the data to the board.
  TexList_SetTextureStatus -Status $Status -Message $Message
  TexList_UpdateTexture -TextureInfo $null

  # Perform "DoEvents" so the dialog refreshes itself.
  [Windows.Forms.Application]::DoEvents() | Out-Null
}
#==============================================================================================================================================================================================
#  Simply checks if the texture is a split RGBA texture and returns the appropriate status.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetStatus()
{
  # Check for this flag.
  if ($Texture.SplitRGBA)
  {
    # If it's there use that as status.
    return "SplitRGBA"
  }
  # Otherwise just make it ok.
  return "OK"
}
#==============================================================================================================================================================================================
#  Part 1/2: Sets the texture Status, Message, or both. Messages are stored in a global, and accessed at the end of a loop iteration with "TexList_UpdateTexture".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_SetTextureStatus([string]$Status='', [string]$Message='')
{
  # Texture status could be overwritten, so this variable prevents that. In all cases, I always want to use the first status message.
  if (!$TexListStatusSet)
  {
    # Make sure it can not be updated again until the next texture is added to the list with "TexList_AddTexture".
    $global:TexListStatusSet = $true

    # Set the values to add to the texture list.
    if ($Status -ne '')  { $global:TexListStatus = $Status }
    if ($Message -ne '') { $global:TexListMessage = $Message }
  }
}
#==============================================================================================================================================================================================
#  Part 2/2: Adds the remaining texture information set by "TexList_SetTextureStatus" at the end of the MasterLoop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateTexture([hashtable]$TextureInfo)
{
  # Subtract 1 from the texture count.
  $i = $TexListPosition - 1

  # Add the entry to the texture list.
  $TexListCatalog[7,$i].Value = $TexListStatus
  $TexListCatalog[8,$i].Value = $TexListMessage

  # Update the log file if there is texture information to add.
  if ($TextureInfo -ne $null)
  {
    # Log: Attempt to update the log file with texture information.
    UpdateLog -TextureInfo $TextureInfo

    # See if the texture was already in the database file.
    if (!$TextureInfo.DBTexture)
    {
      # Attempt to add it to the database log.
      AddTextureDBLog -TextureInfo $TextureInfo
    }
  }
}
#==============================================================================================================================================================================================
#  Updates all progress each loop iteration.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateProgress($File)
{
  # The type of files that increment the counter depends on the operation being performed.
  # Note: Also see (CountTexturesToProcess) as this type of filtering takes place there too.
  switch ($MasterOperation)
  {
    # When batch splitting images, search for CTT files.
    'SplitMultiImage' { $ExtensionCheck = ($File.Name -like '*.ctt') }

    # For PKG files, we only count them during this one mode.
    'ExtractPKAFiles' { $ExtensionCheck = ($File.Name -like '*.pka') }

    # For PKG files, we only count them during this one mode.
    'ExtractPKGFiles' { $ExtensionCheck = ($File.Name -like '*.pkg') }

    # For phyre images, we only count them during this one mode.
    'ConvertPhyrePNG' { $ExtensionCheck = (($File.Name -like '*.png.phyre') -or ($File.Name -like '*.dds.phyre') -or ($File.Name -like '*.bmp.phyre')) }

    # When creating PKG files, search for the "asset_D3D11.xml" file.
    'PackIntoPKGFile' { $ExtensionCheck = (($File.PSIsContainer) -and (TestPath -LiteralPath ($File.FullName + '\asset_D3D11.xml'))) }

    # For every other operation, only look for image files (and possibly icons).
    default           { 
                        # Create a boolean array to store all the checks.
                        $BoolArray = New-Object Collections.Generic.List[bool]

                        # PNG, DDS, and JPG will always be added no matter what.
                        $BoolArray.Add(($File.Name -like '*.png'))
                        $BoolArray.Add(($File.Name -like '*.dds'))
                        $BoolArray.Add(($File.Name -like '*.jpg'))

                        # Converting alone can pass icon files.
                        if ($MasterOperation -eq 'ConvertTextures') { $BoolArray.Add(($File.Name -like '*.ico')) }

                        # Convert, Rescale, and Resize can accept other types of files but only while in "Expert Mode".
                        if (($MasterOperation -eq 'ConvertTextures') -or ($MasterOperation -eq 'RescaleTextures') -or ($MasterOperation -eq 'ResolutionScale'))
                        {
                          # Add these file types to the mix.
                          $BoolArray.Add(($File.Name -like '*.bmp'))
                          $BoolArray.Add(($File.Name -like '*.tga'))
                          $BoolArray.Add(($File.Name -like '*.tif*'))
                        }
                        # Peform an "or" check on all the conditions.
                        $ExtensionCheck = TestBooleanArray -Or -Array $BoolArray
                      }
  }
  # Set up the series of checks in a variable array.
  $UpdateCheck = New-Object bool[] 9

  # Scan all textures allows TextureExtraction Tool "RGBA_" images to pass.
  if ($MasterOperation -eq 'ScanAllTextures')
  {
    # If Expert Mode is enabled, always update for all image types. If it's not enabled, only update for images with "tex1" prefix.
    $UpdateCheck[0] = (($File.Name -like "tex1*") -or ($File.Name -like "RGBA_*"))
  }
  else
  {
    # If Expert Mode is enabled, always update for all image types. If it's not enabled, only update for images with "tex1" prefix.
    $UpdateCheck[0] = (($CTTPSSelectedMode -ne 'Dolphin Mode') -or ($File.Name -like 'tex1*'))
  }
  # We only want images in a path that doesn't contain a "~", and we don't want Dolphin textures that are mipmaps, material maps, or material textures.
  $UpdateCheck[1] = $ExtensionCheck
  $UpdateCheck[2] = (($File.FullName -notlike '*~*') -or ($PathsNeedRestore))
  $UpdateCheck[3] = ($File.Name -notlike '*_mip*')
  $UpdateCheck[4] = ($File.Name -notlike '*tex1*.mat*')
  $UpdateCheck[5] = ($File.Name -notlike '*.nrm*')
  $UpdateCheck[6] = ($File.Name -notlike '*.bump*')
  $UpdateCheck[7] = ($File.Name -notlike '*.spec*')
  $UpdateCheck[8] = ($File.Name -notlike '*.lum*')

  # Check to see if the title bar should be updated.
  if (TestBooleanArray -And -Array $UpdateCheck)
  {
    # If updating the timer, it needs to be paused when the loop is paused. This is done here and now because this function fires AFTER a
    # program is finished. This allows the timer to track programs that are still running after the pause button has already been pressed.
    if ($PauseMasterLoop)
    {
      # Apply the orange font color to all values.
      $FontColor = [Drawing.ColorTranslator]::FromHtml('#FF8000')

      # Stop the timer, but don't destroy it.
      TexList_StopTimer -Destroy $false

      # The timer updates itself after every tick, so this update only takes place to turn the font red.
      TexList_UpdateStatus -Status 'Timer' -Value $TexListTimerValue.Text -FontColor $FontColor
    }
    # The count has been finished so perform calculations.
    if ($TotalFiles -gt 0)
    {
      # Update the counts as expected.
      $TextureCountString = $TextureCount.ToString() + '/' + $TotalFiles.ToString()

      # Find the absolute value and convert it to a string.
      $SplitProgressPC = (FormatDecimal -Value (($TextureCount / $TotalFiles) * 100).ToString()).Split('.', 2)
      $ProgressPercent = $SplitProgressPC[0]
    }
    # The texture count is still being determined, so use a ?? as the value.
    else
    {
      # We don't know the current count, so make it unknown.
      $TextureCountString = $TextureCount.ToString() + "/(??)"

      # Find the absolute value and convert it to a string.
      $ProgressPercent = "(??)"
    }
    # Update the texture count, and update the progress percentage.
    TexList_UpdateStatus -Status 'TextureCount' -Value $TextureCountString -FontColor $FontColor
    TexList_UpdateStatus -Status 'Progress'     -Value $ProgressPercent    -FontColor $FontColor
  }
}
#==============================================================================================================================================================================================
#  The final update that takes place.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateFinal()
{
  # Stop the timer and destroy it now that the loop has finished.
  TexList_StopTimer -Destroy $true

  # Perform the final update to the log file.
  UpdateLogFinal

  # If the MasterLoop was canceled, disable visibility of a bunch of shit and clear the texture list.
  if ($CancelMasterLoop)
  {
    # Set visibility of the progress indicating shit.
    $TexListTexLabel.Visible = $false
    $TexListTexValue.Visible = $false
    $TexListProgLabel.Visible = $false
    $TexListProgBar.Visible = $false
    $TexListProgValue.Visible = $false
    $TexListTimerLabel.Visible = $false
    $TexListTimerValue.Visible = $false

    # Set the operation to "Canceled" status.
    TexList_UpdateStatus -Status 'Operation' -Value 'Canceled' -FontColor ([Drawing.ColorTranslator]::FromHtml('#DF0101'))
  }
  else
  {
    # Set the operation to "Completed" status.
    TexList_UpdateStatus -Status 'Operation' -Value 'Completed' -FontColor ([Drawing.ColorTranslator]::FromHtml('#04B404'))
  }
  # Change the "Pause" button to a second "Start" button.
  $TexListStartButton.Text = 'Start'
  $TexListStartButton.Enabled = $true

  # Disable the cancel buttons.
  $TexListCancelButton.Enabled = $false

  # Enable the Dock/Exit buttons on the texture list.
  $TexListCloseButton.Enabled = $true
  $MainProcessButton.Enabled = $true
  $TexListProcessButton.Enabled = $true

  # Check to see if "Docked Mode" is enabled.
  if ($TextureListMode -eq 'Docked')
  {
    # Also enable all the panels containing options.
    $MainDockedPanelA.Enabled = $true
    $MainDockedPanelB.Enabled = $true
    $MainDockedPanelC.Enabled = $true
  }
  # If the loop was canceled this may still be hanging around.
  $TexListWaitLabel.Visible = $false

  # Check to see if we're calculating VRAM.
  if ($MasterOperation -eq 'CalculatingVRAM')
  {
    # Get the total VRAM consumption in megabytes. Make sure it only has two decimal places.
    [int64]$VRAMTotalMB = [Math]::Round((B2MB -Bytes $VRAMTotal), 1)

    # Add a blank entry to the texture list as a separator. 
    TexList_AddString -TexEntry ''

    # Loop through each of the file extensions.
    foreach ($FileType in @('PNG', 'JPG', 'DDS'))
    {
      # Get the value of the global variable that contains how many of this type of file was found.
      $VRAMCount = Get-Variable -Name ('VRAMCount' + $FileType) -ValueOnly

      # If this type of file was found, report how many.
      if ($VRAMCount -gt 0)
      {
        # Set up the string for total of this format.
        $EntryText = 'Total ' + $FileType + ' Textures: ' + $VRAMCount

        # Show the total amount of textures in this format.
        TexList_AddString -TexEntry $EntryText
      }
    }
    # Display the total VRAM usage. 
    TexList_AddString -TexEntry ''
    TexList_AddString -TexEntry ('Total VRAM Usage: ' + $VRAMTotalMB.ToString() + ' MB')
  }
  # Only show the texture window if its set to always be visible.
  $TexListDialog.Visible = ($TextureListMode -eq 'Window')
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - START PAUSE MASTER LOOP
#==============================================================================================================================================================================================
#  Pauses the main loop when the TexListStartButton "Pause" button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_PauseLoopStart()
{
  # Check the text of the button to know if the Master Loop should be started.
  if ($TexListStartButton.Text -eq 'Start')
  {
    # Allow this button to also start the master loop.
    InitiateMasterLoop
  }
  # The loop is currently running and not paused.
  elseif (!$PauseMasterLoop)
  {
    # Pause the loop by setting this variable to true. The MasterLoop will be looking for it.
    $global:PauseMasterLoop = $true

    # Update the button.
    if ($MasterLoopRunning)
    {
      # If the loop still has more to do, name it resume.
      $TexListStartButton.Text = 'Resume'
    }
    # Work-around a rare race condition. The user has to press the pause button after the script hit 100%.
    else
    {
      # A race condition can name this after 100%, so force it to "Start" in this case.
      $TexListStartButton.Text = 'Start'
    }
    # Play a beep.
    [Media.SystemSounds]::Hand.Play()
  }
  else
  {
    # Unpause the loop by setting this variable to false. The MasterLoop will be looking for it.
    $global:PauseMasterLoop = $false

    # Update the button.
    $TexListStartButton.Text = 'Pause'

    # Update the statuses.
    TexList_UpdateStatus -Status 'Operation'    -Value $TexListOperation
    TexList_UpdateStatus -Status 'TextureCount' -Value $TexListTexValue.Text
    TexList_UpdateStatus -Status 'Progress'     -Value $TexListProgValue.Text.Replace('%','')
    TexList_UpdateStatus -Status 'Timer'        -Value $TexListTimerValue.Text

    # Resume the timer.
    TexList_ResumeTimer
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - PAUSE MASTER LOOP
#==============================================================================================================================================================================================
#  When the script is paused, the main thread hangs out in the loop in this function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_PauseLoopInProgress()
{
  # Get the status of the job before going into the loop.
  $Job = (Get-Job -Name 'ThreadedScript' -ErrorAction 'SilentlyContinue')

  # If there is actually a job to get.
  if ($Job -ne $null)
  {
    # Get the status of it.
    $JobStatus = (Get-Job -Name 'ThreadedScript'-ErrorAction 'SilentlyContinue').State
  }
  # Check to see if the user paused the loop.
  if (($PauseMasterLoop) -and (($Job -eq $null) -or ($JobStatus -ne 'Completed')))
  {
    # Before going into the loop, update stuff related to pause so it isn't ran every loop iteration.
    if (($PauseMasterLoop) -or ($CancelMasterLoop))
    {
      # Update the operation to say that it is paused.
      TexList_UpdateStatus -Status 'Operation' -Value 'Paused' -FontColor ([Drawing.ColorTranslator]::FromHtml('#FF8000'))
    }
    # While it is paused, wait for the user to unpause it.
    while ($PauseMasterLoop)
    {
      # Sleep for a 10th of a second.
      Start-Sleep -m $DialogUpdateRate

      # The buttons are disabled while a texture is processing, so once it is done restore the
      # buttons to their former glory, and hide the "Waiting for texture to finish" message.
      if (!$ProcessingTexture)
      {
        # Bring back the controls if they were disabled.
        $TexListStartButton.Enabled = $true
        $TexListCancelButton.Enabled = $true
        $TexListHelpButton.Enabled = $true
        $TexListAScrollCheck.Enabled = $true
        $TexListStoreSizeCheck.Enabled = $true
        $TexListWaitLabel.Visible = $false

        # Debug:Let me know I'm in the pause loop.
        DebugMessage -Message '<< Currently in Pause Loop >>'
      }
      # Call DoEvents so the dialog doesn't hang.
      [Windows.Forms.Application]::DoEvents()
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - CANCEL MASTER LOOP
#==============================================================================================================================================================================================
#  Cancels the masterloop loop when the "Cancel" button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_CancelMasterLoop()
{
  # The timer continues to count when the dialog hangs so stop it for now.
  TexList_StopTimer -Destroy $false

  # Set the values for the Yes/No dialog.
  $Title   = 'CTT-PS Cancel Operation'
  $Message = 'Are you sure you wish to cancel the current operation?'

  # Show the Yes/No dialog and capture the result.
  $YesNoCancel = ShowYesNoDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 15) -OffsetY (DPISize 18) -Message $Message

  # If the user pressed Yes, ask the user to also remove directories.
  if ($YesNoCancel)
  {
    # The first dialog passed so cancel the loop.
    $global:CancelMasterLoop = $true

    # Set the values for the Yes/No dialog.
    $Title   = 'CTT-PS Cancel Operation'
    $Message = 'Also remove partially generated directories?'

    # Some options can delete multiple paths, so use a string array.
    $PathToRemove = New-Object Collections.Generic.List[string]

    # Show the Yes/No dialog that asks to remove directories.
    if (ShowYesNoDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 38) -OffsetY (DPISize 18) -Message $Message -PlayBeep $false)
    {
      # I decided on just removing whatever folder was being generated, instead of removing the entire generated directory.
      switch ($MasterOperation)
      {
        'ScanAllTextures' { $PathToRemove.Add(($MasterOutputPath + '\BrokenTextures'))
                            $PathToRemove.Add(($MasterOutputPath + '\RepairedTextures'))                           }
        'ConvertTextures' { $PathToRemove.Add(($MasterOutputPath + '\ConvertedTextures' + $OutputFormatLabel))     }
        'RescaleTextures' { $PathToRemove.Add(($MasterOutputPath + '\RescaledTextures' + $OutputFormatLabel))      }
        'ResolutionScale' { $PathToRemove.Add(($MasterOutputPath + '\ResizedTextures' + $OutputFormatLabel))       }
        'CreateMaterials' { $PathToRemove.Add(($MasterOutputPath + '\Materials'))                                  }
        'MakeMaterialMap' { $PathToRemove.Add(($MasterOutputPath + '\MaterialMaps'))                               }
        'CreateWatermark' { $PathToRemove.Add(($MasterOutputPath + '\WatermarkTextures'))                          }
        'SplitMultiImage' { $PathToRemove.Add(($MasterOutputPath + '\SplitTextures'))                              }
        'PNGOptimization' { $PathToRemove.Add(($MasterOutputPath + '\OptimizedTextures(' + $OptimizerTool + ')'))  }
        'UpscaleTextures' { $PathToRemove.Add(($MasterOutputPath + '\FilteredTextures(' + $UpscaleFilter + ')'))   }
        'ExtractPKAFiles' { $PathToRemove.Add(($MasterOutputPath + '\PKA_Extracted'))                              }
        'ExtractPKGFiles' { $PathToRemove.Add(($MasterOutputPath + '\PKG_Extracted'))                              }
        'ConvertPhyrePNG' { $PathToRemove.Add(($MasterOutputPath + '\ConvertedPhyre'))                             }
        'CreateFromPhyre' { $PathToRemove.Add(($MasterOutputPath + '\CreatedPhyre'))                               }
        'MetroidNewFonts' { $PathToRemove.Add(($MasterOutputPath + '\MPNewFonts'))                                 }
        'ExtractTextures' { $PathToRemove.Add(($MasterOutputPath + '\DolphinConverted'))                           }
      }
      # Loop through the paths to remove and, well, remove them.
      foreach ($RemovePath in $PathToRemove) { RemovePath -LiteralPath $RemovePath }
    }
    # Stop whatever job is currently in progress.
    Stop-Job -Name 'ThreadedScript' -ErrorAction 'SilentlyContinue'
    Remove-Job -Name 'ThreadedScript' -ErrorAction 'SilentlyContinue'

    # Clear the texture list.
    TexList_SetInitialState -Rows 150

    # If the loop is also paused, unpause it.
    $global:PauseMasterLoop = $false
    $TexListStartButton.Text = 'Pause'
  }
  # If the cancel was declined, resume the timer.
  else { TexList_ResumeTimer }
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - TRACK ELAPSED TIME
#==============================================================================================================================================================================================
#  Starts a new timer 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_StartTimer()
{
  # Start the time at zero.
  [double]$global:TimeElapsed = 0

  # Create a new timer that will expire every second.
  $global:TexListTimer = New-Object Windows.Forms.Timer
  $TexListTimer.Interval = 1000
  $TexListTimer.Add_Tick({ TexList_TimerTick })
  $TexListTimer.Start()
}
#==============================================================================================================================================================================================
#  Stops the old timer and optionally destroys it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_StopTimer([bool]$Destroy=$false)
{
  # Start the timer in a parallel universe.
  $TexListTimer.Stop()

  # This will be destroyed when the MasterLoop finishes.
  if ($Destroy)
  {
    # Looks like it finished.
    $TexListTimer.Dispose()
  }
}
#==============================================================================================================================================================================================
#  Resumes a stopped timer without creating a new one.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_ResumeTimer()
{
  # Resume the timer.
  $TexListTimer.Start()
}
#==============================================================================================================================================================================================
#  Ran every tick of the timer (or every second).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_TimerTick()
{
  # Track the number of seconds (ticks) that took place.
  [double]$global:TimeElapsed += 1

  # Convert the seconds to H:M:S format.
  $TimeSpan = [TimeSpan]::FromSeconds($TimeElapsed)

  # After an hour, format the time to include hours.
  if ($TimeElapsed -ge 3600)
  {
    $TimerText = "{0:hh:mm:ss}" -f ([DateTime]$TimeSpan.Ticks)
  }
  # After a minute, format the time.
  elseif ($TimeElapsed -ge 60)
  {
    $TimerText = "{0:mm:ss}" -f ([DateTime]$TimeSpan.Ticks)
  }
  # Under a minute, just use the value directly.
  else
  {
    $TimerText = $TimeElapsed.ToString()
  }
  # Update the value on the GUI with the new value. 
  $TexListTimerValue.Text = $TimerText

  # Make sure the timer always updates correctly.
  [Windows.Forms.Application]::DoEvents()
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST DIALOG UPDATE FUNCTIONS
#==============================================================================================================================================================================================
#  Prevents the "X" button from closing the dialogs when an operation is taking place.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_MainDialog_XButton()
{
  # This is a cheap hack to make sure this function doesn't run twice. When the texture list is closed, it also triggers the main dialog to close, which causes 
  # this function to run again. This causes some bugs such as nulling the texture list stored variables, so set a variable to make sure it doesn't run again.
  if ($OnlyExitOnce) { return }

  # Store the texture list column sizes.
  TexList_StoreProperties

  # Cancel closing if the master loop is currently in progress.
  $_.Cancel = ($MasterLoopRunning)

  # If it's running, ask to cancel the master loop.
  if ($MasterLoopRunning)
  {
    # Ask the user to cancel. 
    TexList_CancelMasterLoop

    # If it was not canceled, return so the program remains open.
    if ($CancelMasterLoop) { return }
  }
  # If it's not running, close the program out entirely.
  HideAllDialogs

  # Set the variable since this already ran.
  $global:OnlyExitOnce = $true
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST DOCKED MODE - Supporting functions for enter/exit docked mode are in the DPI profiles!
#==============================================================================================================================================================================================
#  Toggles the visibility state of the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_ToggleVisibility([string]$TexListMode)
{
  # Use the item names found on "MainTexListCombo".
  switch ($TexListMode)
  {
    # Always show the texture list.
    'Window'  { if ($DockedMode)  { TexList_ExitDockedMode  } }
    'Hidden'  { if ($DockedMode)  { TexList_ExitDockedMode  } }
    'Docked'  { if (!$DockedMode) { TexList_EnterDockedMode } }
  }
  # Show the texture list if in texture list "Window" mode, hide if not.
  $TexListDialog.Visible = ($TexListMode -eq 'Window')

  # Check to see if entering texture list "Window" mode.
  if ($TexListMode -eq 'Window')
  {
    # Center and activate the texture list dialog.
    CenterDialogWindow -Dialog $TexListDialog
    ActivateDialog -Dialog $TexListDialog 
  }
  # Center and activate the main dialog.
  CenterDialogWindow -Dialog $MainDialog
  ActivateDialog -Dialog $MainDialog

  # Center the wait label that displays on the texture list catalog.
  TexList_CenterWaitLabel
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - ENTER DOCKED MODE
#==============================================================================================================================================================================================
#  Enters docked mode. What else would it do, silly?
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_EnterDockedMode()
{
  # Switch the name of the title bar to the full name of the script.
  $MainDialog.Text = $ScriptName.Replace("'","")

  # Store that we're in "Docked Mode".
  $global:DockedMode                 = $true
  $global:DockedHidden               = $false

  # Adjust the visibility of some dialog elements.
  $MainStartButton.Visible           = $false
  $MainDialogPanel.Visible           = $false
  $MainDockedPanelA.Visible          = $true
  $MainDockedPanelB.Visible          = $true
  $MainDockedPanelC.Visible          = $true
  $MainDockedButtonsPanel.Visible    = $true
  $TexListHideButton.Visible         = $true

  # Make a few adjustments to the main dialog window.
  $MainDialog.FormBorderStyle        = [Windows.Forms.FormBorderStyle]::Sizable
  $MainDialog.AutoScaleMode          = [Windows.Forms.AutoScaleMode]::None
  $MainDialog.MaximizeBox            = $true

  # Set the size and location of various GUI elements from the main window using info from the DPI file.
  $MainDialog.MaximumSize            = New-Object Drawing.Size(0, 0)
  $MainDialog.Size                   = DPISize (New-Object Drawing.Size(1216, 564))
  $MainDialog.MinimumSize            = DPISize (New-Object Drawing.Size(1216, 564))
  $MainCTTPSGroup.Size               = DPISize (New-Object Drawing.Size(380, 64))
  $MainCTTPSGroup.Location           = DPISize (New-Object Drawing.Point(10, 5))
  $MainCTTPSCombo.Location           = DPISize (New-Object Drawing.Point(10, 26))
  $MainCTTPSLabel.Location           = DPISize (New-Object Drawing.Point(124, 29))
  $MainTexListCombo.Location         = DPISize (New-Object Drawing.Point(208, 26))
  $MainTexListLabel.Location         = DPISize (New-Object Drawing.Point(305, 29))
  $MainInputGroup.Size               = DPISize (New-Object Drawing.Size(380, 64))
  $MainInputGroup.Location           = DPISize (New-Object Drawing.Point(10, 71))
  $MainInputTextBox.Location         = DPISize (New-Object Drawing.Point(22, 25)) -AddY $DPIOffsetFix
  $MainInputButton.Location          = DPISize (New-Object Drawing.Point(325, 24))
  $MainInputFolder.Location          = DPISize (New-Object Drawing.Point(349, 24))
  $MainStoreInput.Location           = DPISize (New-Object Drawing.Point(5, 28))
  $MainOutputGroup.Size              = DPISize (New-Object Drawing.Size(380, 64))
  $MainOutputGroup.Location          = DPISize (New-Object Drawing.Point(10, 139))
  $MainOutputTextBox.Location        = DPISize (New-Object Drawing.Point(22, 25)) -AddY $DPIOffsetFix
  $MainOutputButton.Location         = DPISize (New-Object Drawing.Point(325, 24))
  $MainOutputFolder.Location         = DPISize (New-Object Drawing.Point(349, 24))
  $MainStoreOutput.Location          = DPISize (New-Object Drawing.Point(5, 28))
  $MainOperationsGroup.Location      = DPISize (New-Object Drawing.Point(10, 5))
  $MainFormatTexGroup.Size           = DPISize (New-Object Drawing.Size(380, 108))
  $MainFormatTexGroup.Location       = DPISize (New-Object Drawing.Point(10, 11))
  $MainMipmapGroup.Size              = DPISize (New-Object Drawing.Size(380, 80))
  $MainMipmapGroup.Location          = DPISize (New-Object Drawing.Point(10, 123))
  $MainProcessButton.Location        = DPISize (New-Object Drawing.Point(81, 6))
  $MainOptionsButton.Location        = DPISize (New-Object Drawing.Point(911, 6))
  $MainHelpButton.Location           = DPISize (New-Object Drawing.Point(1007, 6))
  $MainCloseButton.Location          = DPISize (New-Object Drawing.Point(1103, 6))
  $MainNoSaveButton.Location         = DPISize (New-Object Drawing.Point(1175, 6))

  # Set the position and bounds of the texture list catalog.
  $TexListPanelPosX                  = DPISize 10
  $TexListPanelPosY                  = DPISize 249
  $TexListPanelWidth                 = $MainDialog.Width - (DPISize 36)
  $TexListPanelHeight                = $MainDialog.Height - (DPISize 329)
  $TexListPanel.Bounds               = New-Object Drawing.Rectangle($TexListPanelPosX, $TexListPanelPosY, $TexListPanelWidth, $TexListPanelHeight)
  $TexListCatalog.Bounds             = New-Object Drawing.Rectangle(1, 1, ($TexListPanel.Width - 2), ($TexListPanel.Height - 2))
  $TexListCatalog.BringToFront()

  # Set the size and location of various GUI elements from the texture list window using info from the DPI file.
  $TexListOpPanelBG.Size             = DPISize (New-Object Drawing.Size(1144, 32))
  $TexListOpPanelBG.Location         = DPISize (New-Object Drawing.Point(10, 210))
  $TexListOpPanel.Size               = New-Object Drawing.Size(($TexListOpPanelBG.Size.Width - 2), ($TexListOpPanelBG.Size.Height - 2))
  $TexListStartButton.Location       = DPISize (New-Object Drawing.Point(9, 6))
  $TexListCancelButton.Location      = DPISize (New-Object Drawing.Point(110, 6))
  $TexListAScrollCheck.Location      = DPISize (New-Object Drawing.Point(208, 13))
  $TexListStoreSizeCheck.Location    = DPISize (New-Object Drawing.Point(440, 13))

  # Show the arrow button that hides the controls while in docked mode.
  $TexListHideButton.Size            = New-Object Drawing.Size(($TexListOpPanelBG.Size.Height + 2), ($TexListOpPanelBG.Size.Height + 2))
  $TexListHideButton.Location        = New-Object Drawing.Point(($MainDialog.Width - (DPISize 59 -Round)), ($TexListOpPanelBG.Top - 1))
  $TexListHideButton.BackgroundImage = $Image_ArrowTexListUp
  $TexListHideTip.SetToolTip($TexListHideButton, $TexListHideTipStringA)

  # Loop through the array of operation groups.
  foreach ($GroupName in $StaticGroupArray)
  {
    # Move them to the desired location.
    $Group = Get-Variable -Name $GroupName -ValueOnly
    $Group.Size =  DPISize (New-Object Drawing.Size(380, 138))
    $Group.Location = DPISize (New-Object Drawing.Point(10, 65))
    $MainDockedPanelB.Controls.Add($Group)
  }
  # Move several GUI elements to the various docked mode panels.
  $MainDockedPanelA.Controls.Add($MainCTTPSGroup)
  $MainDockedPanelA.Controls.Add($MainInputGroup)
  $MainDockedPanelA.Controls.Add($MainOutputGroup)
  $MainDockedPanelB.Controls.Add($MainOperationsGroup)
  $MainDockedPanelC.Controls.Add($MainFormatTexGroup)
  $MainDockedPanelC.Controls.Add($MainMipmapGroup)

  # Move the buttons to a specialized panel while in docked mode.
  $MainDockedButtonsPanel.Controls.Add($MainProcessButton)
  $MainDockedButtonsPanel.Controls.Add($MainOptionsButton)
  $MainDockedButtonsPanel.Controls.Add($MainHelpButton)
  $MainDockedButtonsPanel.Controls.Add($MainCloseButton)
  $MainDockedButtonsPanel.Controls.Add($MainNoSaveButton)
  $MainDockedButtonsPanel.Controls.Add($TexListStartButton)
  $MainDockedButtonsPanel.Controls.Add($TexListCancelButton)
  $MainDockedButtonsPanel.Controls.Add($TexListAScrollCheck)
  $MainDockedButtonsPanel.Controls.Add($TexListStoreSizeCheck)

  # Move some GUI elements directly to the main dialog.
  $MainDialog.Controls.Add($TexListOpPanelBG)
  $MainDialog.Controls.Add($TexListHideButton)
  $MainDialog.Controls.Add($TexListPanel)
  $TexListPanel.Controls.Add($TexListCatalog)

  # Set the size of the dialog to the stored values.
  TexList_TryLoadUserSettings
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - EXIT DOCKED MODE
#==============================================================================================================================================================================================
#  Exits docked mode. Come on, I don't even need these comments.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_ExitDockedMode()
{
  # Switch the name of the title bar to the say its the main window.
  $MainDialog.Text = 'CTT-PS Main Window (v' + $ScriptVersion + ')'

  # Store that we're no longer in "Docked Mode".
  $global:DockedMode              = $false
  $global:DockedHidden            = $false

  # Adjust the visibility of some dialog elements.
  $MainStartButton.Visible        = $true
  $MainDialogPanel.Visible        = $true
  $MainDockedPanelA.Visible       = $false
  $MainDockedPanelB.Visible       = $false
  $MainDockedPanelC.Visible       = $false
  $MainDockedButtonsPanel.Visible = $false
  $TexListHideButton.Visible      = $false

  # Make a few adjustments to the main dialog window.
  $MainDialog.FormBorderStyle     = [Windows.Forms.FormBorderStyle]::FixedDialog
  $MainDialog.AutoScaleMode       = [Windows.Forms.AutoScaleMode]::None
  $MainDialog.MaximizeBox         = $false

  # Set the size and location of various GUI elements from the main window using info from the DPI file.
  $MainDialog.Size                = DPISize (New-Object Drawing.Size(416, 628))
  $MainDialog.MinimumSize         = DPISize (New-Object Drawing.Size(416, 628))
  $MainDialog.MaximumSize         = DPISize (New-Object Drawing.Size(416, 628))
  $MainCTTPSGroup.Size            = DPISize (New-Object Drawing.Size(380, 42))
  $MainCTTPSGroup.Location        = DPISize (New-Object Drawing.Point(10, 5))
  $MainCTTPSCombo.Location        = DPISize (New-Object Drawing.Point(10, 15))
  $MainCTTPSLabel.Location        = DPISize (New-Object Drawing.Point(124, 18))
  $MainTexListCombo.Location      = DPISize (New-Object Drawing.Point(208, 15))
  $MainTexListLabel.Location      = DPISize (New-Object Drawing.Point(305, 18))
  $MainInputGroup.Size            = DPISize (New-Object Drawing.Size(380, 50))
  $MainInputGroup.Location        = DPISize (New-Object Drawing.Point(10, 50))
  $MainInputTextBox.Location      = DPISize (New-Object Drawing.Point(22, 18)) -AddY $DPIOffsetFix
  $MainInputButton.Location       = DPISize (New-Object Drawing.Point(325, 17))
  $MainInputFolder.Location       = DPISize (New-Object Drawing.Point(349, 17))
  $MainStoreInput.Location        = DPISize (New-Object Drawing.Point(5, 21))
  $MainOutputGroup.Size           = DPISize (New-Object Drawing.Size(380, 50))
  $MainOutputGroup.Location       = DPISize (New-Object Drawing.Point(10, 103))
  $MainOutputTextBox.Location     = DPISize (New-Object Drawing.Point(22, 18)) -AddY $DPIOffsetFix
  $MainOutputButton.Location      = DPISize (New-Object Drawing.Point(325, 17))
  $MainOutputFolder.Location      = DPISize (New-Object Drawing.Point(349, 17))
  $MainStoreOutput.Location       = DPISize (New-Object Drawing.Point(5, 21))
  $MainOperationsGroup.Location   = DPISize (New-Object Drawing.Point(10, 156))
  $MainFormatTexGroup.Size        = DPISize (New-Object Drawing.Size(380, 110))
  $MainFormatTexGroup.Location    = DPISize (New-Object Drawing.Point(10, 347))
  $MainMipmapGroup.Size           = DPISize (New-Object Drawing.Size(380, 84))
  $MainMipmapGroup.Location       = DPISize (New-Object Drawing.Point(10, 462))
  $MainProcessButton.Location     = DPISize (New-Object Drawing.Point(81, 554))
  $MainOptionsButton.Location     = DPISize (New-Object Drawing.Point(110, 554))
  $MainHelpButton.Location        = DPISize (New-Object Drawing.Point(206, 554))
  $MainCloseButton.Location       = DPISize (New-Object Drawing.Point(303, 554))
  $MainNoSaveButton.Location      = DPISize (New-Object Drawing.Point(375, 554))

  # Because a size change is forced below, store the old texture list sizes.
  if ($StoreTexListSizes)
  {
    # These values are restored at the bottom of this function after all the controls are placed.
    $OldTexListWidth              = $TexListWidth
    $OldTexListHeight             = $TexListHeight
  }
  # Set the position and bounds of the texture list catalog.
  $TexListDialog.Size             = DPISize (New-Object Drawing.Size(1172, 600))
  $TexListPanelPosX               = DPISize 10
  $TexListPanelPosY               = DPISize 42
  $TexListPanelWidth              = $TexListDialog.Width - (DPISize 36)
  $TexListPanelHeight             = $TexListDialog.Height - (DPISize 121)
  $TexListPanel.Bounds            = New-Object Drawing.Rectangle($TexListPanelPosX, $TexListPanelPosY, $TexListPanelWidth, $TexListPanelHeight)
  $TexListCatalog.Bounds          = New-Object Drawing.Rectangle(1, 1, ($TexListPanel.Width - 2), ($TexListPanel.Height - 2))
  $TexListCatalog.BringToFront()

  # Set the size and location of various GUI elements from the texture list window using info from the DPI file.
  $TexListOpPanelBG.Size          = DPISize (New-Object Drawing.Size(1136, 32))
  $TexListOpPanelBG.Location      = DPISize (New-Object Drawing.Point(10, 5))
  $TexListOpPanel.Size            = New-Object Drawing.Size(($TexListOpPanelBG.Size.Width - 2), ($TexListOpPanelBG.Size.Height - 2))
  $TexListStartButton.Location    = DPISize (New-Object Drawing.Point(9, 527))
  $TexListCancelButton.Location   = DPISize (New-Object Drawing.Point(110, 527))
  $TexListAScrollCheck.Location   = DPISize (New-Object Drawing.Point(208, 534))
  $TexListStoreSizeCheck.Location = DPISize (New-Object Drawing.Point(440, 534))

  # Loop through the array of operation groups.
  foreach ($GroupName in $StaticGroupArray)
  {
    # Move them to the desired location.
    $Group = Get-Variable -Name $GroupName -ValueOnly
    $Group.Size =  DPISize (New-Object Drawing.Size(380, 124))
    $Group.Location = DPISize (New-Object Drawing.Point(10, 214))
    $MainDialogPanel.Controls.Add($Group)
  }
  # Move several GUI elements to the main dialog panel.
  $MainDialogPanel.Controls.Add($MainCTTPSGroup)
  $MainDialogPanel.Controls.Add($MainInputGroup)
  $MainDialogPanel.Controls.Add($MainOutputGroup)
  $MainDialogPanel.Controls.Add($MainOperationsGroup)
  $MainDialogPanel.Controls.Add($MainFormatTexGroup)
  $MainDialogPanel.Controls.Add($MainMipmapGroup)
  $MainDialogPanel.Controls.Add($MainProcessButton)
  $MainDialogPanel.Controls.Add($MainOptionsButton)
  $MainDialogPanel.Controls.Add($MainHelpButton)
  $MainDialogPanel.Controls.Add($MainCloseButton)
  $MainDialogPanel.Controls.Add($MainNoSaveButton)

  # Move texture list GUI elements back to its parent window.
  $TexListDialog.Controls.Add($TexListOpPanelBG)
  $TexListDialog.Controls.Add($TexListHideButton)
  $TexListDialog.Controls.Add($TexListStartButton)
  $TexListDialog.Controls.Add($TexListCancelButton)
  $TexListDialog.Controls.Add($TexListAScrollCheck)
  $TexListDialog.Controls.Add($TexListStoreSizeCheck)
  $TexListDialog.Controls.Add($TexListPanel)
  $TexListPanel.Controls.Add($TexListCatalog)

  # Try to set the size of the texture list to user specifications.
  TexList_TryLoadUserSettings -ForceWidth $OldTexListWidth -ForceHeight $OldTexListHeight
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - HIDE DOCKED CONTROLS
#==============================================================================================================================================================================================
#  Hides the options while in "Docked Mode" and only shows the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_DockedOptionsToggle()
{
  # Toggle the "Docked Mode" panels.
  $MainDockedPanelA.Visible = $DockedHidden
  $MainDockedPanelB.Visible = $DockedHidden
  $MainDockedPanelC.Visible = $DockedHidden

  # Hide docked controls. If the options are not hidden, hide them.
  if (!$DockedHidden)
  {
    # Store that the options are hidden.
    $global:DockedHidden = $true

    # Set the new size and position of the Texture List catalog.
    $TexListPanelPosX   = DPISize 10
    $TexListPanelPosY   = DPISize 44
    $TexListPanelWidth  = $MainDialog.Width - (DPISize 36)
    $TexListPanelHeight = $MainDialog.Height - (DPISize 124)

    # Move the status panel.
    $TexListOpPanelBG.Location = DPISize (New-Object Drawing.Point(10, 5))

    # Change the image on the button to down arrow.
    $TexListHideButton.BackgroundImage = $Image_ArrowTexListDown
    $TexListHideButton.Location        = New-Object Drawing.Size(($MainDialog.Width - (DPISize 59 -Round)), ($TexListOpPanelBG.Top - 1))
    $TexListHideTip.SetToolTip($TexListHideButton, $TexListHideTipStringB)
  }
  # Show docked controls. If the options are hidden, unhide them.
  else
  {
    # Store that the options are no longer hidden.
    $global:DockedHidden = $false

    # Set the new size and position of the Texture List catalog.
    $TexListPanelPosX   = DPISize 10
    $TexListPanelPosY   = DPISize 249
    $TexListPanelWidth  = $MainDialog.Width - (DPISize 36)
    $TexListPanelHeight = $MainDialog.Height - (DPISize 329)

    # Move the status panel.
    $TexListOpPanelBG.Location = DPISize (New-Object Drawing.Point(10, 210))

    # Change the image on the button to up arrow.
    $TexListHideButton.BackgroundImage = $Image_ArrowTexListUp
    $TexListHideButton.Location        = New-Object Drawing.Size(($MainDialog.Width - (DPISize 59 -Round)), ($TexListOpPanelBG.Top - 1))
    $TexListHideTip.SetToolTip($TexListHideButton, $TexListHideTipStringA)
  }
  # Apply the new size and position to the Texture List catalog.
  $TexListPanel.Bounds = New-Object Drawing.Rectangle($TexListPanelPosX, $TexListPanelPosY, $TexListPanelWidth, $TexListPanelHeight)
  $TexListCatalog.Bounds = New-Object Drawing.Rectangle(1, 1, ($TexListPanel.Width - 2), ($TexListPanel.Height - 2))

  # Set the new position of the wait label.
  TexList_CenterWaitLabel
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST - SET/UPDATE PROPERTIES
#==============================================================================================================================================================================================
#  Set the initial state of the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_SetInitialState([int]$Rows)
{
  # Clear any columns that may exist.
  $TexListCatalog.Columns.Clear()

  # Set the intial columns and rows.
  $TexListCatalog.ColumnCount = 9
  $TexListCatalog.RowCount = $Rows

  # Set up the column headers and widths.
  $TexListCatalog.Columns[0].Width = 230
  $TexListCatalog.Columns[1].Width = 100
  $TexListCatalog.Columns[2].Width = 100
  $TexListCatalog.Columns[3].Width = 80
  $TexListCatalog.Columns[4].Width = 85
  $TexListCatalog.Columns[5].Width = 85
  $TexListCatalog.Columns[6].Width = 180
  $TexListCatalog.Columns[7].Width = 70
  $TexListCatalog.Columns[8].Width = 210
  
  # Set a minimum value so they don't get squished into non-existence.
  $TexListCatalog.Columns[0].MinimumWidth = 75
  $TexListCatalog.Columns[1].MinimumWidth = 30
  $TexListCatalog.Columns[2].MinimumWidth = 30
  $TexListCatalog.Columns[3].MinimumWidth = 25
  $TexListCatalog.Columns[4].MinimumWidth = 30
  $TexListCatalog.Columns[5].MinimumWidth = 30
  $TexListCatalog.Columns[6].MinimumWidth = 60
  $TexListCatalog.Columns[7].MinimumWidth = 20
  $TexListCatalog.Columns[8].MinimumWidth = 70

  # Clearing the gridview also clears the headers so add them back after a clear.
  TexList_SetColumnHeaders -Selection $CTTPSSelectedMode
}
#==============================================================================================================================================================================================
#  Set the user state of the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_TryLoadUserSettings([int]$ForceWidth=0, [int]$ForceHeight=0)
{
  # If the user did not want to load texture settings then exit.
  if (!$StoreTexListSizes) { return }

  # See if the width/height are forced.
  if (($ForceWidth -gt 0) -and ($ForceHeight -gt 0))
  {
    # Overwrite these variables locally.
    $TexListWidth  = $ForceWidth
    $TexListHeight = $ForceHeight
  }
  # Docked mode uses the original GUI
  if ($DockedMode)
  {
    # Set the size of the main dialog to the texture list size since it contains the texture list.
    $MainDialog.Size = DPISize (New-Object Drawing.Size($TexListWidth, $TexListHeight)) 
  }
  # To avoid bugs, always set the size of the texture list even when it isn't visible.
  $TexListDialog.Size = DPISize (New-Object Drawing.Size($TexListWidth, $TexListHeight))

  # Adjust the size of the columns.
  $TexListCatalog.Columns[0].Width = $TexListColumnSizeA
  $TexListCatalog.Columns[1].Width = $TexListColumnSizeB
  $TexListCatalog.Columns[2].Width = $TexListColumnSizeC
  $TexListCatalog.Columns[3].Width = $TexListColumnSizeD
  $TexListCatalog.Columns[4].Width = $TexListColumnSizeE
  $TexListCatalog.Columns[5].Width = $TexListColumnSizeF
  $TexListCatalog.Columns[6].Width = $TexListColumnSizeG
  $TexListCatalog.Columns[7].Width = $TexListColumnSizeH
  $TexListCatalog.Columns[8].Width = $TexListColumnSizeI
}
#==============================================================================================================================================================================================
#  Sets the column sizes to globals so the script saves them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_StoreProperties()
{
  # Don't save the column sizes if it's not checked.
  if (!$StoreTexListSizes)
  {
    # Restore the default texture list dimensions.
    $global:TexListWidth  = (DPISize 1172)
    $global:TexListHeight = (DPISize 600)

    # Restore the default column sizes.
    $global:TexListColumnSizeA = 230
    $global:TexListColumnSizeB = 100
    $global:TexListColumnSizeC = 100
    $global:TexListColumnSizeD = 80
    $global:TexListColumnSizeE = 85
    $global:TexListColumnSizeF = 85
    $global:TexListColumnSizeG = 180
    $global:TexListColumnSizeH = 70
    $global:TexListColumnSizeI = 210
  }
  # Store the current size of everything.
  else
  {
    # If we're in "Docked Mode", the texture list is attached to it.
    if ($DockedMode)
    {
      $global:TexListWidth  = $MainDialog.Size.Width
      $global:TexListHeight = $MainDialog.Size.Height
    }
    # When Texture List is visible, use its dimensions directly.
    else
    {
      $global:TexListWidth  = $TexListDialog.Size.Width
      $global:TexListHeight = $TexListDialog.Size.Height
    }
    # If we get here then save all the sizes to a global before checking out they are saved.
    $global:TexListColumnSizeA = $TexListCatalog.Columns[0].Width
    $global:TexListColumnSizeB = $TexListCatalog.Columns[1].Width
    $global:TexListColumnSizeC = $TexListCatalog.Columns[2].Width
    $global:TexListColumnSizeD = $TexListCatalog.Columns[3].Width
    $global:TexListColumnSizeE = $TexListCatalog.Columns[4].Width
    $global:TexListColumnSizeF = $TexListCatalog.Columns[5].Width
    $global:TexListColumnSizeG = $TexListCatalog.Columns[6].Width
    $global:TexListColumnSizeH = $TexListCatalog.Columns[7].Width
    $global:TexListColumnSizeI = $TexListCatalog.Columns[8].Width
  }
}
#==============================================================================================================================================================================================
#  As the window is resized, store the texture list dimensions into the variables.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateDimensionVars()
{
  # Store the current size of the texture list.
  $global:TexListWidth  = $TexListDialog.Size.Width
  $global:TexListHeight = $TexListDialog.Size.Height
}
#==============================================================================================================================================================================================
#  As columns are resized, store the texture list column values into the variables.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_UpdateColumnSizeVars()
{
  # Creation of the texture list triggers this function, so don't let it run until the dialogs are visible.
  if ($BlockColumnResize) { return }

  # Store the current size of the columns.
  $global:TexListColumnSizeA = $TexListCatalog.Columns[0].Width
  $global:TexListColumnSizeB = $TexListCatalog.Columns[1].Width
  $global:TexListColumnSizeC = $TexListCatalog.Columns[2].Width
  $global:TexListColumnSizeD = $TexListCatalog.Columns[3].Width
  $global:TexListColumnSizeE = $TexListCatalog.Columns[4].Width
  $global:TexListColumnSizeF = $TexListCatalog.Columns[5].Width
  $global:TexListColumnSizeG = $TexListCatalog.Columns[6].Width
  $global:TexListColumnSizeH = $TexListCatalog.Columns[7].Width
  $global:TexListColumnSizeI = $TexListCatalog.Columns[8].Width
}
#==============================================================================================================================================================================================
#  As the window is resized, this relocates the "waiting for program to close" pause label.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_CenterWaitLabel()
{
  # Calculate the position of the label.
  $WaitLabelX = ($TexListCatalog.Width / 2) - ($TexListWaitLabel.Width / 2)
  $WaitLabelY = ($TexListCatalog.Height / 2) - ($TexListWaitLabel.Height)

  # Set the new position of the label.
  $TexListWaitLabel.Location = New-Object Drawing.Point($WaitLabelX, $WaitLabelY)

  # Bring the label to the front of the dialog.
  $TexListWaitLabel.BringToFront()
}
#==============================================================================================================================================================================================
#  Sets the columns of the texture list to match "Dolphin Mode" type fields.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TexList_SetColumnHeaders([string]$Selection)
{
  # These columns are the same no matter which mode we're in.
  $TexListCatalog.Columns[0].HeaderText = "Texture"
  $TexListCatalog.Columns[6].HeaderText = "Path"
  $TexListCatalog.Columns[7].HeaderText = "Status"
  $TexListCatalog.Columns[8].HeaderText = "Message"

  # Find the mode that was selected.
  switch ($Selection)
  {
    # Dolphin can get original dimensions and aspect, as well as the upscale value.
    'Dolphin Mode'
    {
      if ($StoredOperation -eq 'Extract Textures With TextureExtraction Tool')
      {
        $TexListCatalog.Columns[1].HeaderText = 'Dimensions'
        $TexListCatalog.Columns[2].HeaderText = 'Mipmaps'
        $TexListCatalog.Columns[3].HeaderText = 'Scale'
        $TexListCatalog.Columns[4].HeaderText = 'Aspect'
        $TexListCatalog.Columns[5].HeaderText = 'None'
      }
      else
      {
        $TexListCatalog.Columns[1].HeaderText = 'Original'
        $TexListCatalog.Columns[2].HeaderText = 'Dimensions'
        $TexListCatalog.Columns[3].HeaderText = 'Scale'
        $TexListCatalog.Columns[4].HeaderText = 'Dump Aspect'
        $TexListCatalog.Columns[5].HeaderText = 'Aspect'
      }
    }
    # We can't get those properties for normal textures, so show different stuff.
    'Expert Mode'
    {
      $TexListCatalog.Columns[1].HeaderText = 'Dimensions'
      $TexListCatalog.Columns[2].HeaderText = 'Format'
      $TexListCatalog.Columns[3].HeaderText = 'Mipmaps'
      $TexListCatalog.Columns[4].HeaderText = 'Aspect'
      $TexListCatalog.Columns[5].HeaderText = 'Alpha'
    }
    # Dolphin can get original dimensions and aspect, as well as the upscale value.
    'Database Mode' 
    {
      $TexListCatalog.Columns[1].HeaderText = 'Original'
      $TexListCatalog.Columns[2].HeaderText = 'Dimensions'
      $TexListCatalog.Columns[3].HeaderText = 'Scale'
      $TexListCatalog.Columns[4].HeaderText = 'Dump Aspect'
      $TexListCatalog.Columns[5].HeaderText = 'Aspect'
    }
    # Trails of Cold Steel textures has its own type of data similar to expert.
    'Phyre Mode'
    {
      $TexListCatalog.Columns[1].HeaderText = 'Dimensions'
      $TexListCatalog.Columns[2].HeaderText = 'Type'
      $TexListCatalog.Columns[3].HeaderText = 'Format'
      $TexListCatalog.Columns[4].HeaderText = 'Mipmaps'
      $TexListCatalog.Columns[5].HeaderText = 'Extension'
    }
    # Dolphin can get original dimensions and aspect, as well as the upscale value.
    'Metroid Prime' 
    {
      $TexListCatalog.Columns[1].HeaderText = 'Original'
      $TexListCatalog.Columns[2].HeaderText = 'Dimensions'
      $TexListCatalog.Columns[3].HeaderText = 'Scale'
      $TexListCatalog.Columns[4].HeaderText = 'Dump Aspect'
      $TexListCatalog.Columns[5].HeaderText = 'Aspect'
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: TEXTURE LIST DIALOG
#==============================================================================================================================================================================================
#  Create the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_TextureList()
{
  # Create the texture list and set up properties.
  $global:TexListDialog = New-Object Windows.Forms.Form
  $TexListDialog.Size = DPISize (New-Object Drawing.Size(1172, 600))
  $TexListDialog.MinimumSize = DPISize (New-Object Drawing.Size(850, 420))
  $TexListDialog.Text = 'CTT-PS Texture List'
  $TexListDialog.MaximizeBox = $true
  $TexListDialog.MinimizeBox = $true
  $TexListDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $TexListDialog.FormBorderStyle = [Windows.Forms.FormBorderStyle]::Sizable
  $TexListDialog.StartPosition = "CenterScreen"
  $TexListDialog.Add_SizeChanged({ MinimizeAllDialogs ; TexList_CenterWaitLabel ; TexList_UpdateDimensionVars })
  $TexListDialog.Add_FormClosing({ TexList_MainDialog_XButton })
  $TexListDialog.Icon = $Icon_CTTPSPurple

  # Calculate the size of the texture list panel. The datagridview will automatically scale to the panel.
  $TexListPanelPosX   = DPISize 10
  $TexListPanelPosY   = DPISize 42
  $TexListPanelWidth  = $TexListDialog.Width - (DPISize 36)
  $TexListPanelHeight = $TexListDialog.Height - (DPISize 121)

  # Create a panel that will house the texture list.
  $global:TexListPanel = New-Object Windows.Forms.Panel
  $TexListPanel.Bounds = New-Object Drawing.Rectangle($TexListPanelPosX, $TexListPanelPosY, $TexListPanelWidth, $TexListPanelHeight)
  $TexListPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#828790')
  $TexListPanel.Anchor = ( [Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Top, [Windows.Forms.AnchorStyles]::Bottom )
  $TexListDialog.Controls.Add($TexListPanel)

  # Disables the event to store the size of columns when resized.
  $global:BlockColumnResize = $true

  # Create the gridview that will serve as the texture list.
  $global:TexListCatalog = New-Object Windows.Forms.DataGridView
  $TexListCatalog.Bounds = New-Object Drawing.Rectangle(1, 1, ($TexListPanel.Width - 2), ($TexListPanel.Height - 2))
  $TexListCatalog.RowTemplate.Height = DPISize 18
  $TexListCatalog.ColumnHeadersHeight = DPISize 20
  $TexListCatalog.AllowUserToAddRows = $false
  $TexListCatalog.AllowUserToResizeRows = $false
  $TexListCatalog.AllowUserToResizeColumns = $true
  $TexListCatalog.RowHeadersVisible = $false
  $TexListCatalog.ColumnHeadersVisible = $true
  $TexListCatalog.ColumnHeadersBorderStyle = [Windows.Forms.DataGridViewHeaderBorderStyle]::Single
  $TexListCatalog.ColumnHeadersHeightSizeMode = [Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::DisableResizing
  $TexListCatalog.AutoSizeColumnsMode = [Windows.Forms.DataGridViewAutoSizeColumnsMode]::Fill
  $TexListCatalog.AutoSizeRowsMode = [Windows.Forms.DataGridViewAutoSizeRowsMode]::None
  $TexListCatalog.SelectionMode = [Windows.Forms.DataGridViewSelectionMode]::FullRowSelect
  $TexListCatalog.Anchor = ( [Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Top, [Windows.Forms.AnchorStyles]::Bottom )
  $TexListCatalog.GridColor = [Drawing.ColorTranslator]::FromHtml('#F0F0F0')
  $TexListCatalog.BorderStyle = [Windows.Forms.BorderStyle]::None
  $TexListCatalog.ReadOnly = $true
  $TexListCatalog.Add_ColumnWidthChanged({ TexList_UpdateColumnSizeVars })
  $TexListPanel.Controls.Add($TexListCatalog)

  # Enable double buffering to prevent flickering and some slowdown.
  SetDoubleBuffering -Control $TexListCatalog -Enabled

  # Set the initial state of the texture list.
  TexList_SetInitialState -Rows 150

  # When the script is paused and a program is running display this label. Used in "StartJobLoop".
  $global:TexListWaitLabel = New-Object Windows.Forms.Label
  $TexListWaitLabel.Size = DPISize (New-Object Drawing.Size(450, 28))
  $TexListWaitLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 16, [Drawing.FontStyle]::Bold)
  $TexListWaitLabel.Text = ' Waiting for the current program to close...'
  $TexListWaitLabel.BackColor = '#DDDDDD'
  $TexListWaitLabel.Visible = $false
  $TexListCatalog.Controls.Add($TexListWaitLabel)

  # Create a border for the panel below.
  $global:TexListOpPanelBG = New-Object Windows.Forms.Panel
  $TexListOpPanelBG.Size = DPISize (New-Object Drawing.Size(1136, 32))
  $TexListOpPanelBG.Location = DPISize (New-Object Drawing.Point(10, 5))
  $TexListOpPanelBG.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Top)
  $TexListOpPanelBG.BackColor = [Drawing.ColorTranslator]::FromHtml('#DCDCDC')
  $TexListDialog.Controls.Add($TexListOpPanelBG)

  # Create a panel to hold the status information.
  $global:TexListOpPanel = New-Object Windows.Forms.Panel
  $TexListOpPanel.Size = New-Object Drawing.Size(($TexListOpPanelBG.Size.Width - 2), ($TexListOpPanelBG.Size.Height - 2))
  $TexListOpPanel.Location = New-Object Drawing.Point(1,1)
  $TexListOpPanel.BackColor = $TexListDialog.BackColor
  $TexListOpPanel.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Top)
  $TexListOpPanelBG.Controls.Add($TexListOpPanel)

  # Create header label for the operation.
  $global:TexListOpLabel = New-Object Windows.Forms.Label
  $TexListOpLabel.Size = DPISize (New-Object Drawing.Size(76, 18))
  $TexListOpLabel.Location = DPISize (New-Object Drawing.Point(8, 8))
  $TexListOpLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5, [Drawing.FontStyle]::Bold)
  $TexListOpLabel.Text = 'Operation:'
  $TexListOpPanel.Controls.Add($TexListOpLabel)

  # Create value label for the operation.
  $global:TexListOpValue = New-Object Windows.Forms.Label
  $TexListOpValue.Size = DPISize (New-Object Drawing.Size(154, 18))
  $TexListOpValue.Location = DPISize (New-Object Drawing.Point(82, 8))
  $TexListOpValue.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5) 
  $TexListOpValue.Text = 'Idle'
  $TexListOpPanel.Controls.Add($TexListOpValue)

  # Create header label for the current texture.
  $global:TexListTexLabel = New-Object Windows.Forms.Label
  $TexListTexLabel.Size = DPISize (New-Object Drawing.Size(62, 18))
  $TexListTexLabel.Location = DPISize (New-Object Drawing.Point(264, 8))
  $TexListTexLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5, [Drawing.FontStyle]::Bold)
  $TexListTexLabel.Text = 'Texture:'
  $TexListTexLabel.Visible = $false
  $TexListOpPanel.Controls.Add($TexListTexLabel)

  # Create value label for the current texture.
  $global:TexListTexValue = New-Object Windows.Forms.Label
  $TexListTexValue.Size = DPISize (New-Object Drawing.Size(96, 18))
  $TexListTexValue.Location = DPISize (New-Object Drawing.Point(325, 8))
  $TexListTexValue.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5) 
  $TexListTexValue.Text = '0/0'
  $TexListTexValue.Visible = $false
  $TexListOpPanel.Controls.Add($TexListTexValue)

  # Create header label for the progress.
  $global:TexListProgLabel = New-Object Windows.Forms.Label
  $TexListProgLabel.Size = DPISize (New-Object Drawing.Size(66, 18))
  $TexListProgLabel.Location = DPISize (New-Object Drawing.Point(455, 8))
  $TexListProgLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5, [Drawing.FontStyle]::Bold)
  $TexListProgLabel.Text = 'Progress:'
  $TexListProgLabel.Visible = $false
  $TexListOpPanel.Controls.Add($TexListProgLabel)

  # Create a progress bar.
  $global:TexListProgBar = New-Object Windows.Forms.ProgressBar
  $TexListProgBar.Size = DPISize (New-Object Drawing.Size(110, 18))
  $TexListProgBar.Location = DPISize (New-Object Drawing.Point(527, 8))
  $TexListProgBar.Name = 'TexListProgBar'
  $TexListProgBar.Minimum = 0
  $TexListProgBar.Maximum = 100
  $TexListProgBar.Value = 0
  $TexListProgBar.Style = [Windows.Forms.ProgressBarStyle]::Continuous
  $TexListProgBar.Visible = $false
  $TexListOpPanel.Controls.Add($TexListProgBar)

  # Create value label for the current texture.
  $global:TexListProgValue = New-Object Windows.Forms.Label
  $TexListProgValue.Size = DPISize (New-Object Drawing.Size(46, 18))
  $TexListProgValue.Location = DPISize (New-Object Drawing.Point(643, 8))
  $TexListProgValue.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5) 
  $TexListProgValue.Text = '0%'
  $TexListProgValue.Visible = $false
  $TexListOpPanel.Controls.Add($TexListProgValue)

  # Labels for the timer "TexListTimer".
  $global:TexListTimerLabel = New-Object Windows.Forms.Label
  $TexListTimerLabel.Size = DPISize (New-Object Drawing.Size(63, 18))
  $TexListTimerLabel.Location = DPISize (New-Object Drawing.Point(727, 8))
  $TexListTimerLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5, [Drawing.FontStyle]::Bold)
  $TexListTimerLabel.Text = 'Elapsed:'
  $TexListTimerLabel.Visible = $false
  $TexListOpPanel.Controls.Add($TexListTimerLabel)

  # Create value label for the operation.
  $global:TexListTimerValue = New-Object Windows.Forms.Label
  $TexListTimerValue.Size = DPISize (New-Object Drawing.Size(86, 18))
  $TexListTimerValue.Location = DPISize (New-Object Drawing.Point(792, 8))
  $TexListTimerValue.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5) 
  $TexListTimerValue.Text = '0'
  $TexListTimerValue.Visible = $false
  $TexListOpPanel.Controls.Add($TexListTimerValue)

  # Add a button to the dialog to show/hide the options on the texture list.
  $global:TexListHideButton = New-Object Windows.Forms.Button
  $TexListHideButton.Size = DPISize (New-Object Drawing.Size(34, 34))
  $TexListHideButton.Location = New-Object Drawing.Point(0, 0)
  $TexListHideButton.Name = 'HideButton'
  $TexListHideButton.Text = ''
  $TexListHideButton.BackgroundImage = $Image_ArrowTexListUp
  $TexListHideButton.BackgroundImageLayout = [Windows.Forms.ImageLayout]::Center  
  $TexListHideButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Top)
  $TexListHideButton.TabStop = $false
  $TexListHideButton.Visible = $false
  $TexListHideButton.Add_Click({ TexList_DockedOptionsToggle })
  $TexListDialog.Controls.Add($TexListHideButton)

  # Add a tooltip for the button.
  $global:TexListHideTip = New-Object Windows.Forms.ToolTip
  $TexListHideTip.InitialDelay = $ToolTipDelay
  $TexListHideTip.AutoPopDelay = $ToolTipDuration
  $TexListHideTipStringA = 'Hides the options and maximizes the Texture List.'
  $TexListHideTipStringB = 'Shows the options and minimizes the Texture List.'
  $TexListHideTip.SetToolTip($TexListHideButton, $TexListHideTipStringA)

  # Add a start/pause button to the dialog.
  $global:TexListStartButton = New-Object Windows.Forms.Button
  $TexListStartButton.Size = DPISize (New-Object Drawing.Size(73, 28))
  $TexListStartButton.Location = DPISize (New-Object Drawing.Point(9, 527))
  $TexListStartButton.Text = 'Start'
  $TexListStartButton.Enabled = (TestPath -LiteralPath $ImageMagick)
  $TexListStartButton.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListStartButton.Add_Click({ TexList_PauseLoopStart })
  $TexListDialog.Controls.Add($TexListStartButton)

  # Add a tooltip.
  $TexListStartTip = New-Object Windows.Forms.ToolTip
  $TexListStartTip.InitialDelay = $ToolTipDelay
  $TexListStartTip.AutoPopDelay = $ToolTipDuration
  $TexListStartTipString = 'Begins processing all textures found in the{0}'
  $TexListStartTipString += '"Input Path" with the selected operation.'
  $TexListStartTipString = [String]::Format($TexListStartTipString, [Environment]::NewLine)
  $TexListStartTip.SetToolTip($TexListStartButton, $TexListStartTipString)

  # Add a process selected button to the dialog.
  $global:TexListProcessButton = New-Object Windows.Forms.Button
  $TexListProcessButton.Size = DPISize (New-Object Drawing.Size(16, 28))
  $TexListProcessButton.Location = DPISize (New-Object Drawing.Point(81, 527))
  $TexListProcessButton.Text = '$'
  $TexListProcessButton.Enabled = (TestPath -LiteralPath $ImageMagick)
  $TexListProcessButton.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListProcessButton.Add_Click({ if (ProcessSelected_Dialog) { InitiateMasterLoop } })
  $TexListDialog.Controls.Add($TexListProcessButton)

  # Add a tooltip.
  $TexListProcessTip = New-Object Windows.Forms.ToolTip
  $TexListProcessTip.InitialDelay = 250
  $TexListProcessTip.AutoPopDelay = $ToolTipDuration
  $TexListProcessTipString = 'Opens the "Process Selected" dialog that allows{0}'
  $TexListProcessTipString += 'selecting specific textures to process. Textures can{0}'
  $TexListProcessTipString += 'be manually selected or added with a drag and drop.'
  $TexListProcessTipString = [String]::Format($TexListProcessTipString, [Environment]::NewLine)
  $TexListProcessTip.SetToolTip($TexListProcessButton, $TexListProcessTipString)

  # Add a cancel button to the dialog.
  $global:TexListCancelButton = New-Object Windows.Forms.Button
  $TexListCancelButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $TexListCancelButton.Location = DPISize (New-Object Drawing.Point(110, 527))
  $TexListCancelButton.Name = 'CancelButton'
  $TexListCancelButton.Text = 'Cancel'
  $TexListCancelButton.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListCancelButton.Add_Click({ TexList_CancelMasterLoop })
  $TexListCancelButton.Enabled = $false
  $TexListDialog.Controls.Add($TexListCancelButton)

  # Allow auto scrolling as the list is populating.
  $global:TexListAScrollCheck = New-Object Windows.Forms.CheckBox
  $TexListAScrollCheck.Size = DPISize (New-Object Drawing.Size(226, 16))
  $TexListAScrollCheck.Location = DPISize (New-Object Drawing.Point(208, 534))
  $TexListAScrollCheck.Name = 'TexListAutoScroll'
  $TexListAScrollCheck.Checked = $TexListAutoScroll
  $TexListAScrollCheck.Text = ' Auto-Scroll While Populating (Slower)'
  $TexListAScrollCheck.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListAScrollCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexListDialog.Controls.Add($TexListAScrollCheck)

  # Add a tooltip.
  $TexListAScrollTip = New-Object Windows.Forms.ToolTip
  $TexListAScrollTip.InitialDelay = 250
  $TexListAScrollTip.AutoPopDelay = $ToolTipDuration
  $TexListAScrollTipString = 'When running any operation, the texture list will begin{0}'
  $TexListAScrollTipString += 'to populate with textures. This option auto-scrolls the{0}'
  $TexListAScrollTipString += 'Texture List to the most recently added texture.{0}'
  $TexListAScrollTipString += '{0}'
  $TexListAScrollTipString += 'Notice: While the performance of this option was vastly{0}'
  $TexListAScrollTipString += 'improved in CTT-PS v51.0, there is still a performance{0}'
  $TexListAScrollTipString += 'penalty when enabled. Disable for time-sensitive usages.'
  $TexListAScrollTipString = [String]::Format($TexListAScrollTipString, [Environment]::NewLine)
  $TexListAScrollTip.SetToolTip($TexListAScrollCheck, $TexListAScrollTipString)

  # Allow storing the size of the texture list and its columns.
  $global:TexListStoreSizeCheck = New-Object Windows.Forms.CheckBox
  $TexListStoreSizeCheck.Size = DPISize (New-Object Drawing.Size(190, 16))
  $TexListStoreSizeCheck.Location = DPISize (New-Object Drawing.Point(440, 534))
  $TexListStoreSizeCheck.Name = 'StoreTexListSizes'
  $TexListStoreSizeCheck.Checked = $StoreTexListSizes
  $TexListStoreSizeCheck.Text = ' Store Texture List Adjustments'
  $TexListStoreSizeCheck.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListStoreSizeCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexListDialog.Controls.Add($TexListStoreSizeCheck)

  # Add a tooltip.
  $TexListStoreSizeTip = New-Object Windows.Forms.ToolTip
  $TexListStoreSizeTip.InitialDelay = 250
  $TexListStoreSizeTip.AutoPopDelay = $ToolTipDuration
  $TexListStoreSizeTipString = 'Stores the texture list dimensions and column sizes{0}'
  $TexListStoreSizeTipString += 'to the external INI file. When the script is loaded{0}'
  $TexListStoreSizeTipString += 'the stored values will be automatically loaded.'
  $TexListStoreSizeTipString = [String]::Format($TexListStoreSizeTipString, [Environment]::NewLine)
  $TexListStoreSizeTip.SetToolTip($TexListStoreSizeCheck, $TexListStoreSizeTipString)

  # Add a Help button button to the dialog.
  $global:TexListHelpButton = New-Object Windows.Forms.Button
  $TexListHelpButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $TexListHelpButton.Location = DPISize (New-Object Drawing.Point(962, 527))
  $TexListHelpButton.Name = 'Help'
  $TexListHelpButton.Text = 'Help'
  $TexListHelpButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListHelpButton.Add_Click({ if (!$HelpDialog.Visible) { $HelpDialog.Show() } else { $HelpDialog.Hide() } })
  $TexListDialog.Controls.Add($TexListHelpButton)

  # Add a tooltip.
  $TexListHelpTip = New-Object Windows.Forms.ToolTip
  $TexListHelpTip.InitialDelay = 250
  $TexListHelpTip.AutoPopDelay = $ToolTipDuration
  $TexListHelpTipString = 'Opens the Help dialog which{0}'
  $TexListHelpTipString += 'covers how to use this script.'
  $TexListHelpTipString = [String]::Format($TexListHelpTipString, [Environment]::NewLine)
  $TexListHelpTip.SetToolTip($TexListHelpButton, $TexListHelpTipString)

  # Add an Exit button button to the dialog.
  $global:TexListCloseButton = New-Object Windows.Forms.Button
  $TexListCloseButton.Size = DPISize (New-Object Drawing.Size(73, 28))
  $TexListCloseButton.Location = DPISize (New-Object Drawing.Point(1059, 527))
  $TexListCloseButton.Text = 'Exit'
  $TexListCloseButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListCloseButton.Add_Click({ $TexListDialog.Close() ; $MainDialog.Close() })
  $TexListDialog.Controls.Add($TexListCloseButton)

  # Add a tooltip.
  $TexListExitTip = New-Object Windows.Forms.ToolTip
  $TexListExitTip.InitialDelay = 250
  $TexListExitTip.AutoPopDelay = $ToolTipDuration
  $TexListExitTipString  = 'Closes the GUI and exits{0}'
  $TexListExitTipString += 'Custom Texture Tool PS.'
  $TexListExitTipString = [String]::Format($TexListExitTipString, [Environment]::NewLine)
  $TexListExitTip.SetToolTip($TexListCloseButton, $TexListExitTipString)

  # Buttons: No-Save Close - Exits the script.
  $global:TexListNoSaveButton = New-Object Windows.Forms.Button
  $TexListNoSaveButton.Size = DPISize (New-Object Drawing.Size(16, 28))
  $TexListNoSaveButton.Location = DPISize (New-Object Drawing.Point(1131, 527))
  $TexListNoSaveButton.Text = '!'
  $TexListNoSaveButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $TexListNoSaveButton.Add_Click({ $global:NoSave = $true ; $TexListDialog.Close ; $MainDialog.Close() })
  $TexListDialog.Controls.Add($TexListNoSaveButton)

  # Buttons: No-Save Close - Create a tip for the button.
  $TexListNoSaveTip = New-Object Windows.Forms.ToolTip
  $TexListNoSaveTip.InitialDelay = 250
  $TexListNoSaveTip.AutoPopDelay = $ToolTipDuration
  $TexListNoSaveTipString  = 'Closes the GUI and exits{0}'
  $TexListNoSaveTipString += 'Custom Texture Tool PS{0}'
  $TexListNoSaveTipString += 'without saving anything.'
  $TexListNoSaveTipString = [String]::Format($TexListNoSaveTipString, [Environment]::NewLine)
  $TexListNoSaveTip.SetToolTip($TexListNoSaveButton, $TexListNoSaveTipString)

  # Set the size of the texture list to the stored values.
  TexList_TryLoadUserSettings

  # Now that it's been fully created, allow storing of the column size changes.
  $global:BlockColumnResize = $false
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $ProcessDialog           - Form         - Global
#  $ProcessImage            - Button       - Global
#  $ProcessPanel            - Panel        - Global
#  $ProcessTexLabel         - TextBox      - Global
#  $ProcessSizeLabel        - TextBox      - Global
#  $ProcessScaleLabel       - TextBox      - Global
#  $ProcessAspectLabel      - TextBox      - Global
#  $ProcessPathLabel        - TextBox      - Global
#  $ProcessTexBigLabel      - Label        - Global
#  $ProcessIndexBox         - TextBox      - Global
#  $ProcessLeft             - Button       - Global
#  $ProcessRight            - Button       - Global
#  $ProcessImageList        - ListBox      - Global
#  $ProcessStart            - Button       - Global
#  $ProcessClose            - Button       - Global
#==============================================================================================================================================================================================
#  This is a somewhat hidden GUI option to allow selecting a handful of textures and processing those instead of using the "Input Path". My original intention was to make it so a single
#  texture could be processed, but a "bug" allowed me to keep adding textures and it processed them all. So I rolled with it. First I found what I did wrong, which was technically right for
#  processing multiple textures, and built around that instead. The functionality is basic, there is no way to remove textures from the stack other than closing the GUI window.
#==============================================================================================================================================================================================
#  Replaces the input image with the output image directly. Must be added to all operations that use "Process Selected".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelectedOutput([string]$NewTexturePath, [string]$NewFormat, [int]$Width, [int]$Height)
{
  # Check to see if "Process Selected" was used, and the user wants to overwrite the original texture.
  if (($ProcessSelected) -and ($ProcessOverwrite) -and (TestPath -LiteralPath $NewTexturePath))
  {
    # Get the texture as an item to extract properties.
    $NewTextureItem = Get-Item -LiteralPath $NewTexturePath
  
    # Set the path to search for mipmaps.
    $MipmapPath = $NewTextureItem.DirectoryName

    # Calculate the number of mipmap levels the texture should have.
    $MipmapLevels = CalculateMipmapLevels -Dimension ([Math]::Max($Width, $Height))

    # Get the number of external mipmaps.
    $MipmapsFound = CountExternalMipmaps -ImageFile $NewTexturePath -Levels $MipmapLevels

    # There are two situation of when not to remove the original texture.
    if (($Texture.Extension -eq $NewFormat) -or (($Texture.Extension -ne $NewFormat) -and (!$ProcessKeepOriginal)))
    {
      # Remove the original texture.
      RemovePath -LiteralPath $Texture.FullPath
    }
    # Set the final path to the texture.
    $DestinationFile = $Texture.PathName + $NewFormat

    # Move the texture to the original location.
    Move-Item -LiteralPath $NewTexturePath -Destination $DestinationFile

    # Check to see if there are actually any internal mipmaps to be found.
    if ($MipmapsFound -gt 0)
    {
      # The texture may have mipmaps so loop through them if available.
      foreach ($Image in EnumerateFiles -LiteralPath $MipmapPath)
      {
        # The name is needed so get it as an item.
        $ImageItem = Get-Item -LiteralPath $Image

        # The mipmap name will be similar to the texture name.
        if ($ImageItem.BaseName -like ($Texture.Name + '_mip*'))
        {
          # Set the path to where it will be moved.
          $DestinationFile = $Texture.Path + '\' + $ImageItem.Name

          # Move the mipmap to the texture path.
          Move-Item -LiteralPath $Image -Destination $DestinationFile -Force
        }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Sets all global variables that the image viewer uses to their default state. Used when thew viewer is first loaded, or when it is cleared.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_InitializeGlobals()
{
  # Keep track of the total number of images, and keep track of the current page.
  $global:ProcessImageCount = 0
  $global:ProcessImagePage  = 0

  # Create lists to store the bitmap images (for previews).
  $global:ProcessPreviewImage  = New-Object Collections.Generic.List[Drawing.Image]

  # Create a list that will be used to circle through the master loop.
  $global:ProcessMasterList    = New-Object Collections.Generic.List[string]
  $global:ProcessMasterPaths   = New-Object Collections.Generic.List[string]

  # Create lists to store image properties.
  $global:ProcessListTexture   = New-Object Collections.Generic.List[string]
  $global:ProcessListDimension = New-Object Collections.Generic.List[string]
  $global:ProcessListScale     = New-Object Collections.Generic.List[string]
  $global:ProcessListAspect    = New-Object Collections.Generic.List[string]
  $global:ProcessListPath      = New-Object Collections.Generic.List[string]

  # To make tracking textures a lot less stupid, fill index 0 on all lists with garbage data so we can start with index 1.
  $global:ProcessPreviewImage.Add($Image_NoPreview) | Out-Null
  $global:ProcessListTexture.Add(' ') | Out-Null
  $global:ProcessListDimension.Add(' ') | Out-Null
  $global:ProcessListScale.Add(' ') | Out-Null
  $global:ProcessListAspect.Add(' ') | Out-Null
  $global:ProcessListPath.Add(' ') | Out-Null

  # Update the window with the current operation.
  $ProcessOpLabel.Text = 'Operation: ' + $StoredOperation
}
#==============================================================================================================================================================================================
#  Actions that take place when the "Start" button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_Cleanup()
{
  # Disable the buttons.
  $ProcessLeft.Enabled = $false
  $ProcessRight.Enabled = $false
  $ProcessStart.Enabled = $false

  # Clear the image and the text.
  $ProcessImageButton.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ProcessImageButton.Text = 'Drag and drop images or click here.'
  $ProcessImageButton.BackgroundImage = $null
  $ProcessImageButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ProcessImageButton.FlatAppearance.BorderSize = 1
  $ProcessImageButton.ForeColor = [Drawing.Color]::Black

  # Clear the text fields.
  $ProcessIndexBox.Text    = '0'
  $ProcessTexLabel.Text    = ''
  $ProcessSizeLabel.Text   = ''
  $ProcessScaleLabel.Text  = ''
  $ProcessAspectLabel.Text = ''
  $ProcessPathLabel.Text   = ''

  # Destroy all the images in the bitmap list.
  DisposeBitmapList -BitmapList $ProcessPreviewImage

  # Clear the lists so RAM isn't being wasted on stupid shit.
  $ProcessImageList.Items.Clear()
  $ProcessPreviewImage.Clear()
  $ProcessListTexture.Clear()
  $ProcessListDimension.Clear()
  $ProcessListScale.Clear()
  $ProcessListAspect.Clear()
  $ProcessListPath.Clear()
}
#==============================================================================================================================================================================================
#  CTT GUI: DOLPHIN MODE VALIDATION
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_DolphinValidate([string]$ImageFile)
{
  # If we're in Dolphin mode, and the texture is not a Dolphin texture, do not allow adding it.
  if (($CTTPSSelectedMode -eq 'Dolphin Mode') -and ($ImageFile -notlike '*tex1_*'))
  {
    # Check to see if this error was already displayed.
    if (!$ProcessShowOnce)
    {
      # Only allow this error to show once.
      $global:ProcessShowOnce = $true

      # Set the title and message.
      $Title   = 'CTT-PS Notice'
      $Message = 'Only Dolphin textures can be added in "Dolphin Mode".'

      # Show a dialog to the user that says it can't add the texture.
      ShowOKDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 20) -OffsetX (DPISize 14) -OffsetY (DPISize 18) -Message $Message
    }
    # Leave this function and do nothing.
    return $false
  }
  # Keep on rolling rolling rolling.
  return $true
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES - ADD TEXTURE TO STACK
#==============================================================================================================================================================================================
#  Shared function between "button click" and "drag and drop" functions. Adds an image to the stack and generates a preview on the button. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_AddTexture([string]$ImageFile, [string]$RootFolder='')
{
  # If in "Dolphin Mode" make sure it's a "tex1" texture.
  if (!(ProcessSelected_DolphinValidate -ImageFile $ImageFile)) { return }

  # Count the number of times an image was dropped onto the window.
  $global:ProcessImageCount++

  # Create texture info about the texture so various properties can be accessed.
  $LocalTexInfo = CreateTextureInfo -ImageFile $ImageFile -Extended

  # A switch instead of if/else because I want to.
  switch ($ProcessFastMode)
  {
    # Use a default image for the preview.
    $true   { $BitMapImage = New-Object Drawing.Bitmap($Image_NoPreview) }

    # Generate a preview for the image if the user did not disable them.
    $false  {
              # Use those dimensions to calculate the image size for the preview window. The "ProcessImageButton" has a size of "277" for width and height.
              $Dimensions = GetPreviewDimensions -Width $LocalTexInfo.Width -Height $LocalTexInfo.Height -Square (DPISize 277)

              # For PNG and JPG we can just use the image directly for the preview.
              if ($LocalTexInfo.Extension -ne $DDS)
              {
                # Set the path to the image using the input image.
                $TempImageFile = $LocalTexInfo.FullPath
              }
              # DDS is a bit more complex and requires a temporary image to be generated.
              else
              {
                # Create a temporary image for the preview.
                $TempImagePath = CreatePath -LiteralPath ($TempFolder + '\DDS_Preview\')
                $TempImageFile = $TempImagePath + $LocalTexInfo.Name + $PNG

                # Use my handy create texture function to create the image.
                CreatePNGTextureSingle -TextureInfo $LocalTexInfo -ImageFile $LocalTexInfo.FullPath -Width $Dimensions.Width -Height $Dimensions.Height -Format $PNG -OutputPath $TempImagePath
              }
              # Resize it to fit the button. Convert the image type into a bitmap type so it can be resized.
              $ResizedImage = [Drawing.Image]::FromFile($TempImageFile)
              $BitMapImage  = New-Object Drawing.Bitmap($ResizedImage, $Dimensions.Width, $Dimensions.Height)
              $ResizedImage.Dispose()
            }
  }
  # Add the bitmap to the bitmap list.
  $global:ProcessPreviewImage.Add($BitMapImage) | Out-Null

  # Add the texture to the list box.
  $ProcessImageList.Items.Add($LocalTexInfo.FullName) | Out-Null

  # Force the current page to the most recently added texture.
  $global:ProcessImagePage = $ProcessImageCount
  $ProcessIndexBox.Text = $ProcessImageCount

  # Add the texture and its various properties.
  $global:ProcessListTexture.Add($LocalTexInfo.FullName)     | Out-Null
  $global:ProcessListDimension.Add($LocalTexInfo.Dimensions) | Out-Null
  $global:ProcessListScale.Add($LocalTexInfo.FullScale)      | Out-Null
  $global:ProcessListAspect.Add($LocalTexInfo.Aspect)        | Out-Null
  $global:ProcessListPath.Add($LocalTexInfo.Path)            | Out-Null

  # Add the entire path to the master loop list.
  $global:ProcessMasterList.Add($LocalTexInfo.FullPath) | Out-Null

  # Each "main" folder that was dropped will count as a "master input path".
  if (($ProcessMasterPaths -notcontains $RootFolder) -and (TestPath -LiteralPath $RootFolder -PathType 'Container'))
  {
    $global:ProcessMasterPaths.Add($RootFolder) | Out-Null
  }
  # Update the various information fields.
  ProcessSelected_UpdateProperties -Index $ProcessImageCount

  # When textures are added to the stack, update the button.
  if ($ProcessImageCount -eq 1)
  {
    # Update the button to hold the count of the number of images.
    $ProcessImageButton.Font = New-Object Drawing.Font('Arial', 20, [Drawing.FontStyle]::Bold)
    $ProcessImageButton.Text = ''
    $ProcessImageButton.ForeColor = [Drawing.Color]::White
    $ProcessImageButton.FlatAppearance.BorderSize = 0
    $ProcessImageButton.BackColor = [Drawing.Color]::Transparent

    # Enable the buttons.
    $ProcessLeft.Enabled = $true
    $ProcessRight.Enabled = $true
    $ProcessStart.Enabled = $true
  }
  # Don't allow the GUI to hang while adding items. This also allows clicking the cancel button.
  [Windows.Forms.Application]::DoEvents()
}
#==============================================================================================================================================================================================
#  Cancels adding textures to the list when dropping multiple textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_AddTextureCancel()
{
  # Signal that it's time to stop counting up.
  $global:ProcessCancel = $true

  # Hide the button from sight.
  $ProcessCancelButton.Visible = $false
}
#==============================================================================================================================================================================================
#  When dropping multiple textures onto the window this handles the intro and finish.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_ToggleGUI([bool]$Enabled)
{
  # Show this when everything else is made inaccessible. 
  $ProcessCancelButton.Visible      = !$Enabled

  # Set the current state to the parameter.
  $ProcessPanelA.Enabled            = $Enabled
  $ProcessPanelB.Enabled            = $Enabled
  $ProcessImageButton.Enabled       = $Enabled
  $ProcessImageList.Enabled         = $Enabled
  $ProcessGroupBox.Enabled          = $Enabled
  $ProcessOpBox.Enabled             = $Enabled
  $ProcessStart.Enabled             = $Enabled
  $ProcessClose.Enabled             = $Enabled
}
#==============================================================================================================================================================================================
#  Allows adding an image to the stack by dropping an image onto the preview window.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_DragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DropPath = $_.Data.GetData([Windows.Forms.DataFormats]::FileDrop)

    # Disable dialog state.
    ProcessSelected_ToggleGUI -Enabled $false

    # If multiple items were dropped, loop through them all.
    foreach ($DropFile in $DropPath)
    {
      # A list of valid extensions when dropping.
      $ExtCheck = @($PNG,$DDS,$JPG)

      # Test to see if the dropped path is a file.
      if (TestPath -LiteralPath $DropFile -PathType 'Leaf')
      {
        # Get the dropped file as an object.
        $DropItem = Get-Item -LiteralPath $DropFile

        # Make sure the texture has a valid extension and it's not already been added to the list.
        if (($ExtCheck -contains $DropItem.Extension) -and ($ProcessListTexture -notcontains $DropItem.Name) -and ($DropItem.Name -notlike '*_mip*'))
        {
          # Update the image on the button and add the image to the array.
          ProcessSelected_AddTexture -ImageFile $DropItem.FullName -RootFolder $DropItem.DirectoryName
        }
      }
      # Test to see if the dropped path is a folder.
      elseif (TestPath -LiteralPath $DropFile -PathType 'Container')
      {
        # Loop through all files in the dropped folder.
        foreach ($DropLoop in EnumerateFiles -LiteralPath $DropFile -Recurse)
        {
          # Get the loop file as an item to get the name.
          $DropItem = Get-Item -LiteralPath $DropLoop

          # Make sure the texture has a valid extension and it's not already been added to the list.
          if (($ExtCheck -contains $DropItem.Extension) -and ($ProcessListTexture -notcontains $DropItem.Name) -and ($DropItem.Name -notlike '*_mip*'))
          {
            # Update the image on the button and add the image to the array.
            ProcessSelected_AddTexture -ImageFile $DropItem.FullName -RootFolder $DropFile
          }
          # If the user cancels adding textures then cancel early.
          if ($ProcessCancel) { break }
        }
      }
      # If the user cancels adding textures then cancel early.
      if ($ProcessCancel) { break }
    }
    # Enable the dialog state.
    ProcessSelected_ToggleGUI -Enabled $true
  }
  # If the cancel button was pressed then it's time to leave.
  if ($ProcessCancel)
  {
    # Make sure to reset this so images can be added again.
    $global:ProcessCancel = $false

    # Close the dialog which will begin the master loop.
    $ProcessDialog.Close()

    # Make sure everything is cleaned up beforehand.
    ProcessSelected_Cleanup
  }
}
#==============================================================================================================================================================================================
#  Allows adding an image to the stack by clicking the preview window and selecting an image.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_ButtonClick()
{
  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $ProcessListPath[$ProcessListPath.Count -1]

  # Create an open file dialog to grab a PNG image.
  $SelectedFile = Get-FileName -StartPath $GetFilePath -FileName @('*.png','*.dds','*.jpg') -Description @('PNG Images', 'DDS Images', 'JPG Images')

  # Check if the image exists.
  if (TestPath -LiteralPath $SelectedFile)
  {
    # Get the selected file.
    $ExtCheck  = @($PNG,$DDS,$JPG)
    $SelectItem = Get-Item -LiteralPath $SelectedFile

    # Make sure the texture has a valid extension and it's not already been added to the list.
    if (($ExtCheck -contains $SelectItem.Extension) -and ($ProcessListTexture -notcontains $SelectItem.Name) -and ($SelectItem.Name -notlike '*_mip*'))
    {
      # Update the image on the button and add the image to the array.
      ProcessSelected_AddTexture -ImageFile $SelectItem.FullName -RootFolder $SelectItem.DirectoryName
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES - UPDATE TEXTURE
#==============================================================================================================================================================================================
#  Updates the texture properties found on the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_UpdateProperties([int]$Index)
{
  # Set the image as the preview on the button.
  $ProcessImageButton.BackgroundImage = $ProcessPreviewImage[$Index]
  
  # Update all the text boxes with the selected image information.
  $ProcessIndexBox.Text    = $Index.ToString()
  $ProcessTexLabel.Text    = 'Texture : ' + $ProcessListTexture[$Index]
  $ProcessSizeLabel.Text   = 'Size    : ' + $ProcessListDimension[$Index]
  $ProcessScaleLabel.Text  = 'Scale   : ' + $ProcessListScale[$Index]
  $ProcessAspectLabel.Text = 'Aspect  : ' + $ProcessListAspect[$Index] + ':1'
  $ProcessPathLabel.Text   = 'Path    : ' + $ProcessListPath[$Index]

  # Update the selected index on the list to the current index.
  $ProcessImageList.SelectedIndex = $Index - 1
}
#==============================================================================================================================================================================================
#  Allows changing the Process Selected preview image to the previous or next texture in the image stack.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_SwitchPage()
{
  # If going left, subtract 1. If going right, add 1.
  switch ($this.Name)
  {
    # Alter the page variable.
    'Left'  { $global:ProcessImagePage-- }
    'Right' { $global:ProcessImagePage++ }
  }
  # If the page has reached 1 (going left), reset it to the top.
  if ($ProcessImagePage -le 0)
  {
    $global:ProcessImagePage = $ProcessImageCount
  }
  # If the page exceeded the number of images (going right), reset it to the bottom.
  elseif ($ProcessImagePage -gt $ProcessImageCount)
  {
    $global:ProcessImagePage = 1
  }
  # Update the properties on the dialog.
  ProcessSelected_UpdateProperties -Index $ProcessImagePage
}
#==============================================================================================================================================================================================
#  Allows changing the Process Selected preview image to the previous or next texture in the image stack.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_ListSelect()
{
  # Alter the page variable. The image page starts at 1, but the selected index starts at 0 so add 1.
  $global:ProcessImagePage = $this.SelectedIndex + 1

  # Update the properties on the image viewer.
  ProcessSelected_UpdateProperties -Index $ProcessImagePage
}
#==============================================================================================================================================================================================
#  Temporarily overrides the "Output Path" with a custom path. The original path is restored after the "Master Loop" is finished.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_UpdateTempOutputPath($Path)
{
  # Add a work-around for when a directory is chosen that does not contain a sub-folder.
  if ((($Path | Measure-Object -Character).Characters) -eq 3)
  {
    # Set the master output path to the drive root plus the generated folder.
    $ProcessPath = $Path.Replace('\','') + '\~CTT_Generated'
  }
  # A folder was selected within a directory.
  else
  {
    # Set the master output path to the directory plus the generated folder.
    $ProcessPath = $Path + '\~CTT_Generated'
  }
  # Update the variable and the text box with the new path.
  $global:ProcessOverridePath = $ProcessOverrideTextBox.Text = $ProcessPath

  # Override the master output path.
  MasterPaths_Override -OutputPath $ProcessPath
}
#==============================================================================================================================================================================================
#  Allows updating the "Output Path" with a drag and drop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_UpdateFolderPathDragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

    # Make sure the path is a folder.
    if ((TestPath -LiteralPath $DroppedPath -PathType 'Container'))
    {
      # Finish setting the output path.
      ProcessSelected_UpdateTempOutputPath -Path $DroppedPath

      # Do not allow resetting the stored path.
      return
    }
  }
  # Reset the stored path.
  $global:ProcessOverridePath = ''

  # Set the textbox text back to the default.
  $this.Text = '<<- Add with button or drag & drop a folder ->>'
}
#==============================================================================================================================================================================================
#  Allows updating the "Output Path" with a button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_UpdateFolderPathButton()
{
  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $BaseFolder

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Finish setting the output path.
    ProcessSelected_UpdateTempOutputPath -Path $SelectedPath

    # Do not allow resetting the stored path.
    return
  }
  # Reset the stored path.
  $global:ProcessOverridePath = ''

  # Set the textbox text back to the default.
  $ProcessOverrideTextBox.Text  = '<<- Add with button or drag & drop a folder ->>'
}
#==============================================================================================================================================================================================
#  Allows updating the "Output Path" by editing the textbox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_UpdateFolderPathTextBox()
{
  # Get the current value of the MasterPath.
  $CurrentPath = $ProcessOverridePath

  # If the path is already set, allow it to pass.
  $EnteredText = $this.Text.Replace('\~CTT_Generated','')

  # Check to see if the text actually changed and that the path actually exists.
  if (($EnteredText -ne $CurrentPath) -and ($EnteredText -ne '') -and (TestPath -LiteralPath $EnteredText))
  {
    # Finish setting the output path.
    ProcessSelected_UpdateTempOutputPath -Path $EnteredText

    # We're done here. Get out now!
    return
  }
  # Reset the stored path.
  $global:ProcessOverridePath = ''

  # Set the textbox text back to the default.
  $this.Text = '<<- Add with button or drag & drop a folder ->>'
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES - START PROCESSING
#==============================================================================================================================================================================================
#  Actions that take place when the "Start" button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_Start()
{
  # Tell the master loop that process selected is being used.
  $global:ProcessSelected = $true

  # Close the dialog which will begin the master loop.
  $ProcessDialog.Close()

  # Make sure everything is cleaned up beforehand.
  ProcessSelected_Cleanup
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES - DIALOG OPEN FUNCTION
#==============================================================================================================================================================================================
#  Initializes the "Process Selected" dialog when the "$" button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessSelected_Dialog()
{
  # Initialize the global variables that this viewer uses.
  ProcessSelected_InitializeGlobals

  # If the path was stored, overwrite the output path temporarily with the stored path.
  if (($ProcessOverride) -and ($ProcessOverridePath -ne ''))
  {
    # Crop the "CTT_Generated" part because the function does not expect it.
    $OutputRetrieved = $ProcessOverridePath.Replace('\~CTT_Generated','')

    # Update the output path temporarily.
    ProcessSelected_UpdateTempOutputPath -Path $OutputRetrieved
  }
  # Display the GUI to the user.
  $ProcessDialog.ShowDialog() | Out-Null

  # Check that the "Start" button was pressed and that there are images in the stack.
  if (($ProcessSelected) -and ($ProcessImageCount -ge 1))
  {
    # Then process only the images in the stack.
    return $true
  }
  # Take out the trash.
  ProcessSelected_Cleanup

  # We don't want junk laying around so properly dispose of the temp images.
  ClearPath -LiteralPath $TempFolder

  # Return to the main menu.
  return $false
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES - GUI CHECKBOX STATE CHANGES
#==============================================================================================================================================================================================
#  Handles all the crap that needs done when checking/unchecking the 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessOverwriteCheckState()
{
  # Toggle the variable for the checkbox.
  CheckBoxStateToggled

  # Enable the option to keep the original texture.
  $ProcessKeepOriginalCheck.Enabled = $this.Checked

  # Disable all of the override options.
  $ProcessOverrideCheck.Enabled = !$this.Checked

  # If checked, uncheck the override option. If unchecked, also uncheck the option to keep the original.
  if ($this.Checked)
  {
    # Use the enabled version of the linked icon.
    $ProcessLinkIcon.Image = $Image_OptionLinkOn

    # Uncheck the override option.
    $ProcessOverrideCheck.Checked = $false

    # Always disable the override checkboxes.
    $ProcessOverrideTextBox.Enabled = $false
    $ProcessOverrideButton.Enabled = $false
  }
  # When unchecking this option.
  else
  {
    # Use the disabled version of the linked icon.
    $ProcessLinkIcon.Image = $Image_OptionLinkOff

    # Uncheck the option to keep the original
    $ProcessKeepOriginalCheck.Checked = $false
  }
}
#==============================================================================================================================================================================================
#  Handles all the crap that needs done when checking/unchecking the 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ProcessOverrideCheckState()
{
  # Toggle the variable for the checkbox.
  CheckBoxStateToggled

  # Enable the path box and button when checked.
  $ProcessOverrideTextBox.Enabled = $this.Checked
  $ProcessOverrideButton.Enabled = $this.Checked

  # Disable the option to overwrite the texture in-place.
  $ProcessOverwriteCheck.Enabled = !$this.Checked

  # Always disable the option to keep the original.
  $ProcessKeepOriginalCheck.Enabled = $false

  # Always disable the link icon.
  $ProcessLinkIcon.Image = $Image_OptionLinkOff

  # When checking this option.
  if ($this.Checked)
  {
    # Uncheck both options for keeping the original.
    $ProcessOverwriteCheck.Checked = $false
    $ProcessKeepOriginalCheck.Checked = $false
  }
  # When unchecking this option.
  else
  {
    # Restore the Output Path back to the original.
    MasterPaths_Restore

    # Reset this path back to nothing.
    $global:ProcessOverridePath = ''

    # Reset the text box.
    $ProcessOverrideTextBox.Text = '<<- Add with button or drag & drop a folder ->>'
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: PROCESS SELECTED TEXTURES DIALOG CREATION
#==============================================================================================================================================================================================
#  Create the dialog that is displayed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ProcessSelected()
{
  # Create the dialog and set up properties.
  $global:ProcessDialog = New-Object Windows.Forms.Form
  $ProcessDialog.Size = DPISize (New-Object Drawing.Size(596, 494))
  $ProcessDialog.MinimumSize = DPISize (New-Object Drawing.Size(596, 494))
  $ProcessDialog.MaximumSize = DPISize (New-Object Drawing.Size(596, 494))
  $ProcessDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ProcessDialog.Text = 'CTT-PS Process Selected'
  $ProcessDialog.MaximizeBox = $false
  $ProcessDialog.FormBorderStyle = GetFormBorderStyle
  $ProcessDialog.StartPosition = "CenterScreen"
  $ProcessDialog.KeyPreview = $true
  $ProcessDialog.Add_Shown({ ActivateDialog -Dialog $ProcessDialog })
  $ProcessDialog.Icon = $Icon_CTTPSGreen

  # Create the cancel button and add it to the dialog.
  $global:ProcessCancelButton = New-Object Windows.Forms.Button
  $ProcessCancelButton.Size = DPISize (New-Object Drawing.Size(120, 26))
  $ProcessCancelButton.Location = DPISize (New-Object Drawing.Point(88, 136))
  $ProcessCancelButton.Text = 'Cancel'
  $ProcessCancelButton.TabStop = $false
  $ProcessCancelButton.Visible = $false
  $ProcessCancelButton.Add_Click({ ProcessSelected_AddTextureCancel })
  $ProcessDialog.Controls.Add($ProcessCancelButton)

  # Create the image button and add it to the dialog.
  $global:ProcessImageButton = New-Object Windows.Forms.Button
  $ProcessImageButton.Size = DPISize (New-Object Drawing.Size(277, 277))
  $ProcessImageButton.Location = DPISize (New-Object Drawing.Point(10, 10))
  $ProcessImageButton.Text = 'Drag and drop images or click here.'
  $ProcessImageButton.TabStop = $false
  $ProcessImageButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ProcessImageButton.BackgroundImageLayout = [Windows.Forms.ImageLayout]::Center 
  $ProcessImageButton.AllowDrop = $true
  $ProcessImageButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $ProcessImageButton.FlatAppearance.BorderSize = 1
  $ProcessImageButton.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
  $ProcessImageButton.Add_DragDrop({ ProcessSelected_DragAndDrop })
  $ProcessImageButton.Add_Click({ ProcessSelected_ButtonClick })
  $ProcessDialog.Controls.Add($ProcessImageButton)

  # Create a panel that holds the texture properties.
  $global:ProcessPanelA = New-Object Windows.Forms.Panel
  $ProcessPanelA.Size = DPISize (New-Object Drawing.Size(277, 102))
  $ProcessPanelA.Location = DPISize (New-Object Drawing.Point(294, 314))
  $ProcessPanelA.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ProcessPanelA.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ProcessPanelA.AutoScroll = $true
  $ProcessDialog.Controls.Add($ProcessPanelA)

  # Create a panel that holds the texture selection buttons.
  $global:ProcessPanelB = New-Object Windows.Forms.Panel
  $ProcessPanelB.Size = DPISize (New-Object Drawing.Size(200,30))
  $ProcessPanelB.Location = DPISize (New-Object Drawing.Point(348, 290))
  $ProcessPanelB.AutoScroll = $true
  $ProcessDialog.Controls.Add($ProcessPanelB)
  
  # Create a label that holds the texture name.
  $global:ProcessTexLabel = New-Object Windows.Forms.TextBox
  $ProcessTexLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ProcessTexLabel.Location = DPISize (New-Object Drawing.Point(3, 5))
  $ProcessTexLabel.Text = ''
  $ProcessTexLabel.BorderStyle = 0
  $ProcessTexLabel.ReadOnly = $true
  $ProcessTexLabel.BackColor = $ProcessDialog.BackColor
  $ProcessTexLabel.TabStop = $false
  $ProcessPanelA.Controls.Add($ProcessTexLabel)

  # Create a label that holds the texture dimensions.
  $global:ProcessSizeLabel = New-Object Windows.Forms.TextBox
  $ProcessSizeLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ProcessSizeLabel.Location = DPISize (New-Object Drawing.Point(3, 20))
  $ProcessSizeLabel.Text = ''
  $ProcessSizeLabel.BorderStyle = 0
  $ProcessSizeLabel.ReadOnly = $true
  $ProcessSizeLabel.BackColor = $ProcessDialog.BackColor
  $ProcessSizeLabel.TabStop = $false
  $ProcessPanelA.Controls.Add($ProcessSizeLabel)

  # Create a label that holds the texture scale.
  $global:ProcessScaleLabel = New-Object Windows.Forms.TextBox
  $ProcessScaleLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ProcessScaleLabel.Location = DPISize (New-Object Drawing.Point(3, 35))
  $ProcessScaleLabel.Text = ''
  $ProcessScaleLabel.BorderStyle = 0
  $ProcessScaleLabel.ReadOnly = $true
  $ProcessScaleLabel.BackColor = $ProcessDialog.BackColor
  $ProcessScaleLabel.TabStop = $false
  $ProcessPanelA.Controls.Add($ProcessScaleLabel)

  # Create a label that holds the texture aspect.
  $global:ProcessAspectLabel = New-Object Windows.Forms.TextBox
  $ProcessAspectLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ProcessAspectLabel.Location = DPISize (New-Object Drawing.Point(3, 50))
  $ProcessAspectLabel.Text = ''
  $ProcessAspectLabel.BorderStyle = 0
  $ProcessAspectLabel.ReadOnly = $true
  $ProcessAspectLabel.BackColor = $ProcessDialog.BackColor
  $ProcessAspectLabel.TabStop = $false
  $ProcessPanelA.Controls.Add($ProcessAspectLabel)

  # Create a label that holds the texture path.
  $global:ProcessPathLabel = New-Object Windows.Forms.TextBox
  $ProcessPathLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ProcessPathLabel.Location = DPISize (New-Object Drawing.Point(3, 65))
  $ProcessPathLabel.Text = ''
  $ProcessPathLabel.BorderStyle = 0
  $ProcessPathLabel.ReadOnly = $true
  $ProcessPathLabel.BackColor = $ProcessDialog.BackColor
  $ProcessPathLabel.TabStop = $false
  $ProcessPanelA.Controls.Add($ProcessPathLabel)

  # Create a "Texture" label to place in front of the page selection buttons.
  $global:ProcessTexBigLabel = New-Object Windows.Forms.Label
  $ProcessTexBigLabel.Size = DPISize (New-Object Drawing.Size(80, 16))
  $ProcessTexBigLabel.Location = DPISize (New-Object Drawing.Point(0, 4))
  $ProcessTexBigLabel.Text = 'Texture Index:'
  $ProcessPanelB.Controls.Add($ProcessTexBigLabel)

  # Create the Left button and add it to the dialog.
  $global:ProcessLeft = New-Object Windows.Forms.Button
  $ProcessLeft.Size = DPISize (New-Object Drawing.Size(20, 22))
  $ProcessLeft.Location = DPISize (New-Object Drawing.Point(80, 0))
  $ProcessLeft.Name = 'Left'
  $ProcessLeft.Text = '<'
  $ProcessLeft.Enabled = $false
  $ProcessLeft.Add_Click({ ProcessSelected_SwitchPage })
  $ProcessLeft.TabStop = $false
  $ProcessPanelB.Controls.Add($ProcessLeft)

  # Create the number box that holds the current texture page.
  $global:ProcessIndexBox = New-Object Windows.Forms.TextBox
  $ProcessIndexBox.Size = DPISize (New-Object Drawing.Size(28, 16))
  $ProcessIndexBox.Location = DPISize (New-Object Drawing.Point(100, 1)) -AddY $DPIOffsetFix
  $ProcessIndexBox.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ProcessIndexBox.Text = '0'
  $ProcessIndexBox.BackColor = [Drawing.SystemColors]::Window
  $ProcessIndexBox.TabStop = $false
  $ProcessIndexBox.Enabled = $false
  $ProcessIndexBox.ReadOnly = $true
  $ProcessPanelB.Controls.Add($ProcessIndexBox)

  # Create the Right button and add it to the dialog.
  $global:ProcessRight = New-Object Windows.Forms.Button
  $ProcessRight.Size = DPISize (New-Object Drawing.Size(20, 22))
  $ProcessRight.Location = DPISize (New-Object Drawing.Point(128, 0))
  $ProcessRight.Name = 'Right'
  $ProcessRight.Text = '>'
  $ProcessRight.Enabled = $false
  $ProcessRight.Add_Click({ ProcessSelected_SwitchPage })
  $ProcessRight.TabStop = $false
  $ProcessPanelB.Controls.Add($ProcessRight)

  # Create the "Texture List" list box.
  $global:ProcessImageList = New-Object Windows.Forms.ListBox
  $ProcessImageList.Size = DPISize (New-Object Drawing.Size(277, 280))
  $ProcessImageList.Location = DPISize (New-Object Drawing.Point(294, 10))
  $ProcessImageList.TabStop = $false
  $ProcessImageList.AllowDrop = $true
  $ProcessImageList.Add_SelectedIndexChanged({ ProcessSelected_ListSelect })
  $ProcessImageList.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
  $ProcessImageList.Add_DragDrop({ ProcessSelected_DragAndDrop })
  $ProcessDialog.Controls.Add($ProcessImageList)

  # Add a group box to hold the output path options.
  $global:ProcessGroupBox = New-Object Windows.Forms.GroupBox
  $ProcessGroupBox.Size = DPISize (New-Object Drawing.Size(277, 123))
  $ProcessGroupBox.Location = DPISize (New-Object Drawing.Point(10, 294))
  $ProcessDialog.Controls.Add($ProcessGroupBox)
  
  # Create a checkbox to generate preview.
  $global:ProcessFastModeCheck = New-Object Windows.Forms.CheckBox
  $ProcessFastModeCheck.Size = DPISize (New-Object Drawing.Size(260, 16))
  $ProcessFastModeCheck.Location = DPISize (New-Object Drawing.Point(10, 12))
  $ProcessFastModeCheck.Name = 'ProcessFastMode'
  $ProcessFastModeCheck.Text = ' Skip Previews and Validation'
  $ProcessFastModeCheck.Checked = $ProcessFastMode
  $ProcessFastModeCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ProcessGroupBox.Controls.Add($ProcessFastModeCheck)

  # Create a tool tip.
  $global:ProcessFastModeTip = New-Object Windows.Forms.ToolTip
  $ProcessFastModeTip.InitialDelay = $ToolTipDelay
  $ProcessFastModeTip.AutoPopDelay = $ToolTipDuration
  $ProcessFastModeTipString  = 'Disables generating texture previews{0}'
  $ProcessFastModeTipString += 'which speeds up adding them to the list.'
  $ProcessFastModeTipString = [String]::Format($ProcessFastModeTipString, [Environment]::NewLine)
  $ProcessFastModeTip.SetToolTip($ProcessFastModeCheck, $ProcessFastModeTipString)

  # Create a checkbox to overwrite the textures directly.
  $global:ProcessOverwriteCheck = New-Object Windows.Forms.CheckBox
  $ProcessOverwriteCheck.Size = DPISize (New-Object Drawing.Size(260, 16))
  $ProcessOverwriteCheck.Location = DPISize (New-Object Drawing.Point(10, 32))
  $ProcessOverwriteCheck.Name = 'ProcessOverwrite'
  $ProcessOverwriteCheck.Text = ' Overwrite Textures Directly'
  $ProcessOverwriteCheck.Checked = $ProcessOverwrite
  $ProcessOverwriteCheck.Enabled = !$ProcessOverride
  $ProcessOverwriteCheck.Add_CheckStateChanged({ ProcessOverwriteCheckState })
  $ProcessGroupBox.Controls.Add($ProcessOverwriteCheck)

  # Create a tool tip.
  $global:ProcessOverwriteTip = New-Object Windows.Forms.ToolTip
  $ProcessOverwriteTip.InitialDelay = $ToolTipDelay
  $ProcessOverwriteTip.AutoPopDelay = $ToolTipDuration
  $ProcessOverwriteTipString  = 'Overwrites the input texture with the{0}'
  $ProcessOverwriteTipString += 'output texture. If the format changes,{0}'
  $ProcessOverwriteTipString += 'the original texture is deleted unless{0}'
  $ProcessOverwriteTipString += 'enabling the option below this one.'
  $ProcessOverwriteTipString = [String]::Format($ProcessOverwriteTipString, [Environment]::NewLine)
  $ProcessOverwriteTip.SetToolTip($ProcessOverwriteCheck, $ProcessOverwriteTipString)

  # Create an icon that links the above option with the below option.
  $global:ProcessLinkIcon = New-Object Windows.Forms.PictureBox
  $ProcessLinkIcon.Size = DPISize (New-Object Drawing.Size(10, 10))
  $ProcessLinkIcon.Location = DPISize (New-Object Drawing.Point(16, 49))
  $ProcessGroupBox.Controls.Add($ProcessLinkIcon)

  # Set the link image to enabled or disabled based on the global.
  if ($ProcessOverwrite) { $ProcessLinkIcon.Image = $Image_OptionLinkOn } else { $ProcessLinkIcon.Image = $Image_OptionLinkOff }

  # Create a checkbox to allow keeping the original.
  $global:ProcessKeepOriginalCheck = New-Object Windows.Forms.CheckBox
  $ProcessKeepOriginalCheck.Size = DPISize (New-Object Drawing.Size(240, 16))
  $ProcessKeepOriginalCheck.Location = DPISize (New-Object Drawing.Point(29, 51))
  $ProcessKeepOriginalCheck.Name = 'ProcessKeepOriginal'
  $ProcessKeepOriginalCheck.Text = ' Keep Input if Different Output Format'
  $ProcessKeepOriginalCheck.Checked = $ProcessKeepOriginal
  $ProcessKeepOriginalCheck.Enabled = $ProcessOverwrite
  $ProcessKeepOriginalCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ProcessGroupBox.Controls.Add($ProcessKeepOriginalCheck)

  # Create a tool tip.
  $global:ProcessKeepOriginalTip = New-Object Windows.Forms.ToolTip
  $ProcessKeepOriginalTip.InitialDelay = $ToolTipDelay
  $ProcessKeepOriginalTip.AutoPopDelay = $ToolTipDuration
  $ProcessKeepOriginalTipString =  'Also keeps the input texture if the output{0}'
  $ProcessKeepOriginalTipString += 'texture is created with a different format.'
  $ProcessKeepOriginalTipString = [String]::Format($ProcessKeepOriginalTipString, [Environment]::NewLine)
  $ProcessKeepOriginalTip.SetToolTip($ProcessKeepOriginalCheck, $ProcessKeepOriginalTipString)

  # Create a checkbox to override the output path.
  $global:ProcessOverrideCheck = New-Object Windows.Forms.CheckBox
  $ProcessOverrideCheck.Size = DPISize (New-Object Drawing.Size(240, 16))
  $ProcessOverrideCheck.Location = DPISize (New-Object Drawing.Point(10, 71))
  $ProcessOverrideCheck.Name = 'ProcessOverride'
  $ProcessOverrideCheck.Text = ' Override Output Path'
  $ProcessOverrideCheck.Checked = $ProcessOverride
  $ProcessOverrideCheck.Enabled = !$ProcessOverwrite
  $ProcessOverrideCheck.Add_CheckStateChanged({ ProcessOverrideCheckState })
  $ProcessGroupBox.Controls.Add($ProcessOverrideCheck)

  # Create a tool tip.
  $global:ProcessOverrideTip = New-Object Windows.Forms.ToolTip
  $ProcessOverrideTip.InitialDelay = $ToolTipDelay
  $ProcessOverrideTip.AutoPopDelay = $ToolTipDuration
  $ProcessOverrideTipString =  'Temporarily override the output path{0}'
  $ProcessOverrideTipString += 'for a single session. If this path is not{0}'
  $ProcessOverrideTipString += 'specified, the original path is used.'
  $ProcessOverrideTipString = [String]::Format($ProcessOverrideTipString, [Environment]::NewLine)
  $ProcessOverrideTip.SetToolTip($ProcessOverrideCheck, $ProcessOverrideTipString)

  # Create a text box to hold the override path.
  $global:ProcessOverrideTextBox = New-Object Windows.Forms.TextBox
  $ProcessOverrideTextBox.Size = DPISize (New-Object Drawing.Size(236, 22))
  $ProcessOverrideTextBox.Location = DPISize (New-Object Drawing.Point(10, 91)) -AddY $DPIOffsetFix
  $ProcessOverrideTextBox.Name = 'ProcessOverridePath'
  $ProcessOverrideTextBox.Text = '<<- Add with button or drag & drop a folder ->>'
  $ProcessOverrideTextBox.AllowDrop = $true
  $ProcessOverrideTextBox.Enabled = $ProcessOverride
  $ProcessOverrideTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ProcessOverrideTextBox.Add_DragDrop({ ProcessSelected_UpdateFolderPathDragAndDrop })
  $ProcessOverrideTextBox.Add_Click({ ClearTextBox })
  $ProcessOverrideTextBox.Add_Leave({ ProcessSelected_UpdateFolderPathTextBox })
  $ProcessGroupBox.Controls.Add($ProcessOverrideTextBox)

  # Create a button to add an override path.
  $global:ProcessOverrideButton = New-Object Windows.Forms.Button
  $ProcessOverrideButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $ProcessOverrideButton.Location = DPISize (New-Object Drawing.Point(250, 90))
  $ProcessOverrideButton.Name = 'ProcessOverridePath'
  $ProcessOverrideButton.Text = '...'
  $ProcessOverrideButton.Enabled = $ProcessOverride
  $ProcessOverrideButton.Add_Click({ ProcessSelected_UpdateFolderPathButton })
  $ProcessGroupBox.Controls.Add($ProcessOverrideButton)

  # ResPack Manager: Create a groupbox to hold all the shit.
  $global:ProcessOpBox = New-Object Windows.Forms.GroupBox
  $ProcessOpBox.Size = DPISize (New-Object Drawing.Size(349, 33))
  $ProcessOpBox.Location = DPISize (New-Object Drawing.Point(116, 417))
  $ProcessOpBox.Enabled = $true
  $ProcessDialog.Controls.Add($ProcessOpBox)

  # Create a label to hold the operation text.
  $global:ProcessOpLabel = New-Object Windows.Forms.Label
  $ProcessOpLabel.Size = DPISize (New-Object Drawing.Size(320, 16))
  $ProcessOpLabel.Location = DPISize (New-Object Drawing.Point(11, 12))
  $ProcessOpLabel.Text = 'Operation: ' + $StoredOperation
  $ProcessOpBox.Controls.Add($ProcessOpLabel)

  # Create the Start button and add it to the dialog.
  $global:ProcessStart = New-Object Windows.Forms.Button
  $ProcessStart.Size = DPISize (New-Object Drawing.Size(100, 28))
  $ProcessStart.Location = DPISize (New-Object Drawing.Point(10, 422))
  $ProcessStart.Text = 'Start'
  $ProcessStart.Enabled = $false
  $ProcessStart.Add_Click({ ProcessSelected_Start })
  $ProcessDialog.Controls.Add($ProcessStart)

  # Create the Close button and add it to the dialog.
  $global:ProcessClose = New-Object Windows.Forms.Button
  $ProcessClose.Size = DPISize (New-Object Drawing.Size(100, 28))
  $ProcessClose.Location = DPISize (New-Object Drawing.Point(471, 422))
  $ProcessClose.Text = 'Close'
  $ProcessClose.Add_Click({ $ProcessDialog.Close() })
  $ProcessDialog.Controls.Add($ProcessClose)
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $ImgViewDialog            - Form         - Global
#  $ImgViewImageBox          - Button       - Global
#  $ImgViewCurrentTex        - Label        - Global
#  $ImgViewTextureIndexBox   - TextBox      - Global
#  $ImgViewTextureLeft       - Button       - Global
#  $ImgViewTextureRight      - Button       - Global
#  $ImgViewCurrentMip        - Label        - Global
#  $ImgViewMipmapIndexBox    - TextBox      - Global
#  $ImgViewMipmapLeft        - Button       - Global
#  $ImgViewMipmapRight       - Button       - Global
#  $ImgViewListButton        - Button       - Global
#  $ImgViewImageList         - ListBox      - Global
#  $ImgViewProperties        - Panel        - Global
#  $ImgViewDummyProps        - Panel        - Global
#  $ImgViewTextureLabel      - TextBox      - Global
#  $ImgViewDimensionsLabel   - TextBox      - Global
#  $ImgViewFormatLabel       - TextBox      - Global
#  $ImgViewMipmapLabel       - TextBox      - Global
#  $ImgViewPathLabel         - TextBox      - Global
#  $ImgViewClearButton       - Button       - Global
#  $ImgViewClearTip          - ToolTip      - Global
#  $ImgViewWritePNGButton    - Button       - Global
#  $ImgViewWritePNGTip       - ToolTip      - Global
#  $ImgViewCloseButton       - Button       - Global
#==============================================================================================================================================================================================
#  Sets all global variables that the image viewer uses to their default state. Used when thew viewer is first loaded, or when it is cleared.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_InitializeGlobals()
{
  # Keep track of the total number of images, and keep track of the current page.
  $global:ImageCount = 0
  $global:ImagePage  = 0
  $global:MipmapPage = 0

  # Create lists to store the bitmap images (for previews). For mipmaps, each entry will contain an array. This will simulate a 2-dimensional array.
  $global:ImgViewPreviewImage  = New-Object Collections.Generic.List[Drawing.Image]
  $global:ImgViewPreviewMipmap = New-Object Collections.Generic.List[Drawing.Image[]]

  # Create lists to store image properties.
  $global:ImgViewListTexture   = New-Object Collections.Generic.List[string]
  $global:ImgViewListDimension = New-Object Collections.Generic.List[string]
  $global:ImgViewListFormat    = New-Object Collections.Generic.List[string]
  $global:ImgViewListMipmaps   = New-Object Collections.Generic.List[string]
  $global:ImgViewListPaths     = New-Object Collections.Generic.List[string]
  $global:ImgViewListPhyePath  = New-Object Collections.Generic.List[string]

  # To make tracking textures a lot less stupid, fill index 0 on all lists with garbage data so we can start with index 1.
  $global:ImgViewPreviewImage.Add($Image_NoPreview) | Out-Null
  $global:ImgViewPreviewMipmap.Add($Image_NoPreview) | Out-Null
  $global:ImgViewListTexture.Add(' ') | Out-Null
  $global:ImgViewListDimension.Add(' ') | Out-Null
  $global:ImgViewListFormat.Add(' ') | Out-Null
  $global:ImgViewListMipmaps.Add(' ') | Out-Null
  $global:ImgViewListPaths.Add(' ') | Out-Null
  $global:ImgViewListPhyePath.Add(' ') | Out-Null
}
#==============================================================================================================================================================================================
#  Updates all properties on the Image Viewer with the current global values.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_UpdateProperties([int]$Index, [int]$MipmapIndex)
{
  # Set the image as the preview on the button.
  $ImgViewImageBox.BackgroundImage = $ImgViewPreviewImage[$Index]

  # Update all the text boxes with the selected image information.
  $ImgViewTextureIndexBox.Text = $Index.ToString()
  $ImgViewMipmapIndexBox.Text  = $MipmapIndex.ToString()
  $ImgViewTextureLabel.Text    = 'Name    : ' + (Get-Item -LiteralPath $ImgViewListTexture[$Index]).Name
  $ImgViewDimensionsLabel.Text = 'Size    : ' + $ImgViewListDimension[$Index]
  $ImgViewFormatLabel.Text     = 'Format  : ' + $ImgViewListFormat[$Index]
  $ImgViewMipmapLabel.Text     = 'Mipmaps : ' + $ImgViewListMipmaps[$Index]

  # If the image is a phyre image imported from a PKG file, then display the path to the PKG file instead.
  if ($ImgViewListPhyePath[$Index] -ne '') { $ImgViewPathLabel.Text = 'Path    : ' + $ImgViewListPhyePath[$Index] } else { $ImgViewPathLabel.Text = 'Path    : ' + $ImgViewListPaths[$Index] }

  # Always enable the export PNG button.
  $ImgViewWritePNGButton.Enabled = $true

  # Update the selected index on the list to the current index.
  $ImgViewImageList.SelectedIndex = $Index - 1
}
#==============================================================================================================================================================================================
#  Enables functions on the dialog after a texture has been added, or disables them if the dialog has been reset.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_ToggleDialogState([bool]$Enable)
{
  # Allow screwing around with all the controls.
  $ImgViewTextureLeft.Enabled     = $Enable
  $ImgViewTextureRight.Enabled    = $Enable
  $ImgViewTextureIndexBox.Enabled = $Enable
  $ImgViewMipmapLeft.Enabled      = $Enable
  $ImgViewMipmapRight.Enabled     = $Enable
  $ImgViewMipmapIndexBox.Enabled  = $Enable

  # Set the visibility of the properties panel.
  $ImgViewProperties.Visible      = $Enable
  $ImgViewDummyProps.Visible      = !$Enable

  # Show some hidden items and update the background.
  if ($Enable)
  {
    $ImgViewImageBox.Text = ''
    $ImgViewImageBox.BackColor = [Drawing.Color]::Transparent
    $ImgViewImageBox.FlatAppearance.MouseOverBackColor = [Drawing.Color]::Transparent
    $ImgViewImageBox.FlatAppearance.BorderSize = 0
  }
  # If disabling the dialog, set controls back to their default state.
  else
  {
    $ImgViewImageBox.Text = 'Drag and drop an image or click here.'
    $ImgViewImageBox.BackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
    $ImgViewImageBox.FlatAppearance.MouseOverBackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
    $ImgViewImageBox.FlatAppearance.BorderSize = 1
  }
}
#==============================================================================================================================================================================================
#  Writes the currently loaded image to the PNG file format. Launched from "ImgViewWritePNGButton" button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_WriteToPNG()
{
  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $DesktopPath

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and ($SelectedPath -notlike '*~*') -and ($SelectedPath.Length -gt 3) -and (TestPath -LiteralPath $SelectedPath))
  {
    # Can be stubborn if the mode is in Dolphin mode.
    if ($CTTPSSelectedMode -ne 'Expert Mode')
    {
      # Store the current mode and temporarily overwrite it with "Expert".
      $StoredCTTPSMode = $CTTPSSelectedMode
      $global:CTTPSSelectedMode = 'Expert Mode'
    }
    # Get the name of the stored texture.
    $ImgViewListTexName = (Get-Item -LiteralPath $ImgViewListTexture[$ImagePage]).Name

    # If the image is a "phyre" image (cold steel, ffx remaster) we need to get the temporary image that was generated from it.
    if ($ImgViewListTexName -like '*.phyre')
    {
      # The texture in the list will have an extension + phyre which needs to be eliminated, then replaced with the temporary image extension (which is always PNG).
      $NotPNGImageFull = $ImgViewListPaths[$ImagePage] + '\' + $ImgViewListTexName.Replace($PNG,'').Replace($DDS,'').Replace('.phyre','') + $PNG
    }
    # This is what happens 99% of cases.
    else
    {
      # For every other case just use the path and image straight from the lists.
      $NotPNGImageFull = $ImgViewListPaths[$ImagePage] + '\' + $ImgViewListTexName
    }
    # Texture info hash table will be needed so create one.
    $NotPNGInfo = CreateTextureInfo -ImageFile $NotPNGImageFull -Extended

    # Disable the dialog while the PNG texture is being created.
    $ImgViewDialog.Enabled = $false

    # Hide any previews and show a message that a PNG image is being generated.
    $ImgViewImageBox.BackgroundImage = $null
    $ImgViewImageBox.Text = 'Exporting to PNG... please be patient!'
    $ImgViewImageBox.FlatAppearance.BorderSize = 1

    # If it's a texture with material maps, force generating it by overwriting the matmap value.
    if ($NotPNGInfo.HasMatMap) { $NotPNGInfo.HasMatMap = $false }

    # Create the PNG texture in the selected output path.
    $TextureCreated = CreateTexture -TextureInfo $NotPNGInfo -Width $NotPNGInfo.Width -Height $NotPNGInfo.Height -Format $PNG -OutputPath $SelectedPath

    # Show the background image.
    $ImgViewImageBox.BackgroundImage = $ImgViewPreviewImage[$ImagePage]
    $ImgViewImageBox.Text = ''
    $ImgViewImageBox.FlatAppearance.BorderSize = 0

    # Check to see if the texture was created.
    if ($TextureCreated)
    {
      # Tell the user the exciting news.
      $Title   = 'CTT-PS Export PNG'
      $Message = 'Texture successfully exported as PNG!'
      ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 48) -OffsetY (DPISize 18) -Message $Message
    }
    # If the variable was set.
    if ($StoredCTTPSMode)
    {
      # If the mode was temporarily overwritten, restore it.
      $global:CTTPSSelectedMode = $StoredCTTPSMode
    }
    # Enable the dialog after the texture has been created.
    $ImgViewDialog.Enabled = $true
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER - ADD TEXTURE TO THE LIST
#==============================================================================================================================================================================================
#  Adds a texture bitmap to the specified bitmap stack ("ImgViewTexBitMap" for texture or "ImgViewMipBitMap" for mipmap).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_AddPreviewToStack([string]$BitMapStack, [string]$ImageFile, [int]$Width, [int]$Height)
{
  # Get the new dimensions for the preview window.
  $Dimensions = GetPreviewDimensions -Width $Width -Height $Height -Square (DPISize 460)

  # Resize the image to fit the preview area. Convert the image type into a bitmap type so it can be resized.
  $DrawingImage  = [Drawing.Image]::FromFile($ImageFile)
  $DrawingBitmap = New-Object Drawing.Bitmap($DrawingImage, $Dimensions.Width, $Dimensions.Height)
  $DrawingImage.Dispose()

  # Add the bitmap to the specified stack.
  Set-Variable -Name $BitMapStack -Value $DrawingBitmap -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Creates the preview image for the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_CreatePreviews([hashtable]$TextureInfo)
{
  # This will need to be referenced later so store it for now.
  $StoreExtension = $TextureInfo.Extension

  # DDS files need to be converted to PNG to have a preview generated.
  if (($TextureInfo.Extension -ne $PNG) -or ($TextureInfo.Extension -ne $JPG))
  {
    # Overwrite that it has a material so the create texture function for material maps doesn't trigger.
    if ($TextureInfo.HasMatMap) { $TextureInfo.HasMatMap = $false }

    # Create a path for the preview images.
    $PreviewPath = CreatePath -LiteralPath ($TempFolder + '\ImageViewer_' + $ImageCount)

    # Create a temporary path for DDS files.
    $TempDDSFile = $PreviewPath + '\' + $TextureInfo.Name + $PNG

    # Create the image into the preview path.
    CreateTexture -TextureInfo $TextureInfo -Width $TextureInfo.Width -Height $TextureInfo.Height -Format $PNG -OutputPath $PreviewPath -NoReturn

    # We need to get the file as an object to create texture info from it.
    $TextureInfo = CreateTextureInfo -ImageFile $TempDDSFile -Extended
  }
  # Add the texture to the image preview stack.
  ImageViewer_AddPreviewToStack -BitmapStack 'ImgViewTexBitMap' -ImageFile $TextureInfo.FullPath -Width $TextureInfo.Width -Height $TextureInfo.Height

  # Check to see if it is a mipmap texture.
  if (($TextureInfo.IsMipmap) -or ($TextureInfo.Mipmaps -gt 0))
  {
    # A temporary list of all mipmaps is needed, which is then stored in a collection after its fully compiled. The top level counts as mipmap
    # level zero (so it can be viewed with the mipmap arrow selection buttons), and all mipmaps are added as they are found in the loop below.
    $MipmapList = @($ImgViewTexBitMap)

    # Grab some of that mipmap information.
    $MipmapInfo = CreateMipmapInfo -TextureInfo $TextureInfo -Width $TextureInfo.Width -Height $TextureInfo.Height

    # If the option is enabled to treat TIFF as "images" rather than "textures" is enabled.
    switch ($StoreExtension -like ($TIF + '*'))
    {
      # Only include the number of mipmaps that exist. Otherwise, generate them all.
      $true   { $MipmapLevels = CountInternalMipmaps -ImageFile $TextureInfo.FullPath }
      $false  { $MipmapLevels = GetCorrectMipmapLevels -TextureName $TextureInfo.Name -MaxLevels $MipmapInfo.Levels }
    }
    # Loop through all mipmap levels.
    for ($i=1 ; $i -le $MipmapLevels ; $i++)
    {
      # Do stuff it the mipmap exists.
      if ($MipmapInfo.Exists[$i])
      {
        # If the option to not resize TIFF mipmaps is enabled, do not resize them.
        if ($StoreExtension -like ($TIF + '*'))
        {
          # Set the size of the mipmap to its actual size.
          $MipmapWidth  = $MipmapInfo.RealWidth[$i]
          $MipmapHeight = $MipmapInfo.RealHeight[$i]
        }
        # The image is not TIFF or the option to disable mipmap resizing is not enabled.
        else
        {
          # Set the size of the mipmap to the calculated size.
          $MipmapWidth  = $MipmapInfo.Width[$i]
          $MipmapHeight = $MipmapInfo.Height[$i]
        }
        # Add the texture to the mipmap preview stack.
        ImageViewer_AddPreviewToStack -BitmapStack 'ImgViewMipBitMap' -ImageFile $MipmapInfo.FullPath[$i] -Width $MipmapWidth -Height $MipmapHeight

        # Add the bitmap to the bitmap list.
        $MipmapList += $ImgViewMipBitMap
      }
    }
  }
  # Add the all images to the bitmap lists.
  $global:ImgViewPreviewImage.Add($ImgViewTexBitMap) | Out-Null
  $global:ImgViewPreviewMipmap.Add($MipmapList) | Out-Null

  # Remove the temporary file (if it exists) as it is no longer needed.
  RemovePath -LiteralPath $PreviewPath
}
#==============================================================================================================================================================================================
#  Adds a texture to the Image Viewer and updates all properties.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_AddTexture([string]$InputFile, [string]$PKGFile = '')
{
  # Grab a texture hash table to get information about the texture.
  $TextureInfo = CreateTextureInfo -ImageFile $InputFile -Extended

  # Don't do anything if there isn't any texture info.
  if ($TextureInfo -eq $null) { return }

  # Increment the image count variable.
  $global:ImageCount++

  # Hide any previews and show a message that the image is being generated.
  $ImgViewImageBox.BackgroundImage = $null
  $ImgViewImageBox.Text = 'Generating preview... please be patient!'
  $ImgViewImageBox.FlatAppearance.BorderSize = 1

  # Create the preview images. This includes the top level and all mipmaps.
  ImageViewer_CreatePreviews -TextureInfo $TextureInfo

  # Force the current page to the most recently added texture. Reset the mipmap current page to 1.
  $global:ImagePage  = $ImageCount
  $global:MipmapPage = 0

  # Show different information for Phyre images.
  if ($ImageViewPhyreInfo -ne $null)
  {
    # Add the texture to the list box.
    $ImgViewImageList.Items.Add($ImageViewPhyreInfo.RealName) | Out-Null

    # Update the lists with the texture information.
    $global:ImgViewListTexture.Add($ImageViewPhyreInfo.RealPath)
    $global:ImgViewListDimension.Add($ImageViewPhyreInfo.Dimensions)
    $global:ImgViewListFormat.Add($ImageViewPhyreInfo.Extension.Replace('.','').ToUpper() + '-PHYRE' + '-' + $ImageViewPhyreInfo.Format + '-CS' + $ImageViewPhyreInfo.ColdSteel)
    $global:ImgViewListMipmaps.Add($ImageViewPhyreInfo.Mipmaps)
    $global:ImgViewListPaths.Add($TextureInfo.Path)

    # If importing images from a PKG file, add the PKG file to a list. Otherwise, add the original phyre image.
    if ($PKGFile -ne '') { $global:ImgViewListPhyePath.Add($PKGFile) } else { $global:ImgViewListPhyePath.Add($ImageViewPhyreInfo.RealPath) }
  }
  else
  {
    # Add the texture to the list box.
    $ImgViewImageList.Items.Add($TextureInfo.FullName) | Out-Null

    # Display the Direct-3D level of the texture.
    switch ($TextureInfo.DDSFourCC)
    {
      'DX10'  { $DirectX = 'DX10' }
      default { $DirectX = 'DX9'  }
    }
    # If were dealing with a DDS texture, also include the type of DDS texture it is for the format property.
    switch ($TextureInfo.Extension)
    {
      $DDS    { $ImageFormat = 'DDS-' + $DirectX + '-' + $TextureInfo.Format }
      default { $ImageFormat = $TextureInfo.Format }
    }
    # Update the lists with the texture information.
    $global:ImgViewListTexture.Add($TextureInfo.FullPath)
    $global:ImgViewListDimension.Add($TextureInfo.Dimensions)
    $global:ImgViewListFormat.Add($ImageFormat)
    $global:ImgViewListMipmaps.Add($TextureInfo.Mipmaps)
    $global:ImgViewListPaths.Add($TextureInfo.Path)
    $global:ImgViewListPhyePath.Add('')
  }
  # Update the properties on the dialog.
  ImageViewer_UpdateProperties -Index $ImagePage -MipmapIndex $MipmapPage

  # Toggle the state of the dialog if this is the first image added.
  ImageViewer_ToggleDialogState -Enable $true
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER - CONVERSION FUNCTIONS TO ADD COLD STEEL PHYRE TEXTURES OR PKG FILES TO THE LIST
#==============================================================================================================================================================================================
#  Converts a Legend of Heroes: Trails of Cold Steel phyre image into a PNG image and returns it as an item.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_GetPNGFromPhyre([string]$InputFile)
{
  # Get the image as an item.
  $PhyreItem = Get-Item -LiteralPath $InputFile

  # Find only phyre images.
  if (($PhyreItem.Name -like '*.png.phyre') -or ($PhyreItem.Name -like '*.dds.phyre') -or ($PhyreItem.Name -like '*.bmp.phyre'))
  {
    # Back up the selected options for mipmaps and swizzling.
    $StoreSwizzle = $PhyreSwizzle
    $StoreMipmaps = $PhyreSaveMipmaps

    # We always want to unswizzle the texture and create mipmaps so force them temporarily.
    $global:PhyreSwizzle     = $true
    $global:PhyreSaveMipmaps = $true

    # Create texture info on the texture.
    $PhyreInfo = CreatePhyreInfo -InputFile $InputFile

    # Create a temporary path to store the texture.
    $TempPhyrePath = CreatePath -LiteralPath ($TempFolder + '\PhyreTempConvert')
    $TempPhyreFile = $TempPhyrePath + '\' + $PhyreInfo.Name + $PNG

    # Convert the ToCS image to a normal PNG image.
    ConvertPhyreTextures -PhyreInfo $PhyreInfo -OutputPath $TempPhyrePath

    # To make this very easy, store PhyreInfo in a global variable.
    $global:ImageViewPhyreInfo = $PhyreInfo

    # Set these back to whatever they were.
    $global:PhyreSwizzle     = $StoreSwizzle
    $global:PhyreSaveMipmaps = $StoreMipmaps

    # Return the new image.
    return $TempPhyreFile
  }
}
#==============================================================================================================================================================================================
#  An extension of "AddTexture" that allows adding Legend of Heroes: Trails of Cold Steel textures wrapped in "PKG" files.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_AddPhyrePKG([string]$InputFile)
{
  # Create a place to store them temporarily.
  $PKGContents = CreatePath -LiteralPath ($TempFolder + '\PKGContents')

  # Extract all files from the PKG file.
  ExtractColdSteelPKG -InputFile $InputFile -ExtractPath $PKGContents

  # Get the full extracted path.
  $PKGBaseName  = (Get-Item -LiteralPath $InputFile).BaseName
  $PKGExtracted = $PKGContents + '\' + $PKGBaseName

  # Loop through all files in the extracted folder.
  foreach ($PhyreImage in EnumerateFiles -LiteralPath $PKGExtracted -Filter @('*.png.phyre','*.dds.phyre','*.jpg.phyre') -Recurse)
  {
    # Get the phyre image as a PNG image.
    $PNGFromPhyre = ImageViewer_GetPNGFromPhyre -InputFile $PhyreImage

    # Add the texture to the viewer.
    ImageViewer_AddTexture -InputFile $PNGFromPhyre -PKGFile $InputFile

    # Set phyre info to null so the add texture function doesn't get confused.
    $global:ImageViewPhyreInfo = $null
  }
  # Clean up the extracted phyre files now that they were converted.
  RemovePath -LiteralPath $PKGContents
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER - TRIGGER FUNCTIONS TO ADD NORMAL TEXTURES TO THE LIST
#==============================================================================================================================================================================================
#  Attempts to add a texture to the list when a file is added through the button or a drag and drop action.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_AddTextureCheck([string]$ImageFile)
{
  # Force "Expert Mode" when adding an image so there are no limitations. 
  $StoreCTTPSMode = $CTTPSSelectedMode
  $global:CTTPSSelectedMode  = 'Expert Mode'

  # Force TIFF images to keep their original "mipmap" size.
  $StoreTIFFMode = $TIFFNoResizeMipmap
  $global:TIFFNoResizeMipmap = $true

  # Get the image file that needs to be validated.
  $ExtCheck  = @($PNG,$DDS,$JPG,$BMP,$TGA,$TIF,$TIFF)
  $ImageItem = Get-Item -LiteralPath $ImageFile

  # Make sure the texture has a valid extension and it's not already been added to the list.
  if (($ExtCheck -contains $ImageItem.Extension) -and ($ImgViewListTexture -notcontains $ImageItem.FullName) -and ($ImageItem.Name -notlike '*_mip*'))
  {
    # Update the image on the button and add the image to the array.
    ImageViewer_AddTexture -InputFile $ImageFile
  }
  # If it's a phyre texture, try to convert it to a PNG image.
  elseif ($ImageItem.Extension -eq '.phyre')
  {
    # Get the phyre image as a PNG image.
    $PNGFromPhyre = ImageViewer_GetPNGFromPhyre -InputFile $ImageFile

    # Add the texture to the viewer.
    ImageViewer_AddTexture -InputFile $PNGFromPhyre

    # Set phyre info to null so the add texture function doesn't get confused.
    $global:ImageViewPhyreInfo = $null
  }
  # Allow extracting the textures from PKG files directly.
  elseif ($ImageItem.Extension -eq $PKG)
  {
    # Run a special function for PKG files.
    ImageViewer_AddPhyrePKG -InputFile $ImageFile
  }
  # Restore the options the user currently has selected.
  $global:TIFFNoResizeMipmap = $StoreTIFFMode
  $global:CTTPSSelectedMode  = $StoreCTTPSMode
}
#==============================================================================================================================================================================================
#  Adds an image to the viewer by dropping it onto the image button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_DragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Disable the dialog states.
    ToggleDialogStates -State $false

    # Create a list of the data to select the first item from the list.
    $DroppedFiles = $_.Data.GetData([Windows.Forms.DataFormats]::FileDrop)

    # Disable the dialog while it is decoding.
    $ImgViewDialog.Enabled = $false

    # Loop through all dropped files.
    foreach ($File in $DroppedFiles)
    {
      # The dropped item is a folder.
      if (TestPath -LiteralPath $File -PathType 'Container')
      {
        # Loop through all the files in the folder.
        foreach ($LoopFile in EnumerateFiles -LiteralPath $File -Recurse)
        {
          # Attempt to add the file to the list.
          ImageViewer_AddTextureCheck -ImageFile $LoopFile
        }
      }
      # The dropped item is a file.
      elseif (TestPath -LiteralPath $File -PathType 'Leaf')
      {
        # Attempt to add the file to the list.
        ImageViewer_AddTextureCheck -ImageFile $File
      }
    }
    # Enable the dialog after all images are added.
    $ImgViewDialog.Enabled = $true

    # Enable the dialog states.
    ToggleDialogStates -State $true
  }
}
#==============================================================================================================================================================================================
#  Adds an image to the viewer by selecting a texture with the image button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_ButtonClick()
{
  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $ImgViewListPaths[$ImgViewListPaths.Count -1]

  # Create an open file dialog to grab a PNG image.
  $SelectedFile = Get-FileName -StartPath $GetFilePath -FileName '*' -Description 'Image File'

  # Check if the image exists.
  if (!(TestPath -LiteralPath $SelectedFile)) { return }

  # Get the texture as an "item".
  $SelectedItem = Get-Item -LiteralPath $SelectedFile

  # Create a list of valid extensions.
  $ExtensionList = @($PNG,$DDS,$JPG,$BMP,$TGA,$TIF,$TIFF,$PKG,'.phyre')

  # Make sure it has a valid extension
  if ($ExtensionList -contains $SelectedItem.Extension)
  {
    # Disable the dialog states.
    ToggleDialogStates -State $false

    # Disable the dialog while it is decoding.
    $ImgViewDialog.Enabled = $false

    # Attempt to add the texture to the list.
    ImageViewer_AddTextureCheck -ImageFile $SelectedFile

    # Enable the dialog after all images are added.
    $ImgViewDialog.Enabled = $true

    # Enable the dialog states.
    ToggleDialogStates -State $true
  }
  # Don't allow invalid file types.
  else
  {
    # Display a warning to the user.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: Unsupported file or image type. Supported formats are: .png, .dds, .jpg, .tga, .tif, .tiff, .pkg, and .phyre.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 10) -OffsetY (DPISize 12) -Message $Message
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER - PAGE SWITCHING
#==============================================================================================================================================================================================
#  Turns the texture page forward or backwards. Launched from buttons "ImgViewTextureLeft / ImgViewTextureRight".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_TurnPageImage()
{
  # If going left, subtract 1. If going right, add 1.
  switch ($this.Name)
  {
    # Alter the page variable.
    'Left'  { $global:ImagePage-- }
    'Right' { $global:ImagePage++ }
  }
  # If the page has reached 1 (going left), reset it to the top.
  if ($ImagePage -le 0) { $global:ImagePage = $ImageCount }

  # If the page exceeded the number of images (going right), reset it to the bottom.
  if ($ImagePage -gt $ImageCount) { $global:ImagePage = 1 }

  # Reset the mipmap text box.
  $global:MipmapPage = 0

  # Update the properties on the image viewer.
  ImageViewer_UpdateProperties -Index $ImagePage -MipmapIndex $MipmapPage
}
#==============================================================================================================================================================================================
#  Turns the mipmap page forward or backwards. Launched from buttons "ImgViewMipmapLeft / ImgViewMipmapRight".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_TurnPageMipmap()
{
  # Make sure the image actually has mipmaps.
  if ($ImgViewPreviewMipmap[$ImagePage])
  {
    # If going left, subtract 1. If going right, add 1.
    switch ($this.Name)
    {
      # Alter the page variable.
      'Left'  { $global:MipmapPage-- }
      'Right' { $global:MipmapPage++ }
    }
    # If the page has reached 0 (going left), reset it to the top.
    if ($MipmapPage -lt 0) { $global:MipmapPage = [int]$ImgViewListMipmaps[$ImagePage] }

    # If the page exceeded the number of images (going right), reset it to the bottom.
    if ($MipmapPage -gt [int]$ImgViewListMipmaps[$ImagePage]) { $global:MipmapPage = 0 }
    
    # Set the image as the preview on the button. Remove the background color and text.
    $ImgViewImageBox.BackgroundImage = $ImgViewPreviewMipmap[$ImagePage][$MipmapPage]

    # Update the mipmap text box.
    $ImgViewMipmapIndexBox.Text = $MipmapPage
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER - TEXTURE LIST
#==============================================================================================================================================================================================
#  Updates the image viewer when a texture is selected in the "ImgViewImageList" listbox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_ListSelect()
{
  # Alter the page variable. The image page starts at 1, but the selected index starts at 0 so add 1.
  $global:ImagePage  = $this.SelectedIndex + 1
  $global:MipmapPage = 0

  # Update the properties on the image viewer.
  ImageViewer_UpdateProperties -Index $ImagePage -MipmapIndex $MipmapPage
}
#==============================================================================================================================================================================================
#  Toggles the texture list found on the right side of the image viewer. Launched from "ImgViewListButton" button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_ListToggle()
{
  # Check the current width of the dialog to see if its in the smaller state.
  if ($ImgViewDialog.Width -le (DPISize 496))
  {
    # If its in the smaller state, make it bigger.
    $ImgViewDialog.Size        = DPISize (New-Object Drawing.Size(740, 686))
    $ImgViewDialog.MinimumSize = DPISize (New-Object Drawing.Size(740, 686))
    $ImgViewDialog.MaximumSize = DPISize (New-Object Drawing.Size(740, 686))
    $ImgViewListButton.Text    = 'List <'
  }
  # I shit my pants as I wrote this comment.
  else
  {
    # If its in the bigger state, make it smaller.
    $ImgViewDialog.Size        = DPISize (New-Object Drawing.Size(496, 686))
    $ImgViewDialog.MinimumSize = DPISize (New-Object Drawing.Size(496, 686))
    $ImgViewDialog.MaximumSize = DPISize (New-Object Drawing.Size(496, 686))
    $ImgViewListButton.Text    = 'List >'
  }
}
#==============================================================================================================================================================================================
#  Clears all textures from the texture list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImageViewer_ListClear()
{
  # Clear the background image from the dialog.
  $ImgViewImageBox.BackgroundImage = $null

  # Dispose of all the images in the preview lists.
  DisposeBitmapList -BitmapList $ImgViewPreviewImage
  foreach ($BitmapList in $ImgViewPreviewMipmap) { DisposeBitmapList -BitmapList $BitmapList }

  # Clear all entries from the texture list.
  $ImgViewImageList.Items.Clear()

  # Clear all the lists of the now useless data.
  $ImgViewPreviewImage.Clear()
  $ImgViewListTexture.Clear()
  $ImgViewListDimension.Clear()
  $ImgViewListFormat.Clear()
  $ImgViewListMipmaps.Clear()
  $ImgViewListPaths.Clear()
  $ImgViewListPhyePath.Clear()

  # Loop through all the bitmap preview lists.
  foreach ($BitmapList in $ImgViewPreviewMipmap)
  {
    # Make sure the list contains mipmaps before trying to clear them.
    if ($BitmapList.Count -gt 0) { $BitmapList.Clear() }
  }
  # Reset the dialog state.
  ImageViewer_ToggleDialogState -Enable $false

  # Set the texture and mipmap boxes back to zero.
  $ImgViewTextureIndexBox.Text = '0'
  $ImgViewMipmapIndexBox.Text = '0'

  # Set the initial states of all globals.
  ImageViewer_InitializeGlobals

  # We don't want junk laying around so properly dispose of the temp images.
  ClearPath -LiteralPath $TempFolder
}
#==============================================================================================================================================================================================
#  The initiating function that shows the basic image viewer if TexConv is found.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function InitiateBasicImageViewer()
{
  # If the image viewer is already visible.
  if ($ImgViewDialog.Visible)
  {
    # Simply hide it, don't close it or it will be disposed.
    $ImgViewDialog.Hide()
  }
  # The image viewer is currently hidden so show it.
  else
  {
    # Check to see if TexConv exists.
    if (!(TestPath -LiteralPath $TexConvTool))
    {
      # If it doesn't exist, alert the user.
      $Title   = 'CTT-PS Error'
      $Message = 'Error: DirectXTex TexConv is required but not found! The path to this tool can be configured on the "Options" menu.'
      ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 8) -OffsetY (DPISize 12) -Message $Message

      # Do not run the viewer since it requires TexConv.
      return
    }
    # Set the initial states of all globals.
    ImageViewer_InitializeGlobals

    # Bring it to the forefront.
    $ImgViewDialog.Show()
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: BASIC IMAGE VIEWER DIALOG CREATION
#==============================================================================================================================================================================================
#  Create the dialog that is displayed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ImageViewer()
{
  # Create the dialog and set up properties.
  $global:ImgViewDialog = New-Object Windows.Forms.Form
  $ImgViewDialog.Size = DPISize (New-Object Drawing.Size(496, 686))
  $ImgViewDialog.MinimumSize = DPISize (New-Object Drawing.Size(496, 686))
  $ImgViewDialog.MaximumSize = DPISize (New-Object Drawing.Size(496, 686))
  $ImgViewDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewDialog.Text = 'CTT-PS Basic Image Viewer'
  $ImgViewDialog.MaximizeBox = $true
  $ImgViewDialog.MinimizeBox = $true
  $ImgViewDialog.FormBorderStyle = GetFormBorderStyle
  $ImgViewDialog.StartPosition = "CenterScreen"
  $ImgViewDialog.KeyPreview = $true
  $ImgViewDialog.Add_Shown({ ActivateDialog -Dialog $ImgViewDialog })
  $ImgViewDialog.Add_KeyDown({ EscapeCloseDialog })
  $ImgViewDialog.Add_SizeChanged({ MinimizeAllDialogs })
  $ImgViewDialog.Add_FormClosing({ $ImgViewDialog.Hide() ; $_.Cancel = $true })
  $ImgViewDialog.Icon = $Icon_CTTPSYellow

  # Create the image button and add it to the dialog.
  $global:ImgViewImageBox = New-Object Windows.Forms.Button
  $ImgViewImageBox.Size = DPISize (New-Object Drawing.Size(460, 460))
  $ImgViewImageBox.Location = DPISize (New-Object Drawing.Point(10, 10))
  $ImgViewImageBox.Font = New-Object Drawing.Font('Tahoma', 10, [Drawing.FontStyle]::Bold)
  $ImgViewImageBox.Text = 'Drag and drop an image or click here.'
  $ImgViewImageBox.TabStop = $false
  $ImgViewImageBox.BackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ImgViewImageBox.BackgroundImageLayout = [Windows.Forms.ImageLayout]::Center
  $ImgViewImageBox.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $ImgViewImageBox.FlatAppearance.BorderSize = 1
  $ImgViewImageBox.FlatAppearance.MouseOverBackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ImgViewImageBox.AllowDrop = $true
  $ImgViewImageBox.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
  $ImgViewImageBox.Add_DragDrop({ ImageViewer_DragAndDrop })
  $ImgViewImageBox.Add_Click({ ImageViewer_ButtonClick })
  $ImgViewDialog.Controls.Add($ImgViewImageBox)

  # Create the "Current Texture" label and add it to the dialog.
  $global:ImgViewCurrentTex = New-Object Windows.Forms.Label
  $ImgViewCurrentTex.Size = DPISize (New-Object Drawing.Size(50, 16))
  $ImgViewCurrentTex.Location = DPISize (New-Object Drawing.Point(80, 479))
  $ImgViewCurrentTex.Text = 'Texture:'
  $ImgViewDialog.Controls.Add($ImgViewCurrentTex)

  # Create the "Texture Index" selection box.
  $global:ImgViewTextureIndexBox = New-Object Windows.Forms.TextBox
  $ImgViewTextureIndexBox.Size = DPISize (New-Object Drawing.Size(28, 20))
  $ImgViewTextureIndexBox.Location = DPISize (New-Object Drawing.Point(156, 475)) -AddY $DPIOffsetFix
  $ImgViewTextureIndexBox.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewTextureIndexBox.Text = '0'
  $ImgViewTextureIndexBox.BackColor = [Drawing.SystemColors]::Window
  $ImgViewTextureIndexBox.TabStop = $false
  $ImgViewTextureIndexBox.Enabled = $false
  $ImgViewTextureIndexBox.ReadOnly = $true
  $ImgViewDialog.Controls.Add($ImgViewTextureIndexBox)

  # Create the "Texture Left" button.
  $global:ImgViewTextureLeft = New-Object Windows.Forms.Button
  $ImgViewTextureLeft.Size = DPISize (New-Object Drawing.Size(20, 22))
  $ImgViewTextureLeft.Location = DPISize (New-Object Drawing.Point(134, 474))
  $ImgViewTextureLeft.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewTextureLeft.Name = 'Left'
  $ImgViewTextureLeft.Text = '<'
  $ImgViewTextureLeft.TabStop = $false
  $ImgViewTextureLeft.Add_Click({ ImageViewer_TurnPageImage})
  $ImgViewTextureLeft.Enabled = $false
  $ImgViewDialog.Controls.Add($ImgViewTextureLeft)

  # Create the "Texture Right" button.
  $global:ImgViewTextureRight = New-Object Windows.Forms.Button
  $ImgViewTextureRight.Size = DPISize (New-Object Drawing.Size(20, 22))
  $ImgViewTextureRight.Location = DPISize (New-Object Drawing.Point(186, 474))
  $ImgViewTextureRight.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewTextureRight.Name = 'Right'
  $ImgViewTextureRight.Text = '>'
  $ImgViewTextureRight.TabStop = $false
  $ImgViewTextureRight.Add_Click({ ImageViewer_TurnPageImage })
  $ImgViewTextureRight.Enabled = $false
  $ImgViewDialog.Controls.Add($ImgViewTextureRight)

  # Create the "Current Mipmap" label and add it to the dialog.
  $global:ImgViewCurrentMip = New-Object Windows.Forms.Label
  $ImgViewCurrentMip.Size = DPISize (New-Object Drawing.Size(50, 16))
  $ImgViewCurrentMip.Location = DPISize (New-Object Drawing.Point(240, 479))
  $ImgViewCurrentMip.Text = 'Mipmap:'
  $ImgViewDialog.Controls.Add($ImgViewCurrentMip)

  # Create the "Mipmap Index" selection box.
  $global:ImgViewMipmapIndexBox = New-Object Windows.Forms.TextBox
  $ImgViewMipmapIndexBox.Size = DPISize (New-Object Drawing.Size(28, 20))
  $ImgViewMipmapIndexBox.Location = DPISize (New-Object Drawing.Point(316, 475)) -AddY $DPIOffsetFix
  $ImgViewMipmapIndexBox.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewMipmapIndexBox.Text = '0'
  $ImgViewMipmapIndexBox.BackColor = [Drawing.SystemColors]::Window
  $ImgViewMipmapIndexBox.TabStop = $false
  $ImgViewMipmapIndexBox.Enabled = $false
  $ImgViewMipmapIndexBox.ReadOnly = $true
  $ImgViewDialog.Controls.Add($ImgViewMipmapIndexBox)

  # Create the "Mipmap Left" button.
  $global:ImgViewMipmapLeft = New-Object Windows.Forms.Button
  $ImgViewMipmapLeft.Size = DPISize (New-Object Drawing.Size(20, 22))
  $ImgViewMipmapLeft.Location = DPISize (New-Object Drawing.Point(294, 474))
  $ImgViewMipmapLeft.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewMipmapLeft.Name = 'Left'
  $ImgViewMipmapLeft.Text = '<'
  $ImgViewMipmapLeft.TabStop = $false
  $ImgViewMipmapLeft.Add_Click({ ImageViewer_TurnPageMipmap })
  $ImgViewMipmapLeft.Enabled = $false
  $ImgViewDialog.Controls.Add($ImgViewMipmapLeft)

  # Create the "Mipmap Right" button.
  $global:ImgViewMipmapRight = New-Object Windows.Forms.Button
  $ImgViewMipmapRight.Size = DPISize (New-Object Drawing.Size(20, 22))
  $ImgViewMipmapRight.Location = DPISize (New-Object Drawing.Point(346, 474))
  $ImgViewMipmapRight.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ImgViewMipmapRight.Name = 'Right'
  $ImgViewMipmapRight.Text = '>'
  $ImgViewMipmapRight.TabStop = $false
  $ImgViewMipmapRight.Add_Click({ ImageViewer_TurnPageMipmap })
  $ImgViewMipmapRight.Enabled = $false
  $ImgViewDialog.Controls.Add($ImgViewMipmapRight)

  # Create the "Texture List" button.
  $global:ImgViewListButton = New-Object Windows.Forms.Button
  $ImgViewListButton.Size = DPISize (New-Object Drawing.Size(42, 22))
  $ImgViewListButton.Location = DPISize (New-Object Drawing.Point(428, 474))
  $ImgViewListButton.Text = 'List >'
  $ImgViewListButton.TabStop = $false
  $ImgViewListButton.Add_Click({ ImageViewer_ListToggle })
  $ImgViewDialog.Controls.Add($ImgViewListButton)

  # Create the "Texture List" list box.
  $global:ImgViewImageList = New-Object Windows.Forms.ListBox
  $ImgViewImageList.Size = DPISize (New-Object Drawing.Size(234, 600))
  $ImgViewImageList.Location = DPISize (New-Object Drawing.Point(482, 10))
  $ImgViewImageList.Add_SelectedIndexChanged({ ImageViewer_ListSelect })
  $ImgViewImageList.TabStop = $false
  $ImgViewImageList.AllowDrop = $true
  $ImgViewImageList.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
  $ImgViewImageList.Add_DragDrop({ ImageViewer_DragAndDrop })
  $ImgViewDialog.Controls.Add($ImgViewImageList)

  # Create a panel that holds the texture properties.
  $global:ImgViewProperties = New-Object Windows.Forms.Panel
  $ImgViewProperties.Size = DPISize (New-Object Drawing.Size(460, 106))
  $ImgViewProperties.Location = DPISize (New-Object Drawing.Point(10, 500))
  $ImgViewProperties.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ImgViewProperties.AutoScroll = $true
  $ImgViewProperties.Visible = $false
  $ImgViewDialog.Controls.Add($ImgViewProperties)

  # Create a panel that holds the texture properties.
  $global:ImgViewDummyProps = New-Object Windows.Forms.Panel
  $ImgViewDummyProps.Size = DPISize (New-Object Drawing.Size(460, 106))
  $ImgViewDummyProps.Location = DPISize (New-Object Drawing.Point(10, 500))
  $ImgViewDummyProps.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ImgViewDummyProps.AutoScroll = $true
  $ImgViewDialog.Controls.Add($ImgViewDummyProps)

  # Create the "Texture Name" label.
  $global:ImgViewTextureLabel = New-Object Windows.Forms.TextBox
  $ImgViewTextureLabel.Size = DPISize (New-Object Drawing.Size(600, 16))
  $ImgViewTextureLabel.Location = DPISize (New-Object Drawing.Point(10, 5))
  $ImgViewTextureLabel.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ImgViewTextureLabel.Text = 'Name: Example.dds'
  $ImgViewTextureLabel.BorderStyle = 0
  $ImgViewTextureLabel.ReadOnly = $true
  $ImgViewTextureLabel.BackColor = $ImgViewDialog.BackColor
  $ImgViewTextureLabel.TabStop = $false
  $ImgViewProperties.Controls.Add($ImgViewTextureLabel)

  # Create the "Texture Dimensions" label.
  $global:ImgViewDimensionsLabel = New-Object Windows.Forms.TextBox
  $ImgViewDimensionsLabel.Size = DPISize (New-Object Drawing.Size(200, 16))
  $ImgViewDimensionsLabel.Location = DPISize (New-Object Drawing.Point(10, 20))
  $ImgViewDimensionsLabel.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ImgViewDimensionsLabel.Text = 'Dimensions: 64x64'
  $ImgViewDimensionsLabel.BorderStyle = 0
  $ImgViewDimensionsLabel.ReadOnly = $true
  $ImgViewDimensionsLabel.BackColor = $ImgViewDialog.BackColor
  $ImgViewDimensionsLabel.TabStop = $false
  $ImgViewProperties.Controls.Add($ImgViewDimensionsLabel)

  # Create the "Texture Format" label.
  $global:ImgViewFormatLabel = New-Object Windows.Forms.TextBox
  $ImgViewFormatLabel.Size = DPISize (New-Object Drawing.Size(200, 16))
  $ImgViewFormatLabel.Location = DPISize (New-Object Drawing.Point(10, 35))
  $ImgViewFormatLabel.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ImgViewFormatLabel.Text = 'Format: BC7'
  $ImgViewFormatLabel.BorderStyle = 0
  $ImgViewFormatLabel.ReadOnly = $true
  $ImgViewFormatLabel.BackColor = $ImgViewDialog.BackColor
  $ImgViewFormatLabel.TabStop = $false
  $ImgViewProperties.Controls.Add($ImgViewFormatLabel)

  # Create the "Mipmaps" label.
  $global:ImgViewMipmapLabel = New-Object Windows.Forms.TextBox
  $ImgViewMipmapLabel.Size = DPISize (New-Object Drawing.Size(200, 16))
  $ImgViewMipmapLabel.Location = DPISize (New-Object Drawing.Point(10, 50))
  $ImgViewMipmapLabel.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ImgViewMipmapLabel.Text = 'Mipmaps: 7'
  $ImgViewMipmapLabel.BorderStyle = 0
  $ImgViewMipmapLabel.ReadOnly = $true
  $ImgViewMipmapLabel.BackColor = $ImgViewDialog.BackColor
  $ImgViewMipmapLabel.TabStop = $false
  $ImgViewProperties.Controls.Add($ImgViewMipmapLabel)

  # Create the "Texture Path" label.
  $global:ImgViewPathLabel = New-Object Windows.Forms.TextBox
  $ImgViewPathLabel.Size = DPISize (New-Object Drawing.Size(800, 28))
  $ImgViewPathLabel.Location = DPISize (New-Object Drawing.Point(10, 65))
  $ImgViewPathLabel.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ImgViewPathLabel.Text = 'Path: C:\Users\UserName\Pictures\ExamplePath'
  $ImgViewPathLabel.BorderStyle = 0
  $ImgViewPathLabel.ReadOnly = $true
  $ImgViewPathLabel.BackColor = $ImgViewDialog.BackColor
  $ImgViewPathLabel.TabStop = $false
  $ImgViewProperties.Controls.Add($ImgViewPathLabel)

  # Create a button to clear all textures from the viewer.
  $global:ImgViewClearButton = New-Object Windows.Forms.Button
  $ImgViewClearButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ImgViewClearButton.Location = DPISize (New-Object Drawing.Point(9, 612))
  $ImgViewClearButton.Text = 'Clear'
  $ImgViewClearButton.TabStop = $false
  $ImgViewClearButton.Add_Click({ ImageViewer_ListClear })
  $ImgViewClearButton.Anchor = ([Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Left)
  $ImgViewDialog.Controls.Add($ImgViewClearButton)

  # Create a tool tip.
  $global:ImgViewClearTip = New-Object Windows.Forms.ToolTip
  $ImgViewClearTip.InitialDelay = $ToolTipDelay
  $ImgViewClearTip.AutoPopDelay = $ToolTipDuration
  $ImgViewClearTipString = 'Clears all textures from the viewer.'
  $ImgViewClearTip.SetToolTip($ImgViewClearButton, $ImgViewClearTipString)

  # Create a button to write image to PNG.
  $global:ImgViewWritePNGButton = New-Object Windows.Forms.Button
  $ImgViewWritePNGButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ImgViewWritePNGButton.Location = DPISize (New-Object Drawing.Point(95, 612))
  $ImgViewWritePNGButton.Text = 'Export PNG'
  $ImgViewWritePNGButton.TabStop = $false
  $ImgViewWritePNGButton.Enabled = $false
  $ImgViewWritePNGButton.Add_Click({ ImageViewer_WriteToPNG })
  $ImgViewDialog.Controls.Add($ImgViewWritePNGButton)

  # Create a tool tip.
  $global:ImgViewWritePNGTip = New-Object Windows.Forms.ToolTip
  $ImgViewWritePNGTip.InitialDelay = $ToolTipDelay
  $ImgViewWritePNGTip.AutoPopDelay = $ToolTipDuration
  $ImgViewWritePNGTipString = 'Writes the current image to a PNG file.'
  $ImgViewWritePNGTip.SetToolTip($ImgViewWritePNGButton, $ImgViewWritePNGTipString)

  # Create a button to close the dialog.
  $global:ImgViewCloseButton = New-Object Windows.Forms.Button
  $ImgViewCloseButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ImgViewCloseButton.Location = DPISize (New-Object Drawing.Point(391, 612))
  $ImgViewCloseButton.Text = 'Close'
  $ImgViewCloseButton.TabStop = $false
  $ImgViewCloseButton.Add_Click({ $ImgViewDialog.Hide() ; ImageViewer_ListClear })
  $ImgViewDialog.Controls.Add($ImgViewCloseButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: CREATE RESOURCE PACK DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $ResourceDialog           - Form         - Global
#  $ResOpGroupBox            - GroupBox     - Global
#  $ResOpLabel               - Label        - Local
#  $ResOpTip                 - ToolTip      - Local
#  $ResOpCombo               - ComboBox     - Global
#  $ResInputGroupBox         - GroupBox     - Global
#  $ResInputTip              - ToolTip      - Local
#  $ResInputTextBox          - TextBox      - Global
#  $ResInputButton           - Button       - Global
#  $ResOutputGroupBox        - GroupBox     - Global
#  $ResOutputTip             - ToolTip      - Local
#  $ResOutputTextBox         - TextBox      - Global
#  $ResOutputButton          - Button       - Global
#  $ResInfoGroupBox          - GroupBox     - Global
#  $ResGameIDLabel           - Label        - Global
#  $ResGameIDTip             - ToolTip      - Local
#  $ResGameIDTextBox         - TextBox      - Global
#  $ResPackNameLabel         - Label        - Global
#  $ResPackNameTip           - ToolTip      - Local
#  $ResPackNameTextBox       - TextBox      - Global
#  $ResPackIDLabel           - Label        - Global
#  $ResPackIDTip             - ToolTip      - Local
#  $ResPackIDTextBox         - TextBox      - Global
#  $ResVersionLabel          - Label        - Global
#  $ResVersionTip            - ToolTip      - Local
#  $ResVersionTextBox        - TextBox      - Global
#  $ResAuthorsLabel          - Label        - Global
#  $ResAuthorsTip            - ToolTip      - Local
#  $ResAuthorsTextBox        - TextBox      - Global
#  $ResWebsiteLabel          - Label        - Global
#  $ResWebsiteTip            - ToolTip      - Local
#  $ResWebsiteTextBox        - TextBox      - Global
#  $ResDescriptionLabel      - Label        - Global
#  $ResDescriptionTip        - ToolTip      - Local
#  $ResDescriptionTextBox    - TextBox      - Global
#  $ResZipFileNameLabel      - Label        - Global
#  $ResZipFileNameTip        - ToolTip      - Local
#  $ResZipFileNameTextBox    - TextBox      - Global
#  $ResLogoLabel             - Label        - Global
#  $ResLogoTip               - ToolTip      - Local
#  $ResLogoImage             - Button       - Global
#  $ResLogoAdjustLabel       - Label        - Global
#  $ResLogoAdjustTip         - ToolTip      - Local
#  $ResLogoAdjustCombo       - ComboBox     - Global
#  $ResStartButton           - Button       - Global
#  $ResResetButton           - Button       - Global
#  $ResCancelButton          - Button       - Global
#==============================================================================================================================================================================================
#  Variables that store resource pack information. Automatically filled in with a full import.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $ResourcePack             - The path of the resource pack that has been imported with a full import.
#  $ResourceName             - The name of the resource pack.
#  $ResourceID               - Unique identifier for the pack.
#  $ResourceGameID           - The GameID for the pack.
#  $ResourceVersion          - The version of the pack.
#  $ResourceAuthors          - Authors of the pack.
#  $ResourceWebsite          - Website for the pack.
#  $ResourceDescription      - A short description of the pack.
#  $ResourceZipName          - The name of the zip file.
#==============================================================================================================================================================================================
#  These messages are used in multiple locations, so store them in reference variables.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
$ResourceYesNoTitle   = 'Extract from ZIP?'
$ResourceYesNoMessage = 'Press "Yes" to also extract the textures folder. Press "No" if you plan to add/update all textures manually. Use the "Edit Textures" button to manually add them.'
$ResourceOffMessage   = '<< This field is not used in this operation. >>'
$ResourceZipMessage   = '<< Import a Resource Pack Folder or ZIP File >>'
#==============================================================================================================================================================================================
#  CTT GUI: RESOURCE PACK DIALOG
#==============================================================================================================================================================================================
#  Initiates the resource pack dialog and shows it to the user.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function InitiateResourcePackDialog()
{
  # Update all the values on the dialog.
  $ResPackNameTextBox.Text    = $ResourceName
  $ResPackIDTextBox.Text      = $ResourceID
  $ResVersionTextBox.Text     = $ResourceVersion
  $ResDescriptionTextBox.Text = $ResourceDescription
  $ResAuthorsTextBox.Text     = $ResourceAuthors
  $ResWebsiteTextBox.Text     = $ResourceWebsite
  $ResGameIDTextBox.Text      = $ResourceGameID
  $ResZipFileNameTextBox.Text = $ResourceZipName

  # Show the dialog to the user.
  $ResourceDialog.Show() | Out-Null
}
#==============================================================================================================================================================================================
#  Shows or hides certain options depending on the current dialog size.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResourceToggleVisibilities([bool]$Visibility)
{
  # Toggle the visibility of these options.
  $ResInputGroupBox.Visible   = $Visibility
  $ResGameIDLabel.Visible     = $Visibility
  $ResGameIDTextBox.Visible   = $Visibility
  $ResLogoLabel.Visible       = $Visibility
  $ResLogoImage.Visible       = $Visibility
  $ResLogoAdjustLabel.Visible = $Visibility
  $ResLogoAdjustCombo.Visible = $Visibility
  $ResImportButton.Visible    = $Visibility
  $ResModPackGroupBox.Visible = $Visibility
}
#==============================================================================================================================================================================================
#  Resizes the resource pack dialog to a smaller form factor for "Only Create Manifest.json".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResourceResizeSmall()
{
  # Shrink the dialog since some options are going to be removed.
  $ResourceDialog.MinimumSize     = DPISize (New-Object Drawing.Size(395, 451))
  $ResourceDialog.MaximumSize     = DPISize (New-Object Drawing.Size(395, 451))

  # Set the locations.
  $ResPackNameLabel.Location      = DPISize (New-Object Drawing.Point(6, 24))
  $ResPackNameTextBox.Location    = DPISize (New-Object Drawing.Point(80, 21))
  $ResPackIDLabel.Location        = DPISize (New-Object Drawing.Point(6, 54))
  $ResPackIDTextBox.Location      = DPISize (New-Object Drawing.Point(80, 51))
  $ResVersionLabel.Location       = DPISize (New-Object Drawing.Point(6, 84))
  $ResVersionTextBox.Location     = DPISize (New-Object Drawing.Point(80, 81))
  $ResAuthorsLabel.Location       = DPISize (New-Object Drawing.Point(6, 114))
  $ResAuthorsTextBox.Location     = DPISize (New-Object Drawing.Point(80, 111))
  $ResWebsiteLabel.Location       = DPISize (New-Object Drawing.Point(6, 144))
  $ResWebsiteTextBox.Location     = DPISize (New-Object Drawing.Point(80, 141))
  $ResDescriptionLabel.Location   = DPISize (New-Object Drawing.Point(6, 174))
  $ResDescriptionPanel.Location   = DPISize (New-Object Drawing.Point(80, 171))
  $ResOutputGroupBox.Location     = DPISize (New-Object Drawing.Point(10, 60))
  $ResStartButton.Location        = DPISize (New-Object Drawing.Point(10, 374))
  $ResResetButton.Location        = DPISize (New-Object Drawing.Point(116, 374))
  $ResCancelButton.Location       = DPISize (New-Object Drawing.Point(270, 374))

  # Resize the panel that holds the JSON options.
  $ResInfoGroupBox.Size           = DPISize (New-Object Drawing.Size(360, 254))

  # Toggle visibility of some options.
  ResourceToggleVisibilities -Visibility $false
}
#==============================================================================================================================================================================================
#  Resizes the resource pack dialog to the standard size.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResourceResizeNormal()
{
  # Grow the dialog to fit all the option.
  $ResourceDialog.MinimumSize   = DPISize (New-Object Drawing.Size(766, 518))
  $ResourceDialog.MaximumSize   = DPISize (New-Object Drawing.Size(766, 518))

  # Set the locations for all the label locations.
  $ResPackNameLabel.Location    = DPISize (New-Object Drawing.Point(6, 54))
  $ResPackNameTextBox.Location  = DPISize (New-Object Drawing.Point(80, 51))
  $ResPackIDLabel.Location      = DPISize (New-Object Drawing.Point(6, 84))
  $ResPackIDTextBox.Location    = DPISize (New-Object Drawing.Point(80, 81))
  $ResVersionLabel.Location     = DPISize (New-Object Drawing.Point(6, 114))
  $ResVersionTextBox.Location   = DPISize (New-Object Drawing.Point(80, 111))
  $ResAuthorsLabel.Location     = DPISize (New-Object Drawing.Point(6, 144))
  $ResAuthorsTextBox.Location   = DPISize (New-Object Drawing.Point(80, 141))
  $ResWebsiteLabel.Location     = DPISize (New-Object Drawing.Point(6, 174))
  $ResWebsiteTextBox.Location   = DPISize (New-Object Drawing.Point(80, 171))
  $ResDescriptionLabel.Location = DPISize (New-Object Drawing.Point(6, 204))
  $ResDescriptionPanel.Location = DPISize (New-Object Drawing.Point(80, 201))
  $ResOutputGroupBox.Location   = DPISize (New-Object Drawing.Point(380, 60))
  $ResStartButton.Location      = DPISize (New-Object Drawing.Point(10, 440))
  $ResResetButton.Location      = DPISize (New-Object Drawing.Point(332, 440))
  $ResCancelButton.Location     = DPISize (New-Object Drawing.Point(640, 440))

  # Resize the panel that holds the JSON options.
  $ResInfoGroupBox.Size         = DPISize (New-Object Drawing.Size(730, 320))

  # Toggle visibility of some options.
  ResourceToggleVisibilities -Visibility $true
}
#==============================================================================================================================================================================================
#  Update the dialog aesthetics based on the selected Resource Pack Operation.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateResourcePackSelection([string]$Index)
{
  # While this code is not exactly gorgeous, it is tremendously easier to understand than the mess that it replaced.
  switch ($Index)
  {
    # Create a Resource Pack
    '0' {
          # Set the size of the resource dialog.
          ResourceResizeNormal

          # Toggle the availability of a few options.
          $ResManagerGroupBox.Enabled = $false
          $ResInfoGroupBox.Enabled    = $true
          $ResInputGroupBox.Enabled   = $true
          $ResModPackGroupBox.Visible = $false

          # Message that is displayed on the resource pack root folder field.
          $ResourcePackMessage = $ResourceOffMessage
        }
    # Update a Resource Pack
    '1' {
          # Set the size of the resource dialog.
          ResourceResizeNormal

          # Toggle the availability of a few options.
          $ResManagerGroupBox.Enabled = $true
          $ResInfoGroupBox.Enabled    = ($ResourcePack -ne '')
          $ResInputGroupBox.Enabled   = $false
          $ResModPackGroupBox.Visible = $true

          # Message that is displayed on the resource pack root folder field.
          $ResourcePackMessage = $ResourceZipMessage
        }
    # Only Create Manifest.json File
    '2' {
          # Set the size of the resource dialog.
          ResourceResizeSmall

          # Toggle the availability of a few options.
          $ResManagerGroupBox.Enabled = $false
          $ResInfoGroupBox.Enabled    = $true
          $ResInputGroupBox.Enabled   = $true
          $ResModPackGroupBox.Visible = $false

          # Message that is displayed on the resource pack root folder field.
          $ResourcePackMessage = $ResourceOffMessage
        }
  }
  # If a pack has been loaded, show the pack's location. If it hasn't been loaded, show the notice message.
  if ($ResourcePack -eq '') { $ResModPackTextBox.Text = $ResourcePackMessage } else { $ResModPackTextBox.Text = $ResourcePack }
}
#==============================================================================================================================================================================================
#  Opens the folder that contains textures when editing a resource pack.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_OpenTextureFolder()
{
  # If a pack hasn't been imported, this will have no value.
  if ($ResourcePack -ne '')
  {
    # A pack will always contain a "textures\GameID" folder.
    $ResPackTextures = $ResourcePack + '\textures\' + $ResourceGameID

    # Just to be sure, make sure that path exists.
    if (TestPath -LiteralPath $ResPackTextures)
    {
      # If it does, open up the path.
      Start-Process -FilePath $ResPackTextures
    }
  }
}
#==============================================================================================================================================================================================
#  Prevent the Resource Dialog from being closed out completely.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResourceDialogClose()
{
  # Do not allow the dialog to fully close.
  $_.Cancel = $true

  # If the master loop is not running, hide the dialog.
  if (!$MasterLoopRunning) { $ResourceDialog.Hide() }
}
#==============================================================================================================================================================================================
#  Resets all information on the resource dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResetResourceDialog()
{
  # Force the selected index of the pack manager to 0.
  $ResManagerCombo.SelectedIndex = 0

  # Reset all the values used in the resource pack.
  $global:ResourcePack        = ''
  $global:ResourceName        = ''
  $global:ResourceID          = ''
  $global:ResourceVersion     = ''
  $global:ResourceDescription = ''
  $global:ResourceAuthors     = ''
  $global:ResourceWebsite     = ''
  $global:ResourceGameID      = ''
  $global:ResourceZipName     = ''
  $global:ResourceLogo        = ''
  $global:ResourceLogoAdjust  = 'No Scaling | Max 256x256 Resolution'
  $global:ResLogoBase         = ''

  # Update all the values on the dialog.
  $ResPackNameTextBox.Text         = $ResourceName
  $ResPackIDTextBox.Text           = $ResourceID
  $ResVersionTextBox.Text          = $ResourceVersion
  $ResDescriptionTextBox.Text      = $ResourceDescription
  $ResAuthorsTextBox.Text          = $ResourceAuthors
  $ResWebsiteTextBox.Text          = $ResourceWebsite
  $ResGameIDTextBox.Text           = $ResourceGameID
  $ResZipFileNameTextBox.Text      = $ResourceZipName
  $ResLogoImage.Text               = 'Drag and drop a PNG/JPG image file or click here to add a logo.'
  $ResLogoImage.BackgroundImage    = $null
  $ResLogoAdjustCombo.SelectedItem = $ResourceLogoAdjust

  # Set the visibility of the resource pack path and update the text box.
  switch ($ResOpCombo.SelectedIndex)
  {
    # Toggle the pack manager, set the visibility of the resource pack folder, and reset the text on the resource pack folder.
    '0' { $ResManagerGroupBox.Enabled = $ResModPackGroupBox.Visible = $false ; $ResModPackTextBox.Text = $ResourceOffMessage }
    '1' { $ResManagerGroupBox.Enabled = $ResModPackGroupBox.Visible = $true  ; $ResModPackTextBox.Text = $ResourceZipMessage }
    '2' { $ResManagerGroupBox.Enabled = $ResModPackGroupBox.Visible = $false ; $ResModPackTextBox.Text = $ResourceZipMessage }
  }
  # Disable the information fields for "Update a Resource Pack".
  $ResInfoGroupBox.Enabled = ($ResOpCombo.SelectedIndex -ne 1)

  # The pack has been unloaded so disable the texture folder button.
  $ResTexFolderButton.Enabled = $false
}
#==============================================================================================================================================================================================
#  CTT GUI: RESOURCE PACK DIALOG - IMPORT FILE FUNCTIONS
#==============================================================================================================================================================================================
function ValidateResourceZIPFile([string]$ZipFilePath)
{
  # The file needs to be tested to see if its in a proper format.
  $ZipArchive = [IO.Compression.ZipFile]::OpenRead($ZipFilePath)

  # This will store the ZIP file entries in the form of a string list.
  $EntryStrings = New-Object Collections.Generic.List[string]

  # Loop through the ZIP file entries and add them to the string list.
  foreach ($Entry in $ZipArchive.Entries) { $EntryStrings.Add( $Entry.ToString() ) }

  # Make sure it has the signature files and texture path.
  $EntryChecks = New-Object bool[] 3
  $EntryChecks[0] = ($EntryStrings -contains "logo.png")
  $EntryChecks[1] = ($EntryStrings -contains "manifest.json")
  $EntryChecks[2] = ($EntryStrings -contains "textures/")

  # Now verify those strings exist.
  if (!(TestBooleanArray -And -Array $EntryChecks))
  {
    # Show a dialog that tells the user this isn't going to work.
      $Title   = 'CTT-PS Error'
      $Message = 'Error: Resource Pack is not in the proper format.'
      ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 26) -OffsetY (DPISize 18) -Message $Message

    # This ZIP file is not in the proper format.
    return $false
  }
  # The check passed so keep on keeping on.
  return $true
}
#==============================================================================================================================================================================================
#  Attempts to import the GameID from a zip file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportGameIDFromZip([string]$ZipFilePath)
{
  # Open and read the zip file.
  $ZipArchive = [IO.Compression.ZipFile]::OpenRead($ZipFilePath)

  # Getting the GameID is tricky. We need to find the "textures" path WITH the GameID, so check at least the first 5 entries in the zip file.
  for ($i = 0 ; $i -le 5 ; $i++)
  {
    # Convert the entry to a string so manipulation can be performed.
    $EntryString = $ZipArchive.Entries[$i].ToString()

    # See if it contains "textures/", which is 9 spaces long. We don't want this, we want one with the GameID.
    if (($EntryString -like 'textures/*') -and ($EntryString.Length -gt 9))
    {
      # If we're here, the entry should have the GameID. Grab it by splitting on the folder separator.
      $TempID = $EntryString.Split('/', 2)
      $GameID = $TempID[1].TrimEnd('/')

      # To prevent overwriting the GameID, end the loop now.
      break
    }
  }
  # Break all ties to the archive so it isn't locked.
  $ZipArchive.Dispose()

  # The name has now been retrieved, but it also contains another forward slash so eliminate that too.
  return $GameID 
}
#==============================================================================================================================================================================================
#  Imports a ZIP file or JSON file and updates the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportJSON([string]$ManifestFile)
{
  # Read the JSON file.
  $Content = Get-Content -LiteralPath $ManifestFile

  # Update the GUI with the imported values. Loop through each line in the JSON.
  foreach ($Line in $Content)
  {
    # Only look for lines that have value.
    if ($Line -like '*:*')
    {
      # Get only the value by splitting on the ':' and abusing a bunch of string replacement.
      $Split = $Line.Replace('"', '').Replace('[', '').Replace(']', '').TrimEnd(',').Split(':', 2)

      # The value needed will be in array [1]. Trim the space from the beginning.
      $ImportedValue = $Split[1].TrimStart(' ')

      # Get the correct line by searching for the value header.
      switch -wildcard ($Line)
      {
        # Set the appropriate variable based on the line and update the GUI with the new value.
        '*"name"*'        { $global:ResourceName        = $ResPackNameTextBox.Text    = $ImportedValue }
        '*"id"*'          { $global:ResourceID          = $ResPackIDTextBox.Text      = $ImportedValue }
        '*"version"*'     { $global:ResourceVersion     = $ResVersionTextBox.Text     = $ImportedValue }
        '*"authors"*'     { $global:ResourceAuthors     = $ResAuthorsTextBox.Text     = $ImportedValue }
        '*"website"*'     { $global:ResourceWebsite     = $ResWebsiteTextBox.Text     = $ImportedValue }
        '*"description"*' { $global:ResourceDescription = $ResDescriptionTextBox.Text = $ImportedValue }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Imports a ZIP file and updates the GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportZIP([string]$ZipFile, [string]$Method)
{
  # Show the label that a file is being imported.
  $ResWaitLabel.Visible = $true

  # Disable all dialogs.
  ToggleDialogStates -State $false

  # Extract the GameID from the zip, store it in the global, and update the text box.
  $global:ResourceGameID = $ResGameIDTextBox.Text = Resource_ImportGameIDFromZip -ZipFilePath $ZipFile

  # Set the name of the zip file and update the textbox.
  $global:ResourceZipName = $ResZipFileNameTextBox.Text = (Get-Item -LiteralPath $ZipFile).Name

  # Create a temporary path to extract files to, store it into a global, and update the text box with it.
  $global:ResourcePack = $ResModPackTextBox.Text = CreatePath -LiteralPath ($TempFolder + '\ResPackExtracted')

  # Partial method only imports the GameID, manifest.json, and logo.
  if ($Method -eq 'Partial')
  {
    # Extract the logo and JSON files and store them in a variable.
    $OutputLogo = ZipExtractFile -ZipFilePath $ZipFile -ExtractFile 'logo.png' -OutputPath $ResourcePack
    $OutputJSON = ZipExtractFile -ZipFilePath $ZipFile -ExtractFile 'manifest.json' -OutputPath $ResourcePack

    # Since we're only doing a partial import, this folder will not exist so create it.
    CreatePath -LiteralPath ($ResourcePack + '\textures\' + $ResourceGameID) -NoReturn
  }
  # Full method imports everything in the resource pack.
  elseif ($Method -eq 'Full')
  {
    # Create links to these files as they will need to referenced later.
    $OutputLogo = $ResourcePack + '\logo.png'
    $OutputJSON = $ResourcePack + '\manifest.json'

    # If the output already exists, remove all files and recreate it.
    RemovePath -LiteralPath $ResourcePack
    CreatePath -LiteralPath $ResourcePack -NoReturn

    # Extract the entire ZIP to the destination folder.
    ZipExtractArchive -ZipFilePath $ZipFile -OutputPath $ResourcePack
  }
  # Import the values from the JSON file.
  Resource_ImportJSON -ManifestFile $OutputJSON

  # Import the logo image.
  ResAddImage_CreateLogo -ImageFile $OutputLogo -ForceNew

  # Hide the wait label now that the deed is done.
  $ResWaitLabel.Visible = $false

  # Disable all dialogs.
  ToggleDialogStates -State $true

  # Enable these options now that a pack has been fully imported.
  $ResInfoGroupBox.Enabled    = $true
  $ResTexFolderButton.Enabled = $true
  
  # Select the option "Add a Pack" to the resource pack manager.
  $global:BlockSelection = $true
  $ResManagerCombo.SelectedIndex = 0
  $global:BlockSelection = $false
}
#==============================================================================================================================================================================================
#  Imports a ZIP file or JSON file by dragging a file onto the import button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFile_DragDrop()
{
  # Get the item that has been dropped onto the button.
  if (!($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))) { return }

  # Get the data of the item that has been dropped.
  $DroppedFile = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

  # If a bogus path somehow ended up here, run like the wind.
  if (!(TestPath -LiteralPath $DroppedFile)) { return }

  # Get the dropped file as an object.
  $DroppedItem = Get-Item -LiteralPath $DroppedFile

  # Detect JSON files and take them on a special journey.
  if ($DroppedItem.Extension -eq '.json')
  {
    # Simply import the JSON file.
    Resource_ImportJSON -ManifestFile $DroppedFile
  }
  # ZIP files have two methods of importing: extract textures, or don't extract them.
  elseif ($DroppedItem.Extension -eq $ZIP)
  {
    # Make sure the resource pack ZIP is in a proper format.
    if (!(ValidateResourceZIPFile -ZipFilePath $DroppedFile)) { return }
  
    # Ask the user if they also want to extract all textures from the zip file.
    $DialogChoice = ShowYesNoDialog -Title $ResourceYesNoTitle -SizeX (DPISize 280) -SizeY (DPISize 40) -OffsetX (DPISize 18) -OffsetY (DPISize 6) -Message $ResourceYesNoMessage

    # A switch statement because why the fuck not?
    switch ($DialogChoice)
    {
      # Methods: Use "Full" for extract textures, use "Partial" to create an empty texture folder.
      $true   { Resource_ImportZIP -ZipFile $DroppedFile -Method 'Full' }
      $false  { Resource_ImportZIP -ZipFile $DroppedFile -Method 'Partial' }
    }
  }
}
#==============================================================================================================================================================================================
#  Imports a ZIP file or JSON file by clicking on the import button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFile_ButtonClick()
{
  # Load the selected file.
  $ImportedFile = Get-FileName -StartPath $BaseFolder -FileName '*' -Description 'ZIP/JSON File'
  
  # If a bogus path somehow ended up here, run like the wind.
  if (!(TestPath -LiteralPath $ImportedFile)) { return }

  # Get the imported file as an object.
  $ImportedItem = Get-Item -LiteralPath $ImportedFile

  # Detect JSON files and take them on a special journey.
  if ($ImportedItem.Extension -eq '.json')
  {
    # Simply import the JSON file.
    Resource_ImportJSON -ManifestFile $ImportedFile
  }
  # ZIP files have two methods of importing: extract textures, or don't extract them.
  elseif ($ImportedItem.Extension -eq $ZIP)
  {
    # Make sure the resource pack ZIP is in a proper format.
    if (!(ValidateResourceZIPFile -ZipFilePath $ImportedFile)) { return }
  
    # Ask the user if they also want to extract all textures from the zip file.
    $DialogChoice = ShowYesNoDialog -Title $ResourceYesNoTitle -SizeX (DPISize 280) -SizeY (DPISize 40) -OffsetX (DPISize 18) -OffsetY (DPISize 6) -Message $ResourceYesNoMessage

    # Another switch statement because again, why the fuck not?
    switch ($DialogChoice)
    {
      # Methods: Use "Full" for extract textures, use "Partial" to create an empty texture folder.
      $true   { Resource_ImportZIP -ZipFile $ImportedFile -Method 'Full' }
      $false  { Resource_ImportZIP -ZipFile $ImportedFile -Method 'Partial' }
    }
  }
  # If the extension is unsupported, display an error message.
  else
  {
    # Display a warning to the user.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: Incorrect file type. Please select a Resource Pack compiled ".zip" file or a "manifest.json" file.'
    ShowOKDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 22) -OffsetY (DPISize 12) -Message $Message
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: RESOURCE PACK DIALOG - IMPORT FOLDER FUNCTIONS
#==============================================================================================================================================================================================
#  Verifies that the path is linked to a resource pack.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFolder_Verify([string]$ResPackPath)
{
  # Create an array of conditions.
  $ResVerify = New-Object bool[] 3
  $ResVerify[0] = (TestPath -LiteralPath ($ResPackPath + '\textures\'))
  $ResVerify[1] = (TestPath -LiteralPath ($ResPackPath + '\logo.png'))
  $ResVerify[2] = (TestPath -LiteralPath ($ResPackPath + '\manifest.json'))

  # If all conditions pass, return the image format.
  return (TestBooleanArray -And -Array $ResVerify)
}
#==============================================================================================================================================================================================
#  The final function to run when a resource pack folder is included.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFolder_Finish([string]$ResPackPath)
{
  # Disable all dialogs.
  ToggleDialogStates -State $false

  # There should only be a single folder in the "textures" folder.
  foreach ($Folder in Get-ChildItem -LiteralPath ($ResPackPath + '\textures\'))
  {
    # Set the GameID to the name of the folder.
    $global:ResourceGameID = $ResGameIDTextBox.Text = $Folder

    # Shouldn't be necessary as there is only one folder, but meh just in case.
    break
  }
  # Set the name for the zip to name of the folder.
  $global:ResourceZipName = $ResZipFileNameTextBox.Text = (Get-Item -LiteralPath $ResPackPath).BaseName + $ZIP

  # Update the res pack path with the input path.
  $global:ResourcePack = $ResModPackTextBox.Text = $ResPackPath

  # Import the values from the JSON file.
  Resource_ImportJSON -ManifestFile ($ResPackPath + '\manifest.json')

  # Add the image to the button.
  ResAddImage_CreateLogo -ImageFile ($ResPackPath + '\logo.png') -ForceNew

  # Enable these options now that a pack has been fully imported.
  $ResInfoGroupBox.Enabled    = $true
  $ResTexFolderButton.Enabled = $true

  # Disable all dialogs.
  ToggleDialogStates -State $true

  # If the entry exists in the database, force selecting it.
  ResPackManager_SelectEntryIfExists
}
#==============================================================================================================================================================================================
#  Updates the "Input Path" and "Output Path" with a drag and drop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFolder_DragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if (!($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))) { return }

  # Create a list of the data to select the first item from the list.
  $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

  # Make sure the path is a folder.
  if (TestPath -LiteralPath $DroppedPath -PathType 'Container')
  {
    # Verify that the selected folder is a valid resource pack.
    if (Resource_ImportFolder_Verify -ResPackPath $DroppedPath)
    {
      # Update the path using a function that is shared with the below function.
      Resource_ImportFolder_Finish -ResPackPath $DroppedPath
    }
  }
  # Bonus: If the dropped type is a file, support loading in ZIP and JSON.
  elseif (TestPath -LiteralPath $DroppedPath -PathType 'Leaf')
  {
    # Get the dropped file as an object.
    $DroppedItem = Get-Item -LiteralPath $DroppedPath

    # Detect JSON files and take them on a special journey.
    if ($DroppedItem.Extension -eq '.json')
    {
      # Simply import the JSON file.
      Resource_ImportJSON -ManifestFile $DroppedPath
    }
    # ZIP files have two methods of importing: extract textures, or don't extract them.
    elseif ($DroppedItem.Extension -eq $ZIP)
    {
      # Make sure the resource pack ZIP is in a proper format.
      if (!(ValidateResourceZIPFile -ZipFilePath $DroppedPath)) { return }

      # Ask the user if they also want to extract all textures from the zip file.
      $DialogChoice = ShowYesNoDialog -Title $ResourceYesNoTitle -SizeX (DPISize 280) -SizeY (DPISize 40) -OffsetX (DPISize 18) -OffsetY (DPISize 6) -Message $ResourceYesNoMessage

      # And yet another switch statement because why the fuck not?!
      switch ($DialogChoice)
      {
        # Methods: Use "Full" for extract textures, use "Partial" to create an empty texture folder.
        $true   { Resource_ImportZIP -ZipFile $DroppedPath -Method 'Full' }
        $false  { Resource_ImportZIP -ZipFile $DroppedPath -Method 'Partial' }
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Updates the "Input Path" and "Output Path" from the button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFolder_Button()
{
  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $DesktopPath

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (TestPath -LiteralPath $SelectedPath)
  {
    # Verify that the selected folder is a valid resource pack.
    if (Resource_ImportFolder_Verify -ResPackPath $SelectedPath)
    {
      # Update the path using a function that is shared with the above function.
      Resource_ImportFolder_Finish -ResPackPath $SelectedPath
    }
  }
}
#==============================================================================================================================================================================================
#  Updates the "Input Path" and "Output Path" when manually entering the text.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Resource_ImportFolder_TextBox()
{
  # Get the text that was entered.
  $EnteredPath = $this.Text

  # Avoid doing stuff when accidental clicks happen.
  if ($EnteredPath -eq $ResourcePack) { return }

  # Test the path and make sure the path exists.
  if (TestPath -LiteralPath $EnteredPath)
  {
    # To avoid multiple executions, immediately replace the text with nothing.
    $this.Text = ''

    # Make sure the path is a folder.
    if (TestPath -LiteralPath $EnteredPath -PathType 'Container')
    {
      # Verify that the selected folder is a valid resource pack.
      if (Resource_ImportFolder_Verify -ResPackPath $EnteredPath)
      {
        # Update the path using a function that is shared with the above function.
        Resource_ImportFolder_Finish -ResPackPath $EnteredPath

        # Success. Exit so the text isn't reset.
        return
      }
    }
    # Bonus: If the dropped type is a file, support loading in ZIP and JSON.
    elseif (TestPath -LiteralPath $EnteredPath -PathType 'Leaf')
    {
      # Get the dropped file as an object.
      $EnteredItem = Get-Item -LiteralPath $EnteredPath

      # Detect JSON files and take them on a special journey.
      if ($EnteredItem.Extension -eq '.json')
      {
        # Simply import the JSON file.
        Resource_ImportJSON -ManifestFile $EnteredPath

        # Success. Exit so the text isn't reset.
        return
      }
      # ZIP files have two methods of importing: extract textures, or don't extract them.
      elseif ($EnteredItem.Extension -eq $ZIP)
      {
        # Make sure the resource pack ZIP is in a proper format.
        if (!(ValidateResourceZIPFile -ZipFilePath $EnteredPath)) { return }

        # Ask the user if they also want to extract all textures from the zip file.
        $DialogChoice = ShowYesNoDialog -Title $ResourceYesNoTitle -SizeX (DPISize 280) -SizeY (DPISize 40) -OffsetX (DPISize 18) -OffsetY (DPISize 6) -Message $ResourceYesNoMessage

        # You get the picture, why the fuck not?
        switch ($DialogChoice)
        {
          # Methods: Use "Full" for extract textures, use "Partial" to create an empty texture folder.
          $true   { Resource_ImportZIP -ZipFile $EnteredPath -Method 'Full' }
          $false  { Resource_ImportZIP -ZipFile $EnteredPath -Method 'Partial' }
        }
        # Success. Exit so the text isn't reset.
        return
      }
    }
  }
  # If the resource pack has already been loaded.
  if (TestPath -LiteralPath $ResourcePack)
  {
    # Restore the text to this path.
    $this.Text = $ResourcePack
  }
  # Resource pack has not been loaded.
  else
  {
    # If we got here, something didn't take so reset the text box.
    switch ($ResOpCombo.SelectedIndex)
    {
      # Set the visibility of the resource pack path and update the text box.
      '0' { $this.Text = '<< This field is not used in this operation. >>' }
      '1' { $this.Text = $ResourceZipMessage }
      '2' { $this.Text = $ResourceZipMessage }
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: RESOURCE PACK DIALOG - UPDATE PACK OPTIONS
#==============================================================================================================================================================================================
#  Updates the resource ID based on what was entered in the resource name text box.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateResIDTextBox([string]$Value)
{
  # Remove illegal characters, force lowercase, and replace spaces with dashes.
  $Value = RemoveIllegalCharacters -Value $Value.Replace(' ','-').Replace('.','').TrimEnd('-').ToLower()

  # Set the text box to the generated ID.
  $ResPackIDTextBox.Text = $Value

  # Update the variable that stores the ID with the new value.
  $global:ResourceID = $Value
}
#==============================================================================================================================================================================================
#  Update the GameID. Forces 3/6 letter GameIDs.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetResourcePackGameID()
{
  # Store the GameID before it is changed.
  $PrevGameID = $ResourceGameID

  # Remove illegal characters from the text.
  $this.Text = RemoveIllegalCharacters -Value $this.Text

  # If it's less than 3 characters or contains spaces, don't save the text.
  if (($this.Text.Length -lt 3) -or ($this.Text -like '* *'))
  {
    # Destroy the text so it can't be saved.
    $this.Text = $global:ResourceGameID = ''
  }
  # Make sure the text is at least 3 or 6 characters long.
  elseif (($this.Text.Length -eq 3) -or ($this.Text.Length -eq 6))
  {
    # Update the text on the textbox and update the global variable.
    $this.Text = $global:ResourceGameID = $this.Text.ToUpper()
  }
  # If it's greater than 6 characters, format it to 6 characters.
  elseif ($this.Text.Length -gt 6)
  {
    # Destroy the text so it can't be saved.
    $this.Text = $global:ResourceGameID = $this.Text.Substring(0,6).ToUpper()
  }
  # If it's greater than 3 characters, format it to 3 characters.
  elseif ($this.Text.Length -gt 3)
  {
    # Destroy the text so it can't be saved.
    $this.Text = $global:ResourceGameID = $this.Text.Substring(0,3).ToUpper()
  }
  # If on the option "Update a Resource Pack", change the GameID folder.
  if (($ResOpCombo.SelectedIndex -eq 1) -and ($PrevGameID -ne $ResourceGameID)) 
  {
    # Get the paths to the folder and the new folder name.
    $OldGameIDPath = $ResourcePack + '\textures\' + $PrevGameID
    $NewGameIDPath = $ResourcePack + '\textures\' + $ResourceGameID 

    # Rename the GameID folder.
    Move-Item -LiteralPath $OldGameIDPath -Destination $NewGameIDPath
  }
}
#==============================================================================================================================================================================================
#  Force the last four letters to ".zip". 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateResourceOutputZIP()
{
  # Remove illegal characters, force lowercase, and replaces spaces with dashes.
  $Value = RemoveIllegalCharacters -Value $this.Text

  # If the value starts with a period.
  if (($Value.Length -eq 0) -or (($Value.Length -gt 0) -and ($Value.Substring(0,1) -eq '.')))
  {
    # Reset the value.
    $Value = ''
  }
  # If the user tried to force the file extension.
  elseif ($Value -like '*.*')
  {
    # Split on the period.
    $SplitName = $Value.Split('.')

    # Get the last segment in case the name had multiple periods.
    $Segment = $SplitName.Count - 1

    # Check to see if the segment name does not match the type of zip file.
    if ($SplitName[$Segment] -ne $ZIP.Replace('.', ''))
    {
      # Add the extension to the name.
      $Value = $Value + $ZIP
    }
  }
  # Check to see if it's only a few letters.
  elseif ($Value.Length -gt 0)
  {
    $Value = $Value + $ZIP
  }
  # If we're here then it's something invalid. 
  else
  {
    # Reset the value.
    $Value = ''
  }
  # Update the textbox with whatever the value is now.
  $this.Text = $Value

  # Set the variable to the modified value.
  Set-Variable -Name $this.Name -Value $Value -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Support function to generate a logo. Reduces duplicate code.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateLogoStart([string]$LogoPath, [string]$LogoName)
{
  # Set the path to the logo.
  $FullLogoPath = $LogoPath + '\' + $LogoName

  # Check if the logo doesn't exist.
  if (!(TestPath -LiteralPath $FullLogoPath))
  {
    # Remove the logo button image, set the text on the button, and disable it.
    $ResLogoImage.BackgroundImage = $null
    $ResLogoImage.Text = 'Generating preview... please be patient!'
    $ResLogoImage.Enabled = $false

    # Also disable the combobox that allows selecting the type of logo.
    $ResLogoAdjustCombo.Enabled = $false
  }
  # Return the full path to the logo.
  return $FullLogoPath
}
#==============================================================================================================================================================================================
#  Function to generate a logo image.
#  TODO: TEST THE INPUT "IMAGEFILE" AS ALL FUNCTIONS FEED THIS AN "ITEM".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResAddImage_CreateLogo([string]$ImageFile, [switch]$ForceNew=$false)
{
  # Make sure an image was actually sent.
  if (($ImageFile -eq '') -or ($ImageFile -eq $null)) { return }

  # If a new logo is being forced, then wipe out the current folder.
  if ($ForceNew) { RemovePath -LiteralPath ($TempFolder + '\ResourceLogo') }

  # Get info about the image.
  $ImageInfo = CreateTextureInfo -ImageFile $ImageFile

  # Create the path to store generated logos, and store the path to the base that other logos will be generated from.
  $global:ResLogoPath = CreatePath -LiteralPath ($TempFolder + '\ResourceLogo')
  $global:ResLogoBase = $ResLogoPath + '\logo-base.png'

  # If the base logo does not exist, then make a copy of the image dropped.
  if (!(TestPath -LiteralPath $ResLogoBase)) { Copy-Item -LiteralPath $ImageFile -Destination $ResLogoBase -Force }

  # Adjust the image according to the scaling selected.
  switch -wildcard ($ResourceLogoAdjust)
  {
    # Fit the image to 256x256. If dimensions are uneven, empty space will be filled with transparency.
    'Fit *' {
              # Run the function to set up creating a logo.
              $global:ResourceLogo = CreateLogoStart -LogoPath $ResLogoPath -LogoName 'logo-fit.png'

              # If the logo doesn't already exist, then create it.
              if (!(TestPath -LiteralPath $ResourceLogo))
              {
                # A dummy image containing only alpha needs to be generated.
                $TempAlphaFile = $ResLogoPath + '\temp-fit-alpha.png'
                $TempImageFile = $ResLogoPath + '\temp-fit-logo.png'

                # Create the alpha image using ImageMagick.
                $Arguments = [Collections.Generic.List[string]]@('-size', '256x256', '-define', 'png:color-type=6', 'xc:none')
                Magick-Convert -Arguments $Arguments -OutputFile $TempAlphaFile

                # If both dimensions are smaller than the max, just use them directly. Otherwise, scale them down to 256x256.
                if (($ImageInfo.Width -le 256) -and ($ImageInfo.Height -le 256)) { $Dimensions = $ImageInfo.Dimensions } else { $Dimensions = '256x256' }

                # Create the logo but do not stretch the image.
                $Arguments = [Collections.Generic.List[string]]@('-resize', $Dimensions, '-define', 'png:color-type=6')
                Magick-Convert -ImageFile $ResLogoBase -Arguments $Arguments -OutputFile $TempImageFile

                # Add the logo image to the transparent image to create the completed logo.
                Magick-Convert -ImageFile $TempAlphaFile -Arguments @($TempImageFile, '-gravity', 'center', '-composite') -OutputFile $ResourceLogo

                # Remove the temporary images since they are no longer needed.
                RemovePath -LiteralPath $TempAlphaFile
                RemovePath -LiteralPath $TempImageFile
              }
            }
    # Stretches the image to 256x256.
    'Stre*' {
              # Run the function to set up creating a logo.
              $global:ResourceLogo = CreateLogoStart -LogoPath $ResLogoPath -LogoName 'logo-stretch.png'

              # If the logo doesn't already exist, then create it.
              if (!(TestPath -LiteralPath $ResourceLogo))
              {
                # Stretching the image is the simplest one to create out of the bunch.
                $Arguments = [Collections.Generic.List[string]]@('-resize', '256x256!', '-define', 'png:color-type=6')

                # Create the logo image with ImageMagick.
                Magick-Convert -ImageFile $ResLogoBase -Arguments $Arguments -OutputFile $ResourceLogo
              }
            }
    # Takes the image as-is. If dimensions are larger than 256x256, it will be scaled down.
    'No S*' {
              # Run the function to set up creating a logo.
              $global:ResourceLogo = CreateLogoStart -LogoPath $ResLogoPath -LogoName 'logo-noscale.png'

              # If the logo doesn't already exist, then create it.
              if (!(TestPath -LiteralPath $ResourceLogo))
              {
                # If both dimensions are smaller than the max, just use them directly. If either of the image dimensions are larger than the logo max, scale it down to 256x256.
                if (($ImageInfo.Width -le 256) -and ($ImageInfo.Height -le 256)) { $Dimensions = $ImageInfo.Dimensions } else { $Dimensions = '256x256' }

                # Set up the arguments to create the logo.
                $Arguments = [Collections.Generic.List[string]]@('-resize', $Dimensions, '-define', 'png:color-type=6')

                # Create the logo image with ImageMagick.
                Magick-Convert -ImageFile $ResLogoBase -Arguments $Arguments -OutputFile $ResourceLogo
              }
            }
  }
  # Get info about the new image.
  $NewImageInfo = CreateTextureInfo -ImageFile $ResourceLogo

  # Convert the image type into a bitmap type.
  $DrawingImage  = [Drawing.Image]::FromFile($ResourceLogo)
  $DrawingBitmap = New-Object Drawing.Bitmap($DrawingImage, $NewImageInfo.Width, $NewImageInfo.Height)
  $DrawingImage.Dispose()

  # Apply the image to the logo button, remove the text, and enable it.
  $ResLogoImage.BackgroundImage = $DrawingBitmap
  $ResLogoImage.Text = ''
  $ResLogoImage.Enabled = $true

  # Also enable the combobox to select the logo.
  $ResLogoAdjustCombo.Enabled = $true
}
#==============================================================================================================================================================================================
#  Adds a logo image with a drag and drop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResAddImage_DragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedFiles = $_.Data.GetData([Windows.Forms.DataFormats]::FileDrop)

    # Disable the dialog while it is decoding.
    $ResourceDialog.Enabled = $false

    # Loop through all dropped files.
    foreach ($File in $DroppedFiles)
    {
      # Get the dropped file.
      $ImageItem = Get-Item -LiteralPath $File

      # Create a list of valid extensions.
      $ExtensionList = @($PNG,$JPG,$BMP,$TIF,$TIFF)

      # Make sure the texture has a valid extension and it's not already been added to the list.
      if ($ExtensionList -contains $ImageItem.Extension)
      {
        # Update the default path.
        $global:ResLastPath = $ImageItem.DirectoryName

        # Update the image on the button and add the image to the array.
        ResAddImage_CreateLogo -ImageFile $ImageItem -ForceNew

        # Since a valid image was found, use it.
        break
      }
    }
    # Enable the dialog after all images are added.
    $ResourceDialog.Enabled = $true
  }
}
#==============================================================================================================================================================================================
#  Adds a logo image with the selection button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResAddImage_ButtonClick()
{
  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $ResLastPath

  # Create an open file dialog to grab an image.
  $SelectedFile = Get-FileName -StartPath $GetFilePath -FileName '*' -Description 'Image File'

  # Check if the image exists.
  if (TestPath -LiteralPath $SelectedFile)
  {
    # Get the image as an object.
    $SelectedItem = Get-Item -LiteralPath $SelectedFile

    # Create a list of valid extensions.
    $ExtensionList = @($PNG,$JPG,$BMP,$TIF,$TIFF)

    # Make sure it has a valid extension
    if ($ExtensionList -contains $SelectedItem.Extension)
    {
      # Disable the dialog while it is decoding.
      $ResourceDialog.Enabled = $false

      # Attempt to add the texture to the list.
      ResAddImage_CreateLogo -ImageFile $SelectedItem -ForceNew

      # Enable the dialog after all images are added.
      $ResourceDialog.Enabled = $true

      # Update the default path.
      $global:ResLastPath = $SelectedItem.DirectoryName
    }
    # Don't allow invalid file types.
    else
    {
      # Display a warning to the user.
      $Title   = 'CTT-PS Error'
      $Message = 'Error: Unsupported file or image type.'
      ShowOKDialog -Title $Title -SizeX (DPISize 200) -SizeY (DPISize 20) -OffsetX (DPISize 54) -OffsetY (DPISize 18) -Message $Message
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: RESOURCE PACK DIALOG - PACK CREATION
#==============================================================================================================================================================================================
#  When creating manifest.json, this properly formats the authors for the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetAuthorsForResourcePack()
{
  # Get the authors as an array by splitting on the commas.
  $Authors = $ResourceAuthors.Replace(', ',',').Split(',')

  # Check to see if there is more than 1 author.
  if ($Authors.Count -gt 1)
  {
    # Loop through all available authors.
    foreach ($Author in $Authors)
    {
      # Add each author to the collective list.
      $AuthorList += '"' + $Author + '", '
    }
    # Trim the final comma after the final author.
    return $AuthorList.TrimEnd(', ')
  }
  # If there is just 1 author, simply add the single author to the collective list.
  return ('"' + $Authors + '"')
}
#==============================================================================================================================================================================================
#  Creates the manifest.json file using the values entered into the Resource Pack GUI.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateManifestJSON([string]$Destination)
{
  # Store the location to the manifest file.
  $ManifestFile = $Destination + '\manifest.json'

  # Remove the file if it exists (it should always exist).
  RemovePath -LiteralPath $ManifestFile

  # Get the authors list by running the function.
  $ResourceAuthorList = GetAuthorsForResourcePack

  # Generate the "manifest.json" file.
  $ManifestEntry = New-Object string[] 9
  $ManifestEntry[0] = '{'
  $ManifestEntry[1] = '"name": "' + $ResourceName + '",'
  $ManifestEntry[2] = '"id" : "' + $ResourceID + '",'
  $ManifestEntry[3] = '"version": "' + $ResourceVersion + '",'
  $ManifestEntry[4] = '"authors": [' + $ResourceAuthorList + '],'
  $ManifestEntry[5] = '"website": "' + $ResourceWebsite + '",'
  $ManifestEntry[6] = '"description": "' + $ResourceDescription + '",'
  $ManifestEntry[7] = '"compressed": ' + $ResourceCompress.ToString().ToLower()
  $ManifestEntry[8] = '}'

  # Loop through the entries array.
  foreach ($Line in $ManifestEntry)
  {
    # Write each line to the "manifest.json" file.
    Add-Content -LiteralPath $ManifestFile -Value $Line
  }
}
#==============================================================================================================================================================================================
#  Checks to see whether or not a Resource Pack will be generated.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResourcePackConditions([string]$Operation)
{
  # Test the path to 7-Zip if creating a Resource Pack.
  if (!(TestPath -LiteralPath $7ZipPath))
  {
    # Show a dialog that says that not everything has been filled out.
    $Title   = 'CTT-PS Error'
    $Message = 'Error: 7-Zip was not found so the Resource Pack can not be created! Install 7-Zip, or if it is already installed, select the path on the "Options" menu on the "Tool Paths" tab.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 40) -OffsetX (DPISize 8) -OffsetY (DPISize 6) -Message $Message

    # 7-Zip is required to create the resource pack.
    return $false
  }
  # If the operation is to create a resource pack, we need to check six values. If its manifest.json, only need to check three.
  switch ($Operation)
  {
    # Create a Resource Pack
    '0' {
          # Set up the conditions for this operation.
          $ResPackConditions = New-Object bool[] 6
          $ResPackConditions[0] = ($ResourceGameID -ne '')
          $ResPackConditions[1] = ($ResourceName -ne '')
          $ResPackConditions[2] = ($ResourceID -ne '')
          $ResPackConditions[3] = ($ResourceVersion -ne '')
          $ResPackConditions[4] = ($ResourceLogo -ne '')
          $ResPackConditions[5] = ($ResourceZipName -ne '')

          # What to display if the conditions are not met.
          $ConditionList = @('GameID', 'Pack Name', 'Pack ID', 'Version', 'Logo', 'Zip Name')
        }
    # Update a Resource Pack
    '1' {
          # Set up the conditions for this operation.
          $ResPackConditions = New-Object bool[] 7
          $ResPackConditions[0] = ($ResourcePack -ne '')
          $ResPackConditions[1] = ($ResourceGameID -ne '')
          $ResPackConditions[2] = ($ResourceName -ne '')
          $ResPackConditions[3] = ($ResourceID -ne '')
          $ResPackConditions[4] = ($ResourceVersion -ne '')
          $ResPackConditions[5] = ($ResourceLogo -ne '')
          $ResPackConditions[6] = ($ResourceZipName -ne '')

          # What to display if the conditions are not met.
          $ConditionList = @('Imported Pack', 'GameID', 'Pack Name', 'Pack ID', 'Version', 'Logo', 'Zip Name')
        }
    # Create a Manifest.json File
    '2' {
          # Set up the conditions for this operation.
          $ResPackConditions = New-Object bool[] 3
          $ResPackConditions[0] = ($ResourceName -ne '')
          $ResPackConditions[1] = ($ResourceID -ne '')
          $ResPackConditions[2] = ($ResourceVersion -ne '')

          # What to display if the conditions are not met.
          $ConditionList = @('Pack Name', 'Pack ID', 'Version')
        }
  }
  # Create an empty array. 
  $FailedConditions = New-Object Collections.Generic.List[string]
  
  # Loop through all conditions.
  for ($i = 0 ; $i -lt $ResPackConditions.Length ; $i++)
  {
    # See if a condition fails.
    if (!$ResPackConditions[$i])
    {
      # Add the variable name to the list of failed conditions.
      $FailedConditions.Add($ConditionList[$i])

      # Show a debug message if a value fails.
      DebugMessage -Message ('ResPack Create Failed: ' + $ConditionList[$i] + ' Missing')
    }
  }
  # If any of the conditions failed then return an error message.
  if ($FailedConditions.Count -gt 0)
  {
    # Compile the list of failures.
    foreach ($Failed in $FailedConditions) { $ErrorList += $Failed + ', ' }

    # Show a dialog that says that not everything has been filled out.
    $Title   = 'CTT-PS Error'
    $Message = 'Information Missing: ' + $ErrorList.TrimEnd(', ') + '.'
    ShowOKDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 20) -OffsetY (DPISize 12) -Message $Message

    # Do not create the resource pack.
    return $false
  }
  # If everything is a go, get ready for launch.
  return $true
}
#==============================================================================================================================================================================================
#  Creates the resource pack when the start button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StartCreateResourcePack()
{
  # Clear everything that may exist from a previous run.
  TexList_SetInitialState -Rows 150

  # Get the selected operation so we know what we're doing.
  $SelectedOperation = $ResOpCombo.SelectedIndex.ToString()

  # If the conditions don't pass, then don't create a resource pack.
  if (!(ResourcePackConditions -Operation $SelectedOperation)) { return }

  # Set the texture list status to creating a resource pack.
  TexList_UpdateStatus -Status 'Operation' -Value $ResOpCombo.SelectedItem.Replace('a ','')
  TexList_UpdateStatus -Status 'Timer'     -Value '0'

  # Show the timer but hide various other items.
  $TexListTexLabel.Visible   = $false
  $TexListTexValue.Visible   = $false
  $TexListProgLabel.Visible  = $false
  $TexListProgBar.Visible    = $false
  $TexListProgValue.Visible  = $false
  $TexListTimerLabel.Visible = $true
  $TexListTimerValue.Visible = $true

  # Move the timer further left for this session.
  $TexListTimerLabel.Location = DPISize (New-Object Drawing.Point(264, 8))
  $TexListTimerValue.Location = DPISize (New-Object Drawing.Point(329, 8))

  # Start the timer that tracks the amount of time the operation takes to complete.
  TexList_StartTimer

  # Simulate the master loop and processing a texture.
  $global:MasterLoopRunning = $true
  $global:ProcessingTexture = $true

  # Disable all dialogs.
  ToggleDialogStates -State $false

  # Show a label to alert a pack is being generated.
  $ResWaitLabel.Size = DPISize (New-Object Drawing.Size(386, 28))
  $ResWaitLabel.Text = 'Generating Resource Pack ZIP file...'
  $ResWaitLabel.Visible = $true

  # Perform the selected operation.
  switch ($SelectedOperation)
  {
    # Create a Resource Pack
    '0' {
          # Set the path to where the resource pack will be created.
          $TempZipContents = CreatePath -LiteralPath ($TempFolder + '\ZipContents')

          # Copy the logo file and rename it in the process.
          $FinalLogoPath = $TempZipContents + '\logo.png'

          # Copy the logo to the temporary path.
          Copy-Item -LiteralPath $ResourceLogo -Destination $FinalLogoPath -Force

          # Create the manifest.json into the temporary path.
          CreateManifestJSON -Destination $TempZipContents

          # Set the path to the zip file.
          $OutputZipPath = CreatePath -LiteralPath ($MasterOutputPath + '\ResourcePacks\')
          $OutputZipFile = $OutputZipPath + $ResourceZipName

          # If the zip file exists, destroy it.
          if (TestPath -LiteralPath $OutputZipFile) { RemovePath -LiteralPath $OutputZipFile }

          # Zip the logo and the manifest files into the resource pack zip.
          ZipFileArchive -Content $TempZipContents -ZipFileName $OutputZipFile

          # Create a path to move textures to temporarily.
          $TempTexturePath = CreatePath -LiteralPath ($MasterInputPath + '\_TEMPMOVE\textures\' + $ResourceGameID)

          # Loop through textures. They need to be moved temporarily to match the folder structure of the zip.
          foreach ($Object in Get-ChildItem -LiteralPath $MasterInputPath)
          {
            # Make sure the object is a folder but not a generated folder.
            if ((TestPath -LiteralPath $Object.FullName -PathType 'Container') -and ($Object.FullName -notlike '*~*') -and ($Object.Name -ne '_TEMPMOVE'))
            {
              # The relative path to the object must be deciphered.
              $RelativeDir = $Object.FullName.Replace($MasterInputPath,'')

              # Create the location to move the texture folder to temporarily.
              $NewLocation = $TempTexturePath + $RelativeDir

              # Move the folder to the temporary location.
              Move-Item -LiteralPath $Object.FullName -Destination $NewLocation -Force
            }
            # If the type found is a file.
            elseif (TestPath -LiteralPath $Object.FullName -PathType 'Leaf')
            {
              # See if it is a texture file by checking the extension.
              if (($Object.Extension -eq $PNG) -or ($Object.Extension -eq $DDS))
              {
                # The relative path to the texture must be deciphered.
                $RelativeDir = $Object.FullName.Replace($MasterInputPath,'')

                # Create the location to move the texture folder to temporarily.
                $NewLocation = $TempTexturePath + $RelativeDir

                # Move the texture to the temporary location.
                Move-Item -LiteralPath $Object.FullName -Destination $NewLocation -Force
              }
            }
          }
          # Run 7-Zip to pack the textures.
          ZipFileArchive -Content ($MasterInputPath + '\_TEMPMOVE') -ZipFileName $OutputZipFile

          # Loop through textures. They need to be moved temporarily to match the folder structure of the zip.
          foreach ($Object in Get-ChildItem -LiteralPath $TempTexturePath)
          {
            # Set the text that will be cropped from the path.
            $CroppedText = '\_TEMPMOVE\textures\' + $ResourceGameID

            # The relative path to the object must be deciphered.
            $NewDirectory = $Object.FullName.Replace($CroppedText,'')

            # Move the texture or folder back to where it was.
            Move-Item -LiteralPath $Object.FullName -Destination $NewDirectory -Force
          }
          # Remove the temporary folder.
          RemovePath -LiteralPath ($MasterInputPath + '\_TEMPMOVE')
        }
    # Update a Resource Pack
    '1' {
          # Check to see if the pack manager has this entry on the list.
          $ExistingIndex = ResPackManager_CheckAndGetEntry

          # If it exists, index should be greater than 0.
          if ($ExistingIndex -gt 0)
          {
            # Block the list from updating.
            $global:BlockSelection = $true

            # Update the entry that is already on the list. This also generates a new manifest.json.
            ResPackManager_UpdatePack -Index $ExistingIndex

            # Unblock the list from updating.
            $global:BlockSelection = $false
          }
          # The entry does not exist.
          else
          {
            # Create the new manifest.json. The function above also creates a new file.
            CreateManifestJSON -Destination $ResourcePack
          }
          # Set the path to the zip file.
          $OutputZipPath = CreatePath -LiteralPath ($MasterOutputPath + '\ResourcePacks\')
          $OutputZipFile = $OutputZipPath + $ResourceZipName

          # Zip the entire pack into the output folder.
          ZipFileArchive -Content $ResourcePack -ZipFileName $OutputZipFile
        }
    # Create a Manifest.json File
    '2' {
          # Set the path to where the manifest.json will be created.
          $ManifestPath = CreatePath -LiteralPath ($MasterOutputPath + '\ManifestFile\')

          # Create the manifest.json into the temporary path.
          CreateManifestJSON -Destination $ManifestPath
        }
  }
  # Restore the label text and hide it.
  $ResWaitLabel.Size = DPISize (New-Object Drawing.Size(370, 28))
  $ResWaitLabel.Text = 'Importing Resource Pack ZIP file...'
  $ResWaitLabel.Visible = $false

  # Enable all dialogs.
  ToggleDialogStates -State $true

  # Disable the simulated master loop and processed texture.
  $global:MasterLoopRunning = $false
  $global:ProcessingTexture = $false

  # Set the texture list status to creating a resource pack.
  TexList_UpdateStatus -Status 'Operation' -Value 'Completed' -FontColor ([Drawing.ColorTranslator]::FromHtml('#04B404'))

  # Stop the timer that keeps track of the duration.
  TexList_StopTimer -Destroy $true
}
#==============================================================================================================================================================================================
#  CTT GUI: CREATE RESOURCE PACK DATABASE FUNCTIONS
#==============================================================================================================================================================================================
#  Creates a resource pack database file if it doesn't exist.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDatabaseContent()
{
  # See if it does not already exist.
  if (!(TestPath -LiteralPath $ResourcePackData))
  {
    # Create the database. Add necessary lines for resource pack range.
    Add-Content -LiteralPath $ResourcePackData -Value '# RESOURCE PACKS START'
    Add-Content -LiteralPath $ResourcePackData -Value '# RESOURCE PACKS END'
  }
  # Return the content of the database file.
  return (Get-Content -LiteralPath $ResourcePackData)
}
#==============================================================================================================================================================================================
#  Checks a database file and returns the index if it exists. Returns 0 if the entry does not exist.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_CheckAndGetEntry()
{
  # Run the function that creates/loads a database file.
  $Database = GetDatabaseContent

  # Read through each line one by one.
  for ($i = 0 ; $i -lt $Database.Count ; $i++)
  {
    # Skip past comments.
    if ($Database[$i] -like '#*') { continue }

    # Split the line. The first value is the title, the second value is the path.
    $LineValues   = $Database[$i].Split('>')
    $ResEntryPath = $LineValues[1]

    # Check to see if the entry already exists in the list.
    if ($ResEntryPath -eq $ResourcePack)
    {
      # Return the line that the pack is on.
      return $i
    }
  }
  # Return a value of 0 (which will never hold a resource pack).
  return 0
}
#==============================================================================================================================================================================================
#  Force select an entry on the resource pack manager if it exists.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_SelectEntryIfExists()
{
  # Block resource pack manager selection events.
  $global:BlockSelection = $true

  # Read the database file.
  $Database = GetDatabaseContent

  # Default the selected index to 0.
  $DiscoveredIndex = 0

  # Read through each line one by one.
  for ($i = 0 ; $i -lt $Database.Count ; $i++)
  {
    # Skip past comments.
    if ($DataBase[$i] -like '#*') { continue }

    # Split the line. The first value is the title, the second value is the path.
    $LineValues   = $DataBase[$i].Split('>')
    $ResEntryPath = $LineValues[1]

    # Check to see if the entry already exists in the list.
    if ($ResEntryPath -eq $ResourcePack)
    {
      # Force selecting the entry since it already exists.
      $DiscoveredIndex = $i

      # We have our match so end the loop.
      break
    }
  }
  # Select whatever the fuck the index is now.
  $ResManagerCombo.SelectedIndex = $DiscoveredIndex

  # Allow selection events from the resource pack manager combobox.
  $global:BlockSelection = $false
}
#==============================================================================================================================================================================================
#  Loads a resource pack when selected from the Pack Manager menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_SelectPack()
{
  # If the event was blocked, do not allow this function to run.
  if ($BlockSelection) { return }

  # There will never be a pack stored in index 0.
  if ($this.SelectedIndex -eq 0) { return }

  # Read the database file.
  $Database = GetDatabaseContent

  # Read through each line one by one.
  foreach ($Line in $Database)
  {
    # Skip looking through comments.
    if ($Line -like '*#*') { continue }

    # Split the line. The first value is the title, the second value is the path.
    $LineValues   = $Line.Split('>')
    $ResEntryName = $LineValues[0]
    $ResEntryPath = $LineValues[1]

    # The title on the line should match the one on the menu.
    if ($ResEntryName -eq $this.SelectedItem)
    {
      # Set the values for the Yes/No dialog.
      $Title   = 'CTT-PS Error'
      $Message = 'Error: The path for this entry no longer exists! Would you like to remove this entry from the list?'

      # Test the path to the entry to see if it is still valid.
      if (TestPath -LiteralPath $ResEntryPath)
      {
        # Update the path using a function that is shared with the below function.
        Resource_ImportFolder_Finish -ResPackPath $ResEntryPath

        # We're done so get out of here.
        return
      }
      # The entry is good but the path is missing. Ask the user if they wish to remove it.
      elseif (ShowYesNoDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 20) -OffsetY (DPISize 12) -Message $Message)
      {
        # A special function just for this situation.
        ResPackManager_RemoveInvalid
      }
    }
  }
}
#==============================================================================================================================================================================================
#  Adds a resource pack to the database file and the selection list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_AddPack()
{
  # Run the function that creates/loads a database file.
  $Database = GetDatabaseContent

  # Create a virtual database file that will overwrite the old.
  $NewDataBase = New-Object Collections.Generic.List[string]
  $NewDataBase.Add('# RESOURCE PACKS START')

  # Compile the entry to add to the database.
  $NewEntryText = $ResourceName + '>' + $ResourcePack

  # Read through each line one by one.
  for ($i = 0 ; $i -lt $Database.Count ; $i++)
  {
    # Skip past comments.
    if ($DataBase[$i] -like '#*') { continue }

    # Add the line to the new database file.
    $NewDataBase.Add($DataBase[$i])
  }
  # Now write the new entry to the database.
  $NewDataBase.Add($NewEntryText)

  # Add the final line to know when the packs list ends.
  $NewDataBase.Add('# RESOURCE PACKS END')

  # Check to see if there are any differences between the databases.
  if (Compare-Object -ReferenceObject $DataBase -DifferenceObject $NewDataBase)
  {
    # Replace the file with the modified content.
    Set-Content -LiteralPath $ResourcePackData -Value $NewDataBase

    # Add the Resource Pack to the manager list and select it.
    $ResManagerCombo.Items.Add($ResourceName) | Out-Null
    $ResManagerCombo.SelectedIndex = ($NewDataBase.Count - 2)
  }
  # Update the manifest.json since it may contain changes.
  CreateManifestJSON -Destination $ResourcePack
}
#==============================================================================================================================================================================================
#  Updates a resource pack in the database and updates the selection list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_UpdatePack([int]$Index)
{
  # Run the function that creates/loads a database file.
  $Database = GetDatabaseContent

  # Create a virtual database file that will overwrite the old.
  $NewDataBase = New-Object Collections.Generic.List[string]
  $NewDataBase.Add('# RESOURCE PACKS START')

  # Compile the entry to add to the database.
  $NewEntryText = $ResourceName + '>' + $ResourcePack

  # Read through each line one by one.
  for ($i = 0 ; $i -lt $Database.Count ; $i++)
  {
    # Skip past comments.
    if ($DataBase[$i] -like '#*') { continue }

    # When the match is found, replace the entry.
    if ($i -eq $Index)
    {
      # Overwrite the database entry.
      $NewDataBase.Add($NewEntryText)
    }
    else
    {
      # Add the existing entry.
      $NewDataBase.Add($DataBase[$i])
    }
  }
  # Add the final line to know when the packs list ends.
  $NewDataBase.Add('# RESOURCE PACKS END')

  # Check to see if there are any differences between the databases.
  if (Compare-Object -ReferenceObject $DataBase -DifferenceObject $NewDataBase)
  {
    # Replace the file with the modified content.
    Set-Content -LiteralPath $ResourcePackData -Value $NewDataBase

    # The entire list must be repopulated.
    ResPackManager_Populate -SelectedIndex $Index
  }
  # Update the manifest.json since it may contain changes.
  CreateManifestJSON -Destination $ResourcePack
}
#==============================================================================================================================================================================================
#  Relocates a pack and re-imports it if the user imported a ZIP file and wants to add it to the list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_RelocateTempPack()
{
  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $DesktopPath

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and ($SelectedPath.Length -gt 3) -and (TestPath -LiteralPath $SelectedPath))
  {
    # The ZIP name should contain something since it was imported, but just in case.
    if ($ResourceZipName -ne '') 
    {
      $OutputName = $ResourceZipName.Replace($ZIP,'')
    }
    # Use a generic name since I'm not very creative.
    else
    {
      $OutputName = 'ImportedPack'
    }
    # Set up the path to where the resource pack will be moved.
    $DestinationPath = $SelectedPath + '\' + $OutputName

    # Move the resource pack to the new location.
    Move-Item -LiteralPath $ResourcePack -Destination $DestinationPath -Force

    # Import the folder now that it has been moved.
    Resource_ImportFolder_Finish -ResPackPath $DestinationPath

    # Roger / Wilco
    return $true
  }
  # Do not attempt to import the pack if a folder was not selected.
  return $false
}
#==============================================================================================================================================================================================
#  Selects whether to add or update a resource pack.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_AddPackCheck()
{
  # If a pack hasn't been added, then get out of here.
  if (!(TestPath -LiteralPath $ResourcePack)) { return }

  # Set the values for the Yes/No dialog.
  $Title   = 'Fully Import Pack'
  $Message = 'Notice: Imported ZIP files can not be stored! Do you wish to copy the pack to a permanent location?'

  # Do not directly allow importing extracted ZIP files.
  if ($ResourcePack -like '*CTT-PS Data\Temp*') 
  {
    # Display a message asking if the pack will be copied to a new location.
    if (ShowYesNoDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 20) -OffsetY (DPISize 12) -Message $Message)
    {
      # If the user wanted to relocate the pack, grant their wishes.
      if (!(ResPackManager_RelocateTempPack)) { return }
    }
    # Can't do shit if they don't want to.
    else { return }
  }
  # Block resource pack manager selection events.
  $global:BlockSelection = $true

  # A check to see if the entry already exists on the list.
  $ExistingIndex = ResPackManager_CheckAndGetEntry

  # If it does not exist, "Index" should be 0.
  if ($ExistingIndex -eq 0)
  {
    # Add the pack to the list.
    ResPackManager_AddPack
  }
  # Anything above 0 means that it exists on the list.
  else
  {
    # Update the entry that is already on the list.
    ResPackManager_UpdatePack -Index $ExistingIndex
  }
  # Allow selection events from the resource pack manager combobox.
  $global:BlockSelection = $false
}
#==============================================================================================================================================================================================
#  Removes a pack from the database and resource pack manager list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_RemovePack()
{
  # If there is nothing to remove, then get out.
  if ($ResManagerCombo.Items.Count -lt 2) { return }

  # Don't allow removing the '<< Add Imported Pack >>' entry.
  if ($ResManagerCombo.SelectedIndex -eq 0) { return }

  # Set the values for the Yes/No dialog.
  $Title   = 'Remove Resource Pack'
  $Message = 'Are you sure you want to remove this pack?'

  # Ask the user if they really want to remove the pack. If they press "No", exit now.
  if (!(ShowYesNoDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 20) -OffsetX (DPISize 42) -OffsetY (DPISize 18) -Message $Message)) { return }

  # Run the function that creates/loads a database file.
  $Database = GetDatabaseContent

  # Create a virtual database file that may potentially overwrite the old.
  $NewDataBase = New-Object Collections.Generic.List[string]
  $NewDataBase.Add('# RESOURCE PACKS START')

  # Read through each line one by one.
  for ($i = 0 ; $i -lt $Database.Count ; $i++)
  {
    # Skip past comments.
    if ($DataBase[$i] -like '#*') { continue }

    # Split the line. The first value is the title, the second value is the path.
    $LineValues   = $DataBase[$i].Split('>')
    $ResEntryName = $LineValues[0]
    $ResEntryPath = $LineValues[1]

    # Check to see if the entry is not in the list.
    if (($ResEntryName -ne $ResourceName) -and ($ResEntryPath -ne $ResourcePack))
    {
      # Add the line to the new database.
      $NewDataBase.Add($DataBase[$i])
    }
  }
  # Add the final line to know when the packs list ends.
  $NewDataBase.Add('# RESOURCE PACKS END')

  # Compare the two databases to see if anything was removed.
  if (Compare-Object -ReferenceObject $DataBase -DifferenceObject $NewDataBase)
  {
    # Write the new database file that has the entry excluded.
    Set-Content -LiteralPath $ResourcePackData -Value $NewDataBase

    # The entire list must be repopulated.
    ResPackManager_Populate -SelectedIndex 0

    # Reset the dialog.
    ResetResourceDialog
  }
}
#==============================================================================================================================================================================================
#  Forcefully removes a pack from the database and resource pack manager list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_RemoveInvalid()
{
  # Run the function that creates/loads a database file.
  $Database = GetDatabaseContent

  # Create a virtual database file that may potentially overwrite the old.
  $NewDataBase = New-Object Collections.Generic.List[string]
  $NewDataBase.Add('# RESOURCE PACKS START')

  # Read through each line one by one.
  for ($i = 0 ; $i -lt $Database.Count ; $i++)
  {
    # Skip past comments.
    if ($DataBase[$i] -like '#*') { continue }

    # Split the line. The first value is the title, the second value is the path.
    $LineValues   = $DataBase[$i].Split('>')
    $ResEntryName = $LineValues[0]
    $ResEntryPath = $LineValues[1]

    # Check to see if the entry is not in the list.
    if (($ResEntryName -ne $ResManagerCombo.SelectedItem) -or (TestPath -LiteralPath $ResEntryPath))
    {
      # Add the line to the new database.
      $NewDataBase.Add($DataBase[$i])
    }
  }
  # Add the final line to know when the packs list ends.
  $NewDataBase.Add('# RESOURCE PACKS END')

  # Compare the two databases to see if anything was removed.
  if (Compare-Object -ReferenceObject $DataBase -DifferenceObject $NewDataBase)
  {
    # Write the new database file that has the entry excluded.
    Set-Content -LiteralPath $ResourcePackData -Value $NewDataBase

    # The entire list must be repopulated.
    ResPackManager_Populate -SelectedIndex 0

    # Reset the dialog.
    ResetResourceDialog
  }
}
#==============================================================================================================================================================================================
#  Populates the resource pack manager with info found from the database file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResPackManager_Populate([int]$SelectedIndex)
{
  # Remove all entries from the list.
  $ResManagerCombo.Items.Clear() | Out-Null

  # Add the default option of selecting a pack.
  $ResManagerCombo.Items.Add('<< Add Imported Pack >>') | Out-Null

  # Make sure the database exists.
  if (!(TestPath -LiteralPath $ResourcePackData)) { return }

  # Read the database file.
  $Database  = GetDatabaseContent
  $AllowRead = $false

  # Read through each line one by one.
  foreach ($Line in $Database)
  {
    # Start and stop reading when the database tells us to.
    if ($Line -like '*RESOURCE PACKS START*') { $AllowRead = $true  ; continue }
    if ($Line -like '*RESOURCE PACKS END*')   { $AllowRead = $false ; break    }

    # Look for ">" cause we split on that, but avoid "#" because they are comments.
    if (($AllowRead) -and ($Line -like '*>*') -and ($Line -notlike '*#*'))
    {
      # Split the line. The first value is the title, the second value is the path.
      $LineValues   = $Line.Split('>')
      $ResEntryName = $LineValues[0]

      # Add the resource pack to the list.
      $ResManagerCombo.Items.Add($ResEntryName) | Out-Null
    }
  }
  # Select the chosen index.
  $ResManagerCombo.SelectedIndex = $SelectedIndex
}
#==============================================================================================================================================================================================
#  CTT GUI: CREATE RESOURCE PACK DIALOG
#==============================================================================================================================================================================================
#  Create the dialog that is displayed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ResourcePack()
{
  # Create the dialog and set up properties.
  $global:ResourceDialog = New-Object Windows.Forms.Form
  $ResourceDialog.Size = DPISize (New-Object Drawing.Size(766, 518))
  $ResourceDialog.MinimumSize = DPISize (New-Object Drawing.Size(766, 518))
  $ResourceDialog.MaximumSize = DPISize (New-Object Drawing.Size(766, 518))
  $ResourceDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ResourceDialog.Text = 'CTT-PS Resource Pack Manager'
  $ResourceDialog.MaximizeBox = $false
  $ResourceDialog.MinimizeBox = $true
  $ResourceDialog.FormBorderStyle = GetFormBorderStyle
  $ResourceDialog.StartPosition = "CenterScreen"
  $ResourceDialog.KeyPreview = $true
  $ResourceDialog.Add_Shown({ ActivateDialog -Dialog $ResourceDialog })
  $ResourceDialog.Add_KeyDown({ EscapeCloseDialog })
  $ResourceDialog.Add_SizeChanged({ MinimizeAllDialogs })
  $ResourceDialog.Add_FormClosing({ ResourceDialogClose })
  $ResourceDialog.Icon = $Icon_CTTPSGreen

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:ResFocusLabel = New-Object Windows.Forms.Label
  $ResFocusLabel.Size = New-Object Drawing.Size(1,1)
  $ResFocusLabel.Location = New-Object Drawing.Point(0,0)
  $ResourceDialog.Controls.Add($ResFocusLabel)

  # A label to display over the GUI that a file is being imported.
  $global:ResWaitLabel = New-Object Windows.Forms.Label
  $ResWaitLabel.Size = DPISize (New-Object Drawing.Size(370, 28))
  $ResWaitLabel.Location = DPISize (New-Object Drawing.Point(180, 220))
  $ResWaitLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 16, [Drawing.FontStyle]::Bold)
  $ResWaitLabel.Text = 'Importing Resource Pack ZIP file...'
  $ResWaitLabel.Visible = $false
  $ResWaitLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#CCCCCC')
  $ResourceDialog.Controls.Add($ResWaitLabel)

  # Operation: Create the group box to hold the operation.
  $global:ResOpGroupBox = New-Object Windows.Forms.GroupBox
  $ResOpGroupBox.Size = DPISize (New-Object Drawing.Size(360, 50))
  $ResOpGroupBox.Location = DPISize (New-Object Drawing.Point(10, 6))
  $ResOpGroupBox.Text = ' Configuration '
  $ResourceDialog.Controls.Add($ResOpGroupBox)

  # Operation: Create a label for the group box.
  $global:ResOpLabel = New-Object Windows.Forms.Label
  $ResOpLabel.Size = DPISize (New-Object Drawing.Size(60, 20))
  $ResOpLabel.Location = DPISize (New-Object Drawing.Point(10, 24))
  $ResOpLabel.Text = 'Operation:'
  $ResOpGroupBox.Controls.Add($ResOpLabel)

  # Operation: Create a tip for the label and group box.
  $ResOpTip = New-Object Windows.Forms.ToolTip
  $ResOpTip.InitialDelay = $ToolTipDelay
  $ResOpTip.AutoPopDelay = $ToolTipDuration
  $ResOpTipString = 'Selects the operation to perform.'
  $ResOpTip.SetToolTip($ResOpGroupBox, $ResOpTipString)
  $ResOpTip.SetToolTip($ResOpLabel, $ResOpTipString)

  # Operation: Create a combo box to select the operation.
  $global:ResOpCombo = New-Object Windows.Forms.ComboBox
  $ResOpCombo.Size = DPISize (New-Object Drawing.Size(277, 22))
  $ResOpCombo.Location = DPISize (New-Object Drawing.Point(76, 20)) -AddY $DPIOffsetFix
  $ResOpCombo.Name = 'ResourcePackAction'
  $ResOpCombo.Items.Add('Create a Resource Pack') | Out-Null
  $ResOpCombo.Items.Add('Update a Resource Pack') | Out-Null
  $ResOpCombo.Items.Add('Only Generate "Manifest.json" File') | Out-Null
  $ResOpCombo.SelectedItem = $ResourceOperation
  $ResOpCombo.Add_SelectedIndexChanged({ $ResFocusLabel.Focus() })
  $ResOpCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; UpdateResourcePackSelection -Index $this.SelectedIndex })
  $ResOpCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ResOpCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ResOpCombo.Add_DrawItem({ RepopulateComboBox })
  $ResOpGroupBox.Controls.Add($ResOpCombo)

  # ResPack Manager: Create a groupbox to hold all the shit.
  $global:ResManagerGroupBox = New-Object Windows.Forms.GroupBox
  $ResManagerGroupBox.Size = DPISize (New-Object Drawing.Size(360, 50))
  $ResManagerGroupBox.Location = DPISize (New-Object Drawing.Point(380, 6))
  $ResManagerGroupBox.Text = ' Stored Packs '
  $ResManagerGroupBox.Enabled = $false
  $ResourceDialog.Controls.Add($ResManagerGroupBox)

  # Operation: Create a combo box to select the operation.
  $global:ResManagerCombo = New-Object Windows.Forms.ComboBox
  $ResManagerCombo.Size = DPISize (New-Object Drawing.Size(293, 22))
  $ResManagerCombo.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $ResManagerCombo.Name = 'ResourceManagerPack'
  ResPackManager_Populate -SelectedIndex 0 # Populate the list before adding the event to avoid some startup errors.
  $ResManagerCombo.Add_SelectedIndexChanged({ $ResFocusLabel.Focus() })
  $ResManagerCombo.Add_SelectedIndexChanged({ ResPackManager_SelectPack })
  $ResManagerCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ResManagerCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ResManagerCombo.Add_DrawItem({ RepopulateComboBox })
  $ResManagerGroupBox.Controls.Add($ResManagerCombo)

  # Modify ResPack Path: Create a button to add a pack.
  $global:ResManagerAddButton = New-Object Windows.Forms.Button
  $ResManagerAddButton.Size = DPISize (New-Object Drawing.Size(23, 23))
  $ResManagerAddButton.Location = DPISize (New-Object Drawing.Point(306, 19))
  $ResManagerAddButton.Text = '+'
  $ResManagerAddButton.Add_Click({ ResPackManager_AddPackCheck })
  $ResManagerGroupBox.Controls.Add($ResManagerAddButton)

  # Modify ResPack Path: Create a button to remove a pack.
  $global:ResManagerDelButton = New-Object Windows.Forms.Button
  $ResManagerDelButton.Size = DPISize (New-Object Drawing.Size(23, 23))
  $ResManagerDelButton.Location = DPISize (New-Object Drawing.Point(331, 19))
  $ResManagerDelButton.Text = '-'
  $ResManagerDelButton.Add_Click({ ResPackManager_RemovePack })
  $ResManagerGroupBox.Controls.Add($ResManagerDelButton)

  # Modify ResPack Path: Create a groupbox to hold the texture path.
  $global:ResModPackGroupBox = New-Object Windows.Forms.GroupBox
  $ResModPackGroupBox.Size = DPISize (New-Object Drawing.Size(360, 50))
  $ResModPackGroupBox.Location = DPISize (New-Object Drawing.Point(10, 60))
  $ResModPackGroupBox.Text = ' Imported Resource Pack '
  $ResModPackGroupBox.Add_Click({ if (TestPath -LiteralPath $ResourcePack) { Invoke-Item -LiteralPath $ResourcePack} })
  $ResModPackGroupBox.Visible = $false
  $ResourceDialog.Controls.Add($ResModPackGroupBox)

  # Modify ResPack Path: Create a tip for the path.
  $ResModPackTip = New-Object Windows.Forms.ToolTip
  $ResModPackTip.InitialDelay = $ToolTipDelay
  $ResModPackTip.AutoPopDelay = $ToolTipDuration
  $ResModPackTipString =  'Root path of the imported resource pack. If a ZIP is{0}'
  $ResModPackTipString += "imported, a temporary root folder will be created. It's{0}"
  $ResModPackTipString += "also possible to import an extracted pack root folder.{0}"
  $ResModPackTipString += "{0}"
  $ResModPackTipString += 'A resource pack "root" folder must contain logo.png,{0}'
  $ResModPackTipString += 'manifest.json, and a "textures/GameID/" folder.'
  $ResModPackTipString = [String]::Format($ResModPackTipString, [Environment]::NewLine)
  $ResModPackTip.SetToolTip($ResModPackGroupBox, $ResModPackTipString)

  # Modify ResPack Path: Create a text box to display and update the path.
  $global:ResModPackTextBox = New-Object Windows.Forms.TextBox
  $ResModPackTextBox.Size = DPISize (New-Object Drawing.Size(316, 22))
  $ResModPackTextBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $ResModPackTextBox.Name = 'ResourcePack'
  $ResModPackTextBox.Text = 'I AM ERROR'
  $ResModPackTextBox.AllowDrop = $true
  $ResModPackTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ResModPackTextBox.Add_DragDrop({ Resource_ImportFolder_DragAndDrop })
  $ResModPackTextBox.Add_Click({ ClearTextBox })
  $ResModPackTextBox.Add_Leave({ Resource_ImportFolder_TextBox })
  $ResModPackGroupBox.Controls.Add($ResModPackTextBox)

  # Modify ResPack Path: Create a button to select the path.
  $global:ResModPackButton = New-Object Windows.Forms.Button
  $ResModPackButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $ResModPackButton.Location = DPISize (New-Object Drawing.Point(330, 19))
  $ResModPackButton.Name = 'ResourcePack'
  $ResModPackButton.Text = '...'
  $ResModPackButton.Add_Click({ Resource_ImportFolder_Button })
  $ResModPackGroupBox.Controls.Add($ResModPackButton)

  # Input Path: Create a groupbox to hold the texture path.
  $global:ResInputGroupBox = New-Object Windows.Forms.GroupBox
  $ResInputGroupBox.Size = DPISize (New-Object Drawing.Size(360, 50))
  $ResInputGroupBox.Location = DPISize (New-Object Drawing.Point(10, 60))
  $ResInputGroupBox.Text = ' Input Path '
  $ResInputGroupBox.Add_Click({ if (TestPath -LiteralPath $MasterInputPath) { Invoke-Item -LiteralPath $MasterInputPath} })
  $ResourceDialog.Controls.Add($ResInputGroupBox)

  # Input Path: Create a tip for the path.
  $ResInputTip = New-Object Windows.Forms.ToolTip
  $ResInputTip.InitialDelay = $ToolTipDelay
  $ResInputTip.AutoPopDelay = $ToolTipDuration
  $ResInputTipString = 'Path to the textures to include in the resource pack.'
  $ResInputTip.SetToolTip($ResInputGroupBox, $ResInputTipString)

  # Input Path: Create a text box to display and update the path.
  $global:ResInputTextBox = New-Object Windows.Forms.TextBox
  $ResInputTextBox.Size = DPISize (New-Object Drawing.Size(316, 22))
  $ResInputTextBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $ResInputTextBox.Name = 'MasterInputPath'
  $ResInputTextBox.Text = $MasterInputPath
  $ResInputTextBox.AllowDrop = $true
  $ResInputTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ResInputTextBox.Add_DragDrop({ UpdateMasterPaths_DragAndDrop })
  $ResInputTextBox.Add_Click({ ClearTextBox })
  $ResInputTextBox.Add_Leave({ UpdateMasterPaths_TextBox })
  $ResInputGroupBox.Controls.Add($ResInputTextBox)

  # Input Path: Create a button to select the path.
  $global:ResInputButton = New-Object Windows.Forms.Button
  $ResInputButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $ResInputButton.Location = DPISize (New-Object Drawing.Point(330, 19))
  $ResInputButton.Name = 'MasterInputPath'
  $ResInputButton.Text = '...'
  $ResInputButton.Add_Click({ UpdateMasterPaths_Button })
  $ResInputGroupBox.Controls.Add($ResInputButton)

  # Output Path: Create a groupbox to hold the texture path.
  $global:ResOutputGroupBox = New-Object Windows.Forms.GroupBox
  $ResOutputGroupBox.Size = DPISize (New-Object Drawing.Size(360, 50))
  $ResOutputGroupBox.Location = DPISize (New-Object Drawing.Point(380, 60))
  $ResOutputGroupBox.Text = ' Output Path '
  $ResOutputGroupBox.Add_Click({ if (TestPath -LiteralPath $MasterOutputPath) { Invoke-Item -LiteralPath $MasterOutputPath } })
  $ResourceDialog.Controls.Add($ResOutputGroupBox)

  # Output Path: Create a tip for the path.
  $ResOutputTip = New-Object Windows.Forms.ToolTip
  $ResOutputTip.InitialDelay = $ToolTipDelay
  $ResOutputTip.AutoPopDelay = $ToolTipDuration
  $ResOutputTipString = 'Path to where this script will generate the resource pack.'
  $ResOutputTip.SetToolTip($ResOutputGroupBox, $ResOutputTipString)

  # Output Path: Create a text box to display and update the path.
  $global:ResOutputTextBox = New-Object Windows.Forms.TextBox
  $ResOutputTextBox.Size = DPISize (New-Object Drawing.Size(316, 22))
  $ResOutputTextBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $ResOutputTextBox.Name = 'MasterOutputPath'
  $ResOutputTextBox.Text = $MasterOutputPath
  $ResOutputTextBox.AllowDrop = $true
  $ResOutputTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ResOutputTextBox.Add_DragDrop({ UpdateMasterPaths_DragAndDrop })
  $ResOutputTextBox.Add_Click({ ClearTextBox })
  $ResOutputTextBox.Add_Leave({ UpdateMasterPaths_TextBox })
  $ResOutputGroupBox.Controls.Add($ResOutputTextBox)

  # Output Path: Create a button to select the path.
  $global:ResOutputButton = New-Object Windows.Forms.Button
  $ResOutputButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $ResOutputButton.Location = DPISize (New-Object Drawing.Point(330, 19))
  $ResOutputButton.Name = 'MasterOutputPath'
  $ResOutputButton.Text = '...'
  $ResOutputButton.Add_Click({ UpdateMasterPaths_Button })
  $ResOutputGroupBox.Controls.Add($ResOutputButton)

  # Info: Create the panel that holds pack information.
  $global:ResInfoGroupBox = New-Object Windows.Forms.GroupBox
  $ResInfoGroupBox.Size = DPISize (New-Object Drawing.Size(730, 320))
  $ResInfoGroupBox.Location = DPISize (New-Object Drawing.Point(10, 115))
  $ResInfoGroupBox.Text = ' Pack Information:'
  $ResourceDialog.Controls.Add($ResInfoGroupBox)

  # Info: GameID - Create a label.
  $global:ResGameIDLabel = New-Object Windows.Forms.Label
  $ResGameIDLabel.Size = DPISize (New-Object Drawing.Size(60, 20))
  $ResGameIDLabel.Location = DPISize (New-Object Drawing.Point(6, 24))
  $ResGameIDLabel.Text = 'GameID: '
  $ResInfoGroupBox.Controls.Add($ResGameIDLabel)

  # Info: GameID - Create a tooltip.
  $ResGameIDTip = New-Object Windows.Forms.ToolTip
  $ResGameIDTip.InitialDelay = $ToolTipDelay
  $ResGameIDTip.AutoPopDelay = $ToolTipDuration
  $ResGameIDTipString = 'The 3/6 letter GameID for the game the pack modifies.'
  $ResGameIDTip.SetToolTip($ResGameIDLabel, $ResGameIDTipString)

  # Info: GameID - Create a text box.
  $global:ResGameIDTextBox = New-Object Windows.Forms.TextBox
  $ResGameIDTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResGameIDTextBox.Location = DPISize (New-Object Drawing.Point(80, 21)) -AddY $DPIOffsetFix
  $ResGameIDTextBox.Name = 'ResourceGameID'
  $ResGameIDTextBox.Text = $ResourceGameID
  $ResGameIDTextBox.TabStop = $true
  $ResGameIDTextBox.Add_Click({ ClearTextBox })
  $ResGameIDTextBox.Add_Leave({ SetResourcePackGameID })
  $ResInfoGroupBox.Controls.Add($ResGameIDTextBox)

  # Info: Pack Name - Create a label.
  $global:ResPackNameLabel = New-Object Windows.Forms.Label
  $ResPackNameLabel.Size = DPISize (New-Object Drawing.Size(72, 20))
  $ResPackNameLabel.Location = DPISize (New-Object Drawing.Point(6, 54))
  $ResPackNameLabel.Text = 'Pack Name: '
  $ResInfoGroupBox.Controls.Add($ResPackNameLabel)

  # Info: Pack Name - Create a tooltip.
  $ResPackNameTip = New-Object Windows.Forms.ToolTip
  $ResPackNameTip.InitialDelay = $ToolTipDelay
  $ResPackNameTip.AutoPopDelay = $ToolTipDuration
  $ResPackNameTipString = 'The name for the Resource Pack.'
  $ResPackNameTip.SetToolTip($ResPackNameLabel, $ResPackNameTipString)

  # Info: Pack Name - Create a text box.
  $global:ResPackNameTextBox = New-Object Windows.Forms.TextBox
  $ResPackNameTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResPackNameTextBox.Location = DPISize (New-Object Drawing.Point(80, 51)) -AddY $DPIOffsetFix
  $ResPackNameTextBox.Name = 'ResourceName'
  $ResPackNameTextBox.Text = $ResourceName
  $ResPackNameTextBox.TabStop = $true
  $ResPackNameTextBox.BorderStyle = 2
  $ResPackNameTextBox.Add_Click({ ClearTextBox })
  $ResPackNameTextBox.Add_Leave({ Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' ; UpdateResIDTextBox -Value $ResourceName })
  $ResInfoGroupBox.Controls.Add($ResPackNameTextBox)

  # Info: Pack ID - Create a label.
  $global:ResPackIDLabel = New-Object Windows.Forms.Label
  $ResPackIDLabel.Size = DPISize (New-Object Drawing.Size(72, 20))
  $ResPackIDLabel.Location = DPISize (New-Object Drawing.Point(6, 84))
  $ResPackIDLabel.Text = 'Pack ID: '
  $ResInfoGroupBox.Controls.Add($ResPackIDLabel)

  # Info: Pack ID - Create a tooltip.
  $ResPackIDTip = New-Object Windows.Forms.ToolTip
  $ResPackIDTip.InitialDelay = $ToolTipDelay
  $ResPackIDTip.AutoPopDelay = $ToolTipDuration
  $ResPackIDTipString = 'Unique identifier for the pack. This is automatically{0}'
  $ResPackIDTipString += 'generated from the pack name but can be modified.'
  $ResPackIDTipString = [String]::Format($ResPackIDTipString, [Environment]::NewLine)
  $ResPackIDTip.SetToolTip($ResPackIDLabel, $ResPackIDTipString)

  # Info: Pack ID - Create a text box.
  $global:ResPackIDTextBox = New-Object Windows.Forms.TextBox
  $ResPackIDTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResPackIDTextBox.Location = DPISize (New-Object Drawing.Point(80, 81)) -AddY $DPIOffsetFix
  $ResPackIDTextBox.Name = 'ResourceID'
  $ResPackIDTextBox.Text = $ResourceID
  $ResPackIDTextBox.TabStop = $true
  $ResPackIDTextBox.BorderStyle = 2
  $ResPackIDTextBox.Add_Click({ ClearTextBox })
  $ResPackIDTextBox.Add_Leave({ UpdateResIDTextBox -Value $this.Text })
  $ResInfoGroupBox.Controls.Add($ResPackIDTextBox)

  # Info: Pack Version - Create a label.
  $global:ResVersionLabel = New-Object Windows.Forms.Label
  $ResVersionLabel.Size = DPISize (New-Object Drawing.Size(60, 20))
  $ResVersionLabel.Location = DPISize (New-Object Drawing.Point(6, 114))
  $ResVersionLabel.Text = 'Version: '
  $ResInfoGroupBox.Controls.Add($ResVersionLabel)

  # Info: Pack Version - Create a tooltip.
  $ResVersionTip = New-Object Windows.Forms.ToolTip
  $ResVersionTip.InitialDelay = $ToolTipDelay
  $ResVersionTip.AutoPopDelay = $ToolTipDuration
  $ResVersionTipString = 'The current version of the Resource Pack.'
  $ResVersionTip.SetToolTip($ResVersionLabel, $ResVersionTipString)

  # Info: Pack Version - Create a text box.
  $global:ResVersionTextBox = New-Object Windows.Forms.TextBox
  $ResVersionTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResVersionTextBox.Location = DPISize (New-Object Drawing.Point(80, 111)) -AddY $DPIOffsetFix
  $ResVersionTextBox.Name = 'ResourceVersion'
  $ResVersionTextBox.Text = $ResourceVersion
  $ResVersionTextBox.TabStop = $true
  $ResVersionTextBox.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ResVersionTextBox.Add_Click({ ClearTextBox })
  $ResVersionTextBox.Add_Leave({ Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' })
  $ResInfoGroupBox.Controls.Add($ResVersionTextBox)

  # Info: Pack Authors - Create a label.
  $global:ResAuthorsLabel = New-Object Windows.Forms.Label
  $ResAuthorsLabel.Size = DPISize (New-Object Drawing.Size(60, 20))
  $ResAuthorsLabel.Location = DPISize (New-Object Drawing.Point(6, 144))
  $ResAuthorsLabel.Text = 'Authors: '
  $ResInfoGroupBox.Controls.Add($ResAuthorsLabel)

  # Info: Pack Authors - Create a tooltip.
  $ResAuthorsTip = New-Object Windows.Forms.ToolTip
  $ResAuthorsTip.InitialDelay = $ToolTipDelay
  $ResAuthorsTip.AutoPopDelay = $ToolTipDuration
  $ResAuthorsTipString = 'List of authors of the Resource Pack. These should be{0}'
  $ResAuthorsTipString += 'separated by commas. Spaces are allowed in names.'
  $ResAuthorsTipString = [String]::Format($ResAuthorsTipString, [Environment]::NewLine)
  $ResAuthorsTip.SetToolTip($ResAuthorsLabel, $ResAuthorsTipString)

  # Info: Pack Authors - Create a text box.
  $global:ResAuthorsTextBox = New-Object Windows.Forms.TextBox
  $ResAuthorsTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResAuthorsTextBox.Location = DPISize (New-Object Drawing.Point(80, 141)) -AddY $DPIOffsetFix
  $ResAuthorsTextBox.Name = 'ResourceAuthors'
  $ResAuthorsTextBox.Text = $ResourceAuthors
  $ResAuthorsTextBox.TabStop = $true
  $ResAuthorsTextBox.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ResAuthorsTextBox.Add_Click({ ClearTextBox })
  $ResAuthorsTextBox.Add_Leave({ Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' })
  $ResInfoGroupBox.Controls.Add($ResAuthorsTextBox)

  # Info: Pack Website - Create a label.
  $global:ResWebsiteLabel = New-Object Windows.Forms.Label
  $ResWebsiteLabel.Size = DPISize (New-Object Drawing.Size(49, 20))
  $ResWebsiteLabel.Location = DPISize (New-Object Drawing.Point(6, 174))
  $ResWebsiteLabel.Text = 'Website: '
  $ResInfoGroupBox.Controls.Add($ResWebsiteLabel)

  # Info: Pack Website - Create a tooltip.
  $ResWebsiteTip = New-Object Windows.Forms.ToolTip
  $ResWebsiteTip.InitialDelay = $ToolTipDelay
  $ResWebsiteTip.AutoPopDelay = $ToolTipDuration
  $ResWebsiteTipString = 'Homepage or forum post for the project.'
  $ResWebsiteTip.SetToolTip($ResWebsiteLabel, $ResWebsiteTipString)

  # Info: Pack Website - Create a text box.
  $global:ResWebsiteTextBox = New-Object Windows.Forms.TextBox
  $ResWebsiteTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResWebsiteTextBox.Location = DPISize (New-Object Drawing.Point(80, 171)) -AddY $DPIOffsetFix
  $ResWebsiteTextBox.Name = 'ResourceWebsite'
  $ResWebsiteTextBox.Text = $ResourceWebsite
  $ResWebsiteTextBox.TabStop = $true
  $ResWebsiteTextBox.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ResWebsiteTextBox.Add_Click({ ClearTextBox })
  $ResWebsiteTextBox.Add_Leave({ Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' })
  $ResInfoGroupBox.Controls.Add($ResWebsiteTextBox)

  # Info: Pack Description - Create a label.
  $global:ResDescriptionLabel = New-Object Windows.Forms.Label
  $ResDescriptionLabel.Size = DPISize (New-Object Drawing.Size(70, 20))
  $ResDescriptionLabel.Location = DPISize (New-Object Drawing.Point(6, 204))
  $ResDescriptionLabel.Text = 'Description: '
  $ResInfoGroupBox.Controls.Add($ResDescriptionLabel)

  # Info: Pack Description - Create a tooltip.
  $ResDescriptionTip = New-Object Windows.Forms.ToolTip
  $ResDescriptionTip.InitialDelay = $ToolTipDelay
  $ResDescriptionTip.AutoPopDelay = $ToolTipDuration
  $ResDescriptionTipString = 'A brief description of the Resource Pack.'
  $ResDescriptionTip.SetToolTip($ResDescriptionLabel, $ResDescriptionTipString)

  # Info: Pack Description - Create a panel that will serve as the border to the rich text box.
  $global:ResDescriptionPanel = New-Object Windows.Forms.Panel
  $ResDescriptionPanel.Size = DPISize (New-Object Drawing.Size(270, 58))
  $ResDescriptionPanel.Location = DPISize (New-Object Drawing.Point(80, 201)) -AddY $DPIOffsetFix
  $ResDescriptionPanel.Name = 'ResourceDescription'
  $ResDescriptionPanel.BackColor = '#7A7A7A'
  $ResInfoGroupBox.Controls.Add($ResDescriptionPanel)

  # Info: Pack Description - Create a rich textbox that does not have border and attach it to the panel offset by 1x1 pixel.
  $global:ResDescriptionTextBox = New-Object Windows.Forms.RichTextBox
  $ResDescriptionTextBox.Size = New-Object Drawing.Size(($ResDescriptionPanel.Size.Width - 2), ($ResDescriptionPanel.Size.Height - 2))
  $ResDescriptionTextBox.Location = New-Object Drawing.Point(1, 1)
  $ResDescriptionTextBox.Name = 'ResourceDescription'
  $ResDescriptionTextBox.Text = $ResourceDescription
  $ResDescriptionTextBox.TabStop = $true
  $ResDescriptionTextBox.BackColor = "#FFFFFF"
  $ResDescriptionTextBox.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ResDescriptionTextBox.Add_Click({ ClearTextBox })
  $ResDescriptionTextBox.Add_Leave({ Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' })
  $ResDescriptionPanel.Controls.Add($ResDescriptionTextBox)

  # Info: Pack Description - Add mouse enter/leave, got/lost focus, and state change events to simulate the border color changes.
  $ResDescriptionTextBox.Add_MouseEnter(     { if (!$this.Focused) { $ResDescriptionPanel.BackColor = '#000000' } })
  $ResDescriptionTextBox.Add_MouseLeave(     { if (!$this.Focused) { $ResDescriptionPanel.BackColor = '#7A7A7A' } })
  $ResDescriptionTextBox.Add_EnabledChanged( { if ($this.Enabled)  { $ResDescriptionPanel.BackColor = '#7A7A7A' } else { $ResDescriptionPanel.BackColor = '#CCCCCC' } })
  $ResDescriptionTextBox.Add_GotFocus(       { $ResDescriptionPanel.BackColor = '#0078d7' })
  $ResDescriptionTextBox.Add_LostFocus(      { $ResDescriptionPanel.BackColor = '#7A7A7A' })

  # Info: ZIP File Name - Create a label.
  $global:ResZipFileNameLabel = New-Object Windows.Forms.Label
  $ResZipFileNameLabel.Size = DPISize (New-Object Drawing.Size(70, 20))
  $ResZipFileNameLabel.Location = DPISize (New-Object Drawing.Point(6, 268))
  $ResZipFileNameLabel.Text = 'Zip Name: '
  $ResInfoGroupBox.Controls.Add($ResZipFileNameLabel)

  # Info: ZIP File Name - Create a tooltip.
  $ResZipFileNameTip = New-Object Windows.Forms.ToolTip
  $ResZipFileNameTip.InitialDelay = $ToolTipDelay
  $ResZipFileNameTip.AutoPopDelay = $ToolTipDuration
  $ResZipFileNameTipString = 'The output filename of the Resource Pack. Must end with ".zip".'
  $ResZipFileNameTip.SetToolTip($ResZipFileNameLabel, $ResZipFileNameTipString)

  # Info: ZIP File Name - Create a text box.
  $global:ResZipFileNameTextBox = New-Object Windows.Forms.TextBox
  $ResZipFileNameTextBox.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResZipFileNameTextBox.Location = DPISize (New-Object Drawing.Point(80, 265)) -AddY $DPIOffsetFix
  $ResZipFileNameTextBox.Name = 'ResourceZipName'
  $ResZipFileNameTextBox.Text = $ResourceZipName
  $ResZipFileNameTextBox.TabStop = $true
  $ResZipFileNameTextBox.BorderStyle = 2
  $ResZipFileNameTextBox.Add_Click({ ClearTextBox })
  $ResZipFileNameTextBox.Add_Leave({ UpdateResourceOutputZIP })
  $ResInfoGroupBox.Controls.Add($ResZipFileNameTextBox)

  # Info: Compress Resource Pack.
  $global:ResCompressPack = New-Object Windows.Forms.CheckBox
  $ResCompressPack.Size = DPISize (New-Object Drawing.Size(240, 16))
  $ResCompressPack.Location = DPISize (New-Object Drawing.Point(10, 296))
  $ResCompressPack.Name = 'ResourceCompress'
  $ResCompressPack.Text = ' Compress Resource Pack (Read Tooltip)'
  $ResCompressPack.Checked = $ResourceCompress
  $ResCompressPack.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ResInfoGroupBox.Controls.Add($ResCompressPack)

  # Info: Compress Resource Pack tooltip.
  $ResCompressPackTip = New-Object Windows.Forms.ToolTip
  $ResCompressPackTip.InitialDelay = $ToolTipDelay
  $ResCompressPackTip.AutoPopDelay = $ToolTipDuration
  $ResCompressPackTipString = 'This tells 7-Zip to create the pack using the maximum{0}'
  $ResCompressPackTipString += 'compression setting. While this will obviously mean a{0}'
  $ResCompressPackTipString += 'smaller ZIP file, if Dolphin ever gains the ability to read{0}'
  $ResCompressPackTipString += 'textures directly from the ZIP, the pack will not work.'
  $ResCompressPackTipString = [String]::Format($ResCompressPackTipString, [Environment]::NewLine)
  $ResCompressPackTip.SetToolTip($ResCompressPack, $ResCompressPackTipString)

  # Info: Logo - Create a label for the logo.
  $global:ResLogoLabel = New-Object Windows.Forms.Label
  $ResLogoLabel.Size = DPISize (New-Object Drawing.Size(49, 20))
  $ResLogoLabel.Location = DPISize (New-Object Drawing.Point(366, 24))
  $ResLogoLabel.Text = 'Logo: '
  $ResInfoGroupBox.Controls.Add($ResLogoLabel)

  # Info: Logo - Create a tooltip.
  $ResLogoTip = New-Object Windows.Forms.ToolTip
  $ResLogoTip.InitialDelay = $ToolTipDelay
  $ResLogoTip.AutoPopDelay = $ToolTipDuration
  $ResLogoTipString = 'A logo for the Resource Pack, which appears in the Dolphin {0}'
  $ResLogoTipString += 'Resource Pack Manager. The logo must not exceed 256x256 pixels.'
  $ResLogoTipString = [String]::Format($ResLogoTipString, [Environment]::NewLine)
  $ResLogoTip.SetToolTip($ResLogoLabel, $ResLogoTipString)

  # Info: Logo - Create a large button that will serve as both a picture box and a button.
  $global:ResLogoImage = New-Object Windows.Forms.Button
  $ResLogoImage.Size = New-Object Drawing.Size(256, 256)
  $ResLogoImage.Location = DPISize (New-Object Drawing.Point(440, 21))
  $ResLogoImage.Font = New-Object Drawing.Font('Tahoma', 10)
  $ResLogoImage.Name = 'ResourceLogo'
  $ResLogoImage.Text = 'Drag and drop a PNG/JPG image file or click here to add a logo.'
  $ResLogoImage.TabStop = $true
  $ResLogoImage.BackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ResLogoImage.BackgroundImageLayout = [Windows.Forms.ImageLayout]::Center
  $ResLogoImage.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $ResLogoImage.FlatAppearance.BorderSize = 1
  $ResLogoImage.FlatAppearance.MouseOverBackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ResLogoImage.AllowDrop = $true
  $ResLogoImage.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
  $ResLogoImage.Add_DragDrop({ ResAddImage_DragAndDrop })
  $ResLogoImage.Add_Click({ ResAddImage_ButtonClick })
  $ResInfoGroupBox.Controls.Add($ResLogoImage)

  # Info: Logo - Create a label for the logo adjustment.
  $global:ResLogoAdjustLabel = New-Object Windows.Forms.Label
  $ResLogoAdjustLabel.Size = DPISize (New-Object Drawing.Size(68, 20))
  $ResLogoAdjustLabel.Location = New-Object Drawing.Point((DPISize 366), ($ResLogoImage.Bottom + (DPISize 15)))
  $ResLogoAdjustLabel.Text = 'Formatting:'
  $ResInfoGroupBox.Controls.Add($ResLogoAdjustLabel)

  # Info: Logo - Create a tip for the logo adjustment.
  $ResLogoAdjustTip = New-Object Windows.Forms.ToolTip
  $ResLogoAdjustTip.InitialDelay = $ToolTipDelay
  $ResLogoAdjustTip.AutoPopDelay = $ToolTipDuration
  $ResLogoAdjustTipString = 'Allows adjusting the output of the logo.'
  $ResLogoAdjustTip.SetToolTip($ResLogoAdjustLabel, $ResLogoAdjustTipString)

  # Info: Logo - Create a combobox to select the adjustment.
  $global:ResLogoAdjustCombo = New-Object Windows.Forms.ComboBox
  $ResLogoAdjustCombo.Size = DPISize (New-Object Drawing.Size(270, 22))
  $ResLogoAdjustCombo.Location = New-Object Drawing.Point((DPISize 440), ($ResLogoImage.Bottom + (DPISize 12 -AddY $DPIOffsetFix)))
  $ResLogoAdjustCombo.Name = 'ResourceLogoAdjust'
  $ResLogoAdjustCombo.Items.Add('No Scaling | Max 256x256 Resolution') | Out-Null
  $ResLogoAdjustCombo.Items.Add('Fit to 256x256 Resolution') | Out-Null
  $ResLogoAdjustCombo.Items.Add('Stretch to 256x256 Resolution') | Out-Null
  $ResLogoAdjustCombo.SelectedItem = 'No Scaling | Max 256x256 Resolution'
  $ResLogoAdjustCombo.Add_SelectedIndexChanged({ $ResFocusLabel.Focus() })
  $ResLogoAdjustCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; ResAddImage_CreateLogo -ImageFile $ResLogoBase })
  $ResLogoAdjustCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ResLogoAdjustCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ResLogoAdjustCombo.Add_DrawItem({ RepopulateComboBox })
  $ResInfoGroupBox.Controls.Add($ResLogoAdjustCombo)

  # Buttons: Create the Start button.
  $global:ResStartButton = New-Object Windows.Forms.Button
  $ResStartButton.Size = DPISize (New-Object Drawing.Size(100, 32))
  $ResStartButton.Location = DPISize (New-Object Drawing.Point(10, 440))
  $ResStartButton.Name = 'ResStartButton'
  $ResStartButton.Text = 'Create Pack'
  $ResStartButton.Add_Click({ StartCreateResourcePack })
  $ResourceDialog.Controls.Add($ResStartButton)

  # Buttons: Create a button to import a JSON.
  $global:ResImportButton = New-Object Windows.Forms.Button
  $ResImportButton.Size = DPISize (New-Object Drawing.Size(100, 32))
  $ResImportButton.Location = DPISize (New-Object Drawing.Point(226, 440))
  $ResImportButton.Name = 'ResImportButton'
  $ResImportButton.Text = 'Import ZIP'
  $ResImportButton.AllowDrop = $true
  $ResImportButton.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ResImportButton.Add_DragDrop({ Resource_ImportFile_DragDrop })
  $ResImportButton.Add_Click({ Resource_ImportFile_ButtonClick })
  $ResourceDialog.Controls.Add($ResImportButton)

  # Buttons: Create a button to reset all the information on the dialog.
  $global:ResResetButton = New-Object Windows.Forms.Button
  $ResResetButton.Size = DPISize (New-Object Drawing.Size(100, 32))
  $ResResetButton.Location = DPISize (New-Object Drawing.Point(332, 440))
  $ResResetButton.Name = 'ResResetButton'
  $ResResetButton.Text = 'Reset Info'
  $ResResetButton.Add_Click({ ResetResourceDialog })
  $ResourceDialog.Controls.Add($ResResetButton)

  # Buttons: Create a button to quickly navigate to the textures folder.
  $global:ResTexFolderButton = New-Object Windows.Forms.Button
  $ResTexFolderButton.Size = DPISize (New-Object Drawing.Size(100, 32))
  $ResTexFolderButton.Location = DPISize (New-Object Drawing.Point(438, 440))
  $ResTexFolderButton.Name = 'ResTextureButton'
  $ResTexFolderButton.Text = 'Edit Textures'
  $ResTexFolderButton.Add_Click({ Resource_OpenTextureFolder })
  $ResTexFolderButton.Enabled = $false
  $ResourceDialog.Controls.Add($ResTexFolderButton)

  # Buttons: Create a button to close the dialog.
  $global:ResCancelButton = New-Object Windows.Forms.Button
  $ResCancelButton.Size = DPISize (New-Object Drawing.Size(100, 32))
  $ResCancelButton.Location = DPISize (New-Object Drawing.Point(640, 440))
  $ResCancelButton.Name = 'ResCloseButton'
  $ResCancelButton.Text = 'Cancel'
  $ResCancelButton.Add_Click({ $ResourceDialog.Hide() })
  $ResourceDialog.Controls.Add($ResCancelButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: MANUAL RESCALE DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $ManRescaleDialog           - Form           - Global
#  $ManRescalePicBox           - PictureBox     - Global
#  $ManRescalePanel            - Panel          - Local
#  $ManRescaleTexLabel         - TextBox        - Global
#  $ManRescaleSizeLabel        - TextBox        - Global
#  $ManRescaleScaleLabel       - TextBox        - Global
#  $ManRescaleAspectLabel      - TextBox        - Global
#  $ManRescalePathLabel        - TextBox        - Global
#  $ManRescaleControlGroup     - GroupBox       - Local
#  $ManRescaleNumBox           - NumericUpDown  - Global
#  $ManRescaleNumBoxLabel      - Label          - Global
#  $ManRescaleOKButton         - Button         - Global
#  $ManRescaleSkipButton       - Button         - Global
#  $ManRescaleCancelButton     - Button         - Global
#==============================================================================================================================================================================================
#  Sets the preview image for the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ManualRescale_ShowDialog($TextureInfo)
{
  # Get the dimensions of the preview image that doesn't exceed 280.
  $Dimensions = GetPreviewDimensions -Width $TextureInfo.Width -Height $TextureInfo.Height -Square (DPISize 280)

  # Only show previews for PNG textures.
  if ($TextureInfo.Extension -ne $PNG)
  {
    # Create a temporary image for the preview.
    $PreviewPath = CreatePath -LiteralPath ($TempFolder + '\RescalePreview\')
    $PreviewFile = $PreviewPath + $TextureInfo.Name + $PNG

    # Use my handy create texture function to create the image.
    CreatePNGTextureSingle -TextureInfo $TextureInfo -ImageFile $TextureInfo.FullPath -Width $Dimensions.Width -Height $Dimensions.Height -Format $PNG -OutputPath $PreviewPath
  }
  # The image has a PNG extension.
  else
  {
    # Simply use the PNG file to generate the preview.
    $PreviewFile = $TextureInfo.FullPath
  }
  # Resize the image to fit the preview box.
  $ImgObject = [Drawing.Image]::FromFile($PreviewFile)
  $TempBitMap = New-Object Drawing.Bitmap($ImgObject, $Dimensions.Width, $Dimensions.Height)
  $ImgObject.Dispose()

  # Apply the image to the rescale dialog.
  $ManRescalePicBox.Image = $TempBitMap

  # Show some properties of the texture on the dialog.
  $ManRescaleTexLabel.Text    = 'Texture : ' + $TextureInfo.FullName
  $ManRescaleSizeLabel.Text   = 'Size    : ' + $TextureInfo.Dimensions + ' (' + $TextureInfo.OldDimensions + ')'
  $ManRescaleScaleLabel.Text  = 'Scale   : ' + $TextureInfo.FullScale
  $ManRescaleAspectLabel.Text = 'Aspect  : ' + $TextureInfo.Aspect.ToString() + ':1 (' + $TextureInfo.OldAspect.ToString() + ':1)'
  $ManRescalePathLabel.Text   = 'Path    : ' + '..\' + (Get-Item -LiteralPath $MasterInputPath).Name + $TextureInfo.Relative

  # Update the "Scale Adjustment" to show the rescale factor.
  $ManRescaleNumBox.Value = $RescaleFactor

  # Calculate the new dimensions of the texture.
  $NewWidth  = $TextureInfo.OldWidth * [decimal]$RescaleFactor
  $NewHeight = $TextureInfo.OldHeight * [decimal]$RescaleFactor

  # Show the new dimensions on the "Scale Adjustment" window.
  $ManRescaleNumBoxLabel.Text = 'New Dimensions: ' + [int]$NewWidth.ToString() + 'x' + [int]$NewHeight.ToString()

  # Store the manual rescale value.
  $global:ManualScale = $RescaleFactor

  # Show the manual rescale dialog.
  $ManRescaleDialog.ShowDialog() | Out-Null

  # The preview is no longer needed so destroy it.
  $TempBitMap.Dispose()

  # Return the value to rescale the texture which may have been updated in "SetScale".
  return $ManualScale
}
#==============================================================================================================================================================================================
#  Updates the manual rescale value.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ManualRescale_SetScale()
{
  # Calculate the new dimensions of the texture.
  $NewWidth  = $TextureInfo.OldWidth * $this.Value
  $NewHeight = $TextureInfo.OldHeight * $this.Value

  # Show the new dimensions on the "Scale Adjustment" window.
  $ManRescaleNumBoxLabel.Text = 'New Dimensions: ' + [int]$NewWidth.ToString() + 'x' + [int]$NewHeight.ToString()

  # Store the manual rescale value.
  $global:ManualScale = $this.Value
}
#==============================================================================================================================================================================================
#  Allows skipping the texture by setting the scale to 0 (which is obviously invalid).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ManualRescale_SkipTexture()
{
  # Force this to zero before closing the dialog to signal that the texture should be skipped.
  $global:ManualScale = 0

  # Force the dialog closed so the next texture can be evaluated.
  $ManRescaleDialog.Close()
}
#==============================================================================================================================================================================================
#  Cancels the MasterLoop and forces the dialog closed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ManualRescale_CancelProcess()
{
  # Call the function that cancels the master loop.
  TexList_CancelMasterLoop

  # If it was cancelled, force the dialog closed.
  if ($CancelMasterLoop) { $ManRescaleDialog.Close() }
}
#==============================================================================================================================================================================================
#  CTT GUI: MANUAL RESCALE DIALOG CREATE
#==============================================================================================================================================================================================
#  This dialog allows rescaling each texture individually when selected from the corresponding operation.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ManualRescale()
{
  # Create the dialog that is displayed.
  $global:ManRescaleDialog = New-Object Windows.Forms.Form
  $ManRescaleDialog.Size = DPISize (New-Object Drawing.Size(316, 530))
  $ManRescaleDialog.MinimumSize = DPISize (New-Object Drawing.Size(316, 530))
  $ManRescaleDialog.MaximumSize = DPISize (New-Object Drawing.Size(316, 530))
  $ManRescaleDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ManRescaleDialog.Text = "Manual Rescale"
  $ManRescaleDialog.MaximizeBox = $false
  $ManRescaleDialog.MinimizeBox = $false
  $ManRescaleDialog.FormBorderStyle = GetFormBorderStyle
  $ManRescaleDialog.StartPosition = "CenterScreen"
  $ManRescaleDialog.KeyPreview = $true
  $ManRescaleDialog.Topmost = $true
  $ManRescaleDialog.Add_Shown({ ActivateDialog -Dialog $ManRescaleDialog })
  $ManRescaleDialog.Icon = $Icon_CTTPSGreen

  # Create the picture box that will contain the image.
  $global:ManRescalePicBox = New-Object Windows.Forms.PictureBox
  $ManRescalePicBox.Size = DPISize (New-Object Drawing.Size(280, 280))
  $ManRescalePicBox.Location = DPISize (New-Object Drawing.Point(10, 10))
  $ManRescalePicBox.BackColor = [Drawing.ColorTranslator]::FromHtml('#E0E0E0')
  $ManRescalePicBox.SizeMode = [Windows.Forms.PictureBoxSizeMode]::CenterImage
  $ManRescaleDialog.Controls.Add($ManRescalePicBox)

  # Create a panel that holds the texture properties.
  $global:ManRescalePanel = New-Object Windows.Forms.Panel
  $ManRescalePanel.Size = DPISize (New-Object Drawing.Size(280, 102))
  $ManRescalePanel.Location = DPISize (New-Object Drawing.Point(10, 300))
  $ManRescalePanel.Font = New-Object Drawing.Font('Consolas', 8, [Drawing.FontStyle]::Bold)
  $ManRescalePanel.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $ManRescalePanel.AutoScroll = $true
  $ManRescaleDialog.Controls.Add($ManRescalePanel)

  # Create a label that holds the texture name.
  $global:ManRescaleTexLabel = New-Object Windows.Forms.TextBox
  $ManRescaleTexLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ManRescaleTexLabel.Location = DPISize (New-Object Drawing.Point(3, 5))
  $ManRescaleTexLabel.Text = 'Texture : '
  $ManRescaleTexLabel.BorderStyle = 0
  $ManRescaleTexLabel.ReadOnly = $true
  $ManRescaleTexLabel.BackColor = $ManRescaleDialog.BackColor
  $ManRescaleTexLabel.TabStop = $false
  $ManRescalePanel.Controls.Add($ManRescaleTexLabel)

  # Create a label that holds the texture dimensions.
  $global:ManRescaleSizeLabel = New-Object Windows.Forms.TextBox
  $ManRescaleSizeLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ManRescaleSizeLabel.Location = DPISize (New-Object Drawing.Point(3, 20))
  $ManRescaleSizeLabel.Text = 'Size    : '
  $ManRescaleSizeLabel.BorderStyle = 0
  $ManRescaleSizeLabel.ReadOnly = $true
  $ManRescaleSizeLabel.BackColor = $ManRescaleDialog.BackColor
  $ManRescaleSizeLabel.TabStop = $false
  $ManRescalePanel.Controls.Add($ManRescaleSizeLabel)

  # Create a label that holds the texture scale.
  $global:ManRescaleScaleLabel = New-Object Windows.Forms.TextBox
  $ManRescaleScaleLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ManRescaleScaleLabel.Location = DPISize (New-Object Drawing.Point(3, 35))
  $ManRescaleScaleLabel.Text = 'Scale   : '
  $ManRescaleScaleLabel.BorderStyle = 0
  $ManRescaleScaleLabel.ReadOnly = $true
  $ManRescaleScaleLabel.BackColor = $ManRescaleDialog.BackColor
  $ManRescaleScaleLabel.TabStop = $false
  $ManRescalePanel.Controls.Add($ManRescaleScaleLabel)

  # Create a label that holds the texture aspect.
  $global:ManRescaleAspectLabel = New-Object Windows.Forms.TextBox
  $ManRescaleAspectLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ManRescaleAspectLabel.Location = DPISize (New-Object Drawing.Point(3, 50))
  $ManRescaleAspectLabel.Text = 'Aspect  : '
  $ManRescaleAspectLabel.BorderStyle = 0
  $ManRescaleAspectLabel.ReadOnly = $true
  $ManRescaleAspectLabel.BackColor = $ManRescaleDialog.BackColor
  $ManRescaleAspectLabel.TabStop = $false
  $ManRescalePanel.Controls.Add($ManRescaleAspectLabel)

  # Create a label that holds the texture path.
  $global:ManRescalePathLabel = New-Object Windows.Forms.TextBox
  $ManRescalePathLabel.Size = DPISize (New-Object Drawing.Size(500, 14))
  $ManRescalePathLabel.Location = DPISize (New-Object Drawing.Point(3, 65))
  $ManRescalePathLabel.Text = 'Path    : '
  $ManRescalePathLabel.BorderStyle = 0
  $ManRescalePathLabel.ReadOnly = $true
  $ManRescalePathLabel.BackColor = $ManRescaleDialog.BackColor
  $ManRescalePathLabel.TabStop = $false
  $ManRescalePanel.Controls.Add($ManRescalePathLabel)

  # Add a group box that holds the controls.
  $global:ManRescaleControlGroup = New-Object Windows.Forms.GroupBox
  $ManRescaleControlGroup.Size = DPISize (New-Object Drawing.Size(280, 48))
  $ManRescaleControlGroup.Location = DPISize (New-Object Drawing.Point(10, 404))
  $ManRescaleControlGroup.Text = ' Scale Adjustment'
  $ManRescaleDialog.Controls.Add($ManRescaleControlGroup)

  # Add a numeric up/down to select the new scale.
  $global:ManRescaleNumBox = New-Object Windows.Forms.NumericUpDown
  $ManRescaleNumBox.Size = DPISize (New-Object Drawing.Size(56, 12))
  $ManRescaleNumBox.Location = DPISize (New-Object Drawing.Point(10, 18))
  $ManRescaleNumBox.Name = 'RescaleFactor'
  $ManRescaleNumBox.DecimalPlaces = 2
  $ManRescaleNumBox.Value = $RescaleFactor
  $ManRescaleNumBox.Minimum = 1.00
  $ManRescaleNumBox.Maximum = 100.00
  $ManRescaleNumBox.Increment = 1
  $ManRescaleNumBox.Add_ValueChanged({ ManualRescale_SetScale })
  $ManRescaleControlGroup.Controls.Add($ManRescaleNumBox)

  # Create a label to show the new dimensions of the texture.
  $global:ManRescaleNumBoxLabel = New-Object Windows.Forms.Label
  $ManRescaleNumBoxLabel.Size = DPISize (New-Object Drawing.Size(200, 16))
  $ManRescaleNumBoxLabel.Location = DPISize (New-Object Drawing.Point(78, 21))
  $ManRescaleNumBoxLabel.Text = 'New Dimensions: 0x0'
  $ManRescaleControlGroup.Controls.Add($ManRescaleNumBoxLabel)

  # Add an "OK" button to rescale the texture.
  $global:ManRescaleOKButton = New-Object Windows.Forms.Button
  $ManRescaleOKButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $ManRescaleOKButton.Location = DPISize (New-Object Drawing.Point(10, 458))
  $ManRescaleOKButton.Name = 'RescaleOK'
  $ManRescaleOKButton.Text = 'Rescale'
  $ManRescaleOKButton.Add_Click({ $ManRescaleDialog.Close() })
  $ManRescaleDialog.Controls.Add($ManRescaleOKButton)

  # Add a "Skip" button to skip the texture.
  $global:ManRescaleSkipButton = New-Object Windows.Forms.Button
  $ManRescaleSkipButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $ManRescaleSkipButton.Location = DPISize (New-Object Drawing.Point(108, 458))
  $ManRescaleSkipButton.Name = 'RescaleSkip'
  $ManRescaleSkipButton.Text = 'Skip'
  $ManRescaleSkipButton.Add_Click({ ManualRescale_SkipTexture })
  $ManRescaleDialog.Controls.Add($ManRescaleSkipButton)

  # Add a "Cancel" button to cancel the master loop.
  $global:ManRescaleCancelButton = New-Object Windows.Forms.Button
  $ManRescaleCancelButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $ManRescaleCancelButton.Location = DPISize (New-Object Drawing.Point(207, 458))
  $ManRescaleCancelButton.Name = 'RescaleSkip'
  $ManRescaleCancelButton.Text = 'Cancel'
  $ManRescaleCancelButton.Add_Click({ ManualRescale_CancelProcess })
  $ManRescaleDialog.Controls.Add($ManRescaleCancelButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $OptionsDialog               - Form           - Global
#  $OptionsTabControl           - TabControl     - Local
#  $OptionsTabPaths             - TabPage        - Local
#  $OptionsTabPrefs             - TabPage        - Local
#  $OptionsTabDebug             - TabPage        - Local
#  $OptionsPathsPanel           - Panel          - Local
#  $OptionsImageMagickGroup     - GroupBox       - Local
#  $OptionsImageMagickTip       - ToolTip        - Local
#  $OptionsImageMagickTextBox   - TextBox        - Global
#  $OptionsImageMagickButton    - Button         - Local
#  $OptionsTexConvGroup         - GroupBox       - Local
#  $OptionsTexConvTip           - ToolTip        - Local
#  $OptionsTexConvTextBox       - TextBox        - Global
#  $OptionsTexConvButton        - Button         - Local
#  $OptionsCompressGroup        - GroupBox       - Local
#  $OptionsCompressTip          - ToolTip        - Local
#  $OptionsCompressTextBox      - TextBox        - Global
#  $OptionsCompressButton       - Button         - Local
#  $OptionsIshiirukaGroup       - GroupBox       - Local
#  $OptionsIshiirukaTip         - ToolTip        - Local
#  $OptionsIshiirukaTextBox     - TextBox        - Global
#  $OptionsIshiirukaButton      - Button         - Local
#  $OptionsOptimizerGroup       - GroupBox       - Local
#  $OptionsOptimizerTip         - ToolTip        - Local
#  $OptionsOptimizerTextBox     - TextBox        - Global
#  $OptionsOptimizerButton      - Button         - Local
#  $OptionsScalerTestGroup      - GroupBox       - Local
#  $OptionsScalerTestTip        - ToolTip        - Local
#  $OptionsScalerTestTextBox    - TextBox        - Global
#  $OptionsScalerTestButton     - Button         - Local
#  $OptionsWaifu2xGroup         - GroupBox       - Local
#  $OptionsWaifu2xTip           - ToolTip        - Local
#  $OptionsWaifu2xTextBox       - TextBox        - Global
#  $OptionsWaifu2xButton        - Button         - Local
#  $OptionsPKGToolGroup         - GroupBox       - Local
#  $OptionsPKGToolTip           - ToolTip        - Local
#  $OptionsPKGToolTextBox       - TextBox        - Global
#  $OptionsPKGToolButton        - Button         - Local
#  $OptionsAppDataGroup         - GroupBox       - Local
#  $OptionsAppDataTip           - ToolTip        - Local
#  $OptionsAppDataButton        - Button         - Local
#  $OptionsPreferenceGroup      - GroupBox       - Local
#  $OptionsPreferenceGroupTip   - ToolTip        - Local
#  $OptionsEnableStoring        - CheckBox       - Global
#  $OptionsEnableStoringTip     - ToolTip        - Local
#  $OptionsDisableLogFile       - CheckBox       - Global
#  $OptionsDisableLogTip        - ToolTip        - Local
#  $OptionsPSClickOpen          - CheckBox       - Local
#  $OptionsPSClickOpenTip       - ToolTip        - Local
#  $OptionsUpdateRateNumBox     - NumericUpDown  - Global
#  $OptionsUpdateRateLabel      - Label          - Local
#  $OptionsUpdateRateTip        - ToolTip        - Local
#  $OptionsTopMostDialog        - CheckBox       - Global
#  $OptionsTopMostDialogTip     - ToolTip        - Local
#  $OptionsShowQuickHelp        - CheckBox       - Global
#  $OptionsShowQuickHelpTip     - ToolTip        - Local
#  $OptionsGlobalMinimize       - CheckBox       - Global
#  $OptionsGlobalMinimizeTip    - ToolTip        - Local
#  $OptionsVisualStyleCheckBox  - CheckBox       - Global
#  $OptionsVisualStyleTip       - ToolTip        - Local
#  $OptionsDebugWarningGroup    - GroupBox       - Local
#  $OptionsDebugWarningLabel    - Label          - Local
#  $OptionsDebugGroup           - GroupBox       - Local
#  $OptionsDebugGroupTip        - ToolTip        - Local
#  $OptionsPSConsoleCheckBox    - CheckBox       - Global
#  $OptionsPSConsoleTip         - ToolTip        - Local
#  $OptionsForceBC7CheckBox     - CheckBox       - Global
#  $OptionsForceBC7Tip          - ToolTip        - Local
#  $OptionsDDSHeaderCheckBox    - CheckBox       - Global
#  $OptionsDDSHeaderTip         - ToolTip        - Local
#  $OptionsDumpIconsCheckBox    - CheckBox       - Global
#  $OptionsDumpIconsTip         - ToolTip        - Local
#  $OptionsDefaultButton        - Button         - Local
#  $OptionsDefaultTip           - ToolTip        - Local
#  $OptionsImportButton         - Button         - Local
#  $OptionsImportTip            - ToolTip        - Local
#  $OptionsCloseButton          - Button         - Local
#  $OptionsCloseButtonTip       - ToolTip        - Local
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - IMPORT STORED OPTIONS FUNCTIONS
#==============================================================================================================================================================================================
#  Click to open a "Open File" browser to select a CTT-PS script to import.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImportAllGlobalVariables_Button()
{
  # Display an "Open File" menu to get the path.
  $TextureToolPath = Get-FileName -StartPath $BaseFolder -FileName '*.ps1' -Description 'PowerShell Script'

  # Test if a file was actually selected.
  if (TestPath -LiteralPath $TextureToolPath) 
  {
    # Attempt to import stored options.
    ImportAllGlobalVariables -ImportPath $TextureToolPath
  }
}
#==============================================================================================================================================================================================
#  Drag and drop a CTT-PS script onto the "Import Stored Options" button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ImportAllGlobalVariables_DragAndDrop()
{
  # The function was called by dragging and dropping an item.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $TextureToolPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

    # To properly get the extension of the selected file, retrieve it with Get-Item.
    $TextureToolExtn = (Get-Item -LiteralPath $TextureToolPath).Extension

    # Test if a file was actually selected and its a PS1 script.
    if ((TestPath -LiteralPath $TextureToolPath) -and ($TextureToolExtn -eq '.ps1'))
    {
      # Attempt to import stored options.
      ImportAllGlobalVariables -ImportPath $TextureToolPath
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - OPERATION OPTION FUNCTIONS
#==============================================================================================================================================================================================
#  Updates each super scaler script by the below function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateSuperScalerScript([string]$FilterPath, [string]$SearchText, [string]$NewLineText, [string]$ScriptName)
{
  # Test the path to make sure the fucker exists.
  if (TestPath -LiteralPath $FilterPath)
  {
    # Set the complete path to the python script.
    $ScriptedPath = $FilterPath + $ScriptName.Replace("'","")

    # Get the content of the python script.
    $Content = Get-Content -LiteralPath $ScriptedPath

    # Loop through the python script until the device is found.
    for ($i = 0 ; $i -lt $Content.Length ; $i++)
    {
      # Search for the exact string below.
      if ($Content[$i] -like $SearchText)
      {
        # Reassemble the line with the text.
        $Content[$i] = $NewLineText
      }
    }
    # Write the new database file that has the entry excluded.
    Set-Content -LiteralPath $ScriptedPath -Value $Content
  }
}
#==============================================================================================================================================================================================
#  Updates the SFTGAN model when selecting a new one.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateSFTGANModel([string]$Model)
{
  # Check to see if the model is not the segmentation which has its own unique script.
  if ($Model -ne 'segmentation_OST_bic')
  {
    # Build the path to the new model.
    $ModelPath = "model_path = '../pretrained_models/" + $Model + ".pth'"

    # Update the script to set the new model.
    UpdateSuperScalerScript -FilterPath $SFTGANBasePath -SearchText 'model_path =*' -NewLineText $ModelPath -ScriptName '\pytorch_test\test_sftgan.py'
  }
}
#==============================================================================================================================================================================================
#  Updates all the super scaler python scripts.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AttemptEditSuperScalerScripts()
{
  # Update the scripts to set the device to cpu.
  if ($this.Checked)
  {
    UpdateSuperScalerScript -FilterPath $ESRGANBasePath -SearchText 'device =*' -NewLineText "device = torch.device('cpu')" -ScriptName '\test.py'
    UpdateSuperScalerScript -FilterPath $SFTGANBasePath -SearchText 'device =*' -NewLineText "device = torch.device('cpu')" -ScriptName '\pytorch_test\test_sftgan.py'
    UpdateSuperScalerScript -FilterPath $SFTGANBasePath -SearchText 'device =*' -NewLineText "device = torch.device('cpu')" -ScriptName '\pytorch_test\test_segmentation.py'
  }
  # Update the scripts to set the device to cuda.
  else
  {
    UpdateSuperScalerScript -FilterPath $ESRGANBasePath -SearchText 'device =*' -NewLineText "device = torch.device('cuda')" -ScriptName '\test.py'
    UpdateSuperScalerScript -FilterPath $SFTGANBasePath -SearchText 'device =*' -NewLineText "device = torch.device('cuda')" -ScriptName '\pytorch_test\test_sftgan.py'
    UpdateSuperScalerScript -FilterPath $SFTGANBasePath -SearchText 'device =*' -NewLineText "device = torch.device('cuda')" -ScriptName '\pytorch_test\test_segmentation.py'
  }
  # Update the variable with the new state.
  Set-Variable -Name $this.Name -Value $this.Checked -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Undo changes to ESRGAN by rapka because my script was already coded for the original version.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RevertESRGANChanges()
{
  # Replace the changes that rapka made to the python scripts.
  UpdateSuperScalerScript -FilterPath $ESRGANBasePath -SearchText 'test_img_folder = *' -NewLineText "test_img_folder = 'LR/*'" -ScriptName '\test.py'
  UpdateSuperScalerScript -FilterPath $ESRGANBasePath -SearchText '*cv2.imwrite*'       -NewLineText "    cv2.imwrite('results/{:s}_rlt.png'.format(base), output)" -ScriptName '\test.py'

  # Remove all the test images from ESRGAN.
  RemovePath -Literalpath ($ESRGANBasePath + '\LR\baboon.png')
  RemovePath -Literalpath ($ESRGANBasePath + '\LR\comic.png')
  RemovePath -Literalpath ($ESRGANBasePath + '\results\baboon_ESRGAN.png')
  RemovePath -Literalpath ($ESRGANBasePath + '\models\README.md')
}
#==============================================================================================================================================================================================
#  Gets rid of the default garbage in the SFTGAN folder.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CleanSFTGANFolder()
{
  # Remove all the test images from SFTGAN.
  RemovePath -Literalpath ($SFTGANBasePath + '\data\samples\OST_013.png')
  RemovePath -Literalpath ($SFTGANBasePath + '\data\samples\OST_215.png')
  RemovePath -Literalpath ($SFTGANBasePath + '\pretrained_models\README.md')
}
#==============================================================================================================================================================================================
#  Toggles OpenCL when the DisableGPU checkbox is checked since both can't be enabled.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleUseOpenCL()
{
  # If the box is checked then uncheck the competing box.
  if ($this.Checked) { $OptionsW2XOpenCLBox.Checked = $false }

  # Update the variable with the new state.
  Set-Variable -Name $this.Name -Value $this.Checked -Scope 'Global'
}
#==============================================================================================================================================================================================
#  Toggles DisableGPU when the OpenCL checkbox is checked since both can't be enabled.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleDisableGPU()
{
  # If the box is checked then uncheck the competing box.
  if ($this.Checked) { $OptionsW2XDisableGPU.Checked = $false }

  # Update the variable with the new state.
  Set-Variable -Name $this.Name -Value $this.Checked -Scope 'Global'
}
#==============================================================================================================================================================================================
#  There are two names for a model: the one shown on the GUI, and the internal model name. This function flips the name to the other.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Waifu2x_FlipModelName([string]$ModelName)
{
  # Which ever version of the model name is given, give back the opposite name.
  switch ($ModelName)
  {
    # -- Anime Style Art Model
    '2D Illust (RGB)'               { return 'anime_style_art_rgb' }
    'anime_style_art_rgb'           { return '2D Illust (RGB)' }

    # -- High Quality Anime Style Art Model
    '2D Illust (UpRGB)'             { return 'upconv_7_anime_style_art_rgb'}
    'upconv_7_anime_style_art_rgb'  { return '2D Illust (UpRGB)'}

    # -- UpResNet10 Model
    '2D Illust (UpResNet10)'        { return 'upresnet10' }
    'upresnet10'                    { return '2D Illust (UpResNet10)' }

    # -- CUnet Model
    '2D Illust (CUnet)'             { return 'cunet' }
    'cunet'                         { return '2D Illust (CUnet)' }

    # -- Simple Anime Style Art Model
    '2D Illust (Y)'                 { return 'anime_style_art' }
    'anime_style_art'               { return '2D Illust (Y)' }

    # -- Photo Model
    'Photo (Standard)'              { return 'photo' }
    'photo'                         { return 'Photo (Standard)' }

    # -- High Quality Photo Model
    'Photo (UpPhoto)'               { return 'upconv_7_photo' }
    'upconv_7_photo'                { return 'Photo (UpPhoto)' }
  }
}
#==============================================================================================================================================================================================
#  There are two names for a mode: the one shown on the GUI, and the internal mode name. This function flips the name to the other.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Waifu2x_FlipConvertModeName([string]$ModeName)
{
  # Older versions of the tool used capitalization so retain compatibility.
  switch ($ModeName.ToLower())
  {
    # -- Denoise and Scale
    'Denoise & Scale'       { return 'noise_scale' }
    'noise_scale'           { return 'Denoise & Scale' }

    # -- Scale Only
    'Scale Only'            { return 'scale'}
    'scale'                 { return 'Scale Only'}

    # -- Denoise Only
    'Denoise Only'          { return 'noise' }
    'noise'                 { return 'Denoise Only' }

    # -- Scale and Auto-Denoise
    'Scale & Auto-Denoise'  { return 'auto_scale' }
    'auto_scale'            { return 'Scale & Auto-Denoise' }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - FOLDER PATH OPTIONS
#==============================================================================================================================================================================================
#  Moves data from an "old" CTT-PS Data folder to a "new" CTT-PS Data folder.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckMoveCTTPSDataFolder([string]$DataCheckPath)
{
  # Check to see if the data install path exists.
  if (TestPath -LiteralPath $DataCheckPath)
  {
    # Loop through the files and folders found there.
    foreach ($Item in Get-ChildItem -LiteralPath $DataCheckPath)
    {
      # Check to see if the file or folder being moved already exists.
      $DataExistPath = $TextureToolData + '\' + $Item.Name

      # Attempt to remove the existing file or folder.
      RemovePath -LiteralPath $DataExistPath

      # Move the file or folder to the CTT-PS Data path.
      Move-Item -LiteralPath $Item.FullName -Destination $TextureToolData -Force
    }
    # Remove the now empty folder from the script path.
    RemovePath -LiteralPath $DataCheckPath
  }
}
#==============================================================================================================================================================================================
#  Updates the CTT-PS Data folder and relocates the contents.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateCTTPSDataPath()
{
  # Keep track of the old texture tool data folder.
  $OldTextureToolData = $TextureToolData

  # Whatever the path currently is, update the textbox to reflect it.
  $DataFolderTextBox.Text = $TextureToolData

  # Show the dialog to select the path.
  $DataFolderDialog.Icon = $Icon_CTTPSRed
  $DataFolderDialog.ShowDialog() | Out-Null

  # Only update anything if the location has changed.
  if ($DataFolderTextBox.Text -ne $OldTextureToolData)
  {
    # Store the new path and create the folder if it doesn't exist.
    $global:TextureToolData = CreatePath -LiteralPath $DataFolderTextBox.Text

    # Update the textbox on the options menu.
    $OptionsToolDataTextBox.Text = $DataFolderTextBox.Text

    # Update the various paths that are found within.
    $global:StoredOptionsFile = $TextureToolData + '\StoredOptions.ini'
    $global:ResourcePackData  = $TextureToolData + '\ResourcePackDatabase.rpd'
    $global:CustomExecutables = $TextureToolData + '\CLIExecutables.ini'
    $global:TempFolder        = $TextureToolData + '\Temp'

    # Move all the files from the old data folder into the new one.
    CheckMoveCTTPSDataFolder -DataCheckPath $OldTextureToolData

    # Store this variable to the script now in case it gets closed without saving.
    StoreSingleGlobalVariable -VarName 'TextureToolData'
  }
  # If using a master path for programs.
  if ($UseToolsMasterPath)
  {
    # Check if the master programs path was within the ctt-ps data path.
    if ($ToolsMasterPath -like ($OldTextureToolData + '*'))
    {
      # Crop out the data path which will leave just the relative path.
      $RelativePath = $ToolsMasterPath.Replace($OldTextureToolData,'')

      # Set the new path to the tools master path.
      $global:ToolsMasterPath = $TextureToolData + $RelativePath

      # Update the text box with the new path.
      $OptionsMasterToolsTextBox.Text = $ToolsMasterPath

      # Update all the new paths to the programs.
      MasterToolsPathUpdate -UpdateGUI
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - EXCLUSIONS OPTIONS
#==============================================================================================================================================================================================
#  A check to make sure not all file extensions can be unchecked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckFileExtensionExclusions()
{
  # Let's do this array style cause its fun.
  $OptionChecked = New-Object bool[] 5

  # See if all options have been unchecked.
  $OptionChecked[0] = !$OptionsExPNGCheck.Checked
  $OptionChecked[1] = !$OptionsExDDSCheck.Checked
  $OptionChecked[2] = !$OptionsExJPGCheck.Checked
  $OptionChecked[3] = !$OptionsExTGACheck.Checked
  $OptionChecked[4] = !$OptionsExTIFCheck.Checked

  # Test the array of conditions.
  if (TestBooleanArray -And -Array $OptionChecked)
  {
    # If all items are unchecked with PNG being the final one, enable DDS.
    if ($this -eq $OptionsExPNGCheck)
    {
      $OptionsExDDSCheck.Checked = $true
    }
    # If anything else is unchecked, force enable PNG checkbox.
    else
    {
      $OptionsExPNGCheck.Checked = $true
    }
  }
}
#==============================================================================================================================================================================================
#  Excludes certain words and phrases by entering them into the text box.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function StoreExclusionStrings()
{
  # Create a new array to hold all the lines.
  $StringList = New-Object Collections.Generic.List[string]

  # Make sure the textbox is not empty.
  if ($this.Lines.Length -gt 0)
  {
    # Loop through each line in the text box.
    foreach ($Line in $this.Lines)
    {
      # Make sure the line actually contains text.
      if ($Line -ne '')
      {
        # Add the line to the array, but trim any white space.
        $StringList.Add($Line)
      }
    }
  }
  # Make sure that valid entries were actually added.
  if ($StringList.Count -eq 0)
  {
    # Null out the variables if there are no valid entries.
    $StringList = $null
  }
  # Set the array to a global variable to reference later.
  $global:ExcludeStrings = $StringList
}

#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - PREFERENCES FUNCTIONS
#==============================================================================================================================================================================================
#  Builds a list of several potential locations of the "CTT-PS Programs" folder that contains all the external programs.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetCTTPSProgramPaths()
{
  #Build a list of paths to test for the programs folder.
  $SearchPaths = New-Object Collections.Generic.List[string]

  # First search in the CTT-PS Data folder.
  $SearchPaths.Add($TextureToolData + '\Programs')
  $SearchPaths.Add($TextureToolData + '\CTT-PS Programs')

  # Now do a search in AppData\Local folder.
  $SearchPaths.Add([Environment]::GetFolderPath("LocalApplicationData") + '\CTT-PS Data\Programs')
  $SearchPaths.Add([Environment]::GetFolderPath("LocalApplicationData") + '\CTT-PS Data\CTT-PS Programs')

  # Next search through documents.
  $SearchPaths.Add([Environment]::GetFolderPath("MyDocuments") + '\CTT-PS Data\Programs')
  $SearchPaths.Add([Environment]::GetFolderPath("MyDocuments") + '\CTT-PS Data\CTT-PS Programs')

  # Might be in root of a hard disk?
  foreach ($Disk in $HardDisks)
  {
    # Go through all the letters :D.
    $SearchPaths.Add($Disk.ToString() + 'CTT-PS Data\Programs')
    $SearchPaths.Add($Disk.ToString() + 'CTT-PS Data\CTT-PS Programs')
    $SearchPaths.Add($Disk.ToString() + 'CTT-PS Programs')
  }
  # Also add the path where CTT-PS currently is.
  $SearchPaths.Add($BaseFolder + '\CTT-PS Data\Programs')
  $SearchPaths.Add($BaseFolder + '\CTT-PS Data\CTT-PS Programs')

  # Loop through all hard drives to attempt to find the "CTT-PS Programs" folder.
  foreach ($Disk in $HardDisks)
  {
    # Add some paths. The user should not be dumb and use the "Program Files" folders, but check there just in case.
    $SearchPaths.Add($Disk.ToString() + 'Program Files\CTT-PS Programs')
    $SearchPaths.Add($Disk.ToString() + 'Program Files (x86)\CTT-PS Programs')
  }
  # Return the potential paths.
  return $SearchPaths
}
#==============================================================================================================================================================================================
#  Toggles the state of the master path on the "Tool Paths" menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleMasterToolPaths()
{
  # Update the variable with the new value.
  $global:UseToolsMasterPath = $this.Checked

  # Enable or disable the textbox and button depending on the state of the variable.
  $OptionsMasterToolsButton.Enabled = $this.Checked
  $OptionsMasterToolsTextBox.Enabled = $this.Checked

  # The box was unchecked.
  if (!$this.Checked)
  {
    # Reset the path to an empty string.
    $global:ToolsMasterPath = ''

    # Update the text box to hold an empty string.
    $OptionsMasterToolsTextBox.Text = $ToolsMasterPath

    # Leave now so the rest of the function doesn't run.
    return
  }
  # Everything past this point means the box was checked. Build a list of paths to test for the programs folder.
  $ProgramPaths = GetCTTPSProgramPaths

  # Loop through the paths now that we have a pretty thorough list of potential locations.
  foreach ($Path in $ProgramPaths)
  {
    # Check to see if the path exists.
    if (TestPath -LiteralPath $Path)
    {
      # Update the master path to the folder location.
      $global:ToolsMasterPath = $Path

      # Update any and all tools found in the folder.
      MasterToolsPathUpdate -UpdateGUI

      # We're done here boyz.
      break
    }
  }
  # Update the textbox with the new master tool path text.
  $OptionsMasterToolsTextBox.Text = $ToolsMasterPath
}
#==============================================================================================================================================================================================
#  Create and run a registry script that allows double clicking a PowerShell script to open it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TogglePowerShellOpenWithClicks()
{
  # Create a temporary folder to create the registry entry.
  $RegPath = CreatePath -LiteralPath ($TextureToolData + '\RegMods')

  # Get the current state of the value in the registry.
  $PS_DC_State = (Get-ItemProperty -LiteralPath "HKLM:\Software\Classes\Microsoft.PowerShellScript.1\Shell").'(default)'

  # Check the current state. A zero means a double click will work, "Open" means it will open Notepad.
  switch ($PS_DC_State)
  {
    # Set the path to the registry file.
    '0'     { $RegFile = $RegPath + '\' + 'ps_double_click_disable.reg' }
    default { $RegFile = $RegPath + '\' + 'ps_double_click_enable.reg' }
  }
  # If the registry mod doesn't exist it needs to be created.
  if (!(TestPath -LiteralPath $RegFile))
  {
    # Create the registry file.
    Add-Content -LiteralPath $RegFile -Value 'Windows Registry Editor Version 5.00'
    Add-Content -LiteralPath $RegFile -Value ''
    Add-Content -LiteralPath $RegFile -Value '[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Microsoft.PowerShellScript.1\Shell]'

    # Check the current state and add the value to the registry.
    switch ($PS_DC_State)
    {
      # A "0" means that a script won't automatically launch with PowerShell so change it to "Open".
      '0'     { Add-Content -LiteralPath $RegFile -Value '@="Open"' }
      default { Add-Content -LiteralPath $RegFile -Value '@="0"' }
    }
  }
  # Execute the registry file.
  & regedit /s $RegFile
}
#==============================================================================================================================================================================================
#  Toggle whether or not to store all options when the script is closed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleStoringOptions()
{
  # If "Enable Storing" is unchecked, force unchecking the store paths checkboxes.
  if (!$this.Checked)
  {
    $MainStoreInput.Checked  = $false
    $MainStoreOutput.Checked = $false
  }
  # Toggle the "enabled" state of the Master Input/Output store path checkboxes.
  $MainStoreInput.Enabled  = $this.Checked
  $MainStoreOutput.Enabled = $this.Checked
}
#==============================================================================================================================================================================================
#  Toggles whether or not dialogs are set to be above all other windows.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleTopMostDialogs()
{
  $MainDialog.Topmost       = !$DisableTopMost
  $TexListDialog.Topmost    = !$DisableTopMost
  $OptionsDialog.Topmost    = !$DisableTopMost
  $ManRescaleDialog.Topmost = !$DisableTopMost
  $ImgViewDialog.Topmost    = !$DisableTopMost
  $CombineDialog.Topmost    = !$DisableTopMost
  $ProcessDialog.Topmost    = !$DisableTopMost
}
#==============================================================================================================================================================================================
#  Toggles visibility of the "Quick Help" icon shown on the docked menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleDockedQuickHelp()
{
  # Show the docked Quick Help icon if enabled.
  $MainQuickHelp.Visible = $ShowQuickHelpIcon

  # Adjust the width of the Operation combo box based on the icon status.
  switch ($ShowQuickHelpIcon)
  {
    $true  { $MainOperations.Size = DPISize (New-Object Drawing.Size(334, 20)) } 
    $false { $MainOperations.Size = DPISize (New-Object Drawing.Size(360, 20)) }
  }
}
#==============================================================================================================================================================================================
#  Toggle showing the WebLink icons.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleWebLinkIcons()
{
  # To prevent a ton of lines of code, add all groupboxes into an array.
  $TextBoxes = @( $OptionsMasterToolsTextBox, $OptionsImageMagickTextBox, $OptionsTexConvTextBox, $OptionsCompressTextBox, $OptionsIshiirukaTextBox, $OptionsMatMapGenTextBox, $OptionsExtractTexTextBox, `
                  $OptionsOptiPNGTextBox, $OptionsOxiPNGTextBox, $OptionsPingoTextBox, $OptionsECTTextBox, $OptionsScalerTestTextBox, $OptionsWaifu2xTextBox, $Options7ZipTextBox, $OptionsPKGToolTextBox, `
                  $OptionsPythonTextBox, $OptionsESRGANTextBox, $OptionsSFTGANTextBox )

  # Add all the buttons that open the path selection.
  $OpenPaths = @( $OptionsMasterToolsButton, $OptionsImageMagickButton, $OptionsTexConvButton, $OptionsCompressButton, $OptionsIshiirukaButton, $OptionsMatMapGenButton, $OptionsExtractTexButton, `
                  $OptionsOptiPNGButton, $OptionsOxiPNGButton, $OptionsPingoButton, $OptionsECTButton, $OptionsScalerTestButton, $OptionsWaifu2xButton, $Options7ZipButton, $OptionsPKGToolButton, `
                  $OptionsPythonButton, $OptionsESRGANButton, $OptionsSFTGANButton )

  # And add all weblink icons into a separate array.
  $WebLinkBt = @( $OptionsMasterToolsWeb, $OptionsImageMagickWeb, $OptionsTexConvWeb, $OptionsCompressWeb, $OptionsIshiirukaWeb, $OptionsMatMapGenWeb, $OptionsExtractTexWeb, `
                  $OptionsOptiPNGWeb, $OptionsOxiPNGWeb, $OptionsPingoWeb, $OptionsECTWeb, $OptionsScalerTestWeb, $OptionsWaifu2xWeb, $Options7ZipWeb, $OptionsPKGToolWeb, `
                  $OptionsPythonWeb, $OptionsESRGANWeb, $OptionsSFTGANWeb )

  # If showing the icons, use a smaller box and set the icons to visible. If disabling, extend the box and set the buttons to invisible.
  switch ($ShowWebLinkIcons)
  {
    # Show the weblink icons.
    $true   {
              $BoxLength  = DPISize 321
              $ButtonPosX = DPISize 332
              $ButtonPosY = DPISize 19
              $ShowWebLink = $true
            }
    # Hide the weblink icons.
    $false  {
              $BoxLength  = DPISize 344
              $ButtonPosX = DPISize 356
              $ButtonPosY = DPISize 19
              $ShowWebLink = $false
            }
  }
  # The "Master Path" requires a slightly different size so adjust accordingly.
  foreach ($Box in $TextBoxes)
  {
    # Adjust the "Master Path" textbox size to accommodate the missing weblink icon.
    if ($Box -eq $OptionsMasterToolsTextBox)
    {
      $Box.Size = New-Object Drawing.Size(($BoxLength - (DPISize 18)), 22)
    }
    # Adjust any other textboxes to their original size.
    else
    {
      $Box.Size = New-Object Drawing.Size($BoxLength, 22)
    }
  }
  # Move the path selector buttons.
  foreach ($But in $OpenPaths) { $But.Location = New-Object Drawing.Point($ButtonPosX, $ButtonPosY) }

  # Toggle the weblink buttons.
  foreach ($Web in $WebLinkBt) { $Web.Visible = $ShowWebLink }
}
#==============================================================================================================================================================================================
#  Shows a menu strip for weblink buttons that have multiple programs associated with them.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowContextMenuStrip([Windows.Forms.Button]$Button, [Windows.Forms.ContextMenuStrip]$MenuStrip)
{
  # Calculate the position of the button in relation to the screen.
  $FirstPoint  = New-Object System.Drawing.Point($Button.Left, $Button.Bottom)
  $ScreenPoint = $Button.PointToScreen($FirstPoint)

  # Stores whether or not the tooltip currently fits under the button.
  $ToolTipFits = (($ScreenPoint.Y + $MenuStrip.Size.Height) -gt ([System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height))

  # Perform the check to see if the tooltip fits on the screen.
  switch ($ToolTipFits)
  {
    # If it doesn't fit, show it above the button. If it does fit, show it below the button.
    $true  { $DisplayPoint = New-Object System.Drawing.Point(0, -($MenuStrip.Size.Height)) }
    $false { $DisplayPoint = New-Object System.Drawing.Point(0, $Button.Height) }
  }
  # Show the menu at the calculated position.
  $MenuStrip.Show($Button, $DisplayPoint)
}
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - DEBUG FUNCTIONS
#==============================================================================================================================================================================================
#  Toggle showing the PowerShell console.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function TogglePowerShellConsole()
{
  # Toggle the console state based on whether or not it's checked.
  ShowPowerShellConsole -ShowConsole $EnableThePSConsole

  # Activate both the main and options dialog, so the PowerShell console doesn't overlap them.
  ActivateDialog -Dialog $MainDialog 
  ActivateDialog -Dialog $OptionsDialog
}
#==============================================================================================================================================================================================
#  Toggle showing the "No Save" buttons near the "Exit" button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleNoSaveButtons($ToggleCheck)
{
  # Get the state of the checkbox or variable.
  switch ($ToggleCheck)
  {
    # If showing the [!] buttons, show them before shrinking the "Start" buttons to avoid flicker.
    $true   {
              # Toggle the visibility of the [$] buttons, then set the new width of the "Start" buttons.
              $MainNoSaveButton.Visible = $TexListNoSaveButton.Visible = $ToggleCheck
              $MainCloseButton.Size     = $TexListCloseButton.Size     = (DPISize (New-Object Drawing.Size(72, 28)))
            }
    # If hiding the [!] buttons, hide them before growing the "Start" buttons to avoid flicker.
    $false  {
              # Set the new width of the "Start" buttons, then toggle the visibility of the [$] buttons.
              $MainCloseButton.Size     = $TexListCloseButton.Size     = (DPISize (New-Object Drawing.Size(88, 28)))
              $MainNoSaveButton.Visible = $TexListNoSaveButton.Visible = $ToggleCheck
            }
  }
}
#==============================================================================================================================================================================================
#  Set the limit of how many buttons can be created on the combine textures dialog. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetCombineSplitLimit()
{
  # Set the limit for the maximum number of nodes on the grid.
  $CombineColumnsNumBox.Maximum   = $SplitCombineLimits
  $CombineRowsNumBox.Maximum      = $SplitCombineLimits
  $SplitTextureColsNumBox.Maximum = $SplitCombineLimits
  $SplitTextureRowsNumBox.Maximum = $SplitCombineLimits

  # Set the limit for overlap pixels.
  $CombineOverlapNumBox.Maximum    = ($SplitCombineLimits / 4)
  $CombinePixelCropLNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropTNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropBNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropRNumBox.Maximum = $SplitCombineLimits

  # Set the limit for removal of garbage pixels.
  $SplitOverlapNumBox.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreL.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreT.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreB.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreR.Maximum = $SplitCombineLimits
}
#==============================================================================================================================================================================================
#  CTT GUI: OPTIONS MENU DIALOG - CREATE
#==============================================================================================================================================================================================
#  A special dialog for the Preferences, Paths, and Debug options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_OptionsMenu()
{
  # Create the dialog that is displayed.
  $global:OptionsDialog = New-Object Windows.Forms.Form
  $OptionsDialog.Size = DPISize (New-Object Drawing.Size(440, 564))
  $OptionsDialog.MinimumSize = DPISize (New-Object Drawing.Size(440, 564))
  $OptionsDialog.MaximumSize = DPISize (New-Object Drawing.Size(440, 564))
  $OptionsDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $OptionsDialog.Text = 'CTT-PS Options'
  $OptionsDialog.MaximizeBox = $false
  $OptionsDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $OptionsDialog.FormBorderStyle = GetFormBorderStyle
  $OptionsDialog.StartPosition = "CenterScreen"
  $OptionsDialog.Topmost = !$DisableTopMost
  $OptionsDialog.KeyPreview = $true
  $OptionsDialog.Add_Shown({ ActivateDialog -Dialog $this })
  $OptionsDialog.Add_KeyDown({ EscapeCloseDialog })
  $OptionsDialog.Add_SizeChanged({ MinimizeAllDialogs })
  $OptionsDialog.Add_FormClosing({$OptionsDialog.Hide() ; $_.Cancel = $true})
  $OptionsDialog.Icon = $Icon_CTTPSGreen

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:OptionsFocusLabel = New-Object Windows.Forms.Label
  $OptionsFocusLabel.Size = New-Object Drawing.Size(1,1)
  $OptionsFocusLabel.Location = New-Object Drawing.Point(0,0)
  $OptionsDialog.Controls.Add($OptionsFocusLabel)

  # Create a tab control to differentiate preferences, paths, and debug options.
  $global:OptionsTabControl = New-Object Windows.Forms.TabControl
  $OptionsTabControl.Size = DPISize (New-Object Drawing.Size(432, 488))
  $OptionsTabControl.Location = DPISize (New-Object Drawing.Point(-4, 0))
  $OptionsTabControl.Padding = DPISize (New-Object Drawing.Point(10, 6))
  $OptionsDialog.Controls.Add($OptionsTabControl)

  # Create the tab pages to hold the options.
  $global:OptionsTabPaths   = New-Object Windows.Forms.TabPage
  $global:OptionsTabPrefs   = New-Object Windows.Forms.TabPage
  $global:OptionsTabExclude = New-Object Windows.Forms.TabPage
  $global:OptionsTabMisc    = New-Object Windows.Forms.TabPage
  $global:OptionsTabDebug   = New-Object Windows.Forms.TabPage
  $global:OptionsTabAbout   = New-Object Windows.Forms.TabPage
  $OptionsTabPaths.Text     = 'Tool Paths'
  $OptionsTabPrefs.Text     = 'Preferences'
  $OptionsTabExclude.Text   = 'Exclusions'
  $OptionsTabMisc.Text      = 'Miscellanous'
  $OptionsTabDebug.Text     = 'Debug'
  $OptionsTabAbout.Text     = 'About'
  $OptionsTabControl.Controls.Add($OptionsTabPaths)
  $OptionsTabControl.Controls.Add($OptionsTabPrefs)
  $OptionsTabControl.Controls.Add($OptionsTabExclude)
  $OptionsTabControl.Controls.Add($OptionsTabMisc)
  $OptionsTabControl.Controls.Add($OptionsTabDebug)
  $OptionsTabControl.Controls.Add($OptionsTabAbout)

  # Tool Paths: Create a panel to place the paths on.
  $global:OptionsPathsPanel = New-Object Windows.Forms.Panel
  $OptionsPathsPanel.Size = DPISize (New-Object Drawing.Size(424, 456))
  $OptionsPathsPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $OptionsPathsPanel.AutoScroll = $true
  $OptionsTabPaths.Controls.Add($OptionsPathsPanel)

  # Tool Paths: Master Tool Paths - Create a group box.
  $global:OptionsMasterToolsGroup = New-Object Windows.Forms.GroupBox
  $OptionsMasterToolsGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsMasterToolsGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $OptionsMasterToolsGroup.Text = 'Tools Master Path (Optional)'
  $OptionsPathsPanel.Controls.Add($OptionsMasterToolsGroup)

  # Tool Paths: Master Tool - Create a tooltip.
  $OptionsMasterToolsTip = New-Object Windows.Forms.ToolTip
  $OptionsMasterToolsTip.InitialDelay = $ToolTipDelay
  $OptionsMasterToolsTip.AutoPopDelay = $ToolTipDuration
  $OptionsMasterToolsTipString = 'Select a path here that links to a master folder of all tools{0}'
  $OptionsMasterToolsTipString += 'that this script supports. Use the weblink icon to the right{0}'
  $OptionsMasterToolsTipString += 'to find three download links to the most recent version. If{0}'
  $OptionsMasterToolsTipString += 'the "CTT-PS Programs" folder is located at the root of the{0}'
  $OptionsMasterToolsTipString += 'hard drive or within the "CTT-PS Data" folder, all program{0}'
  $OptionsMasterToolsTipString += 'paths will be automatically linked and filled out below.{0}'
  $OptionsMasterToolsTipString += '{0}'
  $OptionsMasterToolsTipString += 'If the programs are located in the CTT-PS Data folder, and{0}'
  $OptionsMasterToolsTipString += 'the CTT-PS Data folder is migrated to another location, the{0}'
  $OptionsMasterToolsTipString += 'script will update the tools master path, all program paths,{0}'
  $OptionsMasterToolsTipString += 'and migrate all programs to the new location.'
  $OptionsMasterToolsTipString = [String]::Format($OptionsMasterToolsTipString, [Environment]::NewLine)
  $OptionsMasterToolsTip.SetToolTip($OptionsMasterToolsGroup, $OptionsMasterToolsTipString)

  # Tool Paths: Master Tool - Create a checkbox.
  $global:OptionsMasterToolsCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsMasterToolsCheckBox.Size = DPISize (New-Object Drawing.Size(16, 16))
  $OptionsMasterToolsCheckBox.Location = DPISize (New-Object Drawing.Point(8, 23))
  $OptionsMasterToolsCheckBox.Name = 'UseToolsMasterPath'
  $OptionsMasterToolsCheckBox.Checked = $UseToolsMasterPath
  $OptionsMasterToolsCheckBox.Add_CheckStateChanged({ ToggleMasterToolPaths })
  $OptionsMasterToolsGroup.Controls.Add($OptionsMasterToolsCheckBox)

  # Tool Paths: Master Tool - Create a checkbox tooltip.
  $OptionsMasterToolsCheckBoxTip = New-Object Windows.Forms.ToolTip
  $OptionsMasterToolsCheckBoxTip.InitialDelay = $ToolTipDelay
  $OptionsMasterToolsCheckBoxTip.AutoPopDelay = $ToolTipDuration
  $OptionsMasterToolsCheckBoxTipString = "Enables use of the 'CTT-PS Programs' folder that{0}"
  $OptionsMasterToolsCheckBoxTipString += 'can be found on the Dolphin emulator forums in{0}'
  $OptionsMasterToolsCheckBoxTipString += "the CTT-PS thread. Selecting a path will scan the{0}"
  $OptionsMasterToolsCheckBoxTipString += "folder for all programs and update their paths.{0}"
  $OptionsMasterToolsCheckBoxTipString += "{0}"
  $OptionsMasterToolsCheckBoxTipString += "Keep the check box enabled to scan this folder{0}"
  $OptionsMasterToolsCheckBoxTipString += "every script load. This allows updating programs{0}"
  $OptionsMasterToolsCheckBoxTipString += "without having to update their paths in CTT-PS,{0}"
  $OptionsMasterToolsCheckBoxTipString += "it will load and update the path automatically."
  $OptionsMasterToolsCheckBoxTipString = [String]::Format($OptionsMasterToolsCheckBoxTipString, [Environment]::NewLine)
  $OptionsMasterToolsCheckBoxTip.SetToolTip($OptionsMasterToolsCheckBox, $OptionsMasterToolsCheckBoxTipString)

  # Tool Paths: Master Tool - Create a text box to display the path.
  $global:OptionsMasterToolsTextBox = New-Object Windows.Forms.TextBox
  $OptionsMasterToolsTextBox.Size = DPISize (New-Object Drawing.Size(303, 22))
  $OptionsMasterToolsTextBox.Location = DPISize (New-Object Drawing.Point(26, 20)) -AddY $DPIOffsetFix
  $OptionsMasterToolsTextBox.Name = 'ToolsMasterPath'
  $OptionsMasterToolsTextBox.Text = $ToolsMasterPath
  $OptionsMasterToolsTextBox.AllowDrop = $true
  $OptionsMasterToolsTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsMasterToolsTextBox.Add_DragDrop({ LoadExternalFolder_DragDrop -TextBox $this ; MasterToolsPathUpdate -UpdateGUI })
  $OptionsMasterToolsTextBox.Add_Leave({ LoadExternalFolder_TextBox -TextBox $this ; MasterToolsPathUpdate -UpdateGUI })
  $OptionsMasterToolsTextBox.Enabled = $UseToolsMasterPath
  $OptionsMasterToolsGroup.Controls.Add($OptionsMasterToolsTextBox)

  # Tool Paths: Master Tool - Create a button to update the path.
  $global:OptionsMasterToolsButton = New-Object Windows.Forms.Button
  $OptionsMasterToolsButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsMasterToolsButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsMasterToolsButton.Name = 'ToolsMasterPath'
  $OptionsMasterToolsButton.Text = '...'
  $OptionsMasterToolsButton.Add_Click({ 
                                        $Message = 'Select the folder "CTT-PS Programs" that contains all the various programs that CTT-PS makes use of. This can be downloaded from the CTT-PS Dolphin thread.'
                                        LoadExternalFolder_Button -TextBox $OptionsMasterToolsTextBox -Message $Message
                                        MasterToolsPathUpdate -UpdateGUI
                                     })
  $OptionsMasterToolsButton.Enabled = $UseToolsMasterPath
  $OptionsMasterToolsGroup.Controls.Add($OptionsMasterToolsButton)

  # Tool Paths: Master Tool - Create a strip menu to hold the mirror links.
  $global:OptionsMasterToolsStrip = New-Object Windows.Forms.ContextMenuStrip
  $OptionsMasterToolsStrip.ShowCheckMargin = $false
  $OptionsMasterToolsStrip.ShowImageMargin = $false

  # Tool Paths: Master Tool - Mirror Link 1
  $OptionsMasterToolsStripItem01 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsMasterToolsStripItem01.Text = "Mirror 01"
  $OptionsMasterToolsStripItem01.Add_Click({ Start-Process -FilePath $Link_CTTPSA })
  $OptionsMasterToolsStrip.Items.Add($OptionsMasterToolsStripItem01) | Out-Null

  # Tool Paths: Master Tool - Mirror Link 2
  $OptionsMasterToolsStripItem02 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsMasterToolsStripItem02.Text = "Mirror 02"
  $OptionsMasterToolsStripItem02.Add_Click({ Start-Process -FilePath $Link_CTTPSB })
  $OptionsMasterToolsStrip.Items.Add($OptionsMasterToolsStripItem02) | Out-Null

  # Tool Paths: Master Tool - Mirror Link 3
  $OptionsMasterToolsStripItem03 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsMasterToolsStripItem03.Text = "Mirror 03"
  $OptionsMasterToolsStripItem03.Add_Click({ Start-Process -FilePath $Link_CTTPSC })
  $OptionsMasterToolsStrip.Items.Add($OptionsMasterToolsStripItem03) | Out-Null

  # Tool Paths: Master Tool - Create a weblink button.
  $global:OptionsMasterToolsWeb = New-Object Windows.Forms.Button
  $OptionsMasterToolsWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsMasterToolsWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsMasterToolsWeb.Image = $Image_WebLinkIcon
  $OptionsMasterToolsWeb.Add_Click({ ShowContextMenuStrip -Button $OptionsMasterToolsWeb -MenuStrip $OptionsMasterToolsStrip })
  $OptionsMasterToolsGroup.Controls.Add($OptionsMasterToolsWeb)

  # Tool Paths: Master Tool - Create a weblink tooltip.
  $OptionsMasterToolsWebTip = New-Object Windows.Forms.ToolTip
  $OptionsMasterToolsWebTip.InitialDelay = $ToolTipDelay
  $OptionsMasterToolsWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsMasterToolsWebTipString = "Click to download a collection of all programs."
  $OptionsMasterToolsWebTip.SetToolTip($OptionsMasterToolsWeb, $OptionsMasterToolsWebTipString)

  # Tool Paths: ImageMagick - Create a group box.
  $global:OptionsImageMagickGroup = New-Object Windows.Forms.GroupBox
  $OptionsImageMagickGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsImageMagickGroup.Location = DPISize (New-Object Drawing.Point(10, 55))
  $OptionsImageMagickGroup.Text = 'ImageMagick'
  $OptionsPathsPanel.Controls.Add($OptionsImageMagickGroup)

  # Tool Paths: ImageMagick - Create a tooltip.
  $OptionsImageMagickTip = New-Object Windows.Forms.ToolTip
  $OptionsImageMagickTip.InitialDelay = $ToolTipDelay
  $OptionsImageMagickTip.AutoPopDelay = $ToolTipDuration
  $OptionsImageMagickTipString =  'The path to ImageMagick. The script by default will pull{0}'
  $OptionsImageMagickTipString += "this path from the Windows registry if it's installed, but{0}"
  $OptionsImageMagickTipString += 'a new path can be forced here. Changing this path will{0}'
  $OptionsImageMagickTipString += "remove the script's ability to grab the registry value.{0}"
  $OptionsImageMagickTipString += "{0}"
  $OptionsImageMagickTipString += "ImageMagick must be installed for the script to function."
  $OptionsImageMagickTipString = [String]::Format($OptionsImageMagickTipString, [Environment]::NewLine)
  $OptionsImageMagickTip.SetToolTip($OptionsImageMagickGroup, $OptionsImageMagickTipString)

  # Tool Paths: ImageMagick - Create a text box to display the path.
  $global:OptionsImageMagickTextBox = New-Object Windows.Forms.TextBox
  $OptionsImageMagickTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsImageMagickTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsImageMagickTextBox.Name = 'ImageMagick'
  $OptionsImageMagickTextBox.Text = $ImageMagick
  $OptionsImageMagickTextBox.AllowDrop = $true
  $OptionsImageMagickTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsImageMagickTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'magick.exe' })
  $OptionsImageMagickTextBox.Add_Click({ ClearTextBox })
  $OptionsImageMagickTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'magick.exe' })
  $OptionsImageMagickGroup.Controls.Add($OptionsImageMagickTextBox)

  # Tool Paths: ImageMagick - Create a button to update the path.
  $global:OptionsImageMagickButton = New-Object Windows.Forms.Button
  $OptionsImageMagickButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsImageMagickButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsImageMagickButton.Name = 'ImageMagick'
  $OptionsImageMagickButton.Text = '...'
  $OptionsImageMagickButton.Add_Click({ LoadExternalFile_Button -TextBox $OptionsImageMagickTextBox -FileName @('magick.exe') -Description @('ImageMagick v7') })
  $OptionsImageMagickGroup.Controls.Add($OptionsImageMagickButton)

  # Tool Paths: ImageMagick - Create a weblink button.
  $global:OptionsImageMagickWeb = New-Object Windows.Forms.Button
  $OptionsImageMagickWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsImageMagickWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsImageMagickWeb.Image = $Image_WebLinkIcon
  $OptionsImageMagickWeb.Add_Click({ Start-Process -FilePath $Link_Magick })
  $OptionsImageMagickGroup.Controls.Add($OptionsImageMagickWeb)

  # Tool Paths: ImageMagick - Create a weblink tooltip.
  $OptionsImageMagickWebTip = New-Object Windows.Forms.ToolTip
  $OptionsImageMagickWebTip.InitialDelay = $ToolTipDelay
  $OptionsImageMagickWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsImageMagickWebTipString = "Click to open this program's webpage."
  $OptionsImageMagickWebTip.SetToolTip($OptionsImageMagickWeb, $OptionsImageMagickWebTipString)

  # Tool Paths: TexConv - Create a group box.
  $global:OptionsTexConvGroup = New-Object Windows.Forms.GroupBox
  $OptionsTexConvGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsTexConvGroup.Location = DPISize (New-Object Drawing.Point(10, 105))
  $OptionsTexConvGroup.Text = 'TexConv'
  $OptionsPathsPanel.Controls.Add($OptionsTexConvGroup)

  # Tool Paths: TexConv - Create a tooltip.
  $OptionsTexConvTip = New-Object Windows.Forms.ToolTip
  $OptionsTexConvTip.InitialDelay = $ToolTipDelay
  $OptionsTexConvTip.AutoPopDelay = $ToolTipDuration
  $OptionsTexConvTipString =  'The path to DirectX TexConv. This program is required by{0}'
  $OptionsTexConvTipString += 'this script to create ARGB8, RGBA8, and BC7 DDS textures.{0}'
  $OptionsTexConvTipString += 'It is much faster than the other DDS creators, but it creates{0}'
  $OptionsTexConvTipString += 'overall lesser quality DDS textures than Compressonator.'
  $OptionsTexConvTipString = [String]::Format($OptionsTexConvTipString, [Environment]::NewLine)
  $OptionsTexConvTip.SetToolTip($OptionsTexConvGroup, $OptionsTexConvTipString)

  # Tool Paths: TexConv - Create a text box to display the path.
  $global:OptionsTexConvTextBox = New-Object Windows.Forms.TextBox
  $OptionsTexConvTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsTexConvTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsTexConvTextBox.Name = 'TexConvTool'
  $OptionsTexConvTextBox.Text = $TexConvTool
  $OptionsTexConvTextBox.AllowDrop = $true
  $OptionsTexConvTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsTexConvTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'texconv.exe' })
  $OptionsTexConvTextBox.Add_Click({ ClearTextBox })
  $OptionsTexConvTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'texconv.exe' })
  $OptionsTexConvGroup.Controls.Add($OptionsTexConvTextBox)

  # Tool Paths: TexConv - Create a button to update the path.
  $global:OptionsTexConvButton = New-Object Windows.Forms.Button
  $OptionsTexConvButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsTexConvButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsTexConvButton.Name = 'TexConvTool'
  $OptionsTexConvButton.Text = '...'
  $OptionsTexConvButton.Add_Click({ LoadExternalFile_Button -TextBox $OptionsTexConvTextBox -FileName @('texconv.exe') -Description @('DirectX TexConv') })
  $OptionsTexConvGroup.Controls.Add($OptionsTexConvButton)

  # Tool Paths: TexConv - Create a weblink button.
  $global:OptionsTexConvWeb = New-Object Windows.Forms.Button
  $OptionsTexConvWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsTexConvWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsTexConvWeb.Image = $Image_WebLinkIcon
  $OptionsTexConvWeb.Add_Click({ Start-Process -FilePath $Link_TexConv })
  $OptionsTexConvGroup.Controls.Add($OptionsTexConvWeb)

  # Tool Paths: TexConv - Create a weblink tooltip.
  $OptionsTexConvWebTip = New-Object Windows.Forms.ToolTip
  $OptionsTexConvWebTip.InitialDelay = $ToolTipDelay
  $OptionsTexConvWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsTexConvWebTipString = "Click to open this program's webpage."
  $OptionsTexConvWebTip.SetToolTip($OptionsTexConvWeb, $OptionsTexConvWebTipString)

  # Tool Paths: Compressonator - Create a group box.
  $global:OptionsCompressGroup = New-Object Windows.Forms.GroupBox
  $OptionsCompressGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsCompressGroup.Location = DPISize (New-Object Drawing.Point(10, 155))
  $OptionsCompressGroup.Text = 'Compressonator'
  $OptionsPathsPanel.Controls.Add($OptionsCompressGroup)

  # Tool Paths: Compressonator - Create a tooltip.
  $OptionsCompressTip = New-Object Windows.Forms.ToolTip
  $OptionsCompressTip.InitialDelay = $ToolTipDelay
  $OptionsCompressTip.AutoPopDelay = $ToolTipDuration
  $OptionsCompressTipString =  'The path to Compressonator. This program can create{0}'
  $OptionsCompressTipString += 'DDS textures in any format (including BC7), and it also{0}'
  $OptionsCompressTipString += 'creates the highest quality DDS textures overall. There{0}'
  $OptionsCompressTipString += 'is a chance it will fail when creating some BC7 images,{0}'
  $OptionsCompressTipString += 'which is why TexConv is required to serve as a backup.'
  $OptionsCompressTipString = [String]::Format($OptionsCompressTipString, [Environment]::NewLine)
  $OptionsCompressTip.SetToolTip($OptionsCompressGroup, $OptionsCompressTipString)

  # Tool Paths: Compressonator - Create a text box to display the path.
  $global:OptionsCompressTextBox = New-Object Windows.Forms.TextBox
  $OptionsCompressTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsCompressTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsCompressTextBox.Name = 'Compressonator'
  $OptionsCompressTextBox.Text = $Compressonator
  $OptionsCompressTextBox.AllowDrop = $true
  $OptionsCompressTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsCompressTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'CompressonatorCLI.exe' })
  $OptionsCompressTextBox.Add_Click({ ClearTextBox })
  $OptionsCompressTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'CompressonatorCLI.exe' })
  $OptionsCompressGroup.Controls.Add($OptionsCompressTextBox)

  # Tool Paths: Compressonator - Create a button to update the path.
  $global:OptionsCompressButton = New-Object Windows.Forms.Button
  $OptionsCompressButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsCompressButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsCompressButton.Name = 'Compressonator'
  $OptionsCompressButton.Text = '...'
  $OptionsCompressButton.Add_Click({ LoadExternalFile_Button -TextBox $OptionsCompressTextBox -FileName @('CompressonatorCLI.exe') -Description @('Compressonator') })
  $OptionsCompressGroup.Controls.Add($OptionsCompressButton)

  # Tool Paths: Compressonator - Create a weblink button.
  $global:OptionsCompressWeb = New-Object Windows.Forms.Button
  $OptionsCompressWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsCompressWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsCompressWeb.Image = $Image_WebLinkIcon
  $OptionsCompressWeb.Add_Click({ Start-Process -FilePath $Link_Compress })
  $OptionsCompressGroup.Controls.Add($OptionsCompressWeb)

  # Tool Paths: Compressonator - Create a weblink tooltip.
  $OptionsCompressWebTip = New-Object Windows.Forms.ToolTip
  $OptionsCompressWebTip.InitialDelay = $ToolTipDelay
  $OptionsCompressWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsCompressWebTipString = "Click to open this program's webpage."
  $OptionsCompressWebTip.SetToolTip($OptionsCompressWeb, $OptionsCompressWebTipString)

  # Tool Paths: Ishiiruka Tool - Create a group box.
  $global:OptionsIshiirukaGroup = New-Object Windows.Forms.GroupBox
  $OptionsIshiirukaGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsIshiirukaGroup.Location = DPISize (New-Object Drawing.Point(10, 205))
  $OptionsIshiirukaGroup.Text = 'Ishiiruka Tool'
  $OptionsPathsPanel.Controls.Add($OptionsIshiirukaGroup)

  # Tool Paths: Ishiiruka Tool - Create a tooltip.
  $OptionsIshiirukaTip = New-Object Windows.Forms.ToolTip
  $OptionsIshiirukaTip.InitialDelay = $ToolTipDelay
  $OptionsIshiirukaTip.AutoPopDelay = $ToolTipDuration
  $OptionsIshiirukaTipString = 'The path to the texture encoder by Tino that combines{0}'
  $OptionsIshiirukaTipString += 'bump/spec/lum/nrm textures into a material map. This{0}'
  $OptionsIshiirukaTipString += 'tool is required to process and convert already combined{0}'
  $OptionsIshiirukaTipString += 'material maps. If this tool is not found, these textures{0}'
  $OptionsIshiirukaTipString += 'are skipped when the script finds them in an operation.{0}'
  $OptionsIshiirukaTipString += '{0}'
  $OptionsIshiirukaTipString += 'Required when working with materials or material maps.'
  $OptionsIshiirukaTipString = [String]::Format($OptionsIshiirukaTipString, [Environment]::NewLine)
  $OptionsIshiirukaTip.SetToolTip($OptionsIshiirukaGroup, $OptionsIshiirukaTipString)

  # Tool Paths: Ishiiruka Tool - Create a text box to display the path.
  $global:OptionsIshiirukaTextBox = New-Object Windows.Forms.TextBox
  $OptionsIshiirukaTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsIshiirukaTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsIshiirukaTextBox.Name = 'IshiirukaTool'
  $OptionsIshiirukaTextBox.Text = $IshiirukaTool
  $OptionsIshiirukaTextBox.AllowDrop = $true
  $OptionsIshiirukaTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsIshiirukaTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'TextureEncoder.exe' })
  $OptionsIshiirukaTextBox.Add_Click({ ClearTextBox })
  $OptionsIshiirukaTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'TextureEncoder.exe' })
  $OptionsIshiirukaGroup.Controls.Add($OptionsIshiirukaTextBox)

  # Tool Paths: Ishiiruka Tool - Create a button to update the path.
  $global:OptionsIshiirukaButton = New-Object Windows.Forms.Button
  $OptionsIshiirukaButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsIshiirukaButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsIshiirukaButton.Name = 'IshiirukaTool'
  $OptionsIshiirukaButton.Text = '...'
  $OptionsIshiirukaButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsIshiirukaTextBox -FileName @('TextureEncoder.exe') -Description @('Ishiiruka Tool') })
  $OptionsIshiirukaGroup.Controls.Add($OptionsIshiirukaButton)

  # Tool Paths: Ishiiruka Tool - Create a weblink button.
  $global:OptionsIshiirukaWeb = New-Object Windows.Forms.Button
  $OptionsIshiirukaWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsIshiirukaWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsIshiirukaWeb.Image = $Image_WebLinkIcon
  $OptionsIshiirukaWeb.Add_Click({ Start-Process -FilePath $Link_Ishiiruka })
  $OptionsIshiirukaGroup.Controls.Add($OptionsIshiirukaWeb)

  # Tool Paths: Ishiiruka Tool - Create a weblink tooltip.
  $OptionsIshiirukaWebTip = New-Object Windows.Forms.ToolTip
  $OptionsIshiirukaWebTip.InitialDelay = $ToolTipDelay
  $OptionsIshiirukaWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsIshiirukaWebTipString = "Click to open this program's webpage."
  $OptionsIshiirukaWebTip.SetToolTip($OptionsIshiirukaWeb, $OptionsIshiirukaWebTipString)

  # Tool Paths: Material Map Generator - Create a group box.
  $global:OptionsMatMapGenGroup = New-Object Windows.Forms.GroupBox
  $OptionsMatMapGenGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsMatMapGenGroup.Location = DPISize (New-Object Drawing.Point(10, 255))
  $OptionsMatMapGenGroup.Text = 'Material Map Generator'
  $OptionsPathsPanel.Controls.Add($OptionsMatMapGenGroup)

  # Tool Paths: Material Map Generator - Create a tooltip.
  $OptionsMatMapGenTip = New-Object Windows.Forms.ToolTip
  $OptionsMatMapGenTip.InitialDelay = $ToolTipDelay
  $OptionsMatMapGenTip.AutoPopDelay = $ToolTipDuration
  $OptionsMatMapGenTipString = 'The path to the Material Map Generator python script{0}'
  $OptionsMatMapGenTipString += 'by JoeyBallentine. This handy script can generate materials{0}'
  $OptionsMatMapGenTipString += 'on the fly for Ishiiruka Dolphin. Requires Python v3.9.x.{0}'
  $OptionsMatMapGenTipString += '{0}'
  $OptionsMatMapGenTipString += 'Required to generate Ishiiruka material textures.'
  $OptionsMatMapGenTipString = [String]::Format($OptionsMatMapGenTipString, [Environment]::NewLine)
  $OptionsMatMapGenTip.SetToolTip($OptionsMatMapGenGroup, $OptionsMatMapGenTipString)

  # Tool Paths: Material Map Generator - Create a text box to display the path.
  $global:OptionsMatMapGenTextBox = New-Object Windows.Forms.TextBox
  $OptionsMatMapGenTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsMatMapGenTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsMatMapGenTextBox.Name = 'MatMapGenPath'
  $OptionsMatMapGenTextBox.Text = $MatMapGenPath
  $OptionsMatMapGenTextBox.AllowDrop = $true
  $OptionsMatMapGenTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsMatMapGenTextBox.Add_DragDrop({  LoadExternalFolder_DragDrop -TextBox $this -FileTest 'generate.py' })
  $OptionsMatMapGenTextBox.Add_Click({ ClearTextBox })
  $OptionsMatMapGenTextBox.Add_Leave({ LoadExternalFolder_TextBox -TextBox $this -FileTest 'generate.py' })
  $OptionsMatMapGenGroup.Controls.Add($OptionsMatMapGenTextBox)

  # Tool Paths: Material Map Generator - Create a button to update the path.
  $global:OptionsMatMapGenButton = New-Object Windows.Forms.Button
  $OptionsMatMapGenButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsMatMapGenButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsMatMapGenButton.Name = 'MatMapGenPath'
  $OptionsMatMapGenButton.Text = '...'
  $OptionsMatMapGenButton.Add_Click({ $Message = 'Select the base folder of the Material Map Generator by JoeyBallentine. The path should contain the "generate.py" Python script in it to succeed.'
                                      LoadExternalFolder_Button -TextBox $OptionsMatMapGenTextBox -Message $Message -FileTest 'generate.py' })
  $OptionsMatMapGenGroup.Controls.Add($OptionsMatMapGenButton)

  # Tool Paths: Material Map Generator - Create a weblink button.
  $global:OptionsMatMapGenWeb = New-Object Windows.Forms.Button
  $OptionsMatMapGenWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsMatMapGenWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsMatMapGenWeb.Image = $Image_WebLinkIcon
  $OptionsMatMapGenWeb.Add_Click({ Start-Process -FilePath $Link_MatMapGen })
  $OptionsMatMapGenGroup.Controls.Add($OptionsMatMapGenWeb)

  # Tool Paths: Material Map Generator - Create a weblink tooltip.
  $OptionsMatMapGenWebTip = New-Object Windows.Forms.ToolTip
  $OptionsMatMapGenWebTip.InitialDelay = $ToolTipDelay
  $OptionsMatMapGenWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsMatMapGenWebTipString = "Click to open this program's webpage."
  $OptionsMatMapGenWebTip.SetToolTip($OptionsMatMapGenWeb, $OptionsMatMapGenWebTipString)

  # Tool Paths: Dolphin TextureExtraction Tool - Create a group box.
  $global:OptionsExtractTexGroup = New-Object Windows.Forms.GroupBox
  $OptionsExtractTexGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsExtractTexGroup.Location = DPISize (New-Object Drawing.Point(10, 305))
  $OptionsExtractTexGroup.Text = 'TextureExtraction Tool'
  $OptionsPathsPanel.Controls.Add($OptionsExtractTexGroup)

  # Tool Paths: Dolphin TextureExtraction Tool - Create a tooltip.
  $OptionsExtractTexGenTip = New-Object Windows.Forms.ToolTip
  $OptionsExtractTexGenTip.InitialDelay = $ToolTipDelay
  $OptionsExtractTexGenTip.AutoPopDelay = $ToolTipDuration
  $OptionsExtractTexGenTipString = 'The path to TextureExtraction Tool by Venomalia.{0}'
  $OptionsExtractTexGenTipString += 'This program extracts textures and converts them{0}'
  $OptionsExtractTexGenTipString += 'to PNGs renamed to match Dolphin texture format.{0}'
  $OptionsExtractTexGenTipString += '{0}'
  $OptionsExtractTexGenTipString += 'Required to extract Dolphin textures from discs.'
  $OptionsExtractTexGenTipString = [String]::Format($OptionsExtractTexGenTipString, [Environment]::NewLine)
  $OptionsExtractTexGenTip.SetToolTip($OptionsExtractTexGroup, $OptionsExtractTexGenTipString)

  # Tool Paths: Dolphin TextureExtraction Tool - Create a text box to display the path.
  $global:OptionsExtractTexTextBox = New-Object Windows.Forms.TextBox
  $OptionsExtractTexTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsExtractTexTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsExtractTexTextBox.Name = 'TexExtractTool'
  $OptionsExtractTexTextBox.Text = $TexExtractTool
  $OptionsExtractTexTextBox.AllowDrop = $true
  $OptionsExtractTexTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('DolphinTextureExtraction tool.exe','DolphinTextureExtraction.tool.exe') })
  $OptionsExtractTexTextBox.Add_Click({ ClearTextBox })
  $OptionsExtractTexTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('DolphinTextureExtraction tool.exe','DolphinTextureExtraction.tool.exe') })
  $OptionsExtractTexGroup.Controls.Add($OptionsExtractTexTextBox)

  # Tool Paths: Dolphin TextureExtraction Tool - Create a button to update the path.
  $global:OptionsExtractTexButton = New-Object Windows.Forms.Button
  $OptionsExtractTexButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsExtractTexButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsExtractTexButton.Name = 'TexExtractTool'
  $OptionsExtractTexButton.Text = '...'
  $OptionsExtractTexButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsExtractTexTextBox -FileName @('DolphinTextureExtraction tool.exe','DolphinTextureExtraction.tool.exe') -Description @('Dolphin TextureExtraction Tool') })
  $OptionsExtractTexGroup.Controls.Add($OptionsExtractTexButton)

  # Tool Paths: Dolphin TextureExtraction Tool - Create a weblink button.
  $global:OptionsExtractTexWeb = New-Object Windows.Forms.Button
  $OptionsExtractTexWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsExtractTexWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsExtractTexWeb.Image = $Image_WebLinkIcon
  $OptionsExtractTexWeb.Add_Click({ Start-Process -FilePath $Link_DolTexExt })
  $OptionsExtractTexGroup.Controls.Add($OptionsExtractTexWeb)

  # Tool Paths: Dolphin TextureExtraction Tool - Create a weblink tooltip.
  $OptionsExtractWebTip = New-Object Windows.Forms.ToolTip
  $OptionsExtractWebTip.InitialDelay = $ToolTipDelay
  $OptionsExtractWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsExtractWebTipString = "Click to open this program's webpage."
  $OptionsExtractWebTip.SetToolTip($OptionsExtractTexWeb, $OptionsExtractWebTipString)

  # Tool Paths: OptiPNG Path - Create a group box.
  $global:OptionsOptiPNGGroup = New-Object Windows.Forms.GroupBox
  $OptionsOptiPNGGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsOptiPNGGroup.Location = DPISize (New-Object Drawing.Point(10, 355))
  $OptionsOptiPNGGroup.Text = 'OptiPNG'
  $OptionsPathsPanel.Controls.Add($OptionsOptiPNGGroup)

  # Tool Paths: OptiPNG Path - Create a tooltip.
  $OptionsOptiPNGTip = New-Object Windows.Forms.ToolTip
  $OptionsOptiPNGTip.InitialDelay = $ToolTipDelay
  $OptionsOptiPNGTip.AutoPopDelay = $ToolTipDuration
  $OptionsOptiPNGTipString = 'The path to OptiPNG.'
  $OptionsOptiPNGTipString = [String]::Format($OptionsOptiPNGTipString, [Environment]::NewLine)
  $OptionsOptiPNGTip.SetToolTip($OptionsOptiPNGGroup, $OptionsOptiPNGTipString)

  # Tool Paths: OptiPNG Path - Create a text box to display the path.
  $global:OptionsOptiPNGTextBox = New-Object Windows.Forms.TextBox
  $OptionsOptiPNGTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsOptiPNGTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsOptiPNGTextBox.Name = 'OptiPNGPath'
  $OptionsOptiPNGTextBox.Text = $OptiPNGPath
  $OptionsOptiPNGTextBox.AllowDrop = $true
  $OptionsOptiPNGTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsOptiPNGTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'optipng.exe' })
  $OptionsOptiPNGTextBox.Add_Click({ ClearTextBox })
  $OptionsOptiPNGTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'optipng.exe' })
  $OptionsOptiPNGGroup.Controls.Add($OptionsOptiPNGTextBox)

  # Tool Paths: OptiPNG Path - Create a button to update the path.
  $global:OptionsOptiPNGButton = New-Object Windows.Forms.Button
  $OptionsOptiPNGButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsOptiPNGButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsOptiPNGButton.Name = 'OptiPNGPath'
  $OptionsOptiPNGButton.Text = '...'
  $OptionsOptiPNGButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsOptiPNGTextBox -FileName @('optipng.exe') -Description @('OptiPNG') })
  $OptionsOptiPNGGroup.Controls.Add($OptionsOptiPNGButton)

  # Tool Paths: OptiPNG Path - Create a weblink button.
  $global:OptionsOptiPNGWeb = New-Object Windows.Forms.Button
  $OptionsOptiPNGWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsOptiPNGWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsOptiPNGWeb.Image = $Image_WebLinkIcon
  $OptionsOptiPNGWeb.Add_Click({ Start-Process -FilePath $Link_OptiPNG })
  $OptionsOptiPNGGroup.Controls.Add($OptionsOptiPNGWeb)

  # Tool Paths: OptiPNG Path - Create a weblink tooltip.
  $OptionsOptiPNGWebTip = New-Object Windows.Forms.ToolTip
  $OptionsOptiPNGWebTip.InitialDelay = $ToolTipDelay
  $OptionsOptiPNGWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsOptiPNGWebTipString = "Click to open this program's webpage."
  $OptionsOptiPNGWebTip.SetToolTip($OptionsOptiPNGWeb, $OptionsOptiPNGWebTipString)

  # Tool Paths: OxiPNG Path - Create a group box.
  $global:OptionsOxiPNGGroup = New-Object Windows.Forms.GroupBox
  $OptionsOxiPNGGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsOxiPNGGroup.Location = DPISize (New-Object Drawing.Point(10, 405))
  $OptionsOxiPNGGroup.Text = 'OxiPNG'
  $OptionsPathsPanel.Controls.Add($OptionsOxiPNGGroup)

  # Tool Paths: OxiPNG Path - Create a tooltip.
  $OptionsOxiPNGTip = New-Object Windows.Forms.ToolTip
  $OptionsOxiPNGTip.InitialDelay = $ToolTipDelay
  $OptionsOxiPNGTip.AutoPopDelay = $ToolTipDuration
  $OptionsOxiPNGTipString = 'The path to OxiPNG.'
  $OptionsOxiPNGTipString = [String]::Format($OptionsOxiPNGTipString, [Environment]::NewLine)
  $OptionsOxiPNGTip.SetToolTip($OptionsOxiPNGGroup, $OptionsOxiPNGTipString)

  # Tool Paths: OxiPNG Path - Create a text box to display the path.
  $global:OptionsOxiPNGTextBox = New-Object Windows.Forms.TextBox
  $OptionsOxiPNGTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsOxiPNGTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsOxiPNGTextBox.Name = 'OxiPNGPath'
  $OptionsOxiPNGTextBox.Text = $OxiPNGPath
  $OptionsOxiPNGTextBox.AllowDrop = $true
  $OptionsOxiPNGTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsOxiPNGTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'oxipng.exe' })
  $OptionsOxiPNGTextBox.Add_Click({ ClearTextBox })
  $OptionsOxiPNGTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'oxipng.exe' })
  $OptionsOxiPNGGroup.Controls.Add($OptionsOxiPNGTextBox)

  # Tool Paths: OxiPNG Path - Create a button to update the path.
  $global:OptionsOxiPNGButton = New-Object Windows.Forms.Button
  $OptionsOxiPNGButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsOxiPNGButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsOxiPNGButton.Name = 'OxiPNGPath'
  $OptionsOxiPNGButton.Text = '...'
  $OptionsOxiPNGButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsOxiPNGTextBox -FileName @('oxipng.exe') -Description @('OxiPNG') })
  $OptionsOxiPNGGroup.Controls.Add($OptionsOxiPNGButton)

  # Tool Paths: OxiPNG Path - Create a weblink button.
  $global:OptionsOxiPNGWeb = New-Object Windows.Forms.Button
  $OptionsOxiPNGWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsOxiPNGWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsOxiPNGWeb.Image = $Image_WebLinkIcon
  $OptionsOxiPNGWeb.Add_Click({ Start-Process -FilePath $Link_OxiPNG })
  $OptionsOxiPNGGroup.Controls.Add($OptionsOxiPNGWeb)

  # Tool Paths: OxiPNG Path - Create a weblink tooltip.
  $OptionsOxiPNGWebTip = New-Object Windows.Forms.ToolTip
  $OptionsOxiPNGWebTip.InitialDelay = $ToolTipDelay
  $OptionsOxiPNGWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsOxiPNGWebTipString = "Click to open this program's webpage."
  $OptionsOxiPNGWebTip.SetToolTip($OptionsOxiPNGWeb, $OptionsOxiPNGWebTipString)

  # Tool Paths: Pingo Path - Create a group box.
  $global:OptionsPingoGroup = New-Object Windows.Forms.GroupBox
  $OptionsPingoGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsPingoGroup.Location = DPISize (New-Object Drawing.Point(10, 455))
  $OptionsPingoGroup.Text = 'Pingo'
  $OptionsPathsPanel.Controls.Add($OptionsPingoGroup)

  # Tool Paths: Pingo Path - Create a tooltip.
  $OptionsPingoTip = New-Object Windows.Forms.ToolTip
  $OptionsPingoTip.InitialDelay = $ToolTipDelay
  $OptionsPingoTip.AutoPopDelay = $ToolTipDuration
  $OptionsPingoTipString = 'The path to Pingo.'
  $OptionsPingoTipString = [String]::Format($OptionsPingoTipString, [Environment]::NewLine)
  $OptionsPingoTip.SetToolTip($OptionsPingoGroup, $OptionsPingoTipString)

  # Tool Paths: Pingo Path - Create a text box to display the path.
  $global:OptionsPingoTextBox = New-Object Windows.Forms.TextBox
  $OptionsPingoTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsPingoTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsPingoTextBox.Name = 'PingoPath'
  $OptionsPingoTextBox.Text = $PingoPath
  $OptionsPingoTextBox.AllowDrop = $true
  $OptionsPingoTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsPingoTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'pingo.exe' })
  $OptionsPingoTextBox.Add_Click({ ClearTextBox })
  $OptionsPingoTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'pingo.exe' })
  $OptionsPingoGroup.Controls.Add($OptionsPingoTextBox)

  # Tool Paths: Pingo Path - Create a button to update the path.
  $global:OptionsPingoButton = New-Object Windows.Forms.Button
  $OptionsPingoButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsPingoButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsPingoButton.Name = 'PingoPath'
  $OptionsPingoButton.Text = '...'
  $OptionsPingoButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsPingoTextBox -FileName @('pingo.exe') -Description @('Pingo') })
  $OptionsPingoGroup.Controls.Add($OptionsPingoButton)

  # Tool Paths: Pingo Path - Create a weblink button.
  $global:OptionsPingoWeb = New-Object Windows.Forms.Button
  $OptionsPingoWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsPingoWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsPingoWeb.Image = $Image_WebLinkIcon
  $OptionsPingoWeb.Add_Click({ Start-Process -FilePath $Link_Pingo })
  $OptionsPingoGroup.Controls.Add($OptionsPingoWeb)

  # Tool Paths: Pingo Path - Create a weblink tooltip.
  $OptionsPingoWebTip = New-Object Windows.Forms.ToolTip
  $OptionsPingoWebTip.InitialDelay = $ToolTipDelay
  $OptionsPingoWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsPingoWebTipString = "Click to open this program's webpage."
  $OptionsPingoWebTip.SetToolTip($OptionsPingoWeb, $OptionsPingoWebTipString)

  # Tool Paths: ECT Path - Create a group box.
  $global:OptionsECTGroup = New-Object Windows.Forms.GroupBox
  $OptionsECTGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsECTGroup.Location = DPISize (New-Object Drawing.Point(10, 505))
  $OptionsECTGroup.Text = 'Efficent Compression Tool'
  $OptionsPathsPanel.Controls.Add($OptionsECTGroup)

  # Tool Paths: ECT Path - Create a tooltip.
  $OptionsECTTip = New-Object Windows.Forms.ToolTip
  $OptionsECTTip.InitialDelay = $ToolTipDelay
  $OptionsECTTip.AutoPopDelay = $ToolTipDuration
  $OptionsECTTipString = 'The path to Efficent Compression Tool.'
  $OptionsECTTipString = [String]::Format($OptionsECTTipString, [Environment]::NewLine)
  $OptionsECTTip.SetToolTip($OptionsECTGroup, $OptionsECTTipString)

  # Tool Paths: ECT Path - Create a text box to display the path.
  $global:OptionsECTTextBox = New-Object Windows.Forms.TextBox
  $OptionsECTTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsECTTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsECTTextBox.Name = 'ECTPath'
  $OptionsECTTextBox.Text = $ECTPath
  $OptionsECTTextBox.AllowDrop = $true
  $OptionsECTTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsECTTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'ect*.exe' })
  $OptionsECTTextBox.Add_Click({ ClearTextBox })
  $OptionsECTTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'ect*.exe' })
  $OptionsECTGroup.Controls.Add($OptionsECTTextBox)

  # Tool Paths: ECT Path - Create a button to update the path.
  $global:OptionsECTButton = New-Object Windows.Forms.Button
  $OptionsECTButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsECTButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsECTButton.Name = 'ECTPath'
  $OptionsECTButton.Text = '...'
  $OptionsECTButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsECTTextBox -FileName @('ect*.exe') -Description @('ECT') })
  $OptionsECTGroup.Controls.Add($OptionsECTButton)

  # Tool Paths: ECT Path - Create a weblink button.
  $global:OptionsECTWeb = New-Object Windows.Forms.Button
  $OptionsECTWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsECTWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsECTWeb.Image = $Image_WebLinkIcon
  $OptionsECTWeb.Add_Click({ Start-Process -FilePath $Link_ECT })
  $OptionsECTGroup.Controls.Add($OptionsECTWeb)

  # Tool Paths: ECT Path - Create a weblink tooltip.
  $OptionsECTWebTip = New-Object Windows.Forms.ToolTip
  $OptionsECTWebTip.InitialDelay = $ToolTipDelay
  $OptionsECTWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsECTWebTipString = "Click to open this program's webpage."
  $OptionsECTWebTip.SetToolTip($OptionsECTWeb, $OptionsECTWebTipString)

  # Tool Paths: xBRZ ScalerTest - Create a group box.
  $global:OptionsScalerTestGroup = New-Object Windows.Forms.GroupBox
  $OptionsScalerTestGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsScalerTestGroup.Location = DPISize (New-Object Drawing.Point(10, 555))
  $OptionsScalerTestGroup.Text = 'xBRZ ScalerTest'
  $OptionsPathsPanel.Controls.Add($OptionsScalerTestGroup)

  # Tool Paths: xBRZ ScalerTest - Create a tooltip.
  $OptionsScalerTestTip = New-Object Windows.Forms.ToolTip
  $OptionsScalerTestTip.InitialDelay = $ToolTipDelay
  $OptionsScalerTestTip.AutoPopDelay = $ToolTipDuration
  $OptionsScalerTestTipString = 'This tool makes it possible to apply the xBRZ upscaling filter to a folder{0}'
  $OptionsScalerTestTipString += 'full of textures. This tool is only used when applying the xBRZ filter, all{0}'
  $OptionsScalerTestTipString += 'other filters are applied to textures using ImageMagick.{0}'
  $OptionsScalerTestTipString += '{0}'
  $OptionsScalerTestTipString += 'Required to use xBRZ in "Apply Upscaling Filter to All Textures".'
  $OptionsScalerTestTipString = [String]::Format($OptionsScalerTestTipString, [Environment]::NewLine)
  $OptionsScalerTestTip.SetToolTip($OptionsScalerTestGroup, $OptionsScalerTestTipString)

  # Tool Paths: xBRZ ScalerTest - Create a text box to display the path.
  $global:OptionsScalerTestTextBox = New-Object Windows.Forms.TextBox
  $OptionsScalerTestTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsScalerTestTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsScalerTestTextBox.Name = 'ScalerTestPath'
  $OptionsScalerTestTextBox.Text = $ScalerTestPath
  $OptionsScalerTestTextBox.AllowDrop = $true
  $OptionsScalerTestTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsScalerTestTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'ScalerTest*.exe' })
  $OptionsScalerTestTextBox.Add_Click({ ClearTextBox })
  $OptionsScalerTestTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'ScalerTest*.exe' })
  $OptionsScalerTestGroup.Controls.Add($OptionsScalerTestTextBox)

  # Tool Paths: xBRZ ScalerTest - Create a button to update the path.
  $global:OptionsScalerTestButton = New-Object Windows.Forms.Button
  $OptionsScalerTestButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsScalerTestButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsScalerTestButton.Name = 'ScalerTestPath'
  $OptionsScalerTestButton.Text = '...'
  $OptionsScalerTestButton.Add_Click({ LoadExternalFile_Button -TextBox $OptionsScalerTestTextBox -FileName @('ScalerTest*.exe') -Description @('xBRZ ScalerTest') })
  $OptionsScalerTestGroup.Controls.Add($OptionsScalerTestButton)

  # Tool Paths: xBRZ ScalerTest - Create a weblink button.
  $global:OptionsScalerTestWeb = New-Object Windows.Forms.Button
  $OptionsScalerTestWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsScalerTestWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsScalerTestWeb.Image = $Image_WebLinkIcon
  $OptionsScalerTestWeb.Add_Click({ Start-Process -FilePath $Link_xBRZ })
  $OptionsScalerTestGroup.Controls.Add($OptionsScalerTestWeb)

  # Tool Paths: xBRZ ScalerTest - Create a weblink tooltip.
  $OptionsScalerTestWebTip = New-Object Windows.Forms.ToolTip
  $OptionsScalerTestWebTip.InitialDelay = $ToolTipDelay
  $OptionsScalerTestWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsScalerTestWebTipString = "Click to open this program's webpage."
  $OptionsScalerTestWebTip.SetToolTip($OptionsScalerTestWeb, $OptionsScalerTestWebTipString)

  # Tool Paths: Waifu2x - Create a group box.
  $global:OptionsWaifu2xPathsGroup = New-Object Windows.Forms.GroupBox
  $OptionsWaifu2xPathsGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsWaifu2xPathsGroup.Location = DPISize (New-Object Drawing.Point(10, 605))
  $OptionsWaifu2xPathsGroup.Text = 'Waifu2x Caffe/CPP'
  $OptionsPathsPanel.Controls.Add($OptionsWaifu2xPathsGroup)

  # Tool Paths: Waifu2x - Create a tooltip.
  $OptionsWaifu2xTip = New-Object Windows.Forms.ToolTip
  $OptionsWaifu2xTip.InitialDelay = $ToolTipDelay
  $OptionsWaifu2xTip.AutoPopDelay = $ToolTipDuration
  $OptionsWaifu2xTipString =  'Allows upscaling textures with the waifu2x{0}'
  $OptionsWaifu2xTipString += 'AI filter. This script is compatible with both{0}'
  $OptionsWaifu2xTipString += 'Waifu2x-Caffe and Waifu2x-CPP. Generally,{0}'
  $OptionsWaifu2xTipString += 'Caffe is better with nvidia GPUs (CUDA) and{0}'
  $OptionsWaifu2xTipString += 'CPP is better with AMD GPUs (OpenCL).{0}'
  $OptionsWaifu2xTipString += '{0}'
  $OptionsWaifu2xTipString += 'Required to use waifu2x in the operation{0}'
  $OptionsWaifu2xTipString += '"Apply Upscaling Filter to All Textures".'
  $OptionsWaifu2xTipString = [String]::Format($OptionsWaifu2xTipString, [Environment]::NewLine)
  $OptionsWaifu2xTip.SetToolTip($OptionsWaifu2xPathsGroup, $OptionsWaifu2xTipString)

  # Tool Paths: Waifu2x - Create a text box to display the path.
  $global:OptionsWaifu2xTextBox = New-Object Windows.Forms.TextBox
  $OptionsWaifu2xTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsWaifu2xTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsWaifu2xTextBox.Name = 'Waifu2xPath'
  $OptionsWaifu2xTextBox.Text = $Waifu2xPath
  $OptionsWaifu2xTextBox.AllowDrop = $true
  $OptionsWaifu2xTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsWaifu2xTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('waifu2x-caffe-cui.exe','waifu2x-converter-cpp.exe') })
  $OptionsWaifu2xTextBox.Add_Click({ ClearTextBox })
  $OptionsWaifu2xTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('waifu2x-caffe-cui.exe','waifu2x-converter-cpp.exe') })
  $OptionsWaifu2xPathsGroup.Controls.Add($OptionsWaifu2xTextBox)

  # Tool Paths: Waifu2x - Create a button to update the path.
  $global:OptionsWaifu2xButton = New-Object Windows.Forms.Button
  $OptionsWaifu2xButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsWaifu2xButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsWaifu2xButton.Name = 'Waifu2xPath'
  $OptionsWaifu2xButton.Text = '...'
  $OptionsWaifu2xButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsWaifu2xTextBox -FileName @('waifu2x-caffe-cui.exe','waifu2x-converter-cpp.exe') -Description 'Waifu2x Program' })
  $OptionsWaifu2xPathsGroup.Controls.Add($OptionsWaifu2xButton)

  # Tool Paths: Waifu2x - Create a strip menu to select between the waifu2x versions.
  $global:OptionsWaifu2xMenuStrip = New-Object Windows.Forms.ContextMenuStrip
  
  # Tool Paths: Waifu2x - Mirror Link 1
  $OptionsWaifu2xStripItem01 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsWaifu2xStripItem01.Text = "Waifu2x-Caffe"
  $OptionsWaifu2xStripItem01.Add_Click({ Start-Process -FilePath $Link_W2x_Caffe })
  $OptionsWaifu2xMenuStrip.Items.Add($OptionsWaifu2xStripItem01) | Out-Null
  
  # Tool Paths: Waifu2x - Mirror Link 2
  $OptionsWaifu2xStripItem02 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsWaifu2xStripItem02.Text = "Waifu2x-CPP"
  $OptionsWaifu2xStripItem02.Add_Click({ Start-Process -FilePath $Link_W2x_CPP })
  $OptionsWaifu2xMenuStrip.Items.Add($OptionsWaifu2xStripItem02) | Out-Null

  # Tool Paths: Waifu2x - Create a weblink button.
  $global:OptionsWaifu2xWeb = New-Object Windows.Forms.Button
  $OptionsWaifu2xWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsWaifu2xWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsWaifu2xWeb.Image = $Image_WebLinkIcon
  $OptionsWaifu2xWeb.Add_Click({ ShowContextMenuStrip -Button $OptionsWaifu2xWeb -MenuStrip $OptionsWaifu2xMenuStrip })
  $OptionsWaifu2xPathsGroup.Controls.Add($OptionsWaifu2xWeb)

  # Tool Paths: Waifu2x - Create a weblink tooltip.
  $OptionsWaifu2xWebTip = New-Object Windows.Forms.ToolTip
  $OptionsWaifu2xWebTip.InitialDelay = $ToolTipDelay
  $OptionsWaifu2xWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsWaifu2xWebTipString = "Click to open this program's webpage."
  $OptionsWaifu2xWebTip.SetToolTip($OptionsWaifu2xWeb, $OptionsWaifu2xWebTipString)

  # Tool Paths: 7-Zip - Create a group box.
  $global:Options7ZipGroup = New-Object Windows.Forms.GroupBox
  $Options7ZipGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $Options7ZipGroup.Location = DPISize (New-Object Drawing.Point(10, 655))
  $Options7ZipGroup.Text = '7-Zip CLI Executable'
  $OptionsPathsPanel.Controls.Add($Options7ZipGroup)

  # Tool Paths: 7-Zip - Create a tooltip.
  $Options7ZipTip = New-Object Windows.Forms.ToolTip
  $Options7ZipTip.InitialDelay = $ToolTipDelay
  $Options7ZipTip.AutoPopDelay = $ToolTipDuration
  $Options7ZipTipString =  '7-Zip is required to pack a Resource Pack. This script{0}'
  $Options7ZipTipString += 'uses the command line executable named "7z.exe".{0}'
  $Options7ZipTipString += 'The script should pull this path from the registry so it{0}'
  $Options7ZipTipString += 'should normally not need to be manually defined.'
  $Options7ZipTipString = [String]::Format($Options7ZipTipString, [Environment]::NewLine)
  $Options7ZipTip.SetToolTip($Options7ZipGroup, $Options7ZipTipString)

  # Tool Paths: 7-Zip - Create a text box to display the path.
  $global:Options7ZipTextBox = New-Object Windows.Forms.TextBox
  $Options7ZipTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $Options7ZipTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $Options7ZipTextBox.Name = '7ZipPath'
  $Options7ZipTextBox.Text = $7ZipPath
  $Options7ZipTextBox.AllowDrop = $true
  $Options7ZipTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $Options7ZipTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName '7z.exe' })
  $Options7ZipTextBox.Add_Click({ ClearTextBox })
  $Options7ZipTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName '7z.exe' })
  $Options7ZipGroup.Controls.Add($Options7ZipTextBox)

  # Tool Paths: 7-Zip - Create a button to update the path.
  $global:Options7ZipButton = New-Object Windows.Forms.Button
  $Options7ZipButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $Options7ZipButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $Options7ZipButton.Name = '7ZipPath'
  $Options7ZipButton.Text = '...'
  $Options7ZipButton.Add_Click({ LoadExternalFile_Button -TextBox $Options7ZipTextBox -FileName @('7z.exe') -Description @('7-Zip CLI Executable') })
  $Options7ZipGroup.Controls.Add($Options7ZipButton)

  # Tool Paths: 7-Zip - Create a weblink button.
  $global:Options7ZipWeb = New-Object Windows.Forms.Button
  $Options7ZipWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $Options7ZipWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $Options7ZipWeb.Image = $Image_WebLinkIcon
  $Options7ZipWeb.Add_Click({ Start-Process -FilePath $Link_SevZip })
  $Options7ZipGroup.Controls.Add($Options7ZipWeb)

  # Tool Paths: 7-Zip - Create a weblink tooltip.
  $Options7ZipWebTip = New-Object Windows.Forms.ToolTip
  $Options7ZipWebTip.InitialDelay = $ToolTipDelay
  $Options7ZipWebTip.AutoPopDelay = $ToolTipDuration
  $Options7ZipWebTipString = "Click to open this program's webpage."
  $Options7ZipWebTip.SetToolTip($Options7ZipWeb, $Options7ZipWebTipString)

  # Tool Paths: ToCS PKG Tool - Create a group box.
  $global:OptionsPKGToolGroup = New-Object Windows.Forms.GroupBox
  $OptionsPKGToolGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsPKGToolGroup.Location = DPISize (New-Object Drawing.Point(10, 705))
  $OptionsPKGToolGroup.Text = 'ToCS PKG Tool'
  $OptionsPathsPanel.Controls.Add($OptionsPKGToolGroup)

  # Tool Paths: ToCS PKG Tool - Create a tooltip.
  $OptionsPKGToolTip = New-Object Windows.Forms.ToolTip
  $OptionsPKGToolTip.InitialDelay = $ToolTipDelay
  $OptionsPKGToolTip.AutoPopDelay = $ToolTipDuration
  $OptionsPKGToolTipString =  'PKG Tools are used to unpack textures for The Legend{0}'
  $OptionsPKGToolTipString += 'of Heroes: Trails of Cold Steel games. While this script{0}'
  $OptionsPKGToolTipString += 'prefers the PKG Tool by Sewer56, the other PKG Tool{0}'
  $OptionsPKGToolTipString += 'by thesupersonic16 is fully compatible as well. Note{0}'
  $OptionsPKGToolTipString += "that .NET Core 2.0 is required to use the PKG Tool.{0}"
  $OptionsPKGToolTipString += '{0}'
  $OptionsPKGToolTipString += 'Required to unpack/pack PKG files in "Phyre Mode".'
  $OptionsPKGToolTipString = [String]::Format($OptionsPKGToolTipString, [Environment]::NewLine)
  $OptionsPKGToolTip.SetToolTip($OptionsPKGToolGroup, $OptionsPKGToolTipString)

  # Tool Paths: ToCS PKG Tool - Create a text box to display the path.
  $global:OptionsPKGToolTextBox = New-Object Windows.Forms.TextBox
  $OptionsPKGToolTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsPKGToolTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsPKGToolTextBox.Name = 'PhyrePKGTool'
  $OptionsPKGToolTextBox.Text = $PhyrePKGTool
  $OptionsPKGToolTextBox.AllowDrop = $true
  $OptionsPKGToolTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsPKGToolTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('PKGToolCmd.dll', 'PKGTool.exe') })
  $OptionsPKGToolTextBox.Add_Click({ ClearTextBox })
  $OptionsPKGToolTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('PKGToolCmd.dll', 'PKGTool.exe') })
  $OptionsPKGToolGroup.Controls.Add($OptionsPKGToolTextBox)

  # Tool Paths: ToCS PKG Tool - Create a button to update the path.
  $global:OptionsPKGToolButton = New-Object Windows.Forms.Button
  $OptionsPKGToolButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsPKGToolButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsPKGToolButton.Name = 'PhyrePKGTool'
  $OptionsPKGToolButton.Text = '...'
  $OptionsPKGToolButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $OptionsPKGToolTextBox -FileName @('PKGToolCmd.dll', 'PKGTool.exe') -Description 'PKG Tool' })
  $OptionsPKGToolGroup.Controls.Add($OptionsPKGToolButton)

  # Tool Paths: ToCS PKG Tool - Create a strip menu to select the PKG Tool or the .NET Core Runtime.
  $global:OptionsPKGToolMenuStrip = New-Object Windows.Forms.ContextMenuStrip
  $OptionsPKGToolStripItem01 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsPKGToolStripItem02 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsPKGToolStripItem03 = New-Object Windows.Forms.ToolStripMenuItem
  $OptionsPKGToolStripItem01.Text = "Kiseki PKG Tool (Sewer56)"
  $OptionsPKGToolStripItem02.Text = "PKG Tool (thesupersonic16)"
  $OptionsPKGToolStripItem03.Text = "NET Core Runtime 2.2.8"
  $OptionsPKGToolStripItem01.Add_Click({ Start-Process -FilePath $Link_PKGSharp })
  $OptionsPKGToolStripItem02.Add_Click({ Start-Process -FilePath $Link_PKGTool })
  $OptionsPKGToolStripItem03.Add_Click({ Start-Process -FilePath $Link_NETCore })
  $OptionsPKGToolMenuStrip.Items.Add($OptionsPKGToolStripItem01) | Out-Null
  $OptionsPKGToolMenuStrip.Items.Add($OptionsPKGToolStripItem02) | Out-Null
  $OptionsPKGToolMenuStrip.Items.Add($OptionsPKGToolStripItem03) | Out-Null

  # Tool Paths: ToCS PKG Tool - Create a weblink button.
  $global:OptionsPKGToolWeb = New-Object Windows.Forms.Button
  $OptionsPKGToolWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsPKGToolWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsPKGToolWeb.Image = $Image_WebLinkIcon
  $OptionsPKGToolWeb.Add_Click({ ShowContextMenuStrip -Button $OptionsPKGToolWeb -MenuStrip $OptionsPKGToolMenuStrip })
  $OptionsPKGToolGroup.Controls.Add($OptionsPKGToolWeb)

  # Tool Paths: ToCS PKG Tool - Create a weblink tooltip.
  $OptionsPKGToolWebTip = New-Object Windows.Forms.ToolTip
  $OptionsPKGToolWebTip.InitialDelay = $ToolTipDelay
  $OptionsPKGToolWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsPKGToolWebTipString = "Click to open this program's webpage."
  $OptionsPKGToolWebTip.SetToolTip($OptionsPKGToolWeb, $OptionsPKGToolWebTipString)

  # Tool Paths: Python - Create a group box.
  $global:OptionsPythonGroup = New-Object Windows.Forms.GroupBox
  $OptionsPythonGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsPythonGroup.Location = DPISize (New-Object Drawing.Point(10, 755))
  $OptionsPythonGroup.Text = 'Python v3.9.x Executable'
  $OptionsPathsPanel.Controls.Add($OptionsPythonGroup)

  # Tool Paths: Python - Create a tooltip.
  $OptionsPythonTip = New-Object Windows.Forms.ToolTip
  $OptionsPythonTip.InitialDelay = $ToolTipDelay
  $OptionsPythonTip.AutoPopDelay = $ToolTipDuration
  $OptionsPythonTipString =  'Python is a cross-platform scripting language. This{0}'
  $OptionsPythonTipString += 'script can now make calls to it by selecting the path{0}'
  $OptionsPythonTipString += 'here. As of now, it is only used for ESRGAN/SFTGAN.'
  $OptionsPythonTipString = [String]::Format($OptionsPythonTipString, [Environment]::NewLine)
  $OptionsPythonTip.SetToolTip($OptionsPythonGroup, $OptionsPythonTipString)

  # Tool Paths: Python - Create a text box to display the path.
  $global:OptionsPythonTextBox = New-Object Windows.Forms.TextBox
  $OptionsPythonTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsPythonTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsPythonTextBox.Name = 'Python'
  $OptionsPythonTextBox.Text = $Python
  $OptionsPythonTextBox.AllowDrop = $true
  $OptionsPythonTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsPythonTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('python.exe') })
  $OptionsPythonTextBox.Add_Click({ ClearTextBox })
  $OptionsPythonTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('python.exe') })
  $OptionsPythonGroup.Controls.Add($OptionsPythonTextBox)

  # Tool Paths: Python - Create a button to update the path.
  $global:OptionsPythonButton = New-Object Windows.Forms.Button
  $OptionsPythonButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsPythonButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsPythonButton.Name = 'Python'
  $OptionsPythonButton.Text = '...'
  $OptionsPythonButton.Add_Click({ LoadExternalFile_Button -TextBox $OptionsPythonTextBox -FileName @('python.exe') -Description @('Python Executable') })
  $OptionsPythonGroup.Controls.Add($OptionsPythonButton)

  # Tool Paths: Python - Create a weblink button.
  $global:OptionsPythonWeb = New-Object Windows.Forms.Button
  $OptionsPythonWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsPythonWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsPythonWeb.Image = $Image_WebLinkIcon
  $OptionsPythonWeb.Add_Click({ Start-Process -FilePath $Link_Python })
  $OptionsPythonGroup.Controls.Add($OptionsPythonWeb)

  # Tool Paths: Python - Create a weblink tooltip.
  $OptionsPythonWebTip = New-Object Windows.Forms.ToolTip
  $OptionsPythonWebTip.InitialDelay = $ToolTipDelay
  $OptionsPythonWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsPythonWebTipString = "Click to open this program's webpage."
  $OptionsPythonWebTip.SetToolTip($OptionsPythonWeb, $OptionsPythonWebTipString)

  # Tool Paths: ESRGAN - Create a group box.
  $global:OptionsESRGANGroup = New-Object Windows.Forms.GroupBox
  $OptionsESRGANGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsESRGANGroup.Location = DPISize (New-Object Drawing.Point(10, 805))
  $OptionsESRGANGroup.Text = 'ESRGAN Root Folder'
  $OptionsPathsPanel.Controls.Add($OptionsESRGANGroup)

  # Tool Paths: ESRGAN - Create a tooltip.
  $OptionsESRGANTip = New-Object Windows.Forms.ToolTip
  $OptionsESRGANTip.InitialDelay = $ToolTipDelay
  $OptionsESRGANTip.AutoPopDelay = $ToolTipDuration
  $OptionsESRGANTipString =  'Advanced AI Upscaling filter accelerated by{0}'
  $OptionsESRGANTipString += 'nvidia CUDA. The CPU can also be used but{0}'
  $OptionsESRGANTipString += 'it is extremely slow. For easier installation,{0}'
  $OptionsESRGANTipString += 'search for the "Auto-Install" on the Options{0}'
  $OptionsESRGANTipString += 'menu on the "Miscellaneous" tab.'
  $OptionsESRGANTipString = [String]::Format($OptionsESRGANTipString, [Environment]::NewLine)
  $OptionsESRGANTip.SetToolTip($OptionsESRGANGroup, $OptionsESRGANTipString)

  # Tool Paths: ESRGAN - Create a text box to display the path.
  $global:OptionsESRGANTextBox = New-Object Windows.Forms.TextBox
  $OptionsESRGANTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsESRGANTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsESRGANTextBox.Name = 'ESRGANBasePath'
  $OptionsESRGANTextBox.Text = $ESRGANBasePath
  $OptionsESRGANTextBox.AllowDrop = $true
  $OptionsESRGANTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsESRGANTextBox.Add_DragDrop({
                                       LoadExternalFolder_DragDrop -TextBox $this -FileTest 'test.py'
                                       PopulateUpscaleFilterList
                                       PopulateSuperScalerModels
                                       RevertESRGANChanges 
                                    })
  $OptionsESRGANTextBox.Add_Click({ ClearTextBox })
  $OptionsESRGANTextBox.Add_Leave({
                                    LoadExternalFolder_TextBox -TextBox $this -FileTest 'test.py'
                                    PopulateUpscaleFilterList
                                    PopulateSuperScalerModels
                                    RevertESRGANChanges 
                                 })
  $OptionsESRGANGroup.Controls.Add($OptionsESRGANTextBox)

  # Tool Paths: ESRGAN - Create a button to update the path.
  $global:OptionsESRGANButton = New-Object Windows.Forms.Button
  $OptionsESRGANButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsESRGANButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsESRGANButton.Name = 'ESRGANBasePath'
  $OptionsESRGANButton.Text = '...'
  $OptionsESRGANButton.Add_Click({
                                   $Message  = 'Select the root path to ESRGAN. This folder should contain various folders and files including "test.py".'
                                   LoadExternalFolder_Button -TextBox $OptionsESRGANTextBox -Message $Message -FileTest 'test.py'
                                   PopulateUpscaleFilterList
                                   PopulateSuperScalerModels 
                                   RevertESRGANChanges 
                                })
  $OptionsESRGANGroup.Controls.Add($OptionsESRGANButton)

  # Tool Paths: ESRGAN - Create a weblink button.
  $global:OptionsESRGANWeb = New-Object Windows.Forms.Button
  $OptionsESRGANWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsESRGANWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsESRGANWeb.Image = $Image_WebLinkIcon
  $OptionsESRGANWeb.Add_Click({ Start-Process -FilePath $Link_ESRGAN })
  $OptionsESRGANGroup.Controls.Add($OptionsESRGANWeb)

  # Tool Paths: ESRGAN - Create a weblink tooltip.
  $OptionsESRGANWebTip = New-Object Windows.Forms.ToolTip
  $OptionsESRGANWebTip.InitialDelay = $ToolTipDelay
  $OptionsESRGANWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsESRGANWebTipString = "Click to open this program's webpage."
  $OptionsESRGANWebTip.SetToolTip($OptionsESRGANWeb, $OptionsESRGANWebTipString)

  # Tool Paths: SFTGAN - Create a group box.
  $global:OptionsSFTGANGroup = New-Object Windows.Forms.GroupBox
  $OptionsSFTGANGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsSFTGANGroup.Location = DPISize (New-Object Drawing.Point(10, 855))
  $OptionsSFTGANGroup.Text = 'SFTGAN Root Folder'
  $OptionsPathsPanel.Controls.Add($OptionsSFTGANGroup)

  # Tool Paths: SFTGAN - Create a tooltip.
  $OptionsSFTGANTip = New-Object Windows.Forms.ToolTip
  $OptionsSFTGANTip.InitialDelay = $ToolTipDelay
  $OptionsSFTGANTip.AutoPopDelay = $ToolTipDuration
  $OptionsSFTGANTipString =  'Advanced AI Upscaling filter accelerated by{0}'
  $OptionsSFTGANTipString += 'nvidia CUDA. The CPU can also be used but{0}'
  $OptionsSFTGANTipString += 'it is extremely slow. For easier installation,{0}'
  $OptionsSFTGANTipString += 'search for the "Auto-Install" on the Options{0}'
  $OptionsSFTGANTipString += 'menu on the "Miscellaneous" tab.'
  $OptionsSFTGANTipString = [String]::Format($OptionsSFTGANTipString, [Environment]::NewLine)
  $OptionsSFTGANTip.SetToolTip($OptionsSFTGANGroup, $OptionsSFTGANTipString)

  # Tool Paths: SFTGAN - Create a text box to display the path.
  $global:OptionsSFTGANTextBox = New-Object Windows.Forms.TextBox
  $OptionsSFTGANTextBox.Size = DPISize (New-Object Drawing.Size(321, 22))
  $OptionsSFTGANTextBox.Location = DPISize (New-Object Drawing.Point(8, 20)) -AddY $DPIOffsetFix
  $OptionsSFTGANTextBox.Name = 'SFTGANBasePath'
  $OptionsSFTGANTextBox.Text = $SFTGANBasePath
  $OptionsSFTGANTextBox.AllowDrop = $true
  $OptionsSFTGANTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsSFTGANTextBox.Add_DragDrop({
                                       LoadExternalFolder_DragDrop -TextBox $this -FileTest 'pytorch_test\test_sftgan.py'
                                       PopulateUpscaleFilterList
                                       PopulateSuperScalerModels
                                       CleanSFTGANFolder
                                    })
  $OptionsSFTGANTextBox.Add_Click({ ClearTextBox })
  $OptionsSFTGANTextBox.Add_Leave({
                                    LoadExternalFolder_TextBox -TextBox $this -FileTest 'pytorch_test\test_sftgan.py'
                                    PopulateUpscaleFilterList
                                    PopulateSuperScalerModels
                                    CleanSFTGANFolder
                                 })
  $OptionsSFTGANGroup.Controls.Add($OptionsSFTGANTextBox)

  # Tool Paths: SFTGAN - Create a button to update the path.
  $global:OptionsSFTGANButton = New-Object Windows.Forms.Button
  $OptionsSFTGANButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsSFTGANButton.Location = DPISize (New-Object Drawing.Point(332, 19))
  $OptionsSFTGANButton.Name = 'SFTGANBasePath'
  $OptionsSFTGANButton.Text = '...'
  $OptionsSFTGANButton.Add_Click({
                                  $Message  = 'Select the root path to SFTGAN. This folder should contain various folders and files including "pytorch_test" folder.'
                                  LoadExternalFolder_Button -TextBox $OptionsSFTGANTextBox -Message $Message -FileTest 'pytorch_test\test_sftgan.py'
                                  PopulateUpscaleFilterList
                                  PopulateSuperScalerModels
                                  CleanSFTGANFolder
                                })
  $OptionsSFTGANGroup.Controls.Add($OptionsSFTGANButton)

  # Tool Paths: SFTGAN - Create a weblink button.
  $global:OptionsSFTGANWeb = New-Object Windows.Forms.Button
  $OptionsSFTGANWeb.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsSFTGANWeb.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsSFTGANWeb.Image = $Image_WebLinkIcon
  $OptionsSFTGANWeb.Add_Click({ Start-Process -FilePath $Link_SFTGAN })
  $OptionsSFTGANGroup.Controls.Add($OptionsSFTGANWeb)

  # Tool Paths: SFTGAN - Create a weblink tooltip.
  $OptionsSFTGANWebTip = New-Object Windows.Forms.ToolTip
  $OptionsSFTGANWebTip.InitialDelay = $ToolTipDelay
  $OptionsSFTGANWebTip.AutoPopDelay = $ToolTipDuration
  $OptionsSFTGANWebTipString = "Click to open this program's webpage."
  $OptionsSFTGANWebTip.SetToolTip($OptionsSFTGANWeb, $OptionsSFTGANWebTipString)

  # Tool Paths: CTT-PS Data Folder - Create a group box.
  $global:OptionsToolDataGroup = New-Object Windows.Forms.GroupBox
  $OptionsToolDataGroup.Size = DPISize (New-Object Drawing.Size(387, 50))
  $OptionsToolDataGroup.Location = DPISize (New-Object Drawing.Point(10, 905))
  $OptionsToolDataGroup.Text = 'CTT-PS Data Folder'
  $OptionsPathsPanel.Controls.Add($OptionsToolDataGroup)

  # Tool Paths: CTT-PS Data Folder - Create a tooltip.
  $OptionsToolDataTip = New-Object System.Windows.Forms.ToolTip
  $OptionsToolDataTip.InitialDelay = $ToolTipDelay
  $OptionsToolDataTip.AutoPopDelay = $ToolTipDuration
  $OptionsToolDataTipString = 'This is where CTT-PS stores external data: where an external{0}'
  $OptionsToolDataTipString += 'options file is created, where temporary images are generated,{0}'
  $OptionsToolDataTipString += 'and where a resource pack database will be located. Also, if{0}'
  $OptionsToolDataTipString += 'the script generates a registry modification (.reg) file, it{0}'
  $OptionsToolDataTipString += 'will create a "RegMods" folder and store it here.{0}'
  $OptionsToolDataTipString += '{0}'
  $OptionsToolDataTipString += 'The default location is "AppData", but also can be changed to{0}'
  $OptionsToolDataTipString += '"Documents", the root of "C:\", or the location of this script{0}'
  $OptionsToolDataTipString += 'file. A custom location can be used but it is not suggested as{0}'
  $OptionsToolDataTipString += 'new versions will not know where it to search for it.{0}'
  $OptionsToolDataTipString += '{0}'
  $OptionsToolDataTipString += 'If a custom location is used and a first boot of a new version{0}'
  $OptionsToolDataTipString += 'of the script does not find it, the script will display the prompt{0}'
  $OptionsToolDataTipString += 'to select the location. Simply select the desired custom folder{0}'
  $OptionsToolDataTipString += 'used before to load all settings into the new version.'
  $OptionsToolDataTipString = [String]::Format($OptionsToolDataTipString, [Environment]::NewLine)
  $OptionsToolDataTip.SetToolTip($OptionsToolDataGroup, $OptionsToolDataTipString)

  # Tool Paths: CTT-PS Data Folder - Create a text box to display the path.
  $global:OptionsToolDataTextBox = New-Object System.Windows.Forms.TextBox
  $OptionsToolDataTextBox.Size = DPISize (New-Object System.Drawing.Size(321, 22))
  $OptionsToolDataTextBox.Location = DPISize (New-Object System.Drawing.Size(8, 20)) -AddY $DPIOffsetFix
  $OptionsToolDataTextBox.Name = 'TextureToolData'
  $OptionsToolDataTextBox.Text = $TextureToolData
  $OptionsToolDataTextBox.ReadOnly = $true
  $OptionsToolDataTextBox.BackColor = '#FFFFFF'
  $OptionsToolDataGroup.Controls.Add($OptionsToolDataTextBox)

  # Tool Paths: CTT-PS Data Folder - Create a button to update the path.
  $global:OptionsToolDataButton = New-Object System.Windows.Forms.Button
  $OptionsToolDataButton.Size = DPISize (New-Object System.Drawing.Size(22, 22))
  $OptionsToolDataButton.Location = DPISize (New-Object System.Drawing.Size(332, 19))
  $OptionsToolDataButton.Name = 'TextureToolData'
  $OptionsToolDataButton.Text = '...'
  $OptionsToolDataButton.Add_Click({ UpdateCTTPSDataPath })
  $OptionsToolDataGroup.Controls.Add($OptionsToolDataButton)

  # Tool Paths: CTT-PS Data Folder - Create an open folder button.
  $global:OptionsToolDataOpen = New-Object Windows.Forms.Button
  $OptionsToolDataOpen.Size = DPISize (New-Object Drawing.Size(22, 22))
  $OptionsToolDataOpen.Location = DPISize (New-Object Drawing.Point(356, 19))
  $OptionsToolDataOpen.Image = $Image_Folder
  $OptionsToolDataOpen.Add_Click({ if (TestPath -LiteralPath $TextureToolData) { Invoke-Item -LiteralPath $TextureToolData } })
  $OptionsToolDataGroup.Controls.Add($OptionsToolDataOpen)

  # Tool Paths: CTT-PS Data Folder - Create a weblink tooltip.
  $OptionsToolDataOpenTip = New-Object Windows.Forms.ToolTip
  $OptionsToolDataOpenTip.InitialDelay = $ToolTipDelay
  $OptionsToolDataOpenTip.AutoPopDelay = $ToolTipDuration
  $OptionsToolDataOpenTipString = "Opens the CTT-PS Data Folder in File Explorer."
  $OptionsToolDataOpenTip.SetToolTip($OptionsToolDataOpen, $OptionsToolDataOpenTipString)

  # Preferences: Create the groupbox.
  $global:OptionsPrefTipGroup = New-Object Windows.Forms.GroupBox
  $OptionsPrefTipGroup.Size = DPISize (New-Object Drawing.Size(404, 40)) -Round
  $OptionsPrefTipGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $OptionsTabPrefs.Controls.Add($OptionsPrefTipGroup)

  # Preferences: Create a label to tell this tab's function.
  $global:OptionsPrefTipLabel = New-Object Windows.Forms.Label
  $OptionsPrefTipLabel.Size = DPISize (New-Object Drawing.Size(384, 20))
  $OptionsPrefTipLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsPrefTipLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5)
  $OptionsPrefTipLabel.Text = "This tab configures the script's behavior and GUI elements."
  $OptionsPrefTipLabel.ForeColor = [Drawing.ColorTranslator]::FromHtml('#600a00')
  $OptionsPrefTipGroup.Controls.Add($OptionsPrefTipLabel)

  # Preferences: Create a group box for "Behavior" preferences.
  $global:OptionsPrefBehaviorGroup = New-Object Windows.Forms.GroupBox
  $OptionsPrefBehaviorGroup.Size = DPISize (New-Object Drawing.Size(404, 199)) -Round
  $OptionsPrefBehaviorGroup.Location = DPISize (New-Object Drawing.Point(10, 47))
  $OptionsPrefBehaviorGroup.Text = "CTT-PS Behavior"
  $OptionsTabPrefs.Controls.Add($OptionsPrefBehaviorGroup)

  # Preferences: Create a tip for the groupbox.
  $OptionsPrefBehaviorGroupTip = New-Object Windows.Forms.ToolTip
  $OptionsPrefBehaviorGroupTip.InitialDelay = $ToolTipDelay
  $OptionsPrefBehaviorGroupTip.AutoPopDelay = $ToolTipDuration
  $OptionsPrefBehaviorGroupTipString = 'These options affect functionality of the script.'
  $OptionsPrefBehaviorGroupTipString = [String]::Format($OptionsPrefBehaviorGroupTipString, [Environment]::NewLine)
  $OptionsPrefBehaviorGroupTip.SetToolTip($OptionsPrefBehaviorGroup, $OptionsPrefBehaviorGroupTipString)

  # Preferences: Enable Storing - Create a checkbox.
  $global:OptionsEnableStoring = New-Object Windows.Forms.CheckBox
  $OptionsEnableStoring.Size = DPISize (New-Object Drawing.Size(280, 16))
  $OptionsEnableStoring.Location = DPISize (New-Object Drawing.Point(12, 22))
  $OptionsEnableStoring.Name = 'EnableStoring'
  $OptionsEnableStoring.Text = " Save any changes made to all options on exit"
  $OptionsEnableStoring.Checked = $EnableStoring
  $OptionsEnableStoring.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleStoringOptions })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsEnableStoring)

  # Preferences: Enable Storing - Create a tooltip.
  $OptionsEnableStoringTip = New-Object Windows.Forms.ToolTip
  $OptionsEnableStoringTip.InitialDelay = $ToolTipDelay
  $OptionsEnableStoringTip.AutoPopDelay = $ToolTipDuration
  $OptionsEnableStoringTipString =  'When the script is closed, changes that{0}'
  $OptionsEnableStoringTipString += 'were made to options will be written to{0}'
  $OptionsEnableStoringTipString += 'the script file itself. This stores all the{0}'
  $OptionsEnableStoringTipString += "personal user settings between runs."
  $OptionsEnableStoringTipString = [String]::Format($OptionsEnableStoringTipString, [Environment]::NewLine)
  $OptionsEnableStoringTip.SetToolTip($OptionsEnableStoring, $OptionsEnableStoringTipString)

  # Preferences: AppData Global Vars - Create a checkbox.
  $global:OptionsAppDataStoring = New-Object Windows.Forms.CheckBox
  $OptionsAppDataStoring.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsAppDataStoring.Location = DPISize (New-Object Drawing.Point(12, 46))
  $OptionsAppDataStoring.Name = 'StoreToAppData'
  $OptionsAppDataStoring.Text = ' Store/load saved changes in "CTT-PS Data" folder'
  $OptionsAppDataStoring.Checked = $StoreToAppData
  $OptionsAppDataStoring.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsAppDataStoring)

  # Preferences: AppData Global Vars - Create a tooltip.
  $OptionsAppDataStoringTip = New-Object Windows.Forms.ToolTip
  $OptionsAppDataStoringTip.InitialDelay = $ToolTipDelay
  $OptionsAppDataStoringTip.AutoPopDelay = $ToolTipDuration
  $OptionsAppDataStoringTipString =  'Store all options into an external text file{0}'
  $OptionsAppDataStoringTipString += 'found in the "CTT-PS Data" folder instead{0}'
  $OptionsAppDataStoringTipString += 'of storing options to the script file itself.'
  $OptionsAppDataStoringTipString = [String]::Format($OptionsAppDataStoringTipString, [Environment]::NewLine)
  $OptionsAppDataStoringTip.SetToolTip($OptionsAppDataStoring, $OptionsAppDataStoringTipString)

  # Preferences: PS Double Click - Create a checkbox.
  $global:OptionsPSClickOpen = New-Object Windows.Forms.CheckBox
  $OptionsPSClickOpen.Size = DPISize (New-Object Drawing.Size(380, 16))
  $OptionsPSClickOpen.Location = DPISize (New-Object Drawing.Point(12, 70))
  $OptionsPSClickOpen.Text = ' Run PowerShell scripts with a double click (Registry Modification)'

  # Check for Windows 11. The registry no longer contains an entry so the hack no longer works.
  if ($WindowsVersion -lt 11)
  {
    # If it's Windows 10 or below, load the registry value.
    $OptionsPSClickOpen.Checked = ((Get-ItemProperty -LiteralPath "HKLM:\Software\Classes\Microsoft.PowerShellScript.1\Shell").'(default)' -eq '0')
  }
  # If the script is ran from a Windows 11 machine.
  else
  {
    # Disable this option because it can no longer work.
    $OptionsPSClickOpen.Text = ' Run PowerShell scripts with a double click (Disabled on Windows 11)'
    $OptionsPSClickOpen.Enabled = $false
  }
  # Add the action after the checkbox has already been toggled.
  $OptionsPSClickOpen.Add_CheckStateChanged({ TogglePowerShellOpenWithClicks })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsPSClickOpen)

  # Preferences: PS Double Click - Create a tooltip.
  $OptionsPSClickOpenTip = New-Object Windows.Forms.ToolTip
  $OptionsPSClickOpenTip.InitialDelay = $ToolTipDelay
  $OptionsPSClickOpenTip.AutoPopDelay = $ToolTipDuration
  $OptionsPSClickOpenTipString = 'Performs a registry modification to allow opening{0}'
  $OptionsPSClickOpenTipString += 'and running PowerShell scripts by double clicking{0}'
  $OptionsPSClickOpenTipString += 'them. Windows 7 users may need to press "OK" if{0}'
  $OptionsPSClickOpenTipString += 'a pop-up dialog appears. Unchecking this option{0}'
  $OptionsPSClickOpenTipString += 'restores the registry entry to the default value.'
  $OptionsPSClickOpenTipString = [String]::Format($OptionsPSClickOpenTipString, [Environment]::NewLine)
  $OptionsPSClickOpenTip.SetToolTip($OptionsPSClickOpen, $OptionsPSClickOpenTipString)

  # Preferences: Create Log File - Create a checkbox.
  $global:OptionsDisableLogFile = New-Object Windows.Forms.CheckBox
  $OptionsDisableLogFile.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsDisableLogFile.Location = DPISize (New-Object Drawing.Point(12, 94))
  $OptionsDisableLogFile.Name = 'CreateLogFile'
  $OptionsDisableLogFile.Text = ' Create a log file of all textures processed'
  $OptionsDisableLogFile.Checked = $CreateLogFile
  $OptionsDisableLogFile.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsDisableLogFile)

  # Preferences: Create Log File - Create a tooltip.
  $OptionsDisableLogTip = New-Object Windows.Forms.ToolTip
  $OptionsDisableLogTip.InitialDelay = $ToolTipDelay
  $OptionsDisableLogTip.AutoPopDelay = $ToolTipDuration
  $OptionsDisableLogTipString = 'Create a log file when any Operation is{0}'
  $OptionsDisableLogTipString += 'performed. The log file is optional in{0}'
  $OptionsDisableLogTipString += 'most cases, but is required when using{0}'
  $OptionsDisableLogTipString += 'the "Scan Dolphin Textures" operation.'
  $OptionsDisableLogTipString = [String]::Format($OptionsDisableLogTipString, [Environment]::NewLine)
  $OptionsDisableLogTip.SetToolTip($OptionsDisableLogFile, $OptionsDisableLogTipString)

  # Preferences: Directory Recursion - Create a checkbox.
  $global:OptionsRecursion = New-Object Windows.Forms.CheckBox
  $OptionsRecursion.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsRecursion.Location = DPISize (New-Object Drawing.Point(12, 118))
  $OptionsRecursion.Name = 'DirectoryRecursion'
  $OptionsRecursion.Text = ' Recurse through all folders found in the "Input Path"'
  $OptionsRecursion.Checked = $DirectoryRecursion
  $OptionsRecursion.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsRecursion)

  # Preferences: Directory Recursion - Create a tooltip.
  $OptionsRecursionTip = New-Object Windows.Forms.ToolTip
  $OptionsRecursionTip.InitialDelay = $ToolTipDelay
  $OptionsRecursionTip.AutoPopDelay = $ToolTipDuration
  $OptionsRecursionTipString = 'When running any Operation, searches{0}'
  $OptionsRecursionTipString += 'all folders and sub-folders found in the{0}'
  $OptionsRecursionTipString += '"Input Path". Disabling this option will{0}'
  $OptionsRecursionTipString += 'only scan the base of the "Input Path".'
  $OptionsRecursionTipString = [String]::Format($OptionsRecursionTipString, [Environment]::NewLine)
  $OptionsRecursionTip.SetToolTip($OptionsRecursion, $OptionsRecursionTipString)

  # Preferences: Allow skip creating an output texture if the output already exists.
  $global:OptionsOpSkipExists = New-Object Windows.Forms.CheckBox
  $OptionsOpSkipExists.Size = DPISize (New-Object Drawing.Size(340, 16))
  $OptionsOpSkipExists.Location = DPISize (New-Object Drawing.Point(12, 142))
  $OptionsOpSkipExists.Name = 'AlwaysOverwrite'
  $OptionsOpSkipExists.Text = ' Overwrite files in the "Output Path" if they already exist'
  $OptionsOpSkipExists.Checked = $AlwaysOverwrite
  $OptionsOpSkipExists.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsOpSkipExists)

  # Preferences: Create a tooltip for the option.
  $OptionsOpSkipExistsTip = New-Object Windows.Forms.ToolTip
  $OptionsOpSkipExistsTip.InitialDelay = $ToolTipDelay
  $OptionsOpSkipExistsTip.AutoPopDelay = $ToolTipDuration
  $OptionsOpSkipExistsTipString = 'When the script creates new textures, this{0}'
  $OptionsOpSkipExistsTipString += 'option will skip creating the texture if the{0}'
  $OptionsOpSkipExistsTipString += 'texture already exists in the output path. If{0}'
  $OptionsOpSkipExistsTipString += 'disabled, the texture will be overwritten.{0}'
  $OptionsOpSkipExistsTipString += 'Not all operations support this feature.'
  $OptionsOpSkipExistsTipString = [String]::Format($OptionsOpSkipExistsTipString, [Environment]::NewLine)
  $OptionsOpSkipExistsTip.SetToolTip($OptionsOpSkipExists, $OptionsOpSkipExistsTipString)

  # Preferences: Auto-Clean Output - Create a checkbox.
  $global:OptionsAutoCleanOutput = New-Object Windows.Forms.CheckBox
  $OptionsAutoCleanOutput.Size = DPISize (New-Object Drawing.Size(335, 16))
  $OptionsAutoCleanOutput.Location = DPISize (New-Object Drawing.Point(12, 166))
  $OptionsAutoCleanOutput.Name = 'AutoCleanOutput'
  $OptionsAutoCleanOutput.Text = ' Automatically remove empty folders from the "Output Path"'
  $OptionsAutoCleanOutput.Checked = $AutoCleanOutput
  $OptionsAutoCleanOutput.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefBehaviorGroup.Controls.Add($OptionsAutoCleanOutput)

  # Preferences: Auto-Clean Output - Create a tooltip.
  $OptionsAutoCleanTip = New-Object Windows.Forms.ToolTip
  $OptionsAutoCleanTip.InitialDelay = $ToolTipDelay
  $OptionsAutoCleanTip.AutoPopDelay = $ToolTipDuration
  $OptionsAutoCleanTipString = 'Some operations may leave empty folders laying{0}'
  $OptionsAutoCleanTipString += 'around in the "Output Path" for various reasons.{0}'
  $OptionsAutoCleanTipString += 'Enable this option to scan for these folders after{0}'
  $OptionsAutoCleanTipString += 'an operation finishes and remove them.'
  $OptionsAutoCleanTipString = [String]::Format($OptionsAutoCleanTipString, [Environment]::NewLine)
  $OptionsAutoCleanTip.SetToolTip($OptionsAutoCleanOutput, $OptionsAutoCleanTipString)

  # Preferences: Create a group box for "GUI" preferences.
  $global:OptionsPrefGUIGroup = New-Object Windows.Forms.GroupBox
  $OptionsPrefGUIGroup.Size = DPISize (New-Object Drawing.Size(404, 201)) -Round
  $OptionsPrefGUIGroup.Location = DPISize (New-Object Drawing.Point(10, 248))
  $OptionsPrefGUIGroup.Text = "GUI Elements"
  $OptionsTabPrefs.Controls.Add($OptionsPrefGUIGroup)

  # Preferences: Create a tip for the groupbox.
  $OptionsPrefGUIGroupTip = New-Object Windows.Forms.ToolTip
  $OptionsPrefGUIGroupTip.InitialDelay = $ToolTipDelay
  $OptionsPrefGUIGroupTip.AutoPopDelay = $ToolTipDuration
  $OptionsPrefGUIGroupTipString = "These options affect the GUI's appearance."
  $OptionsPrefGUIGroupTipString = [String]::Format($OptionsPrefGUIGroupTipString, [Environment]::NewLine)
  $OptionsPrefGUIGroupTip.SetToolTip($OptionsPrefGUIGroup, $OptionsPrefGUIGroupTipString)

  # Preferences: Dialog Update Rate - Create a number selector.  
  $global:OptionsUpdateRateNumBox = New-Object Windows.Forms.NumericUpDown
  $OptionsUpdateRateNumBox.Size = DPISize (New-Object Drawing.Size(48, 10))
  $OptionsUpdateRateNumBox.Location = DPISize (New-Object Drawing.Point(12, 22))
  $OptionsUpdateRateNumBox.Name = 'DialogUpdateRate'
  $OptionsUpdateRateNumBox.DecimalPlaces = 0
  $OptionsUpdateRateNumBox.Minimum = 1
  $OptionsUpdateRateNumBox.Maximum = 250
  $OptionsUpdateRateNumBox.Increment = 1
  $OptionsUpdateRateNumBox.Value = $DialogUpdateRate
  $OptionsUpdateRateNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptionsPrefGUIGroup.Controls.Add($OptionsUpdateRateNumBox)

  # Preferences: Dialog Update Rate - Create a label.  
  $global:OptionsUpdateRateLabel = New-Object Windows.Forms.Label
  $OptionsUpdateRateLabel.Size = DPISize (New-Object Drawing.Size(200, 18))
  $OptionsUpdateRateLabel.Location = DPISize (New-Object Drawing.Point(65, 25))
  $OptionsUpdateRateLabel.Text = 'Dialog Update Rate (in Milliseconds)'
  $OptionsPrefGUIGroup.Controls.Add($OptionsUpdateRateLabel)

  # Preferences: Dialog Update Rate - Create a tooltip.  
  $OptionsUpdateRateTip = New-Object Windows.Forms.ToolTip
  $OptionsUpdateRateTip.InitialDelay = $ToolTipDelay
  $OptionsUpdateRateTip.AutoPopDelay = $ToolTipDuration
  $OptionsUpdateRateTipString = 'The rate the dialog updates in milliseconds when{0}'
  $OptionsUpdateRateTipString += 'paused or when an external program is running.{0}'
  $OptionsUpdateRateTipString += 'A value of "1" is the smoothest possible dialog.{0}'
  $OptionsUpdateRateTipString += '{0}'
  $OptionsUpdateRateTipString += 'Lower values = smoother, heavier CPU usage{0}'
  $OptionsUpdateRateTipString += 'Higher values = choppier, lighter CPU usage{0}'
  $OptionsUpdateRateTipString += '{0}'
  $OptionsUpdateRateTipString += 'To prevent the dialog from freezing during actions{0}'
  $OptionsUpdateRateTipString += 'the script will constantly update it which allows{0}'
  $OptionsUpdateRateTipString += 'general access and populating the texture list. The{0}'
  $OptionsUpdateRateTipString += 'value entered here is the frequency it happens.'
  $OptionsUpdateRateTipString = [String]::Format($OptionsUpdateRateTipString, [Environment]::NewLine)
  $OptionsUpdateRateTip.SetToolTip($OptionsUpdateRateLabel, $OptionsUpdateRateTipString)

  # Preferences: Disable TopMost - Create a checkbox.  
  $global:OptionsTopMostDialog = New-Object Windows.Forms.CheckBox
  $OptionsTopMostDialog.Size = DPISize (New-Object Drawing.Size(280, 16))
  $OptionsTopMostDialog.Location = DPISize (New-Object Drawing.Point(12, 48))
  $OptionsTopMostDialog.Name = 'DisableTopMost'
  $OptionsTopMostDialog.Text = ' Disable forcing the GUI as the top-most window'
  $OptionsTopMostDialog.Checked = $DisableTopMost
  $OptionsTopMostDialog.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleTopMostDialogs ; ActivateDialog -Dialog $OptionsDialog })
  $OptionsPrefGUIGroup.Controls.Add($OptionsTopMostDialog)

  # Preferences: Disable TopMost - Create a tooltip.  
  $OptionsTopMostDialogTip = New-Object Windows.Forms.ToolTip
  $OptionsTopMostDialogTip.InitialDelay = $ToolTipDelay
  $OptionsTopMostDialogTip.AutoPopDelay = $ToolTipDuration
  $OptionsTopMostDialogTipString = 'CTT-PS by default can fall behind other{0}'
  $OptionsTopMostDialogTipString += 'windows. Uncheck this option to force{0}'
  $OptionsTopMostDialogTipString += 'CTT-PS over all other open windows.'
  $OptionsTopMostDialogTipString = [String]::Format($OptionsTopMostDialogTipString, [Environment]::NewLine)
  $OptionsTopMostDialogTip.SetToolTip($OptionsTopMostDialog, $OptionsTopMostDialogTipString)

  # Preferences: Minimize All Windows - Create a checkbox.  
  $global:OptionsGlobalMinimize = New-Object Windows.Forms.CheckBox
  $OptionsGlobalMinimize.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsGlobalMinimize.Location = DPISize (New-Object Drawing.Point(12, 72))
  $OptionsGlobalMinimize.Name = 'MinimizeSingle'
  $OptionsGlobalMinimize.Text = ' Minimize visible windows separately from each other'
  $OptionsGlobalMinimize.Checked = $MinimizeSingle
  $OptionsGlobalMinimize.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefGUIGroup.Controls.Add($OptionsGlobalMinimize)

  # Preferences: Minimize All Windows - Create a tooltip.  
  $OptionsGlobalMinimizeTip = New-Object Windows.Forms.ToolTip
  $OptionsGlobalMinimizeTip.InitialDelay = $ToolTipDelay
  $OptionsGlobalMinimizeTip.AutoPopDelay = $ToolTipDuration
  $OptionsGlobalMinimizeTipString = 'When minimizing any CTT-PS window, only{0}'
  $OptionsGlobalMinimizeTipString += 'minimize the window that the button was{0}'
  $OptionsGlobalMinimizeTipString += 'clicked on. If this option is disabled, then{0}'
  $OptionsGlobalMinimizeTipString += 'minimizing any window minimizes them all.'
  $OptionsGlobalMinimizeTipString = [String]::Format($OptionsGlobalMinimizeTipString, [Environment]::NewLine)
  $OptionsGlobalMinimizeTip.SetToolTip($OptionsGlobalMinimize, $OptionsGlobalMinimizeTipString)

  # Preferences: Disable Visual Styles - Create a checkbox.  
  $global:OptionsVisualStyleCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsVisualStyleCheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsVisualStyleCheckBox.Location = DPISize (New-Object Drawing.Point(12, 96))
  $OptionsVisualStyleCheckBox.Name = 'EnableVisualStyle'
  $OptionsVisualStyleCheckBox.Text = ' Enable modern Windows visual styles'
  $OptionsVisualStyleCheckBox.Checked = $EnableVisualStyle
  $OptionsVisualStyleCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleVisualStyle -ToggleCheck $EnableVisualStyle })
  $OptionsPrefGUIGroup.Controls.Add($OptionsVisualStyleCheckBox)

  # Preferences: Disable Visual Styles - Create a tooltip.  
  $OptionsVisualStyleTip = New-Object Windows.Forms.ToolTip
  $OptionsVisualStyleTip.InitialDelay = $ToolTipDelay
  $OptionsVisualStyleTip.AutoPopDelay = $ToolTipDuration
  $OptionsVisualStyleTipString = 'Enables the visual style used by the current{0}'
  $OptionsVisualStyleTipString += 'OS. Disabling uses the classic Windows look.'
  $OptionsVisualStyleTipString = [String]::Format($OptionsVisualStyleTipString, [Environment]::NewLine)
  $OptionsVisualStyleTip.SetToolTip($OptionsVisualStyleCheckBox, $OptionsVisualStyleTipString)

  # Preferences: Show Quick Help - Create a checkbox.  
  $global:OptionsShowQuickHelp = New-Object Windows.Forms.CheckBox
  $OptionsShowQuickHelp.Size = DPISize (New-Object Drawing.Size(280, 16))
  $OptionsShowQuickHelp.Location = DPISize (New-Object Drawing.Point(12, 120))
  $OptionsShowQuickHelp.Name = 'ShowQuickHelpIcon'
  $OptionsShowQuickHelp.Text = ' Show a "Quick Help" icon near the "Operation" list'
  $OptionsShowQuickHelp.Checked = $ShowQuickHelpIcon
  $OptionsShowQuickHelp.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleDockedQuickHelp })
  $OptionsPrefGUIGroup.Controls.Add($OptionsShowQuickHelp)

  # Preferences: Show Quick Help - Create a tooltip.  
  $OptionsShowQuickHelpTip = New-Object Windows.Forms.ToolTip
  $OptionsShowQuickHelpTip.InitialDelay = $ToolTipDelay
  $OptionsShowQuickHelpTip.AutoPopDelay = $ToolTipDuration
  $OptionsShowQuickHelpTipString = 'Shows a "[?]" icon on the Operations{0}'
  $OptionsShowQuickHelpTipString += 'menu that will quickly open the help{0}'
  $OptionsShowQuickHelpTipString += 'window and links the topic covering{0}'
  $OptionsShowQuickHelpTipString += 'the selected operation in more detail.'
  $OptionsShowQuickHelpTipString = [String]::Format($OptionsShowQuickHelpTipString, [Environment]::NewLine)
  $OptionsShowQuickHelpTip.SetToolTip($OptionsShowQuickHelp, $OptionsShowQuickHelpTipString)

  # Preferences: Web Link Icons - Create a checkbox.  
  $global:OptionsWebLinkCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsWebLinkCheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsWebLinkCheckBox.Location = DPISize (New-Object Drawing.Point(12, 144))
  $OptionsWebLinkCheckBox.Name = 'ShowWebLinkIcons'
  $OptionsWebLinkCheckBox.Text = ' Show WebLink icons on the "Tool Paths" menu'
  $OptionsWebLinkCheckBox.Checked = $ShowWebLinkIcons
  $OptionsWebLinkCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleWebLinkIcons })
  $OptionsPrefGUIGroup.Controls.Add($OptionsWebLinkCheckBox)

  # Preferences: Web Link Icons - Create a tooltip.  
  $OptionsWebLinkTip = New-Object Windows.Forms.ToolTip
  $OptionsWebLinkTip.InitialDelay = $ToolTipDelay
  $OptionsWebLinkTip.AutoPopDelay = $ToolTipDuration
  $OptionsWebLinkTipString = 'Toggle showing the weblink icons.'
  $OptionsWebLinkTip.SetToolTip($OptionsWebLinkCheckBox, $OptionsWebLinkTipString)

  # Preferences: Clear Textboxes - Create a checkbox.  
  $global:OptionsClearTextCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsClearTextCheckBox.Size = DPISize (New-Object Drawing.Size(340, 16))
  $OptionsClearTextCheckBox.Location = DPISize (New-Object Drawing.Point(12, 168))
  $OptionsClearTextCheckBox.Name = 'ClickClearText'
  $OptionsClearTextCheckBox.Text = ' Clear textboxes while holding Shift/Alt/Control when clicking'
  $OptionsClearTextCheckBox.Checked = $ClickClearText
  $OptionsClearTextCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsPrefGUIGroup.Controls.Add($OptionsClearTextCheckBox)

  # Preferences: Clear Textboxes - Create a tooltip.  
  $OptionsClearTextTip = New-Object Windows.Forms.ToolTip
  $OptionsClearTextTip.InitialDelay = $ToolTipDelay
  $OptionsClearTextTip.AutoPopDelay = $ToolTipDuration
  $OptionsClearTextTipString = 'Disable this option to always clear textboxes.'
  $OptionsClearTextTip.SetToolTip($OptionsClearTextCheckBox, $OptionsClearTextTipString)

  # Exclusions: Create the groupbox.
  $global:OptionsExclusionDesGroup = New-Object Windows.Forms.GroupBox
  $OptionsExclusionDesGroup.Size = DPISize (New-Object Drawing.Size(404, 40)) -Round
  $OptionsExclusionDesGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $OptionsTabExclude.Controls.Add($OptionsExclusionDesGroup)

  # Exclusions: Create a label to tell this tab's function.
  $global:OptionsExclusionDesLabel = New-Object Windows.Forms.Label
  $OptionsExclusionDesLabel.Size = DPISize (New-Object Drawing.Size(384, 20))
  $OptionsExclusionDesLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsExclusionDesLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5)
  $OptionsExclusionDesLabel.Text = 'Uncheck options to exclude the corresponding texture type.'
  $OptionsExclusionDesLabel.ForeColor = [Drawing.ColorTranslator]::FromHtml('#600a00')
  $OptionsExclusionDesGroup.Controls.Add($OptionsExclusionDesLabel)

  # Exclusions: Create a groupbox to hold the options.
  $global:OptionsExclusionGroup = New-Object Windows.Forms.GroupBox
  $OptionsExclusionGroup.Size = DPISize (New-Object Drawing.Size(404, 402)) -Round
  $OptionsExclusionGroup.Location = DPISize (New-Object Drawing.Point(10, 47))
  $OptionsTabExclude.Controls.Add($OptionsExclusionGroup)

  # Exclusions: Show a label for file extension exclusions.
  $global:OptionsExExtensionLabel = New-Object Windows.Forms.Label
  $OptionsExExtensionLabel.Size = DPISize (New-Object Drawing.Size(90, 18))
  $OptionsExExtensionLabel.Location = DPISize (New-Object Drawing.Point(10, 20))
  $OptionsExExtensionLabel.Text = 'File Extensions:'
  $OptionsExclusionGroup.Controls.Add($OptionsExExtensionLabel)

  # Exclusions: Create a tooltip.
  $OptionsExExtensionTip = New-Object Windows.Forms.ToolTip
  $OptionsExExtensionTip.InitialDelay = $ToolTipDelay
  $OptionsExExtensionTip.AutoPopDelay = $ToolTipDuration
  $OptionsExExtensionTipString = 'Toggle the type of textures this script will process.'
  $OptionsExExtensionTip.SetToolTip($OptionsExExtensionLabel, $OptionsExExtensionTipString)

  # Exclusions: The PNG checkbox.
  $global:OptionsExPNGCheck = New-Object Windows.Forms.CheckBox
  $OptionsExPNGCheck.Size = DPISize (New-Object Drawing.Size(48, 16))
  $OptionsExPNGCheck.Location = DPISize (New-Object Drawing.Point(116, 20))
  $OptionsExPNGCheck.Name = 'ExcludePNG'
  $OptionsExPNGCheck.Text = 'PNG'
  $OptionsExPNGCheck.Checked = $ExcludePNG
  $OptionsExPNGCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; CheckFileExtensionExclusions })
  $OptionsExclusionGroup.Controls.Add($OptionsExPNGCheck)

  # Exclusions: Create a tooltip.
  $OptionsExPNGTip = New-Object Windows.Forms.ToolTip
  $OptionsExPNGTip.InitialDelay = $ToolTipDelay
  $OptionsExPNGTip.AutoPopDelay = $ToolTipDuration
  $OptionsExPNGTipString = 'Allow PNG textures.'
  $OptionsExPNGTip.SetToolTip($OptionsExPNGCheck, $OptionsExPNGTipString)

  # Exclusions: The DDS checkbox.
  $global:OptionsExDDSCheck = New-Object Windows.Forms.CheckBox
  $OptionsExDDSCheck.Size = DPISize (New-Object Drawing.Size(48, 16))
  $OptionsExDDSCheck.Location = DPISize (New-Object Drawing.Point(168, 20))
  $OptionsExDDSCheck.Name = 'ExcludeDDS'
  $OptionsExDDSCheck.Text = 'DDS'
  $OptionsExDDSCheck.Checked = $ExcludeDDS
  $OptionsExDDSCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; CheckFileExtensionExclusions })
  $OptionsExclusionGroup.Controls.Add($OptionsExDDSCheck)

  # Exclusions: Create a tooltip.
  $OptionsExDDSTip = New-Object Windows.Forms.ToolTip
  $OptionsExDDSTip.InitialDelay = $ToolTipDelay
  $OptionsExDDSTip.AutoPopDelay = $ToolTipDuration
  $OptionsExDDSTipString = 'Allow DDS textures.'
  $OptionsExDDSTip.SetToolTip($OptionsExDDSCheck, $OptionsExDDSTipString)

  # Exclusions: The JPG checkbox.
  $global:OptionsExJPGCheck = New-Object Windows.Forms.CheckBox
  $OptionsExJPGCheck.Size = DPISize (New-Object Drawing.Size(48, 16))
  $OptionsExJPGCheck.Location = DPISize (New-Object Drawing.Point(220, 20))
  $OptionsExJPGCheck.Name = 'ExcludeJPG'
  $OptionsExJPGCheck.Text = 'JPG'
  $OptionsExJPGCheck.Checked = $ExcludeJPG
  $OptionsExJPGCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; CheckFileExtensionExclusions })
  $OptionsExclusionGroup.Controls.Add($OptionsExJPGCheck)

  # Exclusions: Create a tooltip.
  $OptionsExJPGTip = New-Object Windows.Forms.ToolTip
  $OptionsExJPGTip.InitialDelay = $ToolTipDelay
  $OptionsExJPGTip.AutoPopDelay = $ToolTipDuration
  $OptionsExJPGTipString = 'Allow JPG textures.'
  $OptionsExJPGTip.SetToolTip($OptionsExJPGCheck, $OptionsExJPGTipString)

  # Exclusions: The TGA checkbox.
  $global:OptionsExTGACheck = New-Object Windows.Forms.CheckBox
  $OptionsExTGACheck.Size = DPISize (New-Object Drawing.Size(48, 16))
  $OptionsExTGACheck.Location = DPISize (New-Object Drawing.Point(272, 20))
  $OptionsExTGACheck.Name = 'ExcludeTGA'
  $OptionsExTGACheck.Text = 'TGA'
  $OptionsExTGACheck.Checked = $ExcludeTGA
  $OptionsExTGACheck.Add_CheckStateChanged({ CheckBoxStateToggled ; CheckFileExtensionExclusions })
  $OptionsExclusionGroup.Controls.Add($OptionsExTGACheck)

  # Exclusions: Create a tooltip.
  $OptionsExTGATip = New-Object Windows.Forms.ToolTip
  $OptionsExTGATip.InitialDelay = $ToolTipDelay
  $OptionsExTGATip.AutoPopDelay = $ToolTipDuration
  $OptionsExTGATipString = 'Allow TGA textures.'
  $OptionsExTGATip.SetToolTip($OptionsExTGACheck, $OptionsExTGATipString)

  # Exclusions: The TIF/TIFF checkbox.
  $global:OptionsExTIFCheck = New-Object Windows.Forms.CheckBox
  $OptionsExTIFCheck.Size = DPISize (New-Object Drawing.Size(52, 16))
  $OptionsExTIFCheck.Location = DPISize (New-Object Drawing.Point(324, 20))
  $OptionsExTIFCheck.Name = 'ExcludeTIF'
  $OptionsExTIFCheck.Text = 'TIFF'
  $OptionsExTIFCheck.Checked = $ExcludeTIF
  $OptionsExTIFCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; CheckFileExtensionExclusions })
  $OptionsExclusionGroup.Controls.Add($OptionsExTIFCheck)

  # Exclusions: Create a tooltip.
  $OptionsExTIFTip = New-Object Windows.Forms.ToolTip
  $OptionsExTIFTip.InitialDelay = $ToolTipDelay
  $OptionsExTIFTip.AutoPopDelay = $ToolTipDuration
  $OptionsExTIFTipString = 'Allow TIF/TIFF textures.'
  $OptionsExTIFTip.SetToolTip($OptionsExTIFCheck, $OptionsExTIFTipString)

  # Exclusions: Create a label for mipmaps.
  $global:OptionsExMipmapLabel = New-Object Windows.Forms.Label
  $OptionsExMipmapLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsExMipmapLabel.Location = DPISize (New-Object Drawing.Point(10, 45))
  $OptionsExMipmapLabel.Text = 'Mipmaps:'
  $OptionsExclusionGroup.Controls.Add($OptionsExMipmapLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMipmapTip = New-Object Windows.Forms.ToolTip
  $OptionsExMipmapTip.InitialDelay = $ToolTipDelay
  $OptionsExMipmapTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMipmapTipString = 'Toggle mipmap textures and textures with mipmaps.'
  $OptionsExMipmapTip.SetToolTip($OptionsExMipmapLabel, $OptionsExMipmapTipString)
  
  # Exclusions: The texture is a mipmap texture.
  $global:OptionsExIsMipmap = New-Object Windows.Forms.CheckBox
  $OptionsExIsMipmap.Size = DPISize (New-Object Drawing.Size(84, 16))
  $OptionsExIsMipmap.Location = DPISize (New-Object Drawing.Point(116, 45))
  $OptionsExIsMipmap.Name = 'ExcludeIsMipmap'
  $OptionsExIsMipmap.Text = 'Is Mipmap'
  $OptionsExIsMipmap.Checked = $ExcludeIsMipmap
  $OptionsExIsMipmap.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsExclusionGroup.Controls.Add($OptionsExIsMipmap)

  # Exclusions: Create a tooltip.
  $OptionsExIsMipmapTip = New-Object Windows.Forms.ToolTip
  $OptionsExIsMipmapTip.InitialDelay = $ToolTipDelay
  $OptionsExIsMipmapTip.AutoPopDelay = $ToolTipDuration
  $OptionsExIsMipmapTipString = 'Allow Dolphin mipmap [m] textures.'
  $OptionsExIsMipmapTip.SetToolTip($OptionsExIsMipmap, $OptionsExIsMipmapTipString)
  
  # Exclusions: The texture has lower mipmap levels.
  $global:OptionsExHasMipmap = New-Object Windows.Forms.CheckBox
  $OptionsExHasMipmap.Size = DPISize (New-Object Drawing.Size(94, 16))
  $OptionsExHasMipmap.Location = DPISize (New-Object Drawing.Point(220, 45))
  $OptionsExHasMipmap.Name = 'ExcludeHasMipmap'
  $OptionsExHasMipmap.Text = 'Has Mipmaps'
  $OptionsExHasMipmap.Checked = $ExcludeHasMipmap
  $OptionsExHasMipmap.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsExclusionGroup.Controls.Add($OptionsExHasMipmap)

  # Exclusions: Create a tooltip.
  $OptionsExHasMipmapTip = New-Object Windows.Forms.ToolTip
  $OptionsExHasMipmapTip.InitialDelay = $ToolTipDelay
  $OptionsExHasMipmapTip.AutoPopDelay = $ToolTipDuration
  $OptionsExHasMipmapTipString = 'Allow textures that have mipmaps.'
  $OptionsExHasMipmapTip.SetToolTip($OptionsExHasMipmap, $OptionsExHasMipmapTipString)

  # Exclusions: Create a label for the alpha channel.
  $global:OptionsExAlphaLabel = New-Object Windows.Forms.Label
  $OptionsExAlphaLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsExAlphaLabel.Location = DPISize (New-Object Drawing.Point(10, 70))
  $OptionsExAlphaLabel.Text = 'Alpha Channel:'
  $OptionsExclusionGroup.Controls.Add($OptionsExAlphaLabel)

  # Exclusions: Create a tooltip.
  $OptionsExAlphaLabelTip = New-Object Windows.Forms.ToolTip
  $OptionsExAlphaLabelTip.InitialDelay = $ToolTipDelay
  $OptionsExAlphaLabelTip.AutoPopDelay = $ToolTipDuration
  $OptionsExAlphaLabelTipString = 'Toggle textures that have/miss alpha channel.'
  $OptionsExAlphaLabelTip.SetToolTip($OptionsExAlphaLabel, $OptionsExAlphaLabelTipString)

  # Exclusions: The texture does not have an alpha channel.
  $global:OptionsExNoAlpha = New-Object Windows.Forms.CheckBox
  $OptionsExNoAlpha.Size = DPISize (New-Object Drawing.Size(84, 16))
  $OptionsExNoAlpha.Location = DPISize (New-Object Drawing.Point(116, 70))
  $OptionsExNoAlpha.Name = 'ExcludeNoAlpha'
  $OptionsExNoAlpha.Text = 'No Alpha'
  $OptionsExNoAlpha.Checked = $ExcludeNoAlpha
  $OptionsExNoAlpha.Add_CheckStateChanged({ CheckBoxStateToggled ; if ((!$this.Checked) -and (!$OptionsExHasAlpha.Checked)) { $OptionsExHasAlpha.Checked = $true } })
  $OptionsExclusionGroup.Controls.Add($OptionsExNoAlpha)

  # Exclusions: Create a tooltip.
  $OptionsExNoAlphaTip = New-Object Windows.Forms.ToolTip
  $OptionsExNoAlphaTip.InitialDelay = $ToolTipDelay
  $OptionsExNoAlphaTip.AutoPopDelay = $ToolTipDuration
  $OptionsExNoAlphaTipString = 'Allow textures with no alpha channel.'
  $OptionsExNoAlphaTip.SetToolTip($OptionsExNoAlpha, $OptionsExNoAlphaTipString)

  # Exclusions: The texture has an alpha channel.
  $global:OptionsExHasAlpha = New-Object Windows.Forms.CheckBox
  $OptionsExHasAlpha.Size = DPISize (New-Object Drawing.Size(94, 16))
  $OptionsExHasAlpha.Location = DPISize (New-Object Drawing.Point(220, 70))
  $OptionsExHasAlpha.Name = 'ExcludeHasAlpha'
  $OptionsExHasAlpha.Text = 'Has Alpha'
  $OptionsExHasAlpha.Checked = $ExcludeHasAlpha
  $OptionsExHasAlpha.Add_CheckStateChanged({ CheckBoxStateToggled ; if ((!$this.Checked) -and (!$OptionsExNoAlpha.Checked)) { $OptionsExNoAlpha.Checked = $true }  })
  $OptionsExclusionGroup.Controls.Add($OptionsExHasAlpha)

  # Exclusions: Create a tooltip.
  $OptionsExHasAlphaTip = New-Object Windows.Forms.ToolTip
  $OptionsExHasAlphaTip.InitialDelay = $ToolTipDelay
  $OptionsExHasAlphaTip.AutoPopDelay = $ToolTipDuration
  $OptionsExHasAlphaTipString = 'Allow textures with an alpha channel.'
  $OptionsExHasAlphaTip.SetToolTip($OptionsExHasAlpha, $OptionsExHasAlphaTipString)

  # Exclusions: Create a label for material maps.
  $global:OptionsExMaterialLabel = New-Object Windows.Forms.Label
  $OptionsExMaterialLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsExMaterialLabel.Location = DPISize (New-Object Drawing.Point(10, 95))
  $OptionsExMaterialLabel.Text = 'Material Maps:'
  $OptionsExclusionGroup.Controls.Add($OptionsExMaterialLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMaterialTip = New-Object Windows.Forms.ToolTip
  $OptionsExMaterialTip.InitialDelay = $ToolTipDelay
  $OptionsExMaterialTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMaterialTipString = 'Toggle textures with materials or material maps.'
  $OptionsExMaterialTip.SetToolTip($OptionsExMaterialLabel, $OptionsExMaterialTipString)
  
  # Exclusions: The texture has material textures.
  $global:OptionsExHasMaterials = New-Object Windows.Forms.CheckBox
  $OptionsExHasMaterials.Size = DPISize (New-Object Drawing.Size(94, 16))
  $OptionsExHasMaterials.Location = DPISize (New-Object Drawing.Point(116, 95))
  $OptionsExHasMaterials.Name = 'ExcludeHasMats'
  $OptionsExHasMaterials.Text = 'Has Materials'
  $OptionsExHasMaterials.Checked = $ExcludeHasMats
  $OptionsExHasMaterials.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsExclusionGroup.Controls.Add($OptionsExHasMaterials)

  # Exclusions: Create a tooltip.
  $OptionsExHasMaterialsTip = New-Object Windows.Forms.ToolTip
  $OptionsExHasMaterialsTip.InitialDelay = $ToolTipDelay
  $OptionsExHasMaterialsTip.AutoPopDelay = $ToolTipDuration
  $OptionsExHasMaterialsTipString = 'Allow textures with materials (bump/spec/nrm/lum).'
  $OptionsExHasMaterialsTip.SetToolTip($OptionsExHasMaterials, $OptionsExHasMaterialsTipString)
  
  # Exclusions: The texture has a material map.
  $global:OptionsExHasMatMaps = New-Object Windows.Forms.CheckBox
  $OptionsExHasMatMaps.Size = DPISize (New-Object Drawing.Size(120, 16))
  $OptionsExHasMatMaps.Location = DPISize (New-Object Drawing.Point(220, 95))
  $OptionsExHasMatMaps.Name = 'ExcludeHasMatMaps'
  $OptionsExHasMatMaps.Text = 'Has Material Maps'
  $OptionsExHasMatMaps.Checked = $ExcludeHasMatMaps
  $OptionsExHasMatMaps.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsExclusionGroup.Controls.Add($OptionsExHasMatMaps)

  # Exclusions: Create a tooltip.
  $OptionsExHasMatMapsTip = New-Object Windows.Forms.ToolTip
  $OptionsExHasMatMapsTip.InitialDelay = $ToolTipDelay
  $OptionsExHasMatMapsTip.AutoPopDelay = $ToolTipDuration
  $OptionsExHasMatMapsTipString = 'Allow textures with materials maps (mat).'
  $OptionsExHasMatMapsTip.SetToolTip($OptionsExHasMatMaps, $OptionsExHasMatMapsTipString)

  # Exclusions: Create a label for transparency setting.
  $global:OptionsExTransLabel = New-Object Windows.Forms.Label
  $OptionsExTransLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsExTransLabel.Location = DPISize (New-Object Drawing.Point(10, 120))
  $OptionsExTransLabel.Text = 'Transparency:'
  $OptionsExclusionGroup.Controls.Add($OptionsExTransLabel)

  # Exclusions: Create a tooltip.
  $OptionsExTransTip = New-Object Windows.Forms.ToolTip
  $OptionsExTransTip.InitialDelay = $ToolTipDelay
  $OptionsExTransTip.AutoPopDelay = $ToolTipDuration
  $OptionsExTransTipString =  'Toggle textures by checking actual transparency. Setting this to{0}'
  $OptionsExTransTipString += 'anything other than "Allow All" will increase the time it takes to{0}'
  $OptionsExTransTipString += 'finish most operations. Checking images for actual transparency{0}'
  $OptionsExTransTipString += 'is much slower than a check to see if an alpha channel exists.'
  $OptionsExTransTipString = [String]::Format($OptionsExTransTipString, [Environment]::NewLine)
  $OptionsExTransTip.SetToolTip($OptionsExTransLabel, $OptionsExTransTipString)

  # Exclusions: Create a combobox for transparency setting.
  $global:OptionsExTransCombo = New-Object Windows.Forms.ComboBox
  $OptionsExTransCombo.Size = DPISize (New-Object Drawing.Size(164, 20))
  $OptionsExTransCombo.Location = DPISize (New-Object Drawing.Point(116, 116)) -AddY $DPIOffsetFix
  $OptionsExTransCombo.Name = 'ExcludeTransparency'
  $OptionsExTransCombo.Items.Add('Allow All (Fastest)') | Out-Null
  $OptionsExTransCombo.Items.Add('Only Fully Opaque') | Out-Null
  $OptionsExTransCombo.Items.Add('Only Has Transparency') | Out-Null
  $OptionsExTransCombo.SelectedItem = $ExcludeTransparency
  $OptionsExTransCombo.Add_SelectedIndexChanged({ $OptionsFocusLabel.Focus() })
  $OptionsExTransCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $OptionsExTransCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsExTransCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsExTransCombo.Add_DrawItem({ RepopulateComboBox })
  $OptionsExclusionGroup.Controls.Add($OptionsExTransCombo)

  # Exclusions: Create a label for minimum dimensions.
  $global:OptionsExMinDimLabel = New-Object Windows.Forms.Label
  $OptionsExMinDimLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsExMinDimLabel.Location = DPISize (New-Object Drawing.Point(10, 145))
  $OptionsExMinDimLabel.Text = 'Min Dimensions:'
  $OptionsExclusionGroup.Controls.Add($OptionsExMinDimLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMinDimTip = New-Object Windows.Forms.ToolTip
  $OptionsExMinDimTip.InitialDelay = $ToolTipDelay
  $OptionsExMinDimTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMinDimTipString =  'Configures the minimum dimensions allowed.{0}'
  $OptionsExMinDimTipString += 'Enter a value of "0" to disable this feature.'
  $OptionsExMinDimTipString = [String]::Format($OptionsExMinDimTipString, [Environment]::NewLine)
  $OptionsExMinDimTip.SetToolTip($OptionsExMinDimLabel, $OptionsExMinDimTipString)

  # Exclusions: Create a number box for minimum width.
  $global:OptionsExMinWidth = New-Object Windows.Forms.NumericUpDown
  $OptionsExMinWidth.Size = DPISize (New-Object Drawing.Size(60, 10))
  $OptionsExMinWidth.Location = DPISize (New-Object Drawing.Point(116, 142)) -AddY $DPIOffsetFix
  $OptionsExMinWidth.Name = 'ExcludeMinWidth'
  $OptionsExMinWidth.DecimalPlaces = 0
  $OptionsExMinWidth.Minimum = 0
  $OptionsExMinWidth.Maximum = 65536
  $OptionsExMinWidth.Increment = 1
  $OptionsExMinWidth.Value = $ExcludeMinWidth
  $OptionsExMinWidth.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptionsExclusionGroup.Controls.Add($OptionsExMinWidth)

  # Exclusions: Create a label for minimum width.
  $global:OptionsExMinWLabel = New-Object Windows.Forms.Label
  $OptionsExMinWLabel.Size = DPISize (New-Object Drawing.Size(40, 22))
  $OptionsExMinWLabel.Location = DPISize (New-Object Drawing.Point(179, 145))
  $OptionsExMinWLabel.Text = 'Width'
  $OptionsExclusionGroup.Controls.Add($OptionsExMinWLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMinWLabelTip = New-Object Windows.Forms.ToolTip
  $OptionsExMinWLabelTip.InitialDelay = $ToolTipDelay
  $OptionsExMinWLabelTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMinWLabelTipString = 'Configures the minimum width.'
  $OptionsExMinWLabelTip.SetToolTip($OptionsExMinWLabel, $OptionsExMinWLabelTipString)

  # Exclusions: Create a number box for minimum height.
  $global:OptionsExMinHeight = New-Object Windows.Forms.NumericUpDown
  $OptionsExMinHeight.Size = DPISize (New-Object Drawing.Size(60, 10))
  $OptionsExMinHeight.Location = DPISize (New-Object Drawing.Point(220, 142)) -AddY $DPIOffsetFix
  $OptionsExMinHeight.Name = 'ExcludeMinHeight'
  $OptionsExMinHeight.DecimalPlaces = 0
  $OptionsExMinHeight.Minimum = 0
  $OptionsExMinHeight.Maximum = 65536
  $OptionsExMinHeight.Increment = 1
  $OptionsExMinHeight.Value = $ExcludeMinHeight
  $OptionsExMinHeight.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptionsExclusionGroup.Controls.Add($OptionsExMinHeight)

  # Exclusions: Create a label for minimum height.
  $global:OptionsExMinHLabel = New-Object Windows.Forms.Label
  $OptionsExMinHLabel.Size = DPISize (New-Object Drawing.Size(45, 22))
  $OptionsExMinHLabel.Location = DPISize (New-Object Drawing.Point(283, 145))
  $OptionsExMinHLabel.Text = 'Height'
  $OptionsExclusionGroup.Controls.Add($OptionsExMinHLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMinHLabelTip = New-Object Windows.Forms.ToolTip
  $OptionsExMinHLabelTip.InitialDelay = $ToolTipDelay
  $OptionsExMinHLabelTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMinHLabelTipString = 'Configures the minimum height.'
  $OptionsExMinHLabelTip.SetToolTip($OptionsExMinHLabel, $OptionsExMinHLabelTipString)

  # Exclusions: Create a label for maximum dimensions.
  $global:OptionsExMaxDimLabel = New-Object Windows.Forms.Label
  $OptionsExMaxDimLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsExMaxDimLabel.Location = DPISize (New-Object Drawing.Point(10, 170))
  $OptionsExMaxDimLabel.Text = 'Max Dimensions:'
  $OptionsExclusionGroup.Controls.Add($OptionsExMaxDimLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMaxDimTip = New-Object Windows.Forms.ToolTip
  $OptionsExMaxDimTip.InitialDelay = $ToolTipDelay
  $OptionsExMaxDimTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMaxDimTipString =  'Configures the maximum dimensions allowed.{0}'
  $OptionsExMaxDimTipString += 'Enter a value of "0" to disable this feature.'
  $OptionsExMaxDimTipString = [String]::Format($OptionsExMaxDimTipString, [Environment]::NewLine)
  $OptionsExMaxDimTip.SetToolTip($OptionsExMaxDimLabel, $OptionsExMaxDimTipString)

  # Exclusions: Create a number box for maximum width.
  $global:OptionsExMaxWidth = New-Object Windows.Forms.NumericUpDown
  $OptionsExMaxWidth.Size = DPISize (New-Object Drawing.Size(60, 10))
  $OptionsExMaxWidth.Location = DPISize (New-Object Drawing.Point(116, 167)) -AddY $DPIOffsetFix
  $OptionsExMaxWidth.Name = 'ExcludeMaxWidth'
  $OptionsExMaxWidth.DecimalPlaces = 0
  $OptionsExMaxWidth.Minimum = 0
  $OptionsExMaxWidth.Maximum = 65536
  $OptionsExMaxWidth.Increment = 1
  $OptionsExMaxWidth.Value = $ExcludeMaxWidth
  $OptionsExMaxWidth.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptionsExclusionGroup.Controls.Add($OptionsExMaxWidth)

  # Exclusions: Create a label for maximum width.
  $global:OptionsExMaxWLabel = New-Object Windows.Forms.Label
  $OptionsExMaxWLabel.Size = DPISize (New-Object Drawing.Size(40, 22))
  $OptionsExMaxWLabel.Location = DPISize (New-Object Drawing.Point(179, 170))
  $OptionsExMaxWLabel.Text = 'Width'
  $OptionsExclusionGroup.Controls.Add($OptionsExMaxWLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMaxWLabelTip = New-Object Windows.Forms.ToolTip
  $OptionsExMaxWLabelTip.InitialDelay = $ToolTipDelay
  $OptionsExMaxWLabelTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMaxWLabelTipString = 'Configures the maximum width.'
  $OptionsExMaxWLabelTip.SetToolTip($OptionsExMaxWLabel, $OptionsExMaxWLabelTipString)

  # Exclusions: Create a number box for maximum height.
  $global:OptionsExMaxHeight = New-Object Windows.Forms.NumericUpDown
  $OptionsExMaxHeight.Size = DPISize (New-Object Drawing.Size(60, 10))
  $OptionsExMaxHeight.Location = DPISize (New-Object Drawing.Point(220, 167)) -AddY $DPIOffsetFix
  $OptionsExMaxHeight.Name = 'ExcludeMaxHeight'
  $OptionsExMaxHeight.DecimalPlaces = 0
  $OptionsExMaxHeight.Minimum = 0
  $OptionsExMaxHeight.Maximum = 65536
  $OptionsExMaxHeight.Increment = 1
  $OptionsExMaxHeight.Value = $ExcludeMaxHeight
  $OptionsExMaxHeight.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptionsExclusionGroup.Controls.Add($OptionsExMaxHeight)

  # Exclusions: Create a label for maximum height.
  $global:OptionsExMaxHLabel = New-Object Windows.Forms.Label
  $OptionsExMaxHLabel.Size = DPISize (New-Object Drawing.Size(45, 22))
  $OptionsExMaxHLabel.Location = DPISize (New-Object Drawing.Point(283, 170))
  $OptionsExMaxHLabel.Text = 'Height'
  $OptionsExclusionGroup.Controls.Add($OptionsExMaxHLabel)

  # Exclusions: Create a tooltip.
  $OptionsExMaxHLabelTip = New-Object Windows.Forms.ToolTip
  $OptionsExMaxHLabelTip.InitialDelay = $ToolTipDelay
  $OptionsExMaxHLabelTip.AutoPopDelay = $ToolTipDuration
  $OptionsExMaxHLabelTipString = 'Configures the maximum height.'
  $OptionsExMaxHLabelTip.SetToolTip($OptionsExMaxHLabel, $OptionsExMaxHLabelTipString)

  # Exclusions: Create a label for names and phrases.
  $global:OptionsExStringLabel = New-Object Windows.Forms.Label
  $OptionsExStringLabel.Size = DPISize (New-Object Drawing.Size(120, 15))
  $OptionsExStringLabel.Location = DPISize (New-Object Drawing.Point(10, 195))
  $OptionsExStringLabel.Text = 'Names / Phrases:'
  $OptionsExclusionGroup.Controls.Add($OptionsExStringLabel)

  # Exclusions: Create a tooltip.
  $OptionsExStringTip = New-Object Windows.Forms.ToolTip
  $OptionsExStringTip.InitialDelay = $ToolTipDelay
  $OptionsExStringTip.AutoPopDelay = $ToolTipDuration
  $OptionsExStringTipString =  'Exclude textures using a full or partial text{0}'
  $OptionsExStringTipString += 'string match. Example: Adding a pattern{0}'
  $OptionsExStringTipString += 'such as "320x240" will exclude all textures{0}'
  $OptionsExStringTipString += 'with these dimensions in their name. Each{0}'
  $OptionsExStringTipString += 'entry must be entered onto a new line.'
  $OptionsExStringTipString = [String]::Format($OptionsExStringTipString, [Environment]::NewLine)
  $OptionsExStringTip.SetToolTip($OptionsExStringLabel, $OptionsExStringTipString)

  # Exclusions: Create a textbox for the names and phrases.
  $global:OptionsExStringTextBox = New-Object Windows.Forms.RichTextBox
  $OptionsExStringTextBox.Size = DPISize (New-Object Drawing.Size(377, 164))
  $OptionsExStringTextBox.Location = DPISize (New-Object Drawing.Point(10, 212))
  $OptionsExStringTextBox.Text = ''
  $OptionsExStringTextBox.TabStop = $true
  $OptionsExStringTextBox.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $OptionsExStringTextBox.Add_Click({ ClearTextBox })
  $OptionsExStringTextBox.Add_Leave({ StoreExclusionStrings })
  $OptionsExclusionGroup.Controls.Add($OptionsExStringTextBox)

  # Exclusions: Create a label for names and phrases tip.
  $global:OptionsExStringHintLabel = New-Object Windows.Forms.Label
  $OptionsExStringHintLabel.Size = DPISize (New-Object Drawing.Size(300, 14))
  $OptionsExStringHintLabel.Location = DPISize (New-Object Drawing.Point(10, 381))
  $OptionsExStringHintLabel.Text = '*Each entry to exclude should be entered onto a new line.'
  $OptionsExclusionGroup.Controls.Add($OptionsExStringHintLabel)

  # Misc: Create the groupbox.
  $global:OptionsGeneralDesGroup = New-Object Windows.Forms.GroupBox
  $OptionsGeneralDesGroup.Size = DPISize (New-Object Drawing.Size(404, 40)) -Round
  $OptionsGeneralDesGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $OptionsTabMisc.Controls.Add($OptionsGeneralDesGroup)

  # Misc: Create a label to tell this tab's function.
  $global:OptionsGeneralDesLabel = New-Object Windows.Forms.Label
  $OptionsGeneralDesLabel.Size = DPISize (New-Object Drawing.Size(384, 20))
  $OptionsGeneralDesLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsGeneralDesLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5)
  $OptionsGeneralDesLabel.Text = "Contains various options that don't quite fit anywhere else."
  $OptionsGeneralDesLabel.ForeColor = [Drawing.ColorTranslator]::FromHtml('#600a00')
  $OptionsGeneralDesGroup.Controls.Add($OptionsGeneralDesLabel)

  # Misc: Create a groupbox to hold the "DDS Tools Options".
  $global:OptionsDDSToolsGroup = New-Object Windows.Forms.GroupBox
  $OptionsDDSToolsGroup.Size = DPISize (New-Object Drawing.Size(404, 80)) -Round
  $OptionsDDSToolsGroup.Location = DPISize (New-Object Drawing.Point(10, 47))
  $OptionsTabMisc.Controls.Add($OptionsDDSToolsGroup)

  # Misc: Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:OptionsDDSToolsTTBox = New-Object TransparentLabel
  $OptionsDDSToolsTTBox.Size = DPISize (New-Object Drawing.Size(380, 30))
  $OptionsDDSToolsTTBox.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsDDSToolsTTBox.Text = ""
  $OptionsDDSToolsGroup.Controls.Add($OptionsDDSToolsTTBox)

  # Misc: Add a short description of this dialog.
  $global:OptionsDDSToolsLabel = New-Object AdvRichTextBox
  $OptionsDDSToolsLabel.Size = DPISize (New-Object Drawing.Size(380, 30))
  $OptionsDDSToolsLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsDDSToolsLabel.Text = 'The programs used to create DDS textures each have their own individual options that offer strengths and weaknesses over the other programs.'
  $OptionsDDSToolsLabel.SelectionAlignment = [TextAlign]::Justify
  $OptionsDDSToolsLabel.TabStop = $false
  $OptionsDDSToolsLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $OptionsDDSToolsLabel.ReadOnly = $true
  $OptionsDDSToolsLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $OptionsDDSToolsGroup.Controls.Add($OptionsDDSToolsLabel)

  # Misc: Create a button for Compressonator options.
  $global:OptionsDDSCompressButton = New-Object Windows.Forms.Button
  $OptionsDDSCompressButton.Size = DPISize (New-Object Drawing.Size(116, 24))
  $OptionsDDSCompressButton.Location = DPISize (New-Object Drawing.Point(15, 47))
  $OptionsDDSCompressButton.Text = "Compressonator"
  $OptionsDDSCompressButton.Add_Click({ ShowDDSToolOptions -DDSTool 'Compressonator' })
  $OptionsDDSToolsGroup.Controls.Add($OptionsDDSCompressButton)

  # Misc: Create a button for TexConv options.
  $global:OptionsDDSTexConvButton = New-Object Windows.Forms.Button
  $OptionsDDSTexConvButton.Size = DPISize (New-Object Drawing.Size(116, 24))
  $OptionsDDSTexConvButton.Location = DPISize (New-Object Drawing.Point(144, 47))
  $OptionsDDSTexConvButton.Text = "TexConv"
  $OptionsDDSTexConvButton.Add_Click({ ShowDDSToolOptions -DDSTool 'TexConv' })
  $OptionsDDSToolsGroup.Controls.Add($OptionsDDSTexConvButton)

  # Misc: Create a button for ImageMagick options.
  $global:OptionsMagickButton = New-Object Windows.Forms.Button
  $OptionsMagickButton.Size = DPISize (New-Object Drawing.Size(116, 24))
  $OptionsMagickButton.Location = DPISize (New-Object Drawing.Point(273, 47))
  $OptionsMagickButton.Text = "ImageMagick"
  $OptionsMagickButton.Add_Click({ ShowDDSToolOptions -DDSTool 'ImageMagick' })
  $OptionsDDSToolsGroup.Controls.Add($OptionsMagickButton)

  # Misc: Create a groupbox to hold the "Additional Options".
  $global:OptionsAdditionalGroup = New-Object Windows.Forms.GroupBox
  $OptionsAdditionalGroup.Size = DPISize (New-Object Drawing.Size(404, 80)) -Round
  $OptionsAdditionalGroup.Location = DPISize (New-Object Drawing.Point(10, 129))
  $OptionsTabMisc.Controls.Add($OptionsAdditionalGroup)

  # Misc: Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:OptionsAdditionalTTBox = New-Object TransparentLabel
  $OptionsAdditionalTTBox.Size = DPISize (New-Object Drawing.Size(380, 30))
  $OptionsAdditionalTTBox.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsAdditionalTTBox.Text = ""
  $OptionsAdditionalGroup.Controls.Add($OptionsAdditionalTTBox)

  # Misc: Add a short description of this dialog.
  $global:OptionsAdditionalLabel = New-Object AdvRichTextBox
  $OptionsAdditionalLabel.Size = DPISize (New-Object Drawing.Size(380, 30))
  $OptionsAdditionalLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsAdditionalLabel.Text = 'Some operations have a button in their config window that gives access to additional options, and have been gathered here for convenience.'
  $OptionsAdditionalLabel.SelectionAlignment = [TextAlign]::Justify
  $OptionsAdditionalLabel.TabStop = $false
  $OptionsAdditionalLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $OptionsAdditionalLabel.ReadOnly = $true
  $OptionsAdditionalLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $OptionsAdditionalGroup.Controls.Add($OptionsAdditionalLabel)

  # Misc: Create a button for Waifu2x options.
  $global:OptionsW2xOptionButton = New-Object Windows.Forms.Button
  $OptionsW2xOptionButton.Size = DPISize (New-Object Drawing.Size(116, 24))
  $OptionsW2xOptionButton.Location = DPISize (New-Object Drawing.Point(15, 47))
  $OptionsW2xOptionButton.Text = "Waifu2x"
  $OptionsW2xOptionButton.Add_Click({ ShowWaifu2xDialog })
  $OptionsAdditionalGroup.Controls.Add($OptionsW2xOptionButton)

  # Misc: Create a button for ESRGAN/SFTGAN options.
  $global:OptionsESRGANOptionButton = New-Object Windows.Forms.Button
  $OptionsESRGANOptionButton.Size = DPISize (New-Object Drawing.Size(116, 24))
  $OptionsESRGANOptionButton.Location = DPISize (New-Object Drawing.Point(144, 47))
  $OptionsESRGANOptionButton.Text = "ESRGAN/SFTGAN"
  $OptionsESRGANOptionButton.Add_Click({ ShowESRGANDialog -CombineScalers })
  $OptionsAdditionalGroup.Controls.Add($OptionsESRGANOptionButton)

  # Misc: Create a groupbox for ESRGAN/SFTGAN auto-setup.
  $global:AutoSuperScalerGroup = New-Object Windows.Forms.GroupBox
  $AutoSuperScalerGroup.Size = DPISize (New-Object Drawing.Size(404, 110)) -Round
  $AutoSuperScalerGroup.Location = DPISize (New-Object Drawing.Point(10, 211))
  $OptionsTabMisc.Controls.Add($AutoSuperScalerGroup)

  # Misc: Create a label for the auto-setup window.
  $global:OptionsSSAutoSetupLabel = New-Object Windows.Forms.Label
  $OptionsSSAutoSetupLabel.Size = DPISize (New-Object Drawing.Size(380, 15))
  $OptionsSSAutoSetupLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsSSAutoSetupLabel.Text = 'ESRGAN/SFTGAN Automatic Setup:'
  $AutoSuperScalerGroup.Controls.Add($OptionsSSAutoSetupLabel)

  # Misc: Create the auto-setup button.
  $global:OptionsSSAutoSetupButton = New-Object Windows.Forms.Button
  $OptionsSSAutoSetupButton.Size = DPISize (New-Object Drawing.Size(116, 24))
  $OptionsSSAutoSetupButton.Location = DPISize (New-Object Drawing.Point(15, 33))
  $OptionsSSAutoSetupButton.Text = 'Start Auto-Setup'
  $OptionsSSAutoSetupButton.Add_Click({ SSAutoSetup_Show })
  $AutoSuperScalerGroup.Controls.Add($OptionsSSAutoSetupButton)

  # Misc: Create a tip for the auto-setup button.
  $OptionsSSAutoSetupTip = New-Object Windows.Forms.ToolTip
  $OptionsSSAutoSetupTip.InitialDelay = $ToolTipDelay
  $OptionsSSAutoSetupTip.AutoPopDelay = $ToolTipDuration
  $OptionsSSAutoSetupTipString = 'This option allows you to easily set up ESRGAN and{0}'
  $OptionsSSAutoSetupTipString += 'SFTGAN. Click the "Auto Setup" button to download{0}'
  $OptionsSSAutoSetupTipString += 'and install everything required. To manually set{0}'
  $OptionsSSAutoSetupTipString += 'up the paths, open the "Tool Paths" tab.'
  $OptionsSSAutoSetupTipString = [String]::Format($OptionsSSAutoSetupTipString, [Environment]::NewLine)
  $OptionsSSAutoSetupTip.SetToolTip($OptionsSSAutoSetupButton, $OptionsSSAutoSetupTipString)

  # Misc: Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:OptionsSSAutoSetupTTBox = New-Object TransparentLabel
  $OptionsSSAutoSetupTTBox.Size = DPISize (New-Object Drawing.Size(380, 44))
  $OptionsSSAutoSetupTTBox.Location = DPISize (New-Object Drawing.Point(10, 62))
  $OptionsSSAutoSetupTTBox.Text = ""
  $AutoSuperScalerGroup.Controls.Add($OptionsSSAutoSetupTTBox)

  # Misc: Set up the text for the label.
  $OptionsSSAutoSetupText =  'Click to download, install, and update Python, Nvidia CUDA, ESRGAN, and SFTGAN. AMD GPU users may have to skip '
  $OptionsSSAutoSetupText += 'the "Install CUDA" step. After installing, the filters will appear in "Apply Upscaling Filter to All Textures".'

  # Misc: Add a short description of this dialog.
  $global:OptionsSSAutoSetupLabelB = New-Object AdvRichTextBox
  $OptionsSSAutoSetupLabelB.Size = DPISize (New-Object Drawing.Size(380, 44))
  $OptionsSSAutoSetupLabelB.Location = DPISize (New-Object Drawing.Point(10, 62))
  $OptionsSSAutoSetupLabelB.Text = $OptionsSSAutoSetupText
  $OptionsSSAutoSetupLabelB.SelectionAlignment = [TextAlign]::Justify
  $OptionsSSAutoSetupLabelB.TabStop = $false
  $OptionsSSAutoSetupLabelB.BorderStyle = [Windows.Forms.BorderStyle]::None
  $OptionsSSAutoSetupLabelB.ReadOnly = $true
  $OptionsSSAutoSetupLabelB.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $AutoSuperScalerGroup.Controls.Add($OptionsSSAutoSetupLabelB)

  # Misc: Create a groupbox to shutdown the PC after use.
  $global:OptionsShutdownGroup = New-Object Windows.Forms.GroupBox
  $OptionsShutdownGroup.Size = DPISize (New-Object Drawing.Size(404, 125)) -Round
  $OptionsShutdownGroup.Location = DPISize (New-Object Drawing.Point(10, 324))
  $OptionsTabMisc.Controls.Add($OptionsShutdownGroup)

  # Misc: Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:OptionsShutdownLabelA = New-Object Windows.Forms.Label
  $OptionsShutdownLabelA.Size = DPISize (New-Object Drawing.Size(314, 14))
  $OptionsShutdownLabelA.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsShutdownLabelA.Text = 'PC Automatic Shutdown:'
  $OptionsShutdownGroup.Controls.Add($OptionsShutdownLabelA)

  # Misc: Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:OptionsShutdownTTBox = New-Object TransparentLabel
  $OptionsShutdownTTBox.Size = DPISize (New-Object Drawing.Size(380, 58))
  $OptionsShutdownTTBox.Location = DPISize (New-Object Drawing.Point(10, 34))
  $OptionsShutdownTTBox.Text = ""
  $OptionsShutdownGroup.Controls.Add($OptionsShutdownTTBox)

  # Misc: Add a short description of this dialog.
  $global:OptionsShutdownLabelB = New-Object AdvRichTextBox
  $OptionsShutdownLabelB.Size = DPISize (New-Object Drawing.Size(380, 58))
  $OptionsShutdownLabelB.Location = DPISize (New-Object Drawing.Point(10, 34))
  $OptionsShutdownLabelB.Text =  'Some operations (most notably converting, rescaling, resizing, optimizing, upscaling) can take several hours, enough to justify leaving the PC on overnight and letting '
  $OptionsShutdownLabelB.Text += 'it finish remotely. The checkbox here can be used to automatically shutdown the PC after any operation has finished. '
  $OptionsShutdownLabelB.SelectionAlignment = [TextAlign]::Justify
  $OptionsShutdownLabelB.TabStop = $false
  $OptionsShutdownLabelB.BorderStyle = [Windows.Forms.BorderStyle]::None
  $OptionsShutdownLabelB.ReadOnly = $true
  $OptionsShutdownLabelB.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $OptionsShutdownGroup.Controls.Add($OptionsShutdownLabelB)

  # Debug: Disable Texture Counts - Create a checkbox.
  $global:OptionsShutdownPCCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsShutdownPCCheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsShutdownPCCheckBox.Location = DPISize (New-Object Drawing.Point(12, 98))
  $OptionsShutdownPCCheckBox.Name = 'AutoShutdownPC'
  $OptionsShutdownPCCheckBox.Text = ' Shutdown the PC after any operation has finished'
  $OptionsShutdownPCCheckBox.Checked = $AutoShutdownPC
  $OptionsShutdownPCCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsShutdownGroup.Controls.Add($OptionsShutdownPCCheckBox)

  # Debug: Create a warning to alert users of missing/broken textures.
  $global:OptionsDebugWarningGroup = New-Object Windows.Forms.GroupBox
  $OptionsDebugWarningGroup.Size = DPISize (New-Object Drawing.Size(404, 40)) -Round
  $OptionsDebugWarningGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $OptionsTabDebug.Controls.Add($OptionsDebugWarningGroup)

  # Debug: Create a label to display the warning.
  $global:OptionsDebugWarningLabel = New-Object Windows.Forms.Label
  $OptionsDebugWarningLabel.Size = DPISize (New-Object Drawing.Size(384, 20))
  $OptionsDebugWarningLabel.Location = DPISize (New-Object Drawing.Point(10, 14))
  $OptionsDebugWarningLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5)
  $OptionsDebugWarningLabel.Text = 'Warning: Some options may result in broken / missing textures!'
  $OptionsDebugWarningLabel.ForeColor = [Drawing.ColorTranslator]::FromHtml('#600a00')
  $OptionsDebugWarningGroup.Controls.Add($OptionsDebugWarningLabel)

  # Debug: Create a groupbox to hold all the options.
  $global:OptionsDebugGroup = New-Object Windows.Forms.GroupBox
  $OptionsDebugGroup.Size = DPISize (New-Object Drawing.Size(404, 402)) -Round
  $OptionsDebugGroup.Location = DPISize (New-Object Drawing.Point(10, 47))
  $OptionsTabDebug.Controls.Add($OptionsDebugGroup)

  # Debug: Create a tooltip for the groupbox.
  $OptionsDebugGroupTip = New-Object Windows.Forms.ToolTip
  $OptionsDebugGroupTip.InitialDelay = $ToolTipDelay
  $OptionsDebugGroupTip.AutoPopDelay = $ToolTipDuration
  $OptionsDebugGroupTipString = 'These options should only be modified{0}'
  $OptionsDebugGroupTipString += 'if you fully understand what they do!'
  $OptionsDebugGroupTipString = [String]::Format($OptionsDebugGroupTipString, [Environment]::NewLine)
  $OptionsDebugGroupTip.SetToolTip($OptionsDebugGroup, $OptionsDebugGroupTipString)

  # Debug: PowerShell Console - Create a checkbox.
  $global:OptionsPSConsoleCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsPSConsoleCheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsPSConsoleCheckBox.Location = DPISize (New-Object Drawing.Point(12, 22))
  $OptionsPSConsoleCheckBox.Name = 'EnableThePSConsole'
  $OptionsPSConsoleCheckBox.Text = ' Show the PowerShell Console window'
  $OptionsPSConsoleCheckBox.Checked = $EnableThePSConsole
  $OptionsPSConsoleCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; TogglePowerShellConsole })
  $OptionsDebugGroup.Controls.Add($OptionsPSConsoleCheckBox)

  # Debug: PowerShell Console - Create a tooltip.
  $OptionsPSConsoleTip = New-Object Windows.Forms.ToolTip
  $OptionsPSConsoleTip.InitialDelay = $ToolTipDelay
  $OptionsPSConsoleTip.AutoPopDelay = $ToolTipDuration
  $OptionsPSConsoleTipString = 'Opens the PowerShell console. This is only{0}'
  $OptionsPSConsoleTipString += 'useful to find code errors when things go{0}'
  $OptionsPSConsoleTipString += 'wrong. The PS Console tracks and reports{0}'
  $OptionsPSConsoleTipString += 'basic debug information when processing.'
  $OptionsPSConsoleTipString = [String]::Format($OptionsPSConsoleTipString, [Environment]::NewLine)
  $OptionsPSConsoleTip.SetToolTip($OptionsPSConsoleCheckBox, $OptionsPSConsoleTipString)

  # Debug: Disable Auto-Center Console - Create a checkbox.
  $global:OptionsAutoConsoleCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsAutoConsoleCheckBox.Size = DPISize (New-Object Drawing.Size(320, 16))
  $OptionsAutoConsoleCheckBox.Location = DPISize (New-Object Drawing.Point(12, 46))
  $OptionsAutoConsoleCheckBox.Name = 'DisableAutoConsole'
  $OptionsAutoConsoleCheckBox.Text = ' Disable auto-centering the PowerShell console on launch'
  $OptionsAutoConsoleCheckBox.Checked = $DisableAutoConsole
  $OptionsAutoConsoleCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsDebugGroup.Controls.Add($OptionsAutoConsoleCheckBox)

  # Debug: Disable Auto-Center Console - Create a tooltip.
  $OptionsAutoConsoleTip = New-Object Windows.Forms.ToolTip
  $OptionsAutoConsoleTip.InitialDelay = $ToolTipDelay
  $OptionsAutoConsoleTip.AutoPopDelay = $ToolTipDuration
  $OptionsAutoConsoleTipString = 'Disables centering the PowerShell console{0}'
  $OptionsAutoConsoleTipString += 'when the script is first launched. I use this{0}'
  $OptionsAutoConsoleTipString += 'option when I develop because it jumping{0}'
  $OptionsAutoConsoleTipString += 'to the center every run can get annoying.'
  $OptionsAutoConsoleTipString = [String]::Format($OptionsAutoConsoleTipString, [Environment]::NewLine)
  $OptionsAutoConsoleTip.SetToolTip($OptionsAutoConsoleCheckBox, $OptionsAutoConsoleTipString)

  # Debug: Force Show BC7 - Create a checkbox.
  $global:OptionsForceBC7CheckBox = New-Object Windows.Forms.CheckBox
  $OptionsForceBC7CheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsForceBC7CheckBox.Location = DPISize (New-Object Drawing.Point(12, 70))
  $OptionsForceBC7CheckBox.Name = 'ForceShowBC7Format'
  $OptionsForceBC7CheckBox.Text = ' Force show BC7 on DDS Format list without TexConv'
  $OptionsForceBC7CheckBox.Checked = $ForceShowBC7Format
  $OptionsForceBC7CheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; RefreshDDSLists -FormatOnly })
  $OptionsDebugGroup.Controls.Add($OptionsForceBC7CheckBox)

  # Debug: Force Show BC7 - Create a tooltip.
  $OptionsForceBC7Tip = New-Object Windows.Forms.ToolTip
  $OptionsForceBC7Tip.InitialDelay = $ToolTipDelay
  $OptionsForceBC7Tip.AutoPopDelay = $ToolTipDuration
  $OptionsForceBC7TipString = 'It is highly suggested to link TexConv to this script{0}'
  $OptionsForceBC7TipString += 'under "Tool Paths" instead of using this option!{0}'
  $OptionsForceBC7TipString += '{0}'
  $OptionsForceBC7TipString += 'Allows BC7 to be added to to the DDS Format list{0}'
  $OptionsForceBC7TipString += 'even if TexConv was not linked to the script. Do{0}'
  $OptionsForceBC7TipString += 'be warned that this may cause missing textures or{0}'
  $OptionsForceBC7TipString += 'mipmaps when creating BC7 with Compressonator.'
  $OptionsForceBC7TipString = [String]::Format($OptionsForceBC7TipString, [Environment]::NewLine)
  $OptionsForceBC7Tip.SetToolTip($OptionsForceBC7CheckBox, $OptionsForceBC7TipString)

  # Debug: DDS Headers - Create a checkbox.
  $global:OptionsDDSHeaderCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsDDSHeaderCheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $OptionsDDSHeaderCheckBox.Location = DPISize (New-Object Drawing.Point(12, 94))
  $OptionsDDSHeaderCheckBox.Name = 'UseStockDDSHeaders'
  $OptionsDDSHeaderCheckBox.Text = ' Disable CTT-PS from writing custom DDS headers'
  $OptionsDDSHeaderCheckBox.Checked = $UseStockDDSHeaders
  $OptionsDDSHeaderCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsDebugGroup.Controls.Add($OptionsDDSHeaderCheckBox)

  # Debug: DDS Headers - Create a tooltip.
  $OptionsDDSHeaderTip = New-Object Windows.Forms.ToolTip
  $OptionsDDSHeaderTip.InitialDelay = $ToolTipDelay
  $OptionsDDSHeaderTip.AutoPopDelay = $ToolTipDuration
  $OptionsDDSHeaderTipString = 'Disables this script from writing DDS headers{0}'
  $OptionsDDSHeaderTipString += 'and instead keeps the headers created by the{0}'
  $OptionsDDSHeaderTipString += 'individual programs. BC7 textures will end up{0}'
  $OptionsDDSHeaderTipString += 'with bad headers if using Compressonator.{0}'
  $OptionsDDSHeaderTipString += '{0}'
  $OptionsDDSHeaderTipString += 'It is not suggested to ever use this option.{0}'
  $OptionsDDSHeaderTipString += 'DDS Headers created by this script adhere to{0}'
  $OptionsDDSHeaderTipString += "Microsoft's standard. TexConv does create{0}"
  $OptionsDDSHeaderTipString += "proper headers, but other programs do not."
  $OptionsDDSHeaderTipString = [String]::Format($OptionsDDSHeaderTipString, [Environment]::NewLine)
  $OptionsDDSHeaderTip.SetToolTip($OptionsDDSHeaderCheckBox, $OptionsDDSHeaderTipString)

  # Debug: Dump CTT-PS Icons - Create a checkbox.
  $global:OptionsDumpIconsCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsDumpIconsCheckBox.Size = DPISize (New-Object Drawing.Size(320, 16))
  $OptionsDumpIconsCheckBox.Location = DPISize (New-Object Drawing.Point(12, 118))
  $OptionsDumpIconsCheckBox.Name = 'DumpCTTPSIconAsPNG'
  $OptionsDumpIconsCheckBox.Text = ' Dump CTT-PS icons on Desktop when launched'
  $OptionsDumpIconsCheckBox.Checked = $DumpCTTPSIconAsPNG
  $OptionsDumpIconsCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsDebugGroup.Controls.Add($OptionsDumpIconsCheckBox)

  # Debug: Dump CTT-PS Icons - Create a tooltip.
  $OptionsDumpIconsTip = New-Object Windows.Forms.ToolTip
  $OptionsDumpIconsTip.InitialDelay = $ToolTipDelay
  $OptionsDumpIconsTip.AutoPopDelay = $ToolTipDuration
  $OptionsDumpIconsTipString = 'Dumps all icons used by CTT-PS when{0}'
  $OptionsDumpIconsTipString += 'the script is started. I use this option to{0}'
  $OptionsDumpIconsTipString += 'dump the images that I want to edit.'
  $OptionsDumpIconsTipString = [String]::Format($OptionsDumpIconsTipString, [Environment]::NewLine)
  $OptionsDumpIconsTip.SetToolTip($OptionsDumpIconsCheckBox, $OptionsDumpIconsTipString)

  # Debug: Show [!] Button Near Exit - Create a checkbox.
  $global:OptionsNoSaveCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsNoSaveCheckBox.Size = DPISize (New-Object Drawing.Size(340, 16))
  $OptionsNoSaveCheckBox.Location = DPISize (New-Object Drawing.Point(12, 142))
  $OptionsNoSaveCheckBox.Name = 'CloseNoSaveButtons'
  $OptionsNoSaveCheckBox.Text = ' Show a [!] button near "Exit" that closes without saving'
  $OptionsNoSaveCheckBox.Checked = $CloseNoSaveButtons
  $OptionsNoSaveCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleNoSaveButtons -ToggleCheck $this.Checked })
  $OptionsDebugGroup.Controls.Add($OptionsNoSaveCheckBox)

  # Debug: Show [!] Button Near Exit - Create a tooltip.
  $OptionsNoSaveTip = New-Object Windows.Forms.ToolTip
  $OptionsNoSaveTip.InitialDelay = $ToolTipDelay
  $OptionsNoSaveTip.AutoPopDelay = $ToolTipDuration
  $OptionsNoSaveTipString =  'Displays a small [!] button that skips{0}'
  $OptionsNoSaveTipString += 'saving all options when the script is{0}'
  $OptionsNoSaveTipString += 'closed. This button only exists for{0}'
  $OptionsNoSaveTipString += 'development and debugging.'
  $OptionsNoSaveTipString = [String]::Format($OptionsNoSaveTipString, [Environment]::NewLine)
  $OptionsNoSaveTip.SetToolTip($OptionsNoSaveCheckBox, $OptionsNoSaveTipString)

  # Debug: Disable High DPI Scaling - Create a checkbox.
  $global:OptionsDPIScaleCheckBox = New-Object Windows.Forms.CheckBox
  $OptionsDPIScaleCheckBox.Size = DPISize (New-Object Drawing.Size(340, 16))
  $OptionsDPIScaleCheckBox.Location = DPISize (New-Object Drawing.Point(12, 166))
  $OptionsDPIScaleCheckBox.Name = 'DisableHighDPIMode'
  $OptionsDPIScaleCheckBox.Text = ' Disable High DPI Scaling (Requires Restart)'
  $OptionsDPIScaleCheckBox.Checked = $DisableHighDPIMode
  $OptionsDPIScaleCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; StoreSingleGlobalVariable -VarName 'DisableHighDPIMode' })
  $OptionsDebugGroup.Controls.Add($OptionsDPIScaleCheckBox)

  # Debug: Disable High DPI Scaling - Create a tooltip.
  $OptionsDPIScaleTip = New-Object Windows.Forms.ToolTip
  $OptionsDPIScaleTip.InitialDelay = $ToolTipDelay
  $OptionsDPIScaleTip.AutoPopDelay = $ToolTipDuration
  $OptionsDPIScaleTipString = 'Disables High DPI and allows Windows{0}'
  $OptionsDPIScaleTipString += 'to auto-scale the GUI. This option will{0}'
  $OptionsDPIScaleTipString += 'will take effect on the next script run.'
  $OptionsDPIScaleTipString = [String]::Format($OptionsDPIScaleTipString, [Environment]::NewLine)
  $OptionsDPIScaleTip.SetToolTip($OptionsDPIScaleCheckBox, $OptionsDPIScaleTipString)

  # Debug: Split Combine Limits - Create a number selector.
  $global:OptionsSplitCombLimitNumBox = New-Object Windows.Forms.NumericUpDown
  $OptionsSplitCombLimitNumBox.Size = DPISize (New-Object Drawing.Size(48, 10))
  $OptionsSplitCombLimitNumBox.Location = DPISize (New-Object Drawing.Point(12, 190))
  $OptionsSplitCombLimitNumBox.Name = 'SplitCombineLimits'
  $OptionsSplitCombLimitNumBox.DecimalPlaces = 0
  $OptionsSplitCombLimitNumBox.Minimum = 120
  $OptionsSplitCombLimitNumBox.Maximum = 1000
  $OptionsSplitCombLimitNumBox.Value = $SplitCombineLimits
  $OptionsSplitCombLimitNumBox.Increment = 1
  $OptionsSplitCombLimitNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; SetCombineSplitLimit })
  $OptionsDebugGroup.Controls.Add($OptionsSplitCombLimitNumBox)

  # Debug: Split Combine Limits - Create a number label.
  $global:OptionsSplitCombLimitLabel = New-Object Windows.Forms.Label
  $OptionsSplitCombLimitLabel.Size = DPISize (New-Object Drawing.Size(300, 18))
  $OptionsSplitCombLimitLabel.Location = DPISize (New-Object Drawing.Point(65, 193))
  $OptionsSplitCombLimitLabel.Text = 'Split/Combine Textures Grid Array/Garbage Pixel Limit'
  $OptionsDebugGroup.Controls.Add($OptionsSplitCombLimitLabel)

  # Debug: Split Combine Limits - Create a tooltip.
  $OptionsSplitCombLimitTip = New-Object Windows.Forms.ToolTip
  $OptionsSplitCombLimitTip.InitialDelay = $ToolTipDelay
  $OptionsSplitCombLimitTip.AutoPopDelay = $ToolTipDuration
  $OptionsSplitCombLimitTipString = 'This option allows increasing the maximum{0}'
  $OptionsSplitCombLimitTipString += 'values for the "Grid Array" used in Combine{0}'
  $OptionsSplitCombLimitTipString += 'Multiple Textures and the Split Combined{0}'
  $OptionsSplitCombLimitTipString += 'Multi-Texture operations. It also increases{0}'
  $OptionsSplitCombLimitTipString += 'the limit imposed on garbage pixel removal{0}'
  $OptionsSplitCombLimitTipString += 'found in the Zelda:OoT Methods window.{0}'
  $OptionsSplitCombLimitTipString += '{0}'
  $OptionsSplitCombLimitTipString += 'The reason this limit is here to begin with{0}'
  $OptionsSplitCombLimitTipString += 'is that too many nodes will cause the GUI{0}'
  $OptionsSplitCombLimitTipString += 'to hang for long periods of time, and may{0}'
  $OptionsSplitCombLimitTipString += 'even crash. Use this option with caution!'
  $OptionsSplitCombLimitTipString = [String]::Format($OptionsSplitCombLimitTipString, [Environment]::NewLine)
  $OptionsSplitCombLimitTip.SetToolTip($OptionsSplitCombLimitLabel, $OptionsSplitCombLimitTipString)

  # Debug: Create a button to open the custom code dialog.
  $global:OptionsHotCodeButton = New-Object Windows.Forms.Button
  $OptionsHotCodeButton.Size = DPISize (New-Object Drawing.Size(120, 28))
  $OptionsHotCodeButton.Location = DPISize (New-Object Drawing.Point(11, 362))
  $OptionsHotCodeButton.Text = "Run Custom Code"
  $OptionsHotCodeButton.Add_Click({ ShowHotCodeDialog })
  $OptionsDebugGroup.Controls.Add($OptionsHotCodeButton)

  # About: Section A - Create a groupbox to hold information.
  $global:OptionsAboutGroup = New-Object Windows.Forms.GroupBox
  $OptionsAboutGroup.Size = DPISize (New-Object Drawing.Size(404, 113)) -Round
  $OptionsAboutGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $OptionsTabAbout.Controls.Add($OptionsAboutGroup)

  # About: Section A - Create a label with the script name.
  $global:OptionsAboutLabelHeader = New-Object Windows.Forms.Label
  $OptionsAboutLabelHeader.Size = DPISize (New-Object Drawing.Size(260, 20))
  $OptionsAboutLabelHeader.Location = DPISize (New-Object Drawing.Point(70, 14))
  $OptionsAboutLabelHeader.Font = New-Object Drawing.Font('Microsoft Sans Serif', 13, [Drawing.FontStyle]::Bold)
  $OptionsAboutLabelHeader.Text = $ScriptName.Replace("'","")
  $OptionsAboutGroup.Controls.Add($OptionsAboutLabelHeader)

  # About: Section A - Create a label with my name.
  $global:OptionsAboutLabelBighead = New-Object Windows.Forms.Label
  $OptionsAboutLabelBighead.Size = DPISize (New-Object Drawing.Size(180, 16))
  $OptionsAboutLabelBighead.Location = DPISize (New-Object Drawing.Point(130, 42))
  $OptionsAboutLabelBighead.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9.5)
  $OptionsAboutLabelBighead.Text = 'Created By: Bighead'
  $OptionsAboutGroup.Controls.Add($OptionsAboutLabelBighead)

  # About: Section A - Create a label for the website.
  $global:OptionsAboutLabelWebsiteA = New-Object Windows.Forms.Label
  $OptionsAboutLabelWebsiteA.Size = DPISize (New-Object Drawing.Size(72, 20))
  $OptionsAboutLabelWebsiteA.Location = DPISize (New-Object Drawing.Point(28, 66))
  $OptionsAboutLabelWebsiteA.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsAboutLabelWebsiteA.Text = 'My Website:'
  $OptionsAboutGroup.Controls.Add($OptionsAboutLabelWebsiteA)

  # About: Section A - Create a label for the website.
  $global:OptionsAboutLabelWebsiteB = New-Object Windows.Forms.LinkLabel
  $OptionsAboutLabelWebsiteB.Size = DPISize (New-Object Drawing.Size(200, 20))
  $OptionsAboutLabelWebsiteB.Location = DPISize (New-Object Drawing.Point(100, 66))
  $OptionsAboutLabelWebsiteB.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsAboutLabelWebsiteB.Text = $Link_Bighead
  $OptionsAboutLabelWebsiteB.ForeColor = [Drawing.Color]::Blue
  $OptionsAboutLabelWebsiteB.Add_LinkClicked({ Start-Process -FilePath $Link_Bighead })
  $OptionsAboutGroup.Controls.Add($OptionsAboutLabelWebsiteB) 

  # About: Section A - Create a label for the forum link.
  $global:OptionsAboutLabelForumA = New-Object Windows.Forms.Label
  $OptionsAboutLabelForumA.Size = DPISize (New-Object Drawing.Size(72, 20))
  $OptionsAboutLabelForumA.Location = DPISize (New-Object Drawing.Point(28, 86))
  $OptionsAboutLabelForumA.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsAboutLabelForumA.Text = 'Forum Post:'
  $OptionsAboutGroup.Controls.Add($OptionsAboutLabelForumA)

  # About: Section A - Create a label for the forum link.
  $global:OptionsAboutLabelForumB = New-Object Windows.Forms.LinkLabel
  $OptionsAboutLabelForumB.Size = DPISize (New-Object Drawing.Size(280, 20))
  $OptionsAboutLabelForumB.Location = DPISize (New-Object Drawing.Point(100, 86))
  $OptionsAboutLabelForumB.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsAboutLabelForumB.Text = 'https://forums.dolphin-emu.org/thread-custom...'
  $OptionsAboutLabelForumB.ForeColor = [Drawing.Color]::Blue
  $OptionsAboutLabelForumB.Add_LinkClicked({ Start-Process -FilePath $Link_CTTPS })
  $OptionsAboutGroup.Controls.Add($OptionsAboutLabelForumB) 

  # About: Section B - Create a groupbox to hold information.
  $global:OptionsDonateGroup = New-Object Windows.Forms.GroupBox
  $OptionsDonateGroup.Size = DPISize (New-Object Drawing.Size(404, 133)) -Round
  $OptionsDonateGroup.Location = DPISize (New-Object Drawing.Point(10, 120))
  $OptionsTabAbout.Controls.Add($OptionsDonateGroup)

  # About: Section B - Create a label for the donation section.
  $global:OptionsDonateHeader = New-Object Windows.Forms.Label
  $OptionsDonateHeader.Size = DPISize (New-Object Drawing.Size(200, 26))
  $OptionsDonateHeader.Location = DPISize (New-Object Drawing.Point(122, 14))
  $OptionsDonateHeader.Font = New-Object Drawing.Font('Microsoft Sans Serif', 13, [Drawing.FontStyle]::Bold)
  $OptionsDonateHeader.Text = 'Donation Support'
  $OptionsDonateGroup.Controls.Add($OptionsDonateHeader)

  # About: Section B - Create a label with more information.
  $global:OptionsDonateMessage = New-Object Windows.Forms.Label
  $OptionsDonateMessage.Size = DPISize (New-Object Drawing.Size(350, 50))
  $OptionsDonateMessage.Location = DPISize (New-Object Drawing.Point(22, 38))
  $OptionsDonateMessage.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsDonateMessage.Text = 'If you find this tool useful, or enjoy my texture packs, do kindly consider donating! Donations will never be required, and my projects will always remain free for everyone forever.'
  $OptionsDonateMessage.TextAlign = [System.Drawing.ContentAlignment]::MiddleCenter 
  $OptionsDonateGroup.Controls.Add($OptionsDonateMessage)

  # About: Create a button to open the donation page.
  $global:OptionsDonateButton = New-Object Windows.Forms.Button
  $OptionsDonateButton.Size = DPISize (New-Object Drawing.Size(200, 30))
  $OptionsDonateButton.Location = DPISize (New-Object Drawing.Point(98, 91))
  $OptionsDonateButton.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsDonateButton.Text = "Bighead's Donate Page"
  $OptionsDonateButton.Add_Click({ Start-Process -FilePath $Link_Donate })
  $OptionsDonateGroup.Controls.Add($OptionsDonateButton)

  # About: Section C - Create a groupbox to hold information.
  $global:OptionsCreditsGroup = New-Object Windows.Forms.GroupBox
  $OptionsCreditsGroup.Size = DPISize (New-Object Drawing.Size(404, 194)) -Round
  $OptionsCreditsGroup.Location = DPISize (New-Object Drawing.Point(10, 255))
  $OptionsTabAbout.Controls.Add($OptionsCreditsGroup)

  # About: Section C - Create a label for the credits.
  $global:OptionsCreditsHeader = New-Object Windows.Forms.Label
  $OptionsCreditsHeader.Size = DPISize (New-Object Drawing.Size(150, 26))
  $OptionsCreditsHeader.Location = DPISize (New-Object Drawing.Point(130, 14))
  $OptionsCreditsHeader.Font = New-Object Drawing.Font('Microsoft Sans Serif', 13, [Drawing.FontStyle]::Bold)
  $OptionsCreditsHeader.Text = 'Special Thanks'
  $OptionsCreditsGroup.Controls.Add($OptionsCreditsHeader)

  # About: Section C - Create a label with more information.
  $global:OptionsCreditsMessage = New-Object Windows.Forms.Label
  $OptionsCreditsMessage.Size = DPISize (New-Object Drawing.Size(350, 30))
  $OptionsCreditsMessage.Location = DPISize (New-Object Drawing.Point(22, 38))
  $OptionsCreditsMessage.Font = New-Object Drawing.Font('Microsoft Sans Serif', 9)
  $OptionsCreditsMessage.Text = 'This script would not have come this far without the testing and ideas of others that helped shape it into what it is today.'
  $OptionsCreditsMessage.TextAlign = [System.Drawing.ContentAlignment]::MiddleCenter
  $OptionsCreditsGroup.Controls.Add($OptionsCreditsMessage)

  # About: Section C - Create a label with more information.
  $global:OptionsCreditsBorder = New-Object Windows.Forms.Panel
  $OptionsCreditsBorder.Size = DPISize (New-Object Drawing.Size(385, 110))
  $OptionsCreditsBorder.Location = DPISize (New-Object Drawing.Point(10, 75))
  $OptionsCreditsBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#bcbcbc')
  $OptionsCreditsGroup.Controls.Add($OptionsCreditsBorder)

  # About: Create the list of credits of everyone who has had some impact on this script.
  $CreditsList =  "Dolphin Devs : They make all of this possible.{0}"
  $CreditsList += "degasus      : Gave me the initial idea for this script.{0}"
  $CreditsList += "frozenwings  : Personally tested dozens of early versions.{0}"
  $CreditsList += "Tino         : Ishiiruka Tool command line support.{0}"
  $CreditsList += "Zenju        : xBRZ ScalerTest command line support.{0}"
  $CreditsList += "uncleiroh    : Initial idea of putting watermarks on textures.{0}"
  $CreditsList += "MeleeHD      : Alerted me of uncleiroh's idea of watermarks.{0}"
  $CreditsList += "StripTheSoul : Inadvertently gave me the idea to support OptiPNG.{0}"
  $CreditsList += "masterotaku  : Gave me the idea to implement upscaling filters.{0}"
  $CreditsList += "TheCrach     : Inital idea for progress indication.{0}"
  $CreditsList += "CyberGlitch  : Responsible for the idea of the Seamless Method.{0}"
  $CreditsList += "Admentus     : Tested several versions with many helpful bug reports.{0}"
  $CreditsList += "DarthVitrial : Always reminded me to get ImageMagick v7 to work.{0}"
  $CreditsList += "BennyAlex98  : Idea saving input/output paths. Waifu2x model select.{0}"
  $CreditsList += "CTCaer       : Persuaded me to add an option to force BC3 for DDS.{0}"
  $CreditsList += "Hypatia      : Wind Waker made me realize I needed more options.{0}"
  $CreditsList += "Matrix2525   : Helped test and point out many issues in v40.0 betas.{0}"
  $CreditsList += "Spycrab      : Spotted typo that prevented resource pack compression.{0}"
  $CreditsList += 'Vlad1vostok  : Kickstarted the idea to add the "Exclusions" tab.{0}'
  $CreditsList += "iwubcode     : Helped debug and made me aware of updated Waifu2x-CPP.{0}"
  $CreditsList += "stealthii    : Alerted me/fixed a bug with Material Map Generator.{0}"
  $CreditsList += "Kupo         : Idea to shutdown the PC after an operation completes.{0}"
  $CreditsList += "Venomalia    : Created the Dolphin TextureExtractor Tool.{0}"
  $CreditsList += "GhostlyDark  : Ideas and testing for texture database features.{0}"
  $CreditsList += "{0}"
  $CreditsList += "And to everyone else in the Dolphin community, the feedback and testing is much appreciated and helps motivate me to continue to improve it!"

  # About: Section C - Create a text box to display the list of names.
  $global:OptionsCreditsNameList = New-Object Windows.Forms.RichTextBox
  $OptionsCreditsNameList.Font = New-Object Drawing.Font("Consolas", 6.5)
  $OptionsCreditsNameList.Size = New-Object Drawing.Size(($OptionsCreditsBorder.Size.Width - 2), ($OptionsCreditsBorder.Size.Height - 2))
  $OptionsCreditsNameList.Location = New-Object Drawing.Point(1, 1)
  $OptionsCreditsNameList.Text = [String]::Format($CreditsList, [Environment]::NewLine)
  $OptionsCreditsNameList.ReadOnly = $true
  $OptionsCreditsNameList.BorderStyle = [Windows.Forms.BorderStyle]::None
  $OptionsCreditsNameList.BackColor = [Drawing.ColorTranslator]::FromHtml('#ffffff')
  $OptionsCreditsBorder.Controls.Add($OptionsCreditsNameList)

  # Buttons: Restore Defaults - Create a button.
  $global:OptionsDefaultButton = New-Object Windows.Forms.Button
  $OptionsDefaultButton.Size = DPISize (New-Object Drawing.Size(130, 28))
  $OptionsDefaultButton.Location = DPISize (New-Object Drawing.Point(8, 492))
  $OptionsDefaultButton.Text = 'Restore Defaults'
  $OptionsDefaultButton.Add_Click({RestoreDefaultOptions})
  $OptionsDialog.Controls.Add($OptionsDefaultButton)

  # Buttons: Restore Defaults - Create a tooltip for the button.
  $OptionsDefaultTip = New-Object Windows.Forms.ToolTip
  $OptionsDefaultTip.InitialDelay = $ToolTipDelay
  $OptionsDefaultTip.AutoPopDelay = $ToolTipDuration
  $OptionsDefaultTipString = 'Resets all options to their default values.'
  $OptionsDefaultTip.SetToolTip($OptionsDefaultButton, $OptionsDefaultTipString)
 
  # Buttons: Import Stored Options - Create a button.
  $global:OptionsImportButton = New-Object Windows.Forms.Button
  $OptionsImportButton.Size = DPISize (New-Object Drawing.Size(130, 28))
  $OptionsImportButton.Location = DPISize (New-Object Drawing.Point(147, 492))
  $OptionsImportButton.Text = 'Import Stored Options'
  $OptionsImportButton.Add_Click({ ImportAllGlobalVariables_Button })
  $OptionsImportButton.AllowDrop = $true
  $OptionsImportButton.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $OptionsImportButton.Add_DragDrop({ ImportAllGlobalVariables_DragAndDrop })
  $OptionsDialog.Controls.Add($OptionsImportButton)

  # Buttons: Import Stored Options - Create a tooltip.
  $OptionsImportTip = New-Object Windows.Forms.ToolTip
  $OptionsImportTip.InitialDelay = $ToolTipDelay
  $OptionsImportTip.AutoPopDelay = $ToolTipDuration
  $OptionsImportTipString = 'Allows importing all Stored Options from another version of Custom Texture{0}'
  $OptionsImportTipString += 'Tool PS by simply selecting the script file. It should work on any version of{0}'
  $OptionsImportTipString += 'the PowerShell versions of the script. This feature exists to retain settings{0}'
  $OptionsImportTipString += 'in future versions of this script, and not have to set them every single time.{0}'
  $OptionsImportTipString += 'It is possible to drag and drop an older version of CTT-PS onto the button.'
  $OptionsImportTipString = [String]::Format($OptionsImportTipString, [Environment]::NewLine)
  $OptionsImportTip.SetToolTip($OptionsImportButton, $OptionsImportTipString)

  # Buttons: Close Dialog - Create a button.
  $global:OptionsCloseButton = New-Object Windows.Forms.Button
  $OptionsCloseButton.Size = DPISize (New-Object Drawing.Size(130, 28))
  $OptionsCloseButton.Location = DPISize (New-Object Drawing.Point(286, 492))
  $OptionsCloseButton.Text = 'Close'
  $OptionsCloseButton.Add_Click({ $OptionsDialog.Close() })
  $OptionsDialog.Controls.Add($OptionsCloseButton)

  # Buttons: Close Dialog - Create a tooltip.
  $OptionsCloseButtonTip = New-Object Windows.Forms.ToolTip
  $OptionsCloseButtonTip.InitialDelay = $ToolTipDelay
  $OptionsCloseButtonTip.AutoPopDelay = $ToolTipDuration
  $OptionsCloseButtonTipString = 'Returns to the main window.'
  $OptionsCloseButtonTip.SetToolTip($OptionsCloseButton, $OptionsCloseButtonTipString)
}
#==============================================================================================================================================================================================
#  CTT GUI: SUPERSCALERS AUTO-INSTALL - PATH WINDOW
#==============================================================================================================================================================================================
#  Shows the menu to backup the old SuperScalers path.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowSuperScalerPathDialog()
{
  # Show the dialog.
  $SuperScalerDialog.ShowDialog() | Out-Null

  # Return the dialog choice so the function can be used as a condition.
  return $SuperScalerPathKeep
}
#==============================================================================================================================================================================================
#  Create the panel for SuperScalers backup.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_SuperScalerPath()
{
  # Create the dialog and set up properties.
  $global:SuperScalerDialog = New-Object Windows.Forms.Form
  $SuperScalerDialog.Size = DPISize (New-Object Drawing.Size(320, 130))
  $SuperScalerDialog.MinimumSize = DPISize (New-Object Drawing.Size(320, 130))
  $SuperScalerDialog.MaximumSize = DPISize (New-Object Drawing.Size(320, 130))
  $SuperScalerDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $SuperScalerDialog.Text = 'ESRGAN/SFTGAN Installer'
  $SuperScalerDialog.MinimizeBox = $false
  $SuperScalerDialog.MaximizeBox = $false
  $SuperScalerDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $SuperScalerDialog.FormBorderStyle = GetFormBorderStyle
  $SuperScalerDialog.StartPosition = "CenterScreen"
  $SuperScalerDialog.Topmost = !$DisableTopMost
  $SuperScalerDialog.KeyPreview = $true
  $SuperScalerDialog.Add_FormClosing({ $SuperScalerDialog.Hide() ; $_.Cancel = $true })
  $SuperScalerDialog.Icon = $Icon_CTTPSGreen

  # Create a panel to hold all the shit.
  $global:SuperScalerPathPanel = New-Object Windows.Forms.Panel
  $SuperScalerPathPanel.Size = DPISize (New-Object Drawing.Size(320, 130))
  $SuperScalerPathPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $SuperScalerDialog.Controls.Add($SuperScalerPathPanel)
 
  # Create a label to describe what's going on.
  $global:SuperScalerPathLabel = New-Object Windows.Forms.Label
  $SuperScalerPathLabel.Size = DPISize (New-Object Drawing.Size(270, 30))
  $SuperScalerPathLabel.Location = DPISize (New-Object Drawing.Point(22, 12))
  $SuperScalerPathLabel.Text = 'SuperScalers path exists! Would you like to backup the folder to "_old", or remove it before reinstalling?'
  $SuperScalerPathPanel.Controls.Add($SuperScalerPathLabel)

  # Create the "Keep" button.
  $global:SuperScalerPathBackup = New-Object Windows.Forms.Button
  $SuperScalerPathBackup.Size = DPISize (New-Object Drawing.Size(80, 28))
  $SuperScalerPathBackup.Location = DPISize (New-Object Drawing.Point(52, 50))
  $SuperScalerPathBackup.Text = 'Backup'
  $SuperScalerPathBackup.Add_Click({ $global:SuperScalerPathKeep = $true ; $SuperScalerDialog.Hide() })
  $SuperScalerPathPanel.Controls.Add($SuperScalerPathBackup)

  # Create the "Remove" button.
  $global:SuperScalerPathRemove = New-Object Windows.Forms.Button
  $SuperScalerPathRemove.Size = DPISize (New-Object Drawing.Size(80, 28))
  $SuperScalerPathRemove.Location = DPISize (New-Object Drawing.Point(170, 50))
  $SuperScalerPathRemove.Text = 'Remove'
  $SuperScalerPathRemove.Add_Click({ $global:SuperScalerPathKeep = $false ; $SuperScalerDialog.Hide() })
  $SuperScalerPathPanel.Controls.Add($SuperScalerPathRemove)
}
#==============================================================================================================================================================================================
#  CTT GUI: SUPERSCALERS AUTO-INSTALL DIALOG 
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $SSAutoDialog              - Form           - Global
#  $SSAutoMainPanel           - Panel          - Global
#  $SSAutoStepLabel           - Label          - Global
#  $SSAutoInfoLabel           - Label          - Global
#  $SSAutoDownloadLabel       - Label          - Global
#  $SSAutoProgressLabel       - Label          - Global
#  $SSAutoProgressBar         - ProgressBar    - Global
#  $SSStartButton             - Button         - Global
#  $SSSkipButton              - Button         - Global
#==============================================================================================================================================================================================
#  A loop that is performed while a file is downloading.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_DownloadLoop([bool]$SkipLabels=$false)
{
  # Loop until the download is complete.
  while (!$DownloadComplete)
  {
    # If the file size could be retrieved then show progress.
    if ($FileSize -gt 0)
    {
      # Calculate the value for megabytes recieved.
      $MBRecieved = B2MB -Bytes $BytesReceived
      $MBRPercent = (FormatDecimal -Value (100 - (($FileSize - $MBRecieved) / $FileSize * 100)).ToString()).Split('.', 2)

      # Update the labels on the GUI.
      if (!$SkipLabels)
      {
        # Update the label to show the current progress.
        $SSAutoProgressLabel.Text = $MBRecieved.ToString() + 'MB / ' + $FileSize + 'MB ' + $MBRPercent[0] + '%'

        # Update the progress bar.
        $SSAutoProgressBar.Value = [int]$MBRPercent[0]
      }
    }
    # If the file size is null.
    elseif (!$SkipLabels)
    {
      # Show a generic message on the dialog.
      $SSAutoProgressLabel.Text = 'Downloading file...'
    }
    # Wait a bit before the next iteration.
    Start-Sleep -m $DialogUpdateRate

    # Update the dialog with the new information.
    [Windows.Forms.Application]::DoEvents()
  }
  # If the file size could be retrieved.
  if ($FileSize -gt 0)
  {
    # Calculate the value for megabytes recieved.
    $MBRecieved = B2MB -Bytes $BytesReceived
    $MBRPercent = (FormatDecimal -Value (100 - (($FileSize - $MBRecieved) / $FileSize * 100)).ToString()).Split('.', 2)

    # Update the labels on the GUI.
    if (!$SkipLabels)
    {
      # Update the label to show the current progress.
      $SSAutoProgressLabel.Text = $MBRecieved.ToString() + 'MB / ' + $FileSize + 'MB ' + $MBRPercent[0] + '%'

      # Update the progress bar.
      $SSAutoProgressBar.Value = [int]$MBRPercent[0]
    }
  }
  # If the file size is null.
  elseif (!$SkipLabels)
  {
    # Show a generic message on the dialog.
    $SSAutoProgressLabel.Text = 'Download Complete'
  }
  # Update the dialog one last time.
  [Windows.Forms.Application]::DoEvents()
}
#==============================================================================================================================================================================================
#  Downloads a file from the internet to a specific name and location.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_DownloadFile([string]$Link, [string]$FilePath, [bool]$SkipLabels=$false)
{
  # Track when the file is completed downloading.
  $global:FileSize = 0
  $global:BytesReceived = 0
  $global:DownloadComplete = $false

  # Create a webclient object which downloads the file.
  $WebClient  = New-Object System.Net.WebClient
  $WebLinkUri = New-Object System.Uri($Link)

  # Attempt to get the size of the file.
  $FindFileSize = (Invoke-WebRequest -Uri $WebLinkUri -Method Head).Headers.'Content-Length'

  # Show the progress labels for downloading.
  if (!$SkipLabels) { $SSAutoDownloadLabel.Visible = $true }
  $SSAutoProgressLabel.Visible = $true

  # Invoking a web request for file size may fail. If it does, do not store the file size.
  if ($FindFileSize)
  {
    # Calculate the value in megabytes.
    $global:FileSize = B2MB -Bytes $FindFileSize
  }
  # Download the file.
  $WebClient.Add_DownloadProgressChanged([System.Net.DownloadProgressChangedEventHandler]{ if ($FileSize -gt 0) { $global:BytesReceived = $_.BytesReceived } })
  $WebClient.Add_DownloadFileCompleted([System.ComponentModel.AsyncCompletedEventHandler]{ $global:DownloadComplete = $true }) 
  $WebClient.DownloadFileAsync($WebLinkUri, $FilePath)

  # Trap it in a loop.
  SSAutoSetup_DownloadLoop -SkipLabels $SkipLabels

  # Dispose of the client or there will be problems.
  $WebClient.Dispose()
}
#==============================================================================================================================================================================================
#  Auto-Setup Step 01: Download Python.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step01_Setup()
{
  # Set up the information for the step.
  $SSAutoStepLabel.Text = 'Step 1 / 5: Install Python v3.9.9'
  $SSAutoInfoLabel.Text = 'Python is required to run ESRGAN and SFTGAN. While there may be versions newer than 3.9.9, '
  $SSAutoInfoLabel.Text += 'this version is sufficient to run the current iterations of the super scaler filters.'
  $SSAutoProgressBar.Value = 0
  $SSAutoProgressBar.Visible = $true
  $SSPathTextBox.Visible = $false
  $SSPathButton.Visible = $false
  $SSAutoStepLabel.Location = DPISize (New-Object Drawing.Point(118, 14))
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step01_Start()
{
  # Prevent the dialog from being closed.
  $global:AutoInstallRunning = $true

  # Set up the web address and the path.
  $FileTemp = CreatePath -LiteralPath ($TempFolder)
  $WebLink  = $Link_Python
  $FilePath = $TempFolder + '\python.exe'

  # Download the file.
  SSAutoSetup_DownloadFile -Link $WebLink -FilePath $FilePath

  # Run the installer
  Start-Process -FilePath $FilePath -Wait
  
  # Allow the dialog to be closed.
  $global:AutoInstallRunning = $false
}
#==============================================================================================================================================================================================
#  Auto-Setup Step 02: Download CUDA.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step02_Setup()
{
  # Set up the information for the step.
  $SSAutoStepLabel.Text = 'Step 2 / 5: Install Nvidia CUDA v11.3'
  $SSAutoInfoLabel.Text = 'While CUDA is not required for ESRGAN, using the CPU is extremely slow. AMD users will '
  $SSAutoInfoLabel.Text += 'have to skip this step, and not get to take advantage of the speed that CUDA provides.'
  $SSAutoProgressBar.Value = 0
  $SSAutoProgressBar.Visible = $true
  $SSPathTextBox.Visible = $false
  $SSPathButton.Visible = $false
  $SSAutoStepLabel.Location = DPISize (New-Object Drawing.Point(100, 14))
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step02_Start()
{
  # Prevent the dialog from being closed.
  $global:AutoInstallRunning = $true

  # Set up the web address and the path.
  $FileTemp = CreatePath -LiteralPath ($TempFolder)
  $WebLink  = $Link_CUDA
  $FilePath = ($TempFolder + '\cuda.exe')

  # Download the file.
  SSAutoSetup_DownloadFile -Link $WebLink -FilePath $FilePath

  # Run the installer
  Start-Process -FilePath $FilePath -Wait

  # Allow the dialog to be closed.
  $global:AutoInstallRunning = $false
}
#==============================================================================================================================================================================================
#  Auto-Setup Step 03: Update Python and Install Dependencies.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step03_Setup()
{
  # Set up the information for the step.
  $SSAutoStepLabel.Text = 'Step 3 / 5: Update Python'
  $SSAutoInfoLabel.Text = 'A few updates/packages need to be installed for Python. This must be done after '
  $SSAutoInfoLabel.Text += 'CUDA has already been installed, as one of the the update packages requires CUDA.'
  $SSAutoProgressBar.Value = 0
  $SSAutoProgressBar.Visible = $true
  $SSPathTextBox.Visible = $false
  $SSPathButton.Visible = $false
  $SSAutoStepLabel.Location = DPISize (New-Object Drawing.Point(126, 14))
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step03_Start()
{
  # Prevent the dialog from being closed.
  $global:AutoInstallRunning = $true

  # When the installer is done, grab the install path.
  GetPythonInstallPath

  # If the search failed, prompt the user to manually select the path.
  if ($Python -eq $null)
  {
    # Tell the user I failed and that they need to pick up my slack.
    $Title   = 'Python Path Required'
    $Message = 'Python could not be automatically located. Please manually select "python.exe" to proceed.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 12) -OffsetY (DPISize 12) -Message $Message

    # Display an "Open Folder" menu to get the path.
    $SelectedPath = Get-FileName -StartPath (Get-WmiObject Win32_OperatingSystem).SystemDrive -FileName @('python.exe') -Description  @('Python Executable')

    # Check to see if a folder was selected from the Open menu and test if that path exists.
    if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
    {
      # Add the selected tool to the script.
      LoadExternalFile -TextBox $OptionsPythonTextBox -ToolPathName 'Python' -ToolPath $SelectedPath
    }
  }
  # If the search failed, prompt the user to manually select the path.
  if ($Python -ne $null)
  {
    # Show the console and force it forward.
    ShowPowerShellConsole -ShowConsole $true
    Set-ForegroundWindow -Process 'powershell'

    # Clear out any text on the console.
    Clear-Host

    # Attempt to update the package installer.
    Write-Host 'Get Python Install Path...'
    Write-Host $Python
    Write-Host ''
    Write-Host 'Updating Python package installer...'
    Write-Host ''
    PythonUpdatePip
    Write-Host ''

    # Download and install PyTorch.
    Write-Host 'Downloading and installing PyTorch...'
    Write-Host 'This could take several minutes to an hour. Please be patient!'
    Write-Host ''
    PythonInstallTorch
    Write-Host ''

    # Install OpenCV for python using pip.
    Write-Host 'Downloading and installing OpenCV...'
    Write-Host ''
    PythonInstallModules -Modules @('numpy','opencv-python')
    Write-Host ''
    Write-Host 'Finished!'
    Write-Host ''

    # Show the console for just one more second if its being hidden.
    if (!$EnableThePSConsole) { Start-Sleep -m 1000 }

    # Hide the console unless the user enabled it.
    ShowPowerShellConsole -ShowConsole $EnableThePSConsole
  }
  # Tell the user it's not going to work.
  else
  {
    # Tell the user I failed and that they need to pick up my slack.
    $Title   = 'CTT-PS Error'
    $Message = 'No path to Python selected. ESRGAN and SFTGAN will not be usable without the required updates.'
    ShowOKDialog -Title $Title -SizeX (DPISize 300) -SizeY (DPISize 30) -OffsetX (DPISize 12) -OffsetY (DPISize 12) -Message $Message
  }
  # Allow the dialog to be closed.
  $global:AutoInstallRunning = $false
}
#==============================================================================================================================================================================================
#  Auto-Setup Step 04: Install ESRGAN and SFTGAN.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step04_Setup()
{
  # Set up the information for the step.
  $SSAutoStepLabel.Text = 'Step 4 / 5: Install ESRGAN and SFTGAN'
  $SSAutoInfoLabel.Text = 'This will download and install the two upscaling filters ESRGAN and SFTGAN to a specified directory. These are downloaded from GitHub, so there is no download ' +
                          'progress. Total size is about 500 MB because 8 models are included.'
  $SSAutoProgressBar.Visible = $false
  $SSPathTextBox.Enabled = $true
  $SSPathButton.Enabled = $true
  $SSPathTextBox.Visible = $true
  $SSPathButton.Visible = $true
  $SSAutoStepLabel.Location = DPISize (New-Object Drawing.Point(93, 14))
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step04_ESRGAN([string]$ZipPath)
{
  # Show the user that ESRGAN is being downloaded.
  $SSAutoProgressLabel.Text = 'Downloading ESRGAN...'

  # Download the zip file from GitHub.
  $WebLink = $Link_ESRGAND
  $ZipName = $ZipPath + '\esrgan.zip'
  SSAutoSetup_DownloadFile -Link $WebLink -FilePath $ZipName -SkipLabels $true

  # Extract the zip file and move the contents to the install location.
  $SSAutoProgressLabel.Text = 'Extracting ESRGAN archive...'
  ZipExtractArchive -ZipFilePath $ZipName -OutputPath $ZipPath

  # Remove the "master" from the folder name.
  $OldName = ($ZipPath + '\ESRGAN-master')
  $NewName = ($ZipPath + '\ESRGAN')

  # Rename the file then move it to the SuperScalers folder.
  Move-Item -LiteralPath $OldName -Destination $NewName -Force
  Move-Item -LiteralPath $NewName -Destination $SuperScalersPath -Force

  # Since we are using rapka's ESRGAN package, undo some changes to the command line.
  RevertESRGANChanges
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step04_SFTGAN([string]$ZipPath)
{
  # Prevent the dialog from being closed.
  $global:AutoInstallRunning = $true

  # Show the user that ESRGAN is being downloaded.
  $SSAutoProgressLabel.Text = 'Downloading SFTGAN...'

  # Download the zip file from GitHub.
  $WebLink = $Link_SFTGAND
  $ZipName = $ZipPath + '\sftgan.zip'
  SSAutoSetup_DownloadFile -Link $WebLink -FilePath $ZipName -SkipLabels $true

  # Extract the zip file and move the contents to the install location.
  $SSAutoProgressLabel.Text = 'Extracting SFTGAN archive...'
  ZipExtractArchive -ZipFilePath $ZipName -OutputPath $ZipPath

  # Remove the "master" from the folder name.
  $OldName = ($ZipPath + '\SFTGAN-master')
  $NewName = ($ZipPath + '\SFTGAN')

  # Rename the file then move it to the SuperScalers folder.
  Move-Item -LiteralPath $OldName -Destination $NewName -Force
  Move-Item -LiteralPath $NewName -Destination $SuperScalersPath -Force

  # Remove all the test images from ESRGAN and SFTGAN.
  CleanSFTGANFolder
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step04_Start()
{
  # Prevent the dialog from being closed.
  $global:AutoInstallRunning = $true

  # If the path was changed on the textbox, then update the path.
  if ($SuperScalersPath -ne $SuperScalersPathTemp) { $global:SuperScalersPath = $SuperScalersPathTemp }

  # Disable the textbox so the user can't change it during install.
  $SSPathTextBox.Enabled = $false
  $SSPathButton.Enabled  = $false

  # Test to see if the path already exists.
  if (TestPath -LiteralPath $SuperScalersPath)
  {
    # Show the dialog to keep the path.
    if (ShowSuperScalerPathDialog)
    {
      # If keeping the path, rename it to "SuperScalers_old".
      Move-Item -LiteralPath $SuperScalersPath -Destination ($SuperScalersPath + '_old') -Force
    }
    # If the choice was to discard it. 
    else
    {
      # Remove it completely. 
      RemovePath -LiteralPath $SuperScalersPath
    }
  }
  # Now recreate the path so its empty.
  CreatePath -LiteralPath $SuperScalersPath -NoReturn

  # Create the paths to the SuperScaler programs.
  $global:ESRGANBasePath = $SuperScalersPath + '\ESRGAN'
  $global:SFTGANBasePath = $SuperScalersPath + '\SFTGAN'

  # Create a path to where the zip files will be downloaded.
  $ZipPath = CreatePath -LiteralPath ($TempFolder + '\filters')

  # Flags whether or not to install ESRGAN and SFTGAN.
  $InstallESRGAN = $true
  $InstallSFTGAN = $true

  # Only install if ESRGAN isn't already installed.
  if (TestPath -LiteralPath ($ESRGANBasePath + '\test.py'))
  {
    # Ask the user if they also want to extract all textures from the zip file.
    $Title   = 'ESRGAN Detected'
    $Message = 'ESRGAN is already installed in this directory! Do you want to remove it and reinstall a fresh copy?'
    $Choice  = (ShowYesNoDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 18) -OffsetY (DPISize 12) -Message $Message)

    # If it passes, remove the directory. If it fails, do not install ESRGAN.
    if ($Choice) { RemovePath -LiteralPath $ESRGANBasePath } else { $InstallESRGAN = $false }
  }
  # Only install if SFTGAN isn't already installed.
  if (TestPath -LiteralPath ($SFTGANBasePath + '\pytorch_test\test_sftgan.py'))
  {
    # Ask the user if they also want to extract all textures from the zip file.
    $Title   = 'SFTGAN Detected'
    $Message = 'SFTGAN is already installed in this directory! Do you want to remove it and reinstall a fresh copy?'
    $Choice  = (ShowYesNoDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 18) -OffsetY (DPISize 12) -Message $Message)

    # Show a Yes/No dialog to the user. If it passes, remove the directory. If it fails, do not install SFTGAN.
    if ($Choice) { RemovePath -LiteralPath $SFTGANBasePath } else { $InstallSFTGAN = $false }
  }
  # Create the paths if they didn't exist, or the user wanted to overwrite them.
  if ($InstallESRGAN) { SSAutoSetup_Step04_ESRGAN -ZipPath $ZipPath }
  if ($InstallSFTGAN) { SSAutoSetup_Step04_SFTGAN -ZipPath $ZipPath }

  # Allow the dialog to be closed.
  $global:AutoInstallRunning = $false
}
#==============================================================================================================================================================================================
#  Auto-Setup Step 05: SFTGAN models.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step05_Setup()
{
  # Set up the information for the step.
  $SSAutoStepLabel.Text = 'Step 5 / 5: Install SFTGAN Models'
  $SSAutoInfoLabel.Text = 'The models are installed separately from a Google Drive link. Download all of them, and place them in the "pretrained_models" folder that pops up.'
  $SSAutoProgressBar.Visible = $false
  $SSPathTextBox.Visible = $false
  $SSPathButton.Visible = $false
  $SSAutoStepLabel.Location = DPISize (New-Object Drawing.Point(110, 14))
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Step05_Start()
{
  # Open the web page to download the SFTGAN models.
  Start-Process -FilePath $Link_SFTGANM

  # Open the folder to place the models into.
  Start-Process -FilePath ($SFTGANBasePath + '\pretrained_models')
}
#==============================================================================================================================================================================================
#  Auto-Setup Final Step: Finish up installation.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_FinishSetup()
{
  # Now that we are finished, hide the dialog.
  $SSAutoDialog.Hide()

  # Refresh the lists, which will add the filters if they now exist.
  PopulateUpscaleFilterList
  PopulateSuperScalerModels
}
#==============================================================================================================================================================================================
#  Handles the "Start" or "Skip" button being pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_BeginSetup([bool]$Skip = $false)
{
  # Disable the dialog states.
  ToggleDialogStates -State $false

  # Run the setup if the "start" button is pressed, and set up the next option.
  switch ($CurrentStep)
  {
    '1' { if (!$Skip) { SSAutoSetup_Step01_Start } ; SSAutoSetup_Step02_Setup }
    '2' { if (!$Skip) { SSAutoSetup_Step02_Start } ; SSAutoSetup_Step03_Setup }
    '3' { if (!$Skip) { SSAutoSetup_Step03_Start } ; SSAutoSetup_Step04_Setup }
    '4' { if (!$Skip) { SSAutoSetup_Step04_Start } ; SSAutoSetup_Step05_Setup }
    '5' { if (!$Skip) { SSAutoSetup_Step05_Start } ; SSAutoSetup_FinishSetup  }
  }
  # Hide the progress labels for downloading.
  $SSAutoDownloadLabel.Visible = $false
  $SSAutoProgressLabel.Visible = $false

  # Increment the step count.
  $global:CurrentStep += 1

  # Enable the dialog states.
  ToggleDialogStates -State $true
}
#==============================================================================================================================================================================================
#  Shows the auto-setup dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SSAutoSetup_Show()
{
  # Tracks which step we're on.
  $global:CurrentStep = 1

  # Set the default text and show the dialog.
  SSAutoSetup_Step01_Setup
  $SSAutoDialog.ShowDialog()
}
#==============================================================================================================================================================================================
#  CTT GUI: CREATE SUPERSCALERS AUTO-INSTALL DIALOG 
#==============================================================================================================================================================================================
$global:SuperScalersPathTemp = 'C:\SuperScalers'
#==============================================================================================================================================================================================
#  Fixes the super scalers path to have the "SuperScalers" folder.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateSuperScalerTempPath()
{
  # Check to see if the path contains the SuperScalers folder.
  if ($SuperScalersPathTemp -notlike '*\SuperScalers')
  {
    # Add the SuperScalers folder and update variable and the text box.
    $SSPathTextBox.Text = $global:SuperScalersPathTemp = $SuperScalersPathTemp + '\SuperScalers'
  }
}
#==============================================================================================================================================================================================
#  A dialog that allows installing ESRGAN and SFTGAN.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_SSAutoSetup()
{
  # Create the dialog that is displayed.
  $global:SSAutoDialog = New-Object Windows.Forms.Form
  $SSAutoDialog.Size = DPISize (New-Object Drawing.Size(400, 240))
  $SSAutoDialog.MinimumSize = DPISize (New-Object Drawing.Size(400, 240))
  $SSAutoDialog.MaximumSize = DPISize (New-Object Drawing.Size(400, 240))
  $SSAutoDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $SSAutoDialog.Text = 'ESRGAN / SFTGAN Auto-Setup'
  $SSAutoDialog.MinimizeBox = $false
  $SSAutoDialog.MaximizeBox = $false
  $SSAutoDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $SSAutoDialog.FormBorderStyle = GetFormBorderStyle
  $SSAutoDialog.StartPosition = "CenterScreen"
  $SSAutoDialog.Topmost = !$DisableTopMost
  $SSAutoDialog.KeyPreview = $true
  $SSAutoDialog.Add_Shown({ ActivateDialog -Dialog $this })
  $SSAutoDialog.Add_FormClosing({ if (!$AutoInstallRunning) { $SSAutoDialog.Hide() } ; $_.Cancel = $true })
  $SSAutoDialog.Icon = $Icon_CTTPSGreen

  # Create a panel for the main dialog to put all the controls on.
  $global:SSAutoMainPanel = New-Object Windows.Forms.Panel
  $SSAutoMainPanel.Size = DPISize (New-Object Drawing.Size(400, 200))
  $SSAutoMainPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $SSAutoDialog.Controls.Add($SSAutoMainPanel)

  # Create a label to show the current step.
  $global:SSAutoStepLabel = New-Object Windows.Forms.Label
  $SSAutoStepLabel.Size = DPISize (New-Object Drawing.Size(220, 20))
  $SSAutoStepLabel.Location = DPISize (New-Object Drawing.Point(92, 14))
  $SSAutoStepLabel.Text = 'Step 0 / 0: You Should Not See Me'
  $SSAutoMainPanel.Controls.Add($SSAutoStepLabel)

  # Create a label to display information.
  $global:SSAutoInfoLabel = New-Object Windows.Forms.Label
  $SSAutoInfoLabel.Size = DPISize (New-Object Drawing.Size(320, 80))
  $SSAutoInfoLabel.Location = DPISize (New-Object Drawing.Point(30, 20))
  $SSAutoInfoLabel.Text = 'I am generic information that should never be seen by human eyes. Please if you see me, report this to Bighead! Although you never will see me, so that should never happen!'
  $SSAutoInfoLabel.AutoSize = $false
  $SSAutoInfoLabel.TextAlign = [System.Drawing.ContentAlignment]::MiddleCenter 
  $SSAutoMainPanel.Controls.Add($SSAutoInfoLabel)

  # Create a label to display download information.
  $global:SSAutoDownloadLabel = New-Object Windows.Forms.Label
  $SSAutoDownloadLabel.Size = DPISize (New-Object Drawing.Size(80, 80))
  $SSAutoDownloadLabel.Location = DPISize (New-Object Drawing.Point(10, 102))
  $SSAutoDownloadLabel.Text = 'Downloading:'
  $SSAutoDownloadLabel.AutoSize = $false
  $SSAutoDownloadLabel.Visible = $false
  $SSAutoMainPanel.Controls.Add($SSAutoDownloadLabel)

  # Create a label to display download information.
  $global:SSAutoProgressLabel = New-Object Windows.Forms.Label
  $SSAutoProgressLabel.Size = DPISize (New-Object Drawing.Size(190, 16))
  $SSAutoProgressLabel.Location = DPISize (New-Object Drawing.Point(99, 128))
  $SSAutoProgressLabel.Text = '0.00 MB / 0.00 MB 0%'
  $SSAutoProgressLabel.AutoSize = $false
  $SSAutoProgressLabel.TextAlign = [System.Drawing.ContentAlignment]::MiddleCenter
  $SSAutoProgressLabel.Visible = $false
  $SSAutoMainPanel.Controls.Add($SSAutoProgressLabel)

  # Create a progress bar.
  $global:SSAutoProgressBar = New-Object Windows.Forms.ProgressBar
  $SSAutoProgressBar.Size = DPISize (New-Object Drawing.Size(200, 20))
  $SSAutoProgressBar.Location = DPISize (New-Object Drawing.Point(94, 104))
  $SSAutoProgressBar.Minimum = 0
  $SSAutoProgressBar.Maximum = 100
  $SSAutoProgressBar.Value = 0
  $SSAutoProgressBar.Style = [Windows.Forms.ProgressBarStyle]::Continuous
  $SSAutoMainPanel.Controls.Add($SSAutoProgressBar)

  # Create a text box to display the path.
  $global:SSPathTextBox = New-Object Windows.Forms.TextBox
  $SSPathTextBox.Size = DPISize (New-Object Drawing.Size(328, 22))
  $SSPathTextBox.Location = DPISize (New-Object Drawing.Point(14, 104)) -AddY $DPIOffsetFix
  $SSPathTextBox.Name = 'SuperScalersPathTemp'
  $SSPathTextBox.Text = $SuperScalersPathTemp
  $SSPathTextBox.AllowDrop = $true
  $SSPathTextBox.Visible = $false
  $SSPathTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $SSPathTextBox.Add_DragDrop({ LoadExternalFolder_DragDrop -TextBox $this ; UpdateSuperScalerTempPath })
  $SSPathTextBox.Add_Click({ ClearTextBox })
  $SSPathTextBox.Add_Leave({ LoadExternalFolder_TextBox -TextBox $this ; UpdateSuperScalerTempPath })
  $SSAutoMainPanel.Controls.Add($SSPathTextBox)

  # Create a button to update the path.
  $global:SSPathButton = New-Object Windows.Forms.Button
  $SSPathButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $SSPathButton.Location = DPISize (New-Object Drawing.Point(346, 103))
  $SSPathButton.Name = 'SuperScalersPathTemp'
  $SSPathButton.Text = '...'
  $SSPathButton.Visible = $false
  $SSPathButton.Add_Click({
                            $Message = 'Select a directory to download and install ESRGAN and SFTGAN. The script requires read/write access to these paths. They can be changed later in the "Tool Paths" menu.'
                            LoadExternalFolder_Button -TextBox $SSPathTextBox -Message $Message
                            UpdateSuperScalerTempPath
                         })
  $SSAutoMainPanel.Controls.Add($SSPathButton)

  # Create a button to start the process.
  $global:SSStartButton = New-Object Windows.Forms.Button
  $SSStartButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $SSStartButton.Location = DPISize (New-Object Drawing.Point(110, 158))
  $SSStartButton.Text = 'Start'
  $SSStartButton.Add_Click({ SSAutoSetup_BeginSetup -Skip $false })
  $SSAutoMainPanel.Controls.Add($SSStartButton)

  # Create a button to skip the process.
  $global:SSSkipButton = New-Object Windows.Forms.Button
  $SSSkipButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $SSSkipButton.Location = DPISize (New-Object Drawing.Point(200, 158))
  $SSSkipButton.Text = 'Skip'
  $SSSkipButton.Add_Click({ SSAutoSetup_BeginSetup -Skip $true })
  $SSAutoMainPanel.Controls.Add($SSSkipButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG 
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $MainDialog                - Form           - Global
#  $MainDialogPanel           - Panel          - Global
#  $MainDockedPanelA          - Panel          - Global
#  $MainDockedPanelB          - Panel          - Global
#  $MainDockedPanelC          - Panel          - Global
#  $MainDockedButtonsPanel    - Panel          - Global
#  $MainCTTPSGroup            - GroupBox       - Global
#  $MainCTTPSGroupTip         - ToolTip        - Local
#  $MainCTTPSCombo            - ComboBox       - Global
#  $MainCTTPSLabel            - Label          - Global
#  $MainCTTPSTip              - ToolTip        - Local
#  $MainTexListCombo          - ComboBox       - Global
#  $MainTexListLabel          - Label          - Global
#  $MainTexListTip            - ToolTip        - Local
#  $MainInputGroup            - GroupBox       - Global
#  $MainInputGroupTip         - ToolTip        - Local
#  $MainInputTextBox          - TextBox        - Global
#  $MainInputButton           - Button         - Global
#  $MainStoreInput            - CheckBox       - Global
#  $MainStoreInputTip         - ToolTip        - Local
#  $MainOutputGroup           - GroupBox       - Global
#  $MainOutputGroupTip        - ToolTip        - Local
#  $MainOutputTextBox         - TextBox        - Global
#  $MainOutputButton          - Button         - Global
#  $MainStoreOutput           - CheckBox       - Global
#  $MainStoreOutputTip        - ToolTip        - Local
#  $MainOperationsGroup       - GroupBox       - Global
#  $MainOperations            - ComboBox       - Global
#  $MainQuickHelp             - Button         - Global
#  $MainQuickHelpTip          - ToolTip        - Local
#  $MainFormatTexGroup           - GroupBox       - Global
#  $MainDDSGroupTip           - ToolTip        - Local
#  $MainDDSDX10Check          - CheckBox       - Global
#  $MainDDSDX10Tip            - ToolTip        - Local
#  $MainDDSToolCombo          - ComboBox       - Global
#  $MainDDSToolLabel          - Label          - Global
#  $MainDDSToolTip            - ToolTip        - Local
#  $MainDDSFormat             - ComboBox       - Global
#  $MainDDSFormatLabel        - Label          - Global
#  $MainDDSFormatTip          - ToolTip        - Global
#  $MainDDSFallback           - ComboBox       - Global
#  $MainDDSFallbackLabel      - Label          - Global
#  $MainDDSFallbackTip        - ToolTip        - Global
#  $MainDDSFlagRemoval        - ComboBox       - Global
#  $MainDDSFlagLabel          - Label          - Global
#  $MainDDSFlagTip            - ToolTip        - Global
#  $MainMipmapGroup           - GroupBox       - Global
#  $MainMipmapGroupTip        - ToolTip        - Local
#  $MainForceMipmapsAll       - CheckBox       - Global
#  $MainForceMipmapsAllTip    - ToolTip        - Local
#  $MainForceNewMipmaps       - CheckBox       - Global
#  $MainForceNewMipmapsTip    - ToolTip        - Local
#  $MainTopLevelMipmap        - CheckBox       - Global
#  $MainTopLevelMipmapTip     - ToolTip        - Local
#  $MainTopLevelMipmap        - CheckBox       - Global
#  $MainTopLevelMipmapTip     - ToolTip        - Local
#  $MainExternalDDSMipmap     - CheckBox       - Global
#  $MainExternalDDSMipmapTip  - ToolTip        - Local
#  $MainMaxMipmapToggle       - CheckBox       - Global
#  $MainMaxMipmapNumBox       - NumericUpDown  - Global
#  $MainMaxMipmapTip          - ToolTip        - Local
#  $MainStartButton           - Button         - Global
#  $MainStartTip              - ToolTip        - Local
#  $MainProcessButton         - Button         - Global
#  $MainProcessTip            - ToolTip        - Local
#  $MainOptionsButton         - Button         - Global
#  $MainOptionsTip            - ToolTip        - Local
#  $MainHelpButton            - Button         - Global
#  $MainHelpButtonTip         - ToolTip        - Local
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - UPDATE MASTER INPUT/OUTPUT PATHS
#==============================================================================================================================================================================================
#  Shared between the next three function to reduce duplicate code.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateMasterPaths_Finish([string]$InputPath)
{
  # If a slash was found at the end of the string, keep everything but the slash.
  $InputPath = PathTruncateSlash -Path $InputPath

  # Append the CTT_Generated folder to the InputPath to create the output path.
  $OutputPath = $InputPath + '\~CTT_Generated'

  # Use the name of the object to know which one to update.
  switch -wildcard ($this.Name)
  {
    # If the input path was selected also update the output path.
    '*Input*'   {
                  $MainInputTextBox.Text   = $InputPath
                  $ResInputTextBox.Text    = $InputPath
                  $global:MasterInputPath  = $InputPath
                }
    # If the output path was selected only update that.
    '*Output*'  {
                  $MainOutputTextBox.Text  = $OutputPath
                  $ResOutputTextBox.Text   = $OutputPath
                  $global:MasterOutputPath = $OutputPath
                }
  }
}
#==============================================================================================================================================================================================
#  Updates the "Input Path" and "Output Path" with a drag and drop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateMasterPaths_DragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

    # The Master Input Path can not have a tilde in the path.
    if (($this.Name -eq 'MasterInputPath') -and ($DroppedPath -like "*~*"))
    {
      # Alert the user as to why the path they are trying to input won't work.
      ShowOKDialog -Title "Invalid Path" -SizeX (DPISize 264) -SizeY (DPISize 30) -OffsetX (DPISize 32) -OffsetY (DPISize 12) -Message 'Error: The Input Path may not contain a tilde (~) character. CTT-PS skips any paths with a tilde.'
    }
    # Make sure the path is a folder and prevent the path if it contains a tilde (~) in it.
    if (($DroppedPath -notlike '*~*') -and ($DroppedPath.Length -gt 3) -and (TestPath -LiteralPath $DroppedPath -PathType 'Container'))
    {
      # Update the path using a function that is shared with the below function.
      UpdateMasterPaths_Finish -InputPath $DroppedPath
    }
  }
}
#==============================================================================================================================================================================================
#  Updates the "Input Path" and "Output Path" from the button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateMasterPaths_Button()
{
  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $MasterInputPath

  # The Master Input Path can not have a tilde in the path.
  if (($this.Name -eq 'MasterInputPath') -and ($SelectedPath -like "*~*"))
  {
    # Alert the user as to why the path they are trying to input won't work.
    ShowOKDialog -Title "Invalid Path" -SizeX (DPISize 264) -SizeY (DPISize 30) -OffsetX (DPISize 32) -OffsetY (DPISize 12) -Message 'Error: The Input Path may not contain a tilde (~) character. CTT-PS skips any paths with a tilde.'
  }
  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and ($SelectedPath -notlike '*~*') -and ($SelectedPath.Length -gt 3) -and (TestPath -LiteralPath $SelectedPath))
  {
    # Update the path using a function that is shared with the above function.
    UpdateMasterPaths_Finish -InputPath $SelectedPath
  }
}
#==============================================================================================================================================================================================
#  Updates the "Input Path" and "Output Path" when manually entering the text.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateMasterPaths_TextBox()
{
  # Get the current value of the MasterPath.
  $CurrentPath = Get-Variable -Name $this.Name -ValueOnly
  $EnteredText = $this.Text

  # To avoid updating constantly, check to see if the text actually changed.
  if ($EnteredText -ne $CurrentPath)
  {
    # The Master Input Path can not have a tilde in the path.
    if (($this.Name -eq 'MasterInputPath') -and ($EnteredText -like "*~*"))
    {
      # Alert the user as to why the path they are trying to input won't work.
      ShowOKDialog -Title "Invalid Path" -SizeX (DPISize 264) -SizeY (DPISize 30) -OffsetX (DPISize 32) -OffsetY (DPISize 12) -Message 'Error: The Input Path may not contain a tilde (~) character. CTT-PS skips any paths with a tilde.'
    }
    # Check to see if a folder was selected from the Open menu and test if that path exists.
    if (($EnteredText -ne '') -and ($EnteredText -notlike '*~*') -and ($EnteredText.Length -gt 3) -and (TestPath -LiteralPath $EnteredText))
    {
      # Update the path using a function that is shared with the above function.
      UpdateMasterPaths_Finish -InputPath $EnteredText
    }
    # The text was empty or invalid.
    else
    {
      # Set the textbox text back to the MasterPath.
      $this.Text = $CurrentPath
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - MAIN SUPPORT FUNCTIONS
#==============================================================================================================================================================================================
#  Runs when the Main Dialog is shown for the first time.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MainDialogInit()
{
  # If the user selected "docked" for the texture list, it needs to be updated.
  if ($TextureListMode -eq 'Docked') { TexList_ToggleVisibility -TexListMode $TextureListMode }

  # Show the "Texture List" by toggling its visibility state.
  $TexListDialog.Visible = ($TextureListMode -eq 'Window')

  # Activate the main dialog window.
  ActivateDialog -Dialog $this

  # The CTT-PS Mode combobox is the first to be selected. To prevent the "blue selection" force focus of the dummy label.
  $MainFocusLabel.Focus()
}
#==============================================================================================================================================================================================
#  Quickly load a specific help topic depending on the currently selected "Standard" or "Advanced" Option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LaunchQuickHelpMenu()
{
  # Show the help dialog.
  $HelpDialog.Visible = $true

  # The scan option can have two names.
  if ($StoredOperation -like "Scan D*")
  {
    # We want to match either name so it matches this.
    $CurrentOperation = "Scan Dolphin/Database Textures For Issues"
  }
  # If it's any other operation.
  else
  {
    # We can use it exactly as it is.
    $CurrentOperation = $StoredOperation
  }
  # Find the node that has the same name as the selected operation.
  $FindNode = $HelpTopics.Nodes.Find($CurrentOperation, $true)

  # Not sure why, but "Find" returns an array. Luckily there is only 1 value found, so just "loop" through that 1 value.
  foreach ($Node in $FindNode) { $HelpTopics.SelectedNode = $Node }
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - SELECT CTT-PS MODE
#==============================================================================================================================================================================================
#  Toggles the enabled state of the option "DX10 Header" option. Fired when the user selects a CTT-PS Mode.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleForceDX10Header([bool]$ToggleCheck)
{
  # Toggle the option and it's visibility state.
  $MainDDSDX10Check.Visible = $ToggleCheck

  # If disabling it, also uncheck it.
  if (!$ToggleCheck) { $MainDDSDX10Check.Checked = $false }
}
#==============================================================================================================================================================================================
#  Sets which tooltips are seen on the "DDS Format", "DDS Fallback", and "Flag Removal" combo boxes.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetDDSOptionToolTips([bool]$ExtendedTips)
{
  # Extended tips shows far more information on compression formats not available in Dolphin mode.
  switch ($ExtendedTips)
  {
    # Show tips that explain every single compression format.
    $true   {
              $MainDDSFormatTip.SetToolTip($MainDDSFormatLabel, $MainDDSFormatTipString)
              $MainDDSFallbackTip.SetToolTip($MainDDSFallbackLabel, $MainDDSFallbackTipString)
              $MainDDSFlagTip.SetToolTip($MainDDSFlagLabel, $MainDDSFlagTipString)
            }
    # Only show tips for compression formats available in "Dolphin Mode".
    $false  {
              $MainDDSFormatTip.SetToolTip($MainDDSFormatLabel, $MainDDSFormatTipStringB)
              $MainDDSFallbackTip.SetToolTip($MainDDSFallbackLabel, $MainDDSFallbackTipStringB)
              $MainDDSFlagTip.SetToolTip($MainDDSFlagLabel, $MainDDSFlagTipStringB)
            }
  }
}
#==============================================================================================================================================================================================
#  When a user selects a CTT-PS Mode, this is the main function that fires.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CTT-PSModeSelected([string]$Selection)
{
  # Set the column headers based on what was selected.
  TexList_SetColumnHeaders -Selection $Selection

  # It's dumb little shit like this that bothers me. Hide the "Force Create Mipmaps" option before moving it so users won't see it visibly move.
  $MainForceMipmapsAll.Visible = $false

  # Find the mode that was selected.
  switch -Wildcard ($Selection)
  {
    # Add the indexes of the operations we want to add via the script block array.
    'Dolphin*'  { ToggleForceDX10Header -ToggleCheck $false  ;  SetDDSOptionToolTips -ExtendedTips $false  ;  $MainForceMipmapsAll.Location = (DPISize (New-Object Drawing.Size(185, 58))) }
    'Expert*'   { ToggleForceDX10Header -ToggleCheck $true   ;  SetDDSOptionToolTips -ExtendedTips $true   ;  $MainForceMipmapsAll.Location = (DPISize (New-Object Drawing.Size(185, 58))) }
    'Database*' { ToggleForceDX10Header -ToggleCheck $true   ;  SetDDSOptionToolTips -ExtendedTips $true   ;  $MainForceMipmapsAll.Location = (DPISize (New-Object Drawing.Size(185, 58))) }
    'Phyre*'    { ToggleForceDX10Header -ToggleCheck $false  ;  SetDDSOptionToolTips -ExtendedTips $true   ;  $MainForceMipmapsAll.Location = (DPISize (New-Object Drawing.Size(185, 37))) }
    'Metroid*'  { ToggleForceDX10Header -ToggleCheck $false  ;  SetDDSOptionToolTips -ExtendedTips $false  ;  $MainForceMipmapsAll.Location = (DPISize (New-Object Drawing.Size(185, 58))) }
  }
  # Now that it's been moved restore visibility.
  $MainForceMipmapsAll.Visible = $true

  # Hide the "Upscale Factor as Target" option when in Expert Mode.
  $UpscaleFactorTarget.Visible = ($Selection -eq 'Dolphin Mode')

  # Repopulate the operations list since they have changed.
  PopulateOperationList

  # Repopulate the DDS Format lists ("DDS Format" and "DDS Fallback").
  RefreshDDSLists -FormatOnly

  # Populate the "Output Format" lists for convert and rescale options.
  PopulateFormatLists -Combobox $ConvertFormatCombo -SelectedFormat $ConvertFormatCombo.SelectedItem
  PopulateFormatLists -Combobox $RescaleFormatCombo -SelectedFormat $RescaleFormatCombo.SelectedItem
  PopulateFormatLists -Combobox $ResizeFormatCombo  -SelectedFormat $ResizeFormatCombo.SelectedItem
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - DDS TOOL AND MIPMAP FUNCTIONS
#==============================================================================================================================================================================================
#  Adds a DDS Tool to the corresponding combobox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddDDSTool([Windows.Forms.ComboBox]$ComboBox)
{
  # Create empty arrays for the tools that aren't already added.
  $FileNameArray    = New-Object Collections.Generic.List[string]
  $DescriptionArray = New-Object Collections.Generic.List[string]

  # Add Compressonator and TexConv to the list if they are found.
  if (!(TestPath -LiteralPath $Compressonator)) { $FileNameArray.Add('CompressonatorCLI.exe') ; $DescriptionArray.Add('Compressonator') }
  if (!(TestPath -LiteralPath $TexConvTool))    { $FileNameArray.Add('texconv.exe')           ; $DescriptionArray.Add('TexConv')        }

  # Display an "Open File" menu to get the path. Get-FileName already handles arrays so no need to worry about extra shit.
  $SelectedPath = Get-FileName -StartPath $BaseFolder -FileName $FileNameArray -Description $DescriptionArray

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Get the name of the tool so parameters for it can be set up.
    $ToolName = (Get-Item -LiteralPath $SelectedPath).BaseName

    # Set up parameters based on the selected tool.
    switch -wildcard ($ToolName)
    {
      # Set the values for Compressonator.
      'Compres*'  {
                    $ToolName = 'Compressonator'
                    $TextBox  = $OptionsCompressTextBox
                    $VarName  = 'Compressonator'
                  }
      # Set the values for DirectX TexConv.
      'texconv*'  {
                    $ToolName = 'TexConv'
                    $TextBox  = $OptionsTexConvTextBox
                    $VarName  = 'TexConvTool'
                  }
    }
    # Make sure the tool is not already on the list.
    if (!($ComboBox.Items.Contains($ToolName)))
    {
      # Call the function that is used when updating paths.
      LoadExternalFile -TextBox $TextBox -ToolPathName $VarName -ToolPath $SelectedPath
    }
    # Force the selected item to recently added tool.
    $ComboBox.SelectedItem = $SelectedTool = $ToolName
  }
  # If nothing was selected.
  else
  {
    # Force the currently selected item to ImageMagick.
    $ComboBox.SelectedItem = $SelectedTool = 'ImageMagick'
  }
  # Return the selected tool so it can be set to the global.
  return $SelectedTool
}
#==============================================================================================================================================================================================
#  Fires when a user selects a "DDS Tool" such as ImageMagick, Compressonator, or TexConv.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DDSToolSelection($ComboBox)
{
  # Get the item that was selected from the combobox.
  $SelectedTool = $ComboBox.SelectedItem

  # If the user wants to add a new tool to the list.
  if ($SelectedTool -eq 'Add Tool...') { $SelectedTool = AddDDSTool($ComboBox) }

  # Call the function that fires when a tool is selected.
  ComboBoxStateChanged -NewValue $SelectedTool
}
#==============================================================================================================================================================================================
#  Toggles the availability of "DDS Fallback" and "BC7 Quality" options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DDSFormatSelection()
{
  # Update the global variable that stores the DDS Format.
  ComboBoxStateChanged -NewValue $this.SelectedItem

  # Attempt to toggle the visibility of the fallback format and flag removal.
  ToggleFallbackVisibility -Condition (($this.SelectedItem -eq '*Search Flags*') -or ($this.SelectedItem -eq '*Passthrough*'))
  ToggleFlagRemoveVisibility -Condition ($this.SelectedItem -eq '*Search Flags*')
}
#==============================================================================================================================================================================================
#  Toggles the number box that allows setting the max number of mipmaps.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleMaxMipmapOption($Checkbox)
{
  # Simply change the state based on whether or not it was checked.
  $MainMaxMipmapNumBox.Enabled = $Checkbox.Checked
}
#==============================================================================================================================================================================================
#  Toggles all mipmap options when checking enable or disable mipmap options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleMipmapOptions()
{
  # When checking disable mipmaps.
  if ($this.Checked)
  {
    # Uncheck all the options just to be safe.
    $MainForceNewMipmaps.Checked = $false
    $MainTopLevelMipmap.Checked = $false
    $MainMaxMipmapToggle.Checked = $false
    $MainExternalDDSMipmap.Checked = $false
    $MainForceMipmapsAll.Checked = $false

    # Disable the number box for max mipmaps.
    $MainMaxMipmapNumBox.Enabled = $false
  }
  # Enable or disable the options.
  $MainForceNewMipmaps.Enabled = !$this.Checked
  $MainTopLevelMipmap.Enabled = !$this.Checked
  $MainMaxMipmapToggle.Enabled = !$this.Checked
  $MainExternalDDSMipmap.Enabled = !$this.Checked
  $MainForceMipmapsAll.Enabled = !$this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the enabled states of "Force New Mipmaps" and "Create From Top Level" options since they can not be used together.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleMipmapOptionConflicts()
{
  # Grab the checkbox that fired this function.
  switch ($this)
  {
    # Enabling "Create From Top Level" disables "Force New Mipmaps" and unchecks it.
    $MainTopLevelMipmap   {
                            $MainForceNewMipmaps.Enabled = !$this.Checked
                            if ($this.Checked) { $MainForceNewMipmaps.Checked = $false }
                          }
    # Enabling "Force New Mipmaps" disables "Create From Top Level" and unchecks it.
    $MainForceNewMipmaps  {
                            $MainTopLevelMipmap.Enabled = !$this.Checked
                            if ($this.Checked) { $MainTopLevelMipmap.Checked = $false }
                          }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - OPERATIONS LIST - CREATE
#==============================================================================================================================================================================================
#  Adds operations to two arrays: Title array holds the option's text, while GroupArray holds all GUI controls for that option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateOperationGlobals()
{
  # A permanent array that contains the names of all operation groups. It is required for reference.
  $global:StaticGroupArray  = @(  'DatabaseTextureGroup', 'ScanDolphinTexGroup'  , 'ScanDolphinTexGroup'   , 'ConvertTextureGroup'  , 'RescaleTextureGroup' , 'ResizeTextureGroup'  , 'WatermarkImageGroup' , 
                                  'MaterialTexGroup'    , 'MaterialMapsGroup'    , 'ArbitraryMipmapGroup'  , 'OptimizeTextureGroup' , 'UpscaleFiltersGroup' , 'VRAMRequirementGroup', 
                                  'GenNewMipmapsGroup'  , 'InvalidMipmapsGroup'  , 'ExtractDDSMipmapGroup' , 'RemoveAlphaGroup'     , 'CombineTextureGroup' , 'SplitTextureGroup'   , 
                                  'AlphaPixelGroup'     , 'RGBAChannelsGroup'    , 'ToCSExtractPKAGroup'   , 'ToCSExtractPKGGroup'  , 'ToCSConvertGroup'    , 'ToCSCreateGroup'     , 
                                  'ToCSRepackGroup'     , 'ImageViewerGroup'     , 'ResourcePackGroup'     , 'MetroidReplaceGroup'  , 'CLIExecutableGroup'  , 'ExtractTexturesGroup' )

  #  The GroupArray stores the groupbox the operation belongs to. The TitleArray stores the title of the operation.
  $global:OperationGroupArray = New-Object Collections.Generic.List[string]
  $global:OperationTitleArray = New-Object Collections.Generic.List[string]
  $global:ProcessSelectedBool = New-Object Collections.Generic.List[bool]
}
#==============================================================================================================================================================================================
#  Adds operations to two arrays: Title array holds the option's text, while GroupArray holds all GUI controls for that option.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddOperationArray([string]$GroupArray, [string]$TitleArray, [bool]$ProcessSelected)
{
  $global:OperationGroupArray.Add($GroupArray)
  $global:OperationTitleArray.Add($TitleArray)
  $global:ProcessSelectedBool.Add($ProcessSelected)
}
#==============================================================================================================================================================================================
#  Populates the operations list. Options are added based on what the CTT-PS mode is set to.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateOperationList()
{
  # Clear the arrays so options don't spill over into other CTT-PS modes when it is switched. "Process Selected" boolean takes care of which options show the [!] button.
  if ($OperationGroupArray.Count -gt 0) { $OperationGroupArray.Clear() }
  if ($OperationTitleArray.Count -gt 0) { $OperationTitleArray.Clear() }
  if ($ProcessSelectedBool.Count -gt 0) { $ProcessSelectedBool.Clear() }

  # A really cheesy way to select the options but hey if it works, I'm fine with it. It should be noted that this does not store these operations in the indexes
  # below, but rather it stores them chronologically. ToCS for example, uses 19 through 24. But the index for all added options will be stored as 0, 1, 2, 3, 4.
  switch -Wildcard ($CTTPSSelectedMode)
  {
    # Add the indexes of the operations we want to add via the script block array.
    'Dolphin*' { $OperationList = @(1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,26,27,30) }
    'Expert*'  { $OperationList = @(3,4,5,6,9,10,11,14,15,16,17,19,20,26,29) }
    'Databas*' { $OperationList = @(0,2,3,4,5,6,9,10,14,15,16,17,19,20,26,29) }
    'Phyre*'   { $OperationList = @(21,22,23,24,25,26) }
    'Metroid*' { $OperationList = @(28) }
  }
  # Build a list of all possible operations that can be added to the list in a script block that stores data about the operation into arrays.
  $ScriptBlock = New-Object Collections.Generic.List[Management.Automation.ScriptBlock]

  # Store the GroupBox name and Title string in arrays. GroupBox's are stored as strings because they may not exist yet.
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'DatabaseTextureGroup'  -TitleArray 'Create Texture Size Database'                         -ProcessSelected $false })   # Operation 0
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ScanDolphinTexGroup'   -TitleArray 'Scan Dolphin Textures For Issues'                     -ProcessSelected $true  })   # Operation 1
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ScanDolphinTexGroup'   -TitleArray 'Scan Database Textures For Issues'                    -ProcessSelected $true  })   # Operation 2
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ConvertTextureGroup'   -TitleArray 'Convert Textures to Another Format'                   -ProcessSelected $true  })   # Operation 3
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'RescaleTextureGroup'   -TitleArray 'Rescale Textures With New Scaling Factor'             -ProcessSelected $true  })   # Operation 4
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ResizeTextureGroup'    -TitleArray 'Resize Textures With Specific Dimensions'             -ProcessSelected $true  })   # Operation 5
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'WatermarkImageGroup'   -TitleArray 'Add Identifying Watermark to All Textures'            -ProcessSelected $true  })   # Operation 6
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'MaterialTexGroup'      -TitleArray 'Create Materials With Material Map Generator'         -ProcessSelected $false })   # Operation 7
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'MaterialMapsGroup'     -TitleArray 'Create Material Maps With Ishiiruka Tool'             -ProcessSelected $false })   # Operation 8
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'OptimizeTextureGroup'  -TitleArray 'Optimize PNG Textures With Optimizer Program'         -ProcessSelected $true  })   # Operation 9
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'UpscaleFiltersGroup'   -TitleArray 'Apply Upscaling Filter to All Textures'               -ProcessSelected $true  })   # Operation 10
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'VRAMRequirementGroup'  -TitleArray 'Calculate Textures VRAM Requirement'                  -ProcessSelected $false })   # Operation 11
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'GenNewMipmapsGroup'    -TitleArray 'Generate New Mipmaps For Dolphin Textures'            -ProcessSelected $true  })   # Operation 12
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'InvalidMipmapsGroup'   -TitleArray 'Remove Invalid Mipmaps From Dolphin Textures'         -ProcessSelected $true  })   # Operation 13
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ExtractDDSMipmapGroup' -TitleArray 'Extract Internal Mipmaps'                             -ProcessSelected $true  })   # Operation 14
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'RemoveAlphaGroup'      -TitleArray 'Remove Alpha Channel From Opaque Textures'            -ProcessSelected $true  })   # Operation 15
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'CombineTextureGroup'   -TitleArray 'Combine Multiple Textures'                            -ProcessSelected $false })   # Operation 16
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'SplitTextureGroup'     -TitleArray 'Split Combined Multi-Texture'                         -ProcessSelected $false })   # Operation 17
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ArbitraryMipmapGroup'  -TitleArray 'Add/Remove Arbitrary Mipmap Suffix'                   -ProcessSelected $true  })   # Operation 18
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'AlphaPixelGroup'       -TitleArray 'PNG Alpha Pixel Manipulation'                         -ProcessSelected $true  })   # Operation 19
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'RGBAChannelsGroup'     -TitleArray 'Separate/Combine Texture RGBA Channels'               -ProcessSelected $false })   # Operation 20
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ToCSExtractPKAGroup'   -TitleArray 'Extract Trails of Cold Steel PKA Files'               -ProcessSelected $false })   # Operation 21
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ToCSExtractPKGGroup'   -TitleArray 'Extract Trails of Cold Steel PKG Files'               -ProcessSelected $false })   # Operation 22
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ToCSConvertGroup'      -TitleArray 'Convert Phyre Textures to PNG Textures'               -ProcessSelected $false })   # Operation 23
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ToCSCreateGroup'       -TitleArray 'Create Phyre Textures From PNG/Phyre'                 -ProcessSelected $false })   # Operation 24
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ToCSRepackGroup'       -TitleArray 'Repack Folders/Textures Into PKG Files'               -ProcessSelected $false })   # Operation 25
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ImageViewerGroup'      -TitleArray 'Basic Image Viewer'                                   -ProcessSelected $false })   # Operation 26
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ResourcePackGroup'     -TitleArray 'Dolphin Resource Pack Manager'                        -ProcessSelected $false })   # Operation 27
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'MetroidReplaceGroup'   -TitleArray 'Create New Metroid Prime 2 Fonts From Base Textures'  -ProcessSelected $false })   # Operation 28
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'CLIExecutableGroup'    -TitleArray 'Run Custom CLI Executable With CTT-PS'                -ProcessSelected $false })   # Operation 29
  $ScriptBlock.Add({ AddOperationArray -GroupArray 'ExtractTexturesGroup'  -TitleArray 'Extract Textures With TextureExtraction Tool'         -ProcessSelected $false })   # Operation 30

  # Remove all current operations in the list.
  $MainOperations.Items.Clear() | Out-Null

  # Run only the script blocks with operations we want to add to the list.
  foreach ($Index in $OperationList)
  {
    # Run the script block which builds the GroupBox arrays and Title arrays.
    Invoke-Command -ScriptBlock $ScriptBlock[$Index]
  }
  # Loop through all operations in the title array.
  foreach ($Operation in $OperationTitleArray)
  {
    # Add the title to the "Operations" list on the dialog.
    $MainOperations.Items.Add($Operation) | Out-Null
  }
  # Make sure the list contains the stored operation.
  if ($MainOperations.Items -Contains $StoredOperation)
  {
    # Select the item that was stored in the global.
    $MainOperations.SelectedItem = $StoredOperation
  }
  # The list does not contain it.
  else
  {
    # Select the first item in the list.
    $MainOperations.SelectedItem = $OperationTitleArray[0]
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - OPERATIONS LIST - UPDATE SELECTED 
#==============================================================================================================================================================================================
#  When an option is selected from the Operations list, this updates which sub-options are visible to the user.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateSelectedOperation([object]$ComboBox)
{
  # Get the index of the selected item on the list box.
  $Index = $ComboBox.SelectedIndex

  # Show the control group based on its index. Show it BEFORE hiding other groups to avoid flickering.
  (Get-Variable -Name $OperationGroupArray[$Index] -ValueOnly).Show() | Out-Null

  # Loop through all operation groups.
  for ($i = 0 ; $i -lt $StaticGroupArray.Count ; $i++)
  {
    # Check to see if the selected operation matches the one in the loop.
    if ($OperationGroupArray[$Index] -eq $StaticGroupArray[$i])
    {
      # The order that the [$] buttons are hidden and the "Start" button sizes are changed is important to avoid the [$] buttons from flickering
      # if the they are hidden or shown before the "Start" buttons sizes are changed. So change the order depending on the button state changes.
      switch ($ProcessSelectedBool[$Index])
      {
        # If showing the [$] buttons, show them before shrinking the "Start" buttons to avoid flicker.
        $true   {
                  # Toggle the visibility of the [$] buttons, then set the new width of the "Start" buttons.
                  $MainProcessButton.Visible = $TexListProcessButton.Visible = $ProcessSelectedBool[$Index]
                  $MainStartButton.Size = $TexListStartButton.Size = (DPISize (New-Object Drawing.Size(72, 28)))
                }
        # If hiding the [$] buttons, hide them before growing the "Start" buttons to avoid flicker.
        $false  {
                  # Set the new width of the "Start" buttons, then toggle the visibility of the [$] buttons.
                  $MainStartButton.Size = $TexListStartButton.Size = (DPISize (New-Object Drawing.Size(88, 28)))
                  $MainProcessButton.Visible = $TexListProcessButton.Visible = $ProcessSelectedBool[$Index]
                }
      }
    }
    # The current loop operation does not match the selected operation.
    else
    {
      # Hide the group if it wasn't the selected operation.
      (Get-Variable -Name $StaticGroupArray[$i] -ValueOnly).Hide() | Out-Null
    }
  }
  # Store the selected option group and the current index.
  $global:StoredOperation = $ComboBox.Items[$Index].ToString()

  # Reset the column headers as this can now be operation specific.
  TexList_SetColumnHeaders -Selection $CTTPSSelectedMode
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - OPERATIONS LIST - SHARED FUNCTIONS
#==============================================================================================================================================================================================
#  When "Hide OK Textures" is checked on any operation, clone that state to other options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_ToggleOKTextures()
{
  # All checkboxes get the same state.
  $ScanHideOKTextures.Checked = $this.Checked
  $InvalidHideOKTextures.Checked = $this.Checked
  $RemoveAlphaHideOK.Checked = $this.Checked
}
#==============================================================================================================================================================================================
#  The "Copy Non-Textures" option can be found on the Convert, Rescale, and Resize texture menus.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_ToggleCopyNonTextures()
{
  $ConvertCopyNonTex.Checked = $this.Checked
  $RescaleCopyNonTex.Checked = $this.Checked
  $ResizeCopyNonTex.Checked  = $this.Checked
}
#==============================================================================================================================================================================================
#  The "Disable Sharpening" option can be found on the Convert, Rescale, and Resize texture menus.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_ToggleEnableSharpen()
{
  $ConvertEnableSharpen.Checked = $this.Checked
  $RescaleEnableSharpen.Checked = $this.Checked
  $ResizeEnableSharpen.Checked  = $this.Checked
  $GenNewEnableSharpen.Checked  = $this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the state of the "Scale-Fix" controls on the Convert Textures menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_ToggleScaleFixThreshold()
{
  $ConvertScaleFixLabel.Enabled  = $this.Checked
  $ConvertScaleFixNumBox.Enabled = $this.Checked
}
#==============================================================================================================================================================================================
#  Scale fix threshold can be found on the "Scan Dolphin Textures" menu and the "Convert Textures to Another Format" menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_UpdateScaleFixThreshold()
{
  # Simply update all number boxes to the entered value.
  $ConvertScaleFixNumBox.Value = $ScaleThreshold
  $ScanScaleFixNumBox.Value = $ScaleThreshold
}
#==============================================================================================================================================================================================
#  When "Hide OK Textures" is checked on any operation, clone that state to other options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_ToggleUserScaleValue()
{
  # All checkboxes get the same state.
  $ScanAcceptedScalesTextBox.Enabled = $this.Checked
}
#==============================================================================================================================================================================================
#  Enables the auto-rename output textbox and clear buttons. The global below is used at the end of the MasterLoop when packs are finished converting or rescaling.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_EnableAutoRenameOutput()
{
  # Force both options checked or unchecked.
  $ConvertAutoRename.Checked = $this.Checked
  $RescaleAutoRename.Checked = $this.Checked
  $ResizeAutoRename.Checked  = $this.Checked

  # Enable/disable the text box depending on the check state.
  $ConvertAutoRenameTextBox.Enabled = $this.Checked
  $ConvertAutoRenameButton.Enabled  = $this.Checked
  $RescaleAutoRenameTextBox.Enabled = $this.Checked
  $RescaleAutoRenameButton.Enabled  = $this.Checked
  $ResizeAutoRenameTextBox.Enabled  = $this.Checked
  $ResizeAutoRenameButton.Enabled   = $this.Checked

  # If the box is checked and text has yet to be set.
  if (($this.Checked) -and ($AutoRenameValue -eq ''))
  {
    # Split the master input path on all dashes to find the final folder.
    $FindTexturePath = $MasterInputPath.Split('\')

    # Get the number of folders in the array, subtract 1 from the total (arrays are zero based).
    $Count = $FindTexturePath.Length - 1

    # Set the textbox to the name of the deepest folder found in the master input path.
    $ConvertAutoRenameTextBox.Text = $FindTexturePath[$Count]
    $RescaleAutoRenameTextBox.Text = $FindTexturePath[$Count]
    $ResizeAutoRenameTextBox.Text  = $FindTexturePath[$Count]
    $global:AutoRenameValue = $FindTexturePath[$Count]
  }
}
#==============================================================================================================================================================================================
#  Convert/Rescale/Resize operations can auto-rename the converted pack. This makes sure the characters are legal when leaving the text boxes.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_VerifyAutoRenameOutput()
{
  # Do not allow illegal characters, only alpha-numeric values and spaces.
  if ($this.Text -match "^[a-zA-Z0-9- ]+$")
  {
    Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global'
  }
  # If the text was illegal, clear the text box and reset the variable.
  else
  {
    Set-Variable -Name $this.Name -Value '' -Scope 'Global'
  }
  # If the name is okay then show it on both text boxes.
  $ConvertAutoRenameTextBox.Text = $AutoRenameValue
  $RescaleAutoRenameTextBox.Text = $AutoRenameValue
  $ResizeAutoRenameTextBox.Text  = $AutoRenameValue
}
#==============================================================================================================================================================================================
#  Clears the auto-rename pack textboxes and resets the global variable when clicking the [-] button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Operations_ClearAutoRenameOutput()
{
  # Clear all text boxes and reset the value.
  $ConvertAutoRenameTextBox.Text = ''
  $RescaleAutoRenameTextBox.Text = ''
  $ResizeAutoRenameTextBox.Text  = ''
  $global:AutoRenameValue = ''
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - OPERATIONS LIST - OPERATION SPECIFIC FUNCTIONS
#==============================================================================================================================================================================================
#  Toggles the Scale-Fix and Aspect-Fix Thresholds when checking "Attempt Repairs".
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ScanTextures_ToggleFixThresholds()
{
  # Enable the numbox and labels based on the checked state.
  $ScanScaleFixNumBox.Enabled  = $this.Checked
  $ScanScaleFixLabel.Enabled   = $this.Checked
  $ScanAspectFixNumBox.Enabled = $this.Checked
  $ScanAspectFixLabel.Enabled  = $this.Checked
}
#==============================================================================================================================================================================================
#  Shows a color dialog that allows selecting the font or background color of the watermark.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Watermark_ShowColorDialog()
{
  # Create and show a color dialog to the user.
  $ColorSelect = $ColorDialog.ShowDialog()

  # Check to see if the color selection passed when the dialog was closed.
  if ($ColorSelect -eq 'OK')
  {
    # Compile the color into HTML format by converting each value to hexadecimal.
    $NewColor = '#' + $ColorDialog.Color.R.ToString('X2') + $ColorDialog.Color.G.ToString('X2') + $ColorDialog.Color.B.ToString('X2')

    # Update the color displayed on the button.
    $this.BackColor = $NewColor

    # Update the script with the new color value.
    Set-Variable -Name $this.Name -Value $NewColor -Scope 'Global'
  }
}
#==============================================================================================================================================================================================
#  Since "Scale" and "Noise" can be used independently from each other, disable "Noise" when only "Scale" is selected.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Waif2x_ToggleNoiseValue()
{
  # Translate the current mode.
  $CurrentMode = Waifu2x_FlipConvertModeName -ModeName $this.SelectedItem

  # If the mode is set to "Scale" only.
  if (($CurrentMode -eq 'scale') -or ($CurrentMode -eq 'auto_scale'))
  {
    # Disable the "Noise" configuration.
    $OptionsW2XNoiseNumBox.Enabled = $false
    $OptionsW2XNoiseLabel.Enabled = $false
  }
  # If the mode is set to "Noise" or "Both".
  else
  {
    # Enable the "Noise" configuration.
    $OptionsW2XNoiseNumBox.Enabled = $true
    $OptionsW2XNoiseLabel.Enabled = $true
  }
}
#==============================================================================================================================================================================================
#  Enables/disables some waifu2x options and toggles the visibility of others depending on the selected waifu2x application (Waifu2x-Caffe or Waifu2x-CPP).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Waifu2x_UpdateAppSpecificOptions()
{
  # Can't update anything if there isn't a waifu2x connected to the script.
  if (!(TestPath -LiteralPath $Waifu2xPath)) { return }

  # Get the name of the current waifu2x application.
  $Waifu2xApp = (Get-Item -LiteralPath $Waifu2xPath).Name

  # Set up the values depending on which waifu2x application was found.
  switch -wildcard ($Waifu2xApp)
  {
    # The toggle state takes care of a few options. The "Y" variables adjust offsets. The max noise sets the upper limit for noise reduction.
    '*caffe*' { $ToggleCheck = $true  }
    '*conve*' { $ToggleCheck = $false }
    default   { $ToggleCheck = $false }
  }
  # Toggle the visibility of the model selection.
  $OptionsW2XModelCombo.Enabled = $ToggleCheck
  $OptionsW2XModelLabel.Enabled = $ToggleCheck
}
#==============================================================================================================================================================================================
#  Adds all DDS Tools to the menu that are not already added.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateUpscaleFilterList()
{
  # Remove all current tools from the list.
  $UpscaleSelection.Items.Clear() | Out-Null

  # Add the external tools if they have been found.
  if (TestPath -LiteralPath $ScalerTestPath) { $UpscaleSelection.Items.Add('xBRZ') | Out-Null }
  if (TestPath -LiteralPath $Waifu2xPath)    { $UpscaleSelection.Items.Add('Waifu2x') | Out-Null }

  # ImageMagick should always be found so always add these.
  $UpscaleSelection.Items.Add('Point') | Out-Null
  $UpscaleSelection.Items.Add('Cubic') | Out-Null

  # Set test paths to ESRGAN and SFTGAN.
  $ESRGANTest = $ESRGANBasePath + '\test.py'
  $SFTGANTest = $SFTGANBasePath + '\pytorch_test\test_sftgan.py'

  # Add ESRGAN and SFTGAN if they are found.
  if (TestPath -LiteralPath $ESRGANTest) { $UpscaleSelection.Items.Add('ESRGAN') | Out-Null }
  if (TestPath -LiteralPath $SFTGANTest) { $UpscaleSelection.Items.Add('SFTGAN') | Out-Null }

  # If any tool is not found, then add the "Add Filter..." option to the list.
  $AddToolConditions = New-Object bool[] 3

  # Go through and store the result of each check into the array.
  $AddToolConditions[0] = (!(TestPath -LiteralPath $ScalerTestPath))
  $AddToolConditions[1] = (!(TestPath -LiteralPath $Waifu2xPath))  

  # Test the array of conditions. If it fails, add the item to allow adding more tools.
  if (TestBooleanArray -Or -Array $AddToolConditions) { $UpscaleSelection.Items.Add('Add Filter...') | Out-Null }

  # Reselect the currently selected filter. If it doesn't exist in the list, default to the Point filter.
  if ($UpscaleSelection.Items -contains $FilterSelected) { $UpscaleSelection.SelectedItem = $FilterSelected } else { $UpscaleSelection.SelectedItem = $FilterSelected = 'Point' }
}
#==============================================================================================================================================================================================
#  Adds an external upscaling filter program to CTT-PS by selecting a program file (waifu2x/xBRZ).
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddUpscaleFilterFromFile($ComboBox)
{
  # Create empty arrays based for the tools that aren't already added.
  $FileNameArray    = New-Object Collections.Generic.List[string]
  $DescriptionArray = New-Object Collections.Generic.List[string]

  # Add the scaler test executable and description to the lists.
  if (!(TestPath -LiteralPath $ScalerTestPath))
  {
    $FileNameArray.Add('ScalerTest*.exe')
    $DescriptionArray.Add('xBRZ ScalerTest')
  }
  # Waifu2x has two programs to check for so add them both to the lists.
  if (!(TestPath -LiteralPath $Waifu2xPath))
  {
    $FileNameArray.Add('waifu2x-caffe-cui.exe')
    $FileNameArray.Add('waifu2x-converter-cpp.exe')
    $DescriptionArray.Add('Waifu2x-Caffe')
    $DescriptionArray.Add('Waifu2x-CPP')
  }
  # Display an "Open Folder" menu to get the path. Get-FileName already handles arrays so no need to worry about extra shit.
  $SelectedPath = Get-FileName -StartPath $BaseFolder -FileName $FileNameArray -Description $DescriptionArray

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Get the name of the tool so parameters for it can be set up.
    $ToolName = (Get-Item -LiteralPath $SelectedPath).BaseName

    # Set up parameters based on the selected tool.
    switch -wildcard ($ToolName)
    {
      # Set the values for the xBRZ Scaler Test.
      'ScalerTest*' {
                      $Filter  = 'xBRZ'
                      $TextBox = $OptionsScalerTestTextBox
                      $VarName = 'ScalerTestPath'
                    }
      # Set the values for waifu2x Caffe or CPP.
      'waifu2x*'    { 
                      $Filter  = 'Waifu2x'
                      $TextBox = $OptionsWaifu2xTextBox
                      $VarName = 'Waifu2xPath'
                    }
    }
    # Make sure the tool is not already on the list.
    if (!($ComboBox.Items.Contains($Filter)))
    {
      # Call the function that is used when updating paths.
      LoadExternalFile -TextBox $TextBox -ToolPathName $VarName -ToolPath $SelectedPath
    }
    # Force the selected item to recently added tool.
    $global:FilterSelected = $ComboBox.SelectedItem = $Filter
  }
}
#==============================================================================================================================================================================================
#  Because so much happens when the combo box for filters is changed, it has its very own function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpscaleFilterSelection()
{
  # Use a switch to create the "UpscaleFilter" variable.
  switch -wildcard ($this.SelectedItem)
  {
    # Allow adding filters to the menu.
    'Add*'    {
                # Run the function to add an external filter program to the script.
                AddUpscaleFilterFromFile -ComboBox $this

                # Exit afterwards so the the "FilterSelected" variable isn't overwritten with "Add Filter..".
                return
              }
    # Check if xBRZ was selected as the filter.
    'xBRZ'    {
                # Store the strength in the chosen filter.
                $global:UpscaleFilter = $UpscaleFactor.ToString() + 'xBRZ'

                # Toggle the filter specific options.
                $UpscaleAdditionalOptions.Hide()
              }
    # Check to see if waifu2x was selected as the filter.
    'Waifu2x' {
                # Store the strength in the chosen filter.
                $global:UpscaleFilter = 'waifu' + $UpscaleFactor.ToString() + 'x'

                # Test if the path to waifu2x is valid to avoid errors.
                if (TestPath -LiteralPath $Waifu2xPath)
                {
                  # Update the visibility of all waifu2x options.
                  Waifu2x_UpdateAppSpecificOptions
                }
                # Toggle the filter specific options.
                $UpscaleAdditionalOptions.Show()
              }
    # Check to see if ESRGAN was selected as the filter.
    'ESRGAN'  {
                # Store the strength in the chosen filter.
                $global:UpscaleFilter = 'ESRGAN'

                # Force the upscale factor to 4 before locking it.
                $global:UpscaleFactor = 4
                $UpscaleFactorNumBox.Value = 4

                # Toggle the filter specific options.
                $UpscaleAdditionalOptions.Show()

                # Annoying, but must be done.
                PopulateSuperScalerModels
              }
    # Check to see if ESRGAN was selected as the filter.
    'SFTGAN'  {
                # Store the strength in the chosen filter.
                $global:UpscaleFilter = 'SFTGAN-' + $UpscaleFactor.ToString() + 'x'

                # SFTGAN looks like shit above 4x upscale.
                $global:UpscaleFactor = 4
                $UpscaleFactorNumBox.Value = 4
                $UpscaleFactorNumBox.Minimum = 1
                $UpscaleFactorNumBox.Maximum = 4

                # Toggle the filter specific options.
                $UpscaleAdditionalOptions.Show()

                # Annoying, but must be done.
                PopulateSuperScalerModels
              }
    # All that remains are ImageMagick filters.
    default   {
                # Force it to lowercase so it can be passed to ImageMagick.
                $global:UpscaleFilter = $this.SelectedItem.ToLower()

                # Toggle the filter specific options
                $UpscaleAdditionalOptions.Hide()
              }
  }
  # Store the current selected filter to compare to the new value.
  $global:FilterSelected = $this.SelectedItem

  # Disable these options when selecting ESRGAN and SFTGAN.
  $UpscaleFactorNumBox.Enabled = ($this.SelectedItem -ne 'ESRGAN')
  $UpscaleFactorLabel.Enabled  = ($this.SelectedItem -ne 'ESRGAN')
  $UpscaleFactorTarget.Enabled = ($this.SelectedItem -notlike '*GAN*')

  # Restore the upscale factor maximum if it's not SFTGAN.
  if ($this.SelectedItem -ne 'SFTGAN') { $UpscaleFactorNumBox.Minimum = 2 ; $UpscaleFactorNumBox.Maximum = 16 }
}
#==============================================================================================================================================================================================
#  Whenever the upscale factor is changed, the value must be applied to the global variable that stores the filter + strength.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateUpscaleFilter($NewValue)
{
  # Use a switch to update the "UpscaleFilter" variable.
  switch ($FilterSelected)
  {
    # xBRZ and Waifu2x store the strength in the filter. ImageMagick filters don't, but update them anyway.
    'xBRZ'    { $global:UpscaleFilter = $NewValue.ToString() + 'xBRZ' }
    'Waifu2x' { $global:UpscaleFilter = 'waifu' + $NewValue.ToString() + 'x' }

    # Set the filter to ESRGAN.
    'ESRGAN'  { $global:UpscaleFilter = $FilterSelected }

    # We can use the upscaling factor for SFTGAN.
    'SFTGAN'  { $global:UpscaleFilter = $FilterSelected + '-' + $NewValue.ToString() + 'x' }

    # By default just use the upscaling filter's name.
    default   { $global:UpscaleFilter = $FilterSelected.ToLower() }
  }
}
#==============================================================================================================================================================================================
#  Updates the VRAM path with the path that was added.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function VRAM_UpdateFolderPath($Path)
{
  # Don't allow a final backslash in the path since it will be added manually.
  $Path = PathTruncateSlash -Path $Path

  # Update the global with the new value.
  $global:VRAMPackPath = $Path

  # Update the text box with the new path.
  $VRAMPathTextBox.Text = $Path

  # Override the master input path. It will be restored after the MasterLoop ends.
  MasterPaths_Override -InputPath $VRAMPackPath
}
#==============================================================================================================================================================================================
#  Allows updating the VRAM path with a drag and drop.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function VRAM_UpdateFolderPathDragAndDrop()
{
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedPath = [string]($_.Data.GetData([Windows.Forms.DataFormats]::FileDrop))

    # Make sure the path is a folder.
    if ((TestPath -LiteralPath $DroppedPath -PathType 'Container'))
    {
      # Finish setting the VRAM path.
      VRAM_UpdateFolderPath -Path $DroppedPath
    }
  }
}
#==============================================================================================================================================================================================
#  Allows updating the VRAM path by editing the textbox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function VRAM_UpdateFolderPathTextBox()
{
  # Get the current value of the variable and the textbox text.
  $CurrentPath = Get-Variable -Name $this.Name -ValueOnly
  $EnteredText = $this.Text

  # Check to see if the text actually changed and that the path actually exists.
  if (($EnteredText -ne '') -and (TestPath -LiteralPath $EnteredText))
  {
    # Finish setting the VRAM path.
    VRAM_UpdateFolderPath -Path $EnteredText

    # We're done here. Get out now!
    return
  }
  # Set the textbox text back to the default.
  $this.Text = '<<-- Add with the button or drag and drop a folder -->>'
}
#==============================================================================================================================================================================================
#  Allows updating the VRAM path with a button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function VRAM_UpdateFolderPathButton()
{
  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-Folder -StartPath $DesktopPath

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Finish setting the VRAM path.
    VRAM_UpdateFolderPath -Path $SelectedPath
  }
}
#==============================================================================================================================================================================================
#  When toggling a "Use previous path" checkbox, also update the others found on other ToCS options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToCS_TogglePreviousPathChecks()
{
  $ToCSConvertPrevPath.Checked = $this.Checked
  $ToCSCreatePrevPath.Checked  = $this.Checked
  $ToCSRepackPrevPath.Checked  = $this.Checked
}
#==============================================================================================================================================================================================
#  When toggling a "Only Scan Phyre" checkbox, also update the others found on other ToCS options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToCS_ToggleOnlyScanPhyreChecks()
{
  $ToCSConvertPhyreScan.Checked = $this.Checked
  $ToCSCreatePhyreScan.Checked  = $this.Checked
}
#==============================================================================================================================================================================================
#  Updates the texture format list on ToCS options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateToCSPhyreFormatList()
{
  # Store the item that was previously selected.
  $PreviouslySelected = ""

  # If the list was already created and an item selected, then store what was selected.
  if ($ToCSCreateFormatCombo.SelectedItem -ne $null) { $PreviouslySelected = $ToCSCreateFormatCombo.SelectedItem.ToString(); }

  # Remove everything from the list before rebuilding it.
  $ToCSCreateFormatCombo.Items.Clear();

  # Add back items for PNG and BMP formats.
  if (($ToCSCreateExtension.SelectedItem -eq 'PNG') -or ($ToCSCreateExtension.SelectedItem -eq 'BMP'))
  {
    # They don't have too many options, just uncompressed pixels.
    $ToCSCreateFormatCombo.Items.Add('Source') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('RGBA8') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('ARGB8') | Out-Null
  }
  # And of course the lone wolf DDS.
  else
  {
    # There are several types of DDS images to create.
    $ToCSCreateFormatCombo.Items.Add('Source') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('RGBA8') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('ARGB8') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('DXT1') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('DXT3') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('DXT5') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('L8') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('LA8') | Out-Null
    $ToCSCreateFormatCombo.Items.Add('BC7') | Out-Null
  }
  # If the previously selected item still exists on the list select it.
  if ($ToCSCreateFormatCombo.Items.Contains($PreviouslySelected)) { $ToCSCreateFormatCombo.SelectedItem = $PreviouslySelected }

  # If not just pick "Source" as it's the start of the list.
  else { $ToCSCreateFormatCombo.SelectedItem = 'Source' }  
}
#==============================================================================================================================================================================================
#  Selects the appropriate option from the list. $NUL (references ".nul") which is a fake file extension that translates into 'Source'. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToCS_GetSelectedFormat()
{
  # If the stored extension is ".nul", then set the menu to source.
  if ($PhyreExtension -eq $NUL)
  {
    # Set the list item to "Source" triggered by our fake extension.
    return 'Source'
  }
  # Set the item to whatever other extension is stored.
  return ExtensionToText -Extension $PhyreExtension
}
#==============================================================================================================================================================================================
# The file extension must be translated. Since "Source" is not a file extension it uses "null" to identify it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToCS_SelectOutputFormat()
{
  # Basically "null" means to use the "source" format.
  if ($this.SelectedItem -eq 'Source')
  {
    $NewValue = '.nul'
  }
  # Otherwise, get the extension from the variable.
  else
  {
    $NewValue = Get-Variable -Name $this.SelectedItem -ValueOnly
  }
  # Update the format list.
  PopulateToCSPhyreFormatList

  # Do the usual combobox stuff.
  ComboBoxStateChanged -NewValue $NewValue
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - FORMAT OPTIONS
#==============================================================================================================================================================================================
#  Toggles which options are visible when pressing the format buttons.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleFormatOptions()
{
  # Modify the size of the previously selected button.
  $PrevButtonName = 'Format' + $StoredFormatMenu + 'Button'
  $PrevButtonVars = Get-Variable -Name $PrevButtonName -ValueOnly
  $PrevButtonVars.Size = New-Object Drawing.Size($PrevButtonVars.Size.Width, ($PrevButtonVars.Size.Height - 2))

  # Modify the size of the currently selected button.
  $CurrButtonName = 'Format' + $this.Name + 'Button'
  $CurrButtonVars = Get-Variable -Name $CurrButtonName -ValueOnly
  $CurrButtonVars.Size = New-Object Drawing.Size($CurrButtonVars.Size.Width, ($CurrButtonVars.Size.Height + 2))

  # Set the previously selected panel to invisible.
  $PrevPanelName = 'Main' + $StoredFormatMenu + 'OptionsPanel'
  $PrevPanelVars = Get-Variable -Name $PrevPanelName -ValueOnly
  $PrevPanelVars.Visible = $false

  # Set the currently selected panel to visible.
  $CurrPanelName = 'Main' + $this.Name + 'OptionsPanel'
  $CurrPanelVars = Get-Variable -Name $CurrPanelName -ValueOnly
  $CurrPanelVars.Visible = $true

  # Update the variable that stores the currently selected panel.
  $global:StoredFormatMenu = $this.Name
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - CREATION
#==============================================================================================================================================================================================
#  The main dialog that holds all important options and buttons.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_MainDialog()
{
  # Create the dialog that is displayed.
  $global:MainDialog = New-Object Windows.Forms.Form

  # Default properties for the main window.
  $MainDialog.Text = 'CTT-PS Main Window (v' + $ScriptVersion + ')'
  $MainDialog.MaximizeBox = $false
  $MainDialog.FormBorderStyle = GetFormBorderStyle
  $MainDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None

  # The remaining properties are shared between both modes.
  $MainDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', (DPISize 11), [System.Drawing.FontStyle]::Regular, [System.Drawing.GraphicsUnit]::Pixel)
  $MainDialog.Size = DPISize (New-Object Drawing.Size(416, 628))
  $MainDialog.MinimumSize = DPISize (New-Object Drawing.Size(416, 628))
  $MainDialog.MaximumSize = DPISize (New-Object Drawing.Size(416, 628))
  $MainDialog.StartPosition = "CenterScreen"
  $MainDialog.KeyPreview = $true
  $MainDialog.Topmost = !$DisableTopMost
  $MainDialog.Visible = $false
  $MainDialog.Add_Shown({ MainDialogInit })
  $MainDialog.Add_KeyDown({ EscapeCloseDialog })
  $MainDialog.Add_SizeChanged({ MinimizeAllDialogs ; TexList_CenterWaitLabel })
  $MainDialog.Add_FormClosing({ TexList_MainDialog_XButton })
  $MainDialog.Icon = $Icon_CTTPSBlue

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:MainFocusLabel = New-Object Windows.Forms.Label
  $MainFocusLabel.Size = New-Object Drawing.Size(1,1)
  $MainFocusLabel.Location = New-Object Drawing.Point(0,0)
  $MainDialog.Controls.Add($MainFocusLabel)

  # Create a panel for the main dialog to put all the controls on.
  $global:MainDialogPanel = New-Object Windows.Forms.Panel
  $MainDialogPanel.Size = DPISize (New-Object Drawing.Size(400, 620))
  $MainDialogPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $MainDialog.Controls.Add($MainDialogPanel)

  # Create a panel for "Docked Mode" (1/4).
  $global:MainDockedPanelA = New-Object Windows.Forms.Panel
  $MainDockedPanelA.Size = DPISize (New-Object Drawing.Size(400, 208))
  $MainDockedPanelA.Location = DPISize (New-Object Drawing.Point(0, 0))
  $MainDockedPanelA.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Top)
  $MainDockedPanelA.Visible = $false
  $MainDockedPanelA.BackColor = [Drawing.Color]::Transparent
  $MainDialog.Controls.Add($MainDockedPanelA)

  # Create a panel for "Docked Mode" (2/4).
  $global:MainDockedPanelB = New-Object Windows.Forms.Panel
  $MainDockedPanelB.Size = DPISize (New-Object Drawing.Size(400, 208))
  $MainDockedPanelB.Location = DPISize (New-Object Drawing.Point(400, 0))
  $MainDockedPanelB.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Top)
  $MainDockedPanelB.Visible = $false
  $MainDockedPanelB.BackColor = [Drawing.Color]::Transparent
  $MainDialog.Controls.Add($MainDockedPanelB)

  # Create a panel for "Docked Mode" (3/4).
  $global:MainDockedPanelC = New-Object Windows.Forms.Panel
  $MainDockedPanelC.Size = DPISize (New-Object Drawing.Size(400, 208))
  $MainDockedPanelC.Location = DPISize (New-Object Drawing.Point(800, 0))
  $MainDockedPanelC.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Top)
  $MainDockedPanelC.Visible = $false
  $MainDockedPanelC.BackColor = [Drawing.Color]::Transparent
  $MainDialog.Controls.Add($MainDockedPanelC)

  # Create a panel for "Docked Mode" buttons (4/4).
  $global:MainDockedButtonsPanel = New-Object Windows.Forms.Panel
  $MainDockedButtonsPanel.Size = DPISize (New-Object Drawing.Size(1216, 150))
  $MainDockedButtonsPanel.Location = DPISize (New-Object Drawing.Point(0, 550))
  $MainDockedButtonsPanel.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Right)
  $MainDockedButtonsPanel.Visible = $false
  $MainDockedButtonsPanel.BackColor = [Drawing.Color]::Transparent
  $MainDialog.Controls.Add($MainDockedButtonsPanel)

  # CTT-PS Options: Create a groupbox.
  $global:MainCTTPSGroup = New-Object Windows.Forms.GroupBox
  $MainCTTPSGroup.Size = DPISize (New-Object Drawing.Size(380, 42))
  $MainCTTPSGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $MainCTTPSGroup.Text = ' CTT-PS Options '
  $MainDialogPanel.Controls.Add($MainCTTPSGroup)

  # CTT-PS Options: Create a tooltip for the groupbox.
  $MainCTTPSGroupTip = New-Object Windows.Forms.ToolTip
  $MainCTTPSGroupTip.InitialDelay = $ToolTipDelay
  $MainCTTPSGroupTip.AutoPopDelay = $ToolTipDuration
  $MainCTTPSGroupTipString = 'Affects the behavior of this script.'
  $MainCTTPSGroupTip.SetToolTip($MainCTTPSGroup, $MainCTTPSGroupTipString)

  # CTT-PS Options: CTT-PS Mode - Create a combobox to hold the choices.
  $global:MainCTTPSCombo = New-Object Windows.Forms.ComboBox
  $MainCTTPSCombo.Size = DPISize (New-Object Drawing.Size(112, 20))
  $MainCTTPSCombo.Location = DPISize (New-Object Drawing.Point(10, 15))
  $MainCTTPSCombo.Name = 'CTTPSSelectedMode'
  $MainCTTPSCombo.Items.Add('Dolphin Mode') | Out-Null
  $MainCTTPSCombo.Items.Add('Expert Mode') | Out-Null
  $MainCTTPSCombo.Items.Add('Database Mode') | Out-Null
  $MainCTTPSCombo.Items.Add('Phyre Mode') | Out-Null
  $MainCTTPSCombo.Items.Add('Metroid Prime') | Out-Null
  $MainCTTPSCombo.SelectedItem = $CTTPSSelectedMode
  $MainCTTPSCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainCTTPSCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; CTT-PSModeSelected -Selection $this.SelectedItem })
  $MainCTTPSCombo.Parent = $null
  $MainCTTPSCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainCTTPSCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainCTTPSCombo.Add_DrawItem({ RepopulateComboBox })
#  $MainCTTPSCombo.Region = New-Object Drawing.Region(New-Object Drawing.Rectangle(1, 1, ($MainCTTPSCombo.Width - 2), ($MainCTTPSCombo.Height - 2)))
#  $MainCTTPSCombo.FlatStyle = [Windows.Forms.FlatStyle]::System
  $MainCTTPSGroup.Controls.Add($MainCTTPSCombo)

  # CTT-PS Options: CTT-PS Mode - Create a label.
  $global:MainCTTPSLabel = New-Object Windows.Forms.Label
  $MainCTTPSLabel.Size = DPISize (New-Object Drawing.Size(78, 16))
  $MainCTTPSLabel.Location = DPISize (New-Object Drawing.Point(124, 18))
  $MainCTTPSLabel.Text = 'CTT-PS Mode'
  $MainCTTPSGroup.Controls.Add($MainCTTPSLabel)

  # CTT-PS Options: CTT-PS Mode - Create a tooltip.
  $MainCTTPSTip = New-Object Windows.Forms.ToolTip
  $MainCTTPSTip.InitialDelay = $ToolTipDelay
  $MainCTTPSTip.AutoPopDelay = $ToolTipDuration
  $MainCTTPSTipString = 'Changes the options available and the way this script functions.{0}'
  $MainCTTPSTipString += '{0}'
  $MainCTTPSTipString += 'Expert Mode: Any image file can be processed by this script, and{0}'
  $MainCTTPSTipString += 'multiple DDS compression types become available. Additional{0}'
  $MainCTTPSTipString += 'options are also unlocked such as forcing DX10 headers.{0}'
  $MainCTTPSTipString += '{0}'
  $MainCTTPSTipString += 'Dolphin Mode: Only process images prefixed with "tex1", and hide{0}'
  $MainCTTPSTipString += 'options and DDS compression types that are not useful for Dolphin{0}'
  $MainCTTPSTipString += 'texture packs. Images that do not have the "tex1" prefix are ignored.{0}'
  $MainCTTPSTipString += '{0}'
  $MainCTTPSTipString += 'Database Mode: This mode allows creating and working with texture{0}'
  $MainCTTPSTipString += 'database files that store the dimensions of texture names and their{0}'
  $MainCTTPSTipString += "dimensions. It's important to generate databases from unmodified{0}"
  $MainCTTPSTipString += "dumps so the original dimensions are stored for reference. This will{0}"
  $MainCTTPSTipString += "allow textures to take advantage of operations and features that{0}"
  $MainCTTPSTipString += "only Dolphin textures could take advantage of because they have the{0}"
  $MainCTTPSTipString += "dimensions in the file name.{0}"
  $MainCTTPSTipString += '{0}'  
  $MainCTTPSTipString += 'Phyre Mode: Allow working with phyre engine images specifically{0}'
  $MainCTTPSTipString += 'used in Trails of Cold Steel I & II. All standard and advanced options{0}'
  $MainCTTPSTipString += 'will be tailored towards working with and converting these textures.{0}'
  $MainCTTPSTipString += 'It is confirmed editing Final Fantasy X/X2 textures is also possible.{0}'
  $MainCTTPSTipString += '{0}'
  $MainCTTPSTipString += 'Metroid Prime: Contains a single operation that can automate{0}'
  $MainCTTPSTipString += 'generating the thousands of font textures found in Metroid Prime 2{0}'
  $MainCTTPSTipString += 'by providing a single texture for each variation of the texture. The{0}'
  $MainCTTPSTipString += 'script will take the base textures and generate each color provided{0}'
  $MainCTTPSTipString += 'as a dump. See the "Help" topic for more information on this.'
  $MainCTTPSTipString = [String]::Format($MainCTTPSTipString, [Environment]::NewLine)
  $MainCTTPSTip.SetToolTip($MainCTTPSLabel, $MainCTTPSTipString)

  # CTT-PS Options: Texture List Mode - Create a combobox to hold the choices.
  $global:MainTexListCombo = New-Object Windows.Forms.ComboBox
  $MainTexListCombo.Size = DPISize (New-Object Drawing.Size(94, 20))
  $MainTexListCombo.Location = DPISize (New-Object Drawing.Point(208, 15))
  $MainTexListCombo.Name = 'TextureListMode'
  $MainTexListCombo.Items.Add('Window') | Out-Null
  $MainTexListCombo.Items.Add('Hidden') | Out-Null
  $MainTexListCombo.Items.Add('Docked') | Out-Null
  $MainTexListCombo.SelectedItem = $TextureListMode
  $MainTexListCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainTexListCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; TexList_ToggleVisibility -TexListMode $MainTexListCombo.SelectedItem})
  $MainTexListCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainTexListCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainTexListCombo.Add_DrawItem({ RepopulateComboBox })
  $MainCTTPSGroup.Controls.Add($MainTexListCombo)

  # CTT-PS Options: Texture List Mode - Create a label.
  $global:MainTexListLabel = New-Object Windows.Forms.Label
  $MainTexListLabel.Size = DPISize (New-Object Drawing.Size(72, 16))
  $MainTexListLabel.Location = DPISize (New-Object Drawing.Point(305, 18))
  $MainTexListLabel.Text = 'Texture List'
  $MainCTTPSGroup.Controls.Add($MainTexListLabel)

  # CTT-PS Options: Texture List Mode - Create a tooltip.
  $MainTexListTip = New-Object Windows.Forms.ToolTip
  $MainTexListTip.InitialDelay = $ToolTipDelay
  $MainTexListTip.AutoPopDelay = $ToolTipDuration
  $MainTexListTipString =  'Configures the location and{0}'
  $MainTexListTipString += 'visibility of the Texture List.'
  $MainTexListTipString = [String]::Format($MainTexListTipString, [Environment]::NewLine)
  $MainTexListTip.SetToolTip($MainTexListLabel, $MainTexListTipString)

  # Input Path: Create a groupbox.
  $global:MainInputGroup = New-Object Windows.Forms.GroupBox
  $MainInputGroup.Size = DPISize (New-Object Drawing.Size(380, 50))
  $MainInputGroup.Location = DPISize (New-Object Drawing.Point(10, 50))
  $MainInputGroup.Text = ' Input Path '
  $MainDialogPanel.Controls.Add($MainInputGroup)

  # Input Path: Create a tooltip.
  $MainInputGroupTip = New-Object Windows.Forms.ToolTip
  $MainInputGroupTip.InitialDelay = $ToolTipDelay
  $MainInputGroupTip.AutoPopDelay = $ToolTipDuration
  $MainInputGroupTipString = 'Path to the folder that contains textures.'
  $MainInputGroupTip.SetToolTip($MainInputGroup, $MainInputGroupTipString)

  # Input Path: Checkbox to save the master input path when the script is closed.
  $global:MainStoreInput = New-Object Windows.Forms.CheckBox
  $MainStoreInput.Size = DPISize (New-Object Drawing.Size(16, 16))
  $MainStoreInput.Location = DPISize (New-Object Drawing.Point(5, 21))
  $MainStoreInput.Name = 'StoreInputFolder'
  $MainStoreInput.Text = ''
  $MainStoreInput.Checked = $StoreInputFolder
  $MainStoreInput.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainStoreInput.Enabled = $EnableStoring
  $MainInputGroup.Controls.Add($MainStoreInput)

  # Input Path: Create a tooltip for the for the checkbox.
  $MainStoreInputTip = New-Object Windows.Forms.ToolTip
  $MainStoreInputTip.InitialDelay = 300
  $MainStoreInputTip.AutoPopDelay = $ToolTipDuration
  $MainStoreInputTipString =  'Saves the selected Input Path when the script{0}'
  $MainStoreInputTipString += 'is closed. If the preference to save changes on{0}'
  $MainStoreInputTipString += 'exit is disabled, this box will have no effect.'
  $MainStoreInputTipString = [String]::Format($MainStoreInputTipString, [Environment]::NewLine)
  $MainStoreInputTip.SetToolTip($MainStoreInput, $MainStoreInputTipString)

  # Input Path: Create a textbox to display the path.
  $global:MainInputTextBox = New-Object Windows.Forms.TextBox
  $MainInputTextBox.Size = DPISize (New-Object Drawing.Size(300, 22))
  $MainInputTextBox.Location = DPISize (New-Object Drawing.Point(22, 18)) -AddY $DPIOffsetFix
  $MainInputTextBox.Name = 'MasterInputPath'
  $MainInputTextBox.Text = $MasterInputPath
  $MainInputTextBox.AllowDrop = $true
  $MainInputTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $MainInputTextBox.Add_DragDrop({ UpdateMasterPaths_DragAndDrop })
  $MainInputTextBox.Add_Click({ ClearTextBox })
  $MainInputTextBox.Add_Leave({ UpdateMasterPaths_TextBox })
  $MainInputGroup.Controls.Add($MainInputTextBox)

  # Input Path: Create a button to select the path.
  $global:MainInputButton = New-Object Windows.Forms.Button
  $MainInputButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $MainInputButton.Location = DPISize (New-Object Drawing.Point(325, 17))
  $MainInputButton.Name = 'MasterInputPath'
  $MainInputButton.Text = '...'
  $MainInputButton.Add_Click({ UpdateMasterPaths_Button })
  $MainInputGroup.Controls.Add($MainInputButton)

  # Input Path: Create a button to open the path in explorer.
  $global:MainInputFolder = New-Object Windows.Forms.Button
  $MainInputFolder.Size = DPISize (New-Object Drawing.Size(22, 22))
  $MainInputFolder.Location = DPISize (New-Object Drawing.Point(349, 17))
  $MainInputFolder.Image = $Image_Folder
  $MainInputFolder.Add_Click({ if (TestPath -LiteralPath $MasterInputPath) { Invoke-Item -LiteralPath $MasterInputPath } })
  $MainInputGroup.Controls.Add($MainInputFolder)

  # Input Path: Create a tooltip for the folder path.
  $MainInputFolderTip = New-Object Windows.Forms.ToolTip
  $MainInputFolderTip.InitialDelay = $ToolTipDelay
  $MainInputFolderTip.AutoPopDelay = $ToolTipDuration
  $MainInputFolderTipString = 'Open the "Input Path" in explorer.'
  $MainInputFolderTip.SetToolTip($MainInputFolder, $MainInputFolderTipString)

  # Output Path: Create a groupbox.
  $global:MainOutputGroup = New-Object Windows.Forms.GroupBox
  $MainOutputGroup.Size = DPISize (New-Object Drawing.Size(380, 50))
  $MainOutputGroup.Location = DPISize (New-Object Drawing.Point(10, 103))
  $MainOutputGroup.Text = ' Output Path '
  $MainDialogPanel.Controls.Add($MainOutputGroup)

  # Output Path: Create a tooltip.
  $MainOutputGroupTip = New-Object Windows.Forms.ToolTip
  $MainOutputGroupTip.InitialDelay = $ToolTipDelay
  $MainOutputGroupTip.AutoPopDelay = $ToolTipDuration
  $MainOutputGroupTipString = 'Path to where this script will generate textures.'
  $MainOutputGroupTip.SetToolTip($MainOutputGroup, $MainOutputGroupTipString)

  # Output Path: Checkbox to save the master output path when the script is closed.
  $global:MainStoreOutput = New-Object Windows.Forms.CheckBox
  $MainStoreOutput.Size = DPISize (New-Object Drawing.Size(16, 16))
  $MainStoreOutput.Location = DPISize (New-Object Drawing.Point(5, 23))
  $MainStoreOutput.Name = 'StoreOutputFolder'
  $MainStoreOutput.Text = ''
  $MainStoreOutput.Checked = $StoreOutputFolder
  $MainStoreOutput.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainStoreOutput.Enabled = $EnableStoring
  $MainOutputGroup.Controls.Add($MainStoreOutput)

  # Output Path: Create a tooltip for the for the checkbox.
  $MainStoreOutputTip = New-Object Windows.Forms.ToolTip
  $MainStoreOutputTip.InitialDelay = 300
  $MainStoreOutputTip.AutoPopDelay = $ToolTipDuration
  $MainStoreOutputTipString = 'Saves the selected Output Path when the script{0}'
  $MainStoreOutputTipString += 'is closed. If the preference to save changes on{0}'
  $MainStoreOutputTipString += 'exit is disabled, this box will have no effect.'
  $MainStoreOutputTipString = [String]::Format($MainStoreOutputTipString, [Environment]::NewLine)
  $MainStoreOutputTip.SetToolTip($MainStoreOutput, $MainStoreOutputTipString)

  # Output Path: Create a textbox to display the path.
  $global:MainOutputTextBox = New-Object Windows.Forms.TextBox
  $MainOutputTextBox.Size = DPISize (New-Object Drawing.Size(300, 22))
  $MainOutputTextBox.Location = DPISize (New-Object Drawing.Point(22, 20)) -AddY $DPIOffsetFix
  $MainOutputTextBox.Name = 'MasterOutputPath'
  $MainOutputTextBox.Text = $MasterOutputPath
  $MainOutputTextBox.AllowDrop = $true
  $MainOutputTextBox.Add_DragEnter({$_.Effect = [Windows.Forms.DragDropEffects]::Copy})
  $MainOutputTextBox.Add_DragDrop({ UpdateMasterPaths_DragAndDrop })
  $MainOutputTextBox.Add_Click({ ClearTextBox })
  $MainOutputTextBox.Add_Leave({ UpdateMasterPaths_TextBox })
  $MainOutputGroup.Controls.Add($MainOutputTextBox)

  # Output Path: Create a button to select the path.
  $global:MainOutputButton = New-Object Windows.Forms.Button
  $MainOutputButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $MainOutputButton.Location = DPISize (New-Object Drawing.Point(325, 19))
  $MainOutputButton.Name = 'MasterOutputPath'
  $MainOutputButton.Text = '...'
  $MainOutputButton.Add_Click({ UpdateMasterPaths_Button })
  $MainOutputGroup.Controls.Add($MainOutputButton)

  # Output Path: Create a button to open the path in explorer.
  $global:MainOutputFolder = New-Object Windows.Forms.Button
  $MainOutputFolder.Size = DPISize (New-Object Drawing.Size(22, 22))
  $MainOutputFolder.Location = DPISize (New-Object Drawing.Point(349, 19))
  $MainOutputFolder.Image = $Image_Folder
  $MainOutputFolder.Add_Click({
                                $MasterOutputPathB = $MasterOutputPath.Replace('\~CTT_Generated','')
                                if (TestPath -LiteralPath $MasterOutputPath) { Invoke-Item -LiteralPath $MasterOutputPath }
                                elseif (TestPath -LiteralPath $MasterOutputPathB) { Invoke-Item -LiteralPath $MasterOutputPathB }
                              })
  $MainOutputGroup.Controls.Add($MainOutputFolder)

  # Output Path: Create a tooltip for the folder path.
  $MainOutputFolderTip = New-Object Windows.Forms.ToolTip
  $MainOutputFolderTip.InitialDelay = $ToolTipDelay
  $MainOutputFolderTip.AutoPopDelay = $ToolTipDuration
  $MainOutputFolderTipString = 'Open the "Output Path" in explorer.'
  $MainOutputFolderTip.SetToolTip($MainOutputFolder, $MainOutputFolderTipString)

  # Operation: Create a groupbox.
  $global:MainOperationsGroup = New-Object Windows.Forms.GroupBox
  $MainOperationsGroup.Size = DPISize (New-Object Drawing.Size(380, 54))
  $MainOperationsGroup.Location = DPISize (New-Object Drawing.Point(10, 156))
  $MainOperationsGroup.Text = ' Operation '
  $MainDialogPanel.Controls.Add($MainOperationsGroup)

  # Output Path: Create a tooltip for the for the checkbox.
  $MainOperationsGroupTip = New-Object Windows.Forms.ToolTip
  $MainOperationsGroupTip.InitialDelay = 300
  $MainOperationsGroupTip.AutoPopDelay = $ToolTipDuration
  $MainOperationsGroupTipString = 'The operation that takes place{0}'
  $MainOperationsGroupTipString += 'when pressing the Start button.{0}'
  $MainOperationsGroupTipString += 'Press [?] button to learn more.'
  $MainOperationsGroupTipString = [String]::Format($MainOperationsGroupTipString, [Environment]::NewLine)
  $MainOperationsGroupTip.SetToolTip($MainOperationsGroup, $MainOperationsGroupTipString)

  # Operation: The list of operations presented in a drop-down menu.
  $global:MainOperations = New-Object Windows.Forms.ComboBox
  $MainOperations.Size = DPISize (New-Object Drawing.Size(334, 116))
  $MainOperations.Location = DPISize (New-Object Drawing.Point(10, 19)) -AddY $DPIOffsetFix
  $MainOperations.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainOperations.Add_SelectedIndexChanged({ UpdateSelectedOperation -ComboBox $MainOperations })
  $MainOperations.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainOperations.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainOperations.Add_DrawItem({ RepopulateComboBox })
  $MainOperationsGroup.Controls.Add($MainOperations)

  # Operation: A help button that quickly explains the selected option.
  $global:MainQuickHelp = New-Object Windows.Forms.Button
  $MainQuickHelp.Size = DPISize (New-Object Drawing.Size(24, 23))
  $MainQuickHelp.Location = DPISize (New-Object Drawing.Point(347, 18))
  $MainQuickHelp.Font = New-Object Drawing.Font('Microsoft Sans Serif', 10)
  $MainQuickHelp.Text = '?'
  $MainQuickHelp.Add_Click({ LaunchQuickHelpMenu })
  $MainQuickHelp.Visible = $ShowQuickHelpIcon
  $MainOperationsGroup.Controls.Add($MainQuickHelp)

  # Operation: Create a tip for the button.
  $MainQuickHelpTip = New-Object Windows.Forms.ToolTip
  $MainQuickHelpTip.InitialDelay = 200
  $MainQuickHelpTip.AutoPopDelay = $ToolTipDuration
  $MainQuickHelpTipString = 'Open the Help dialog and quickly{0}'
  $MainQuickHelpTipString += "link to this operation's help topic."
  $MainQuickHelpTipString = [String]::Format($MainQuickHelpTipString, [Environment]::NewLine)
  $MainQuickHelpTip.SetToolTip($MainQuickHelp, $MainQuickHelpTipString)

  # Format Options: The group that holds options to configure various formats: PNG, DDS, JPG, BMP, TIFF
  $global:MainFormatTexGroup = New-Object Windows.Forms.GroupBox
  $MainFormatTexGroup.Size = DPISize (New-Object Drawing.Size(380, 110))
  $MainFormatTexGroup.Location = DPISize (New-Object Drawing.Point(10, 347))
  $MainFormatTexGroup.Text = ''
  $MainDialogPanel.Controls.Add($MainFormatTexGroup)

  # Format Options: Determine the size of all buttons.
  $FormatButtonSizeX = [int]($MainFormatTexGroup.Size.Width / 5)
  $FormatButtonSizeY = DPISize 24

  # To fit the text in all DPI, modify the button font size for all buttons.
  $FormatButtonFont = New-Object Drawing.Font('Microsoft Sans Serif', 7.5)

  # Format Options: Create a panel for DDS.
  $global:FormatDDSPanel = New-Object Windows.Forms.Panel
  $FormatDDSPanel.Size = New-Object Drawing.Size($FormatButtonSizeX, $FormatButtonSizeY)
  $FormatDDSPanel.Location = New-Object Drawing.Point(0, 0)
  $FormatDDSPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#dcdcdc')
  $MainFormatTexGroup.Controls.Add($FormatDDSPanel)

  # Format Options: Find the height of the DDS button.
  if ($StoredFormatMenu -eq 'DDS') { $ButtonHeight = $FormatDDSPanel.Size.Height } else { $ButtonHeight = $FormatDDSPanel.Size.Height - 2 }

  # Format Options: Create a button for DDS.
  $global:FormatDDSButton = New-Object Windows.Forms.Button
  $FormatDDSButton.Size = New-Object Drawing.Size(($FormatDDSPanel.Size.Width - 2), $ButtonHeight)
  $FormatDDSButton.Location = New-Object Drawing.Point(1, 1)
  $FormatDDSButton.Font = $FormatButtonFont
  $FormatDDSButton.Name = 'DDS' 
  $FormatDDSButton.Add_MouseDown({ ToggleFormatOptions })
  $FormatDDSButton.Text = 'DDS Options'
  $FormatDDSButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $FormatDDSButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $FormatDDSButton.FlatAppearance.BorderSize = 0
  $FormatDDSPanel.Controls.Add($FormatDDSButton)

  # Format Options: DDS Options: Create a tooltip for the groupbox.
  $FormatDDSButtonTip = New-Object Windows.Forms.ToolTip
  $FormatDDSButtonTip.InitialDelay = $ToolTipDelay
  $FormatDDSButtonTip.AutoPopDelay = $ToolTipDuration
  $FormatDDSButtonTipString =  'These options affect the way the{0}'
  $FormatDDSButtonTipString += 'script generates DDS textures.'
  $FormatDDSButtonTipString = [String]::Format($FormatDDSButtonTipString, [Environment]::NewLine)
  $FormatDDSButtonTip.SetToolTip($FormatDDSButton, $FormatDDSButtonTipString)

  # Format Options: Set the X position for the PNG button.
  $PNG_X = ($FormatDDSPanel.Right - 1)

  # Format Options: Create a panel for PNG.
  $global:FormatPNGPanel = New-Object Windows.Forms.Panel
  $FormatPNGPanel.Size = New-Object Drawing.Size($FormatButtonSizeX, $FormatButtonSizeY)
  $FormatPNGPanel.Location = New-Object Drawing.Point($PNG_X, 0)
  $FormatPNGPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#dcdcdc')
  $MainFormatTexGroup.Controls.Add($FormatPNGPanel)

  # Format Options: Find the height of the PNG button.
  if ($StoredFormatMenu -eq 'PNG') { $ButtonHeight = $FormatPNGPanel.Size.Height } else { $ButtonHeight = $FormatPNGPanel.Size.Height - 2 }

  # Format Options: Create a button for PNG.
  $global:FormatPNGButton = New-Object Windows.Forms.Button
  $FormatPNGButton.Size = New-Object Drawing.Size(($FormatPNGPanel.Size.Width - 2), $ButtonHeight)
  $FormatPNGButton.Location = New-Object Drawing.Point(1, 1)
  $FormatPNGButton.Font = $FormatButtonFont
  $FormatPNGButton.Name = 'PNG' 
  $FormatPNGButton.Add_MouseDown({ ToggleFormatOptions })
  $FormatPNGButton.Text = 'PNG Options'
  $FormatPNGButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $FormatPNGButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $FormatPNGButton.FlatAppearance.BorderSize = 0
  $FormatPNGPanel.Controls.Add($FormatPNGButton)

  # Format Options: PNG Options: Create a tooltip for the groupbox.
  $FormatPNGButtonTip = New-Object Windows.Forms.ToolTip
  $FormatPNGButtonTip.InitialDelay = $ToolTipDelay
  $FormatPNGButtonTip.AutoPopDelay = $ToolTipDuration
  $FormatPNGButtonTipString =  'These options affect the way the{0}'
  $FormatPNGButtonTipString += 'script generates PNG textures.'
  $FormatPNGButtonTipString = [String]::Format($FormatPNGButtonTipString, [Environment]::NewLine)
  $FormatPNGButtonTip.SetToolTip($FormatPNGButton, $FormatPNGButtonTipString)

  # Format Options: Set the X position for the PNG button.
  $JPG_X = ($FormatPNGPanel.Right - 1)

  # Format Options: Create a panel for JPG.
  $global:FormatJPGPanel = New-Object Windows.Forms.Panel
  $FormatJPGPanel.Size = New-Object Drawing.Size($FormatButtonSizeX, $FormatButtonSizeY)
  $FormatJPGPanel.Location = New-Object Drawing.Point($JPG_X, 0)
  $FormatJPGPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#dcdcdc')
  $MainFormatTexGroup.Controls.Add($FormatJPGPanel)

  # Format Options: Find the height of the JPG button.
  if ($StoredFormatMenu -eq 'JPG') { $ButtonHeight = $FormatJPGPanel.Size.Height } else { $ButtonHeight = $FormatJPGPanel.Size.Height - 2 }

  # Format Options: Create a button for JPG.
  $global:FormatJPGButton = New-Object Windows.Forms.Button
  $FormatJPGButton.Size = New-Object Drawing.Size(($FormatJPGPanel.Size.Width - 2), $ButtonHeight)
  $FormatJPGButton.Location = New-Object Drawing.Point(1, 1)
  $FormatJPGButton.Font = $FormatButtonFont
  $FormatJPGButton.Name = 'JPG' 
  $FormatJPGButton.Add_MouseDown({ ToggleFormatOptions })
  $FormatJPGButton.Text = 'JPG Options'
  $FormatJPGButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $FormatJPGButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $FormatJPGButton.FlatAppearance.BorderSize = 0
  $FormatJPGPanel.Controls.Add($FormatJPGButton)

  # Format Options: JPG Options: Create a tooltip for the groupbox.
  $FormatJPGButtonTip = New-Object Windows.Forms.ToolTip
  $FormatJPGButtonTip.InitialDelay = $ToolTipDelay
  $FormatJPGButtonTip.AutoPopDelay = $ToolTipDuration
  $FormatJPGButtonTipString =  'These options affect the way the{0}'
  $FormatJPGButtonTipString += 'script generates JPG textures.'
  $FormatJPGButtonTipString = [String]::Format($FormatJPGButtonTipString, [Environment]::NewLine)
  $FormatJPGButtonTip.SetToolTip($FormatJPGButton, $FormatJPGButtonTipString)

  # Format Options: Set the X position for the PNG button.
  $BMP_X = ($FormatJPGPanel.Right - 1)

  # Format Options: Create a panel for BMP.
  $global:FormatBMPPanel = New-Object Windows.Forms.Panel
  $FormatBMPPanel.Size = New-Object Drawing.Size($FormatButtonSizeX, $FormatButtonSizeY)
  $FormatBMPPanel.Location = New-Object Drawing.Point($BMP_X, 0)
  $FormatBMPPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#dcdcdc')
  $MainFormatTexGroup.Controls.Add($FormatBMPPanel)

  # Format Options: Find the height of the BMP button.
  if ($StoredFormatMenu -eq 'BMP') { $ButtonHeight = $FormatBMPPanel.Size.Height } else { $ButtonHeight = $FormatBMPPanel.Size.Height - 2 }

  # Format Options: Create a button for BMP.
  $global:FormatBMPButton = New-Object Windows.Forms.Button
  $FormatBMPButton.Size = New-Object Drawing.Size(($FormatBMPPanel.Size.Width - 2), $ButtonHeight)
  $FormatBMPButton.Location = New-Object Drawing.Point(1, 1)
  $FormatBMPButton.Font = $FormatButtonFont
  $FormatBMPButton.Name = 'BMP' 
  $FormatBMPButton.Add_MouseDown({ ToggleFormatOptions })
  $FormatBMPButton.Text = 'BMP Options'
  $FormatBMPButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $FormatBMPButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $FormatBMPButton.FlatAppearance.BorderSize = 0
  $FormatBMPPanel.Controls.Add($FormatBMPButton)

  # Format Options: BMP Options: Create a tooltip for the groupbox.
  $FormatBMPButtonTip = New-Object Windows.Forms.ToolTip
  $FormatBMPButtonTip.InitialDelay = $ToolTipDelay
  $FormatBMPButtonTip.AutoPopDelay = $ToolTipDuration
  $FormatBMPButtonTipString =  'These options affect the way the{0}'
  $FormatBMPButtonTipString += 'script generates BMP textures.'
  $FormatBMPButtonTipString = [String]::Format($FormatBMPButtonTipString, [Environment]::NewLine)
  $FormatBMPButtonTip.SetToolTip($FormatBMPButton, $FormatBMPButtonTipString)

  # Format Options: Set the X position for the PNG button.
  $TIFF_X = ($FormatBMPPanel.Right - 1)

  # Format Options: Create a panel for TIFF.
  $global:FormatTIFPanel = New-Object Windows.Forms.Panel
  $FormatTIFPanel.Size = New-Object Drawing.Size(($FormatButtonSizeX + 4), $FormatButtonSizeY)
  $FormatTIFPanel.Location = New-Object Drawing.Point($TIFF_X, 0)
  $FormatTIFPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#dcdcdc')
  $MainFormatTexGroup.Controls.Add($FormatTIFPanel)

  # Format Options: Find the height of the TIF button.
  if ($StoredFormatMenu -eq 'TIF') { $ButtonHeight = $FormatTIFPanel.Size.Height } else { $ButtonHeight = $FormatTIFPanel.Size.Height - 2 }

  # Format Options: Create a button for TIFF.
  $global:FormatTIFButton = New-Object Windows.Forms.Button
  $FormatTIFButton.Size = New-Object Drawing.Size(($FormatTIFPanel.Size.Width - 2), $ButtonHeight)
  $FormatTIFButton.Location = New-Object Drawing.Point(1, 1)
  $FormatTIFButton.Font = $FormatButtonFont
  $FormatTIFButton.Name = 'TIF' 
  $FormatTIFButton.Add_MouseDown({ ToggleFormatOptions })
  $FormatTIFButton.Text = 'TIFF Options'
  $FormatTIFButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $FormatTIFButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $FormatTIFButton.FlatAppearance.BorderSize = 0
  $FormatTIFPanel.Controls.Add($FormatTIFButton)

  # Format Options: TIFF Options: Create a tooltip for the groupbox.
  $FormatTIFButtonTip = New-Object Windows.Forms.ToolTip
  $FormatTIFButtonTip.InitialDelay = $ToolTipDelay
  $FormatTIFButtonTip.AutoPopDelay = $ToolTipDuration
  $FormatTIFButtonTipString =  'These options affect the way the{0}'
  $FormatTIFButtonTipString += 'script generates TIFF textures.'
  $FormatTIFButtonTipString = [String]::Format($FormatTIFButtonTipString, [Environment]::NewLine)
  $FormatTIFButtonTip.SetToolTip($FormatTIFButton, $FormatTIFButtonTipString)
  
  # Format Options: Sets the size of all main format panels.
  $FormatMainPanelX = $MainFormatTexGroup.Size.Width - 4
  $FormatMainPanelY = $MainFormatTexGroup.Size.Height - 4

  # Format Options: DDS Options: Main Panel
  $global:MainDDSOptionsPanel = New-Object Windows.Forms.Panel
  $MainDDSOptionsPanel.Size = New-Object Drawing.Size($FormatMainPanelX, $FormatMainPanelY)
  $MainDDSOptionsPanel.Location = New-Object Drawing.Point(1, 1)
  $MainDDSOptionsPanel.Visible = ($StoredFormatMenu -eq 'DDS')
  $MainFormatTexGroup.Controls.Add($MainDDSOptionsPanel)

  # Format Options: DDS Options: DDS Tool - Create a combobox.
  $global:MainDDSToolCombo = New-Object Windows.Forms.ComboBox
  $MainDDSToolCombo.Size = DPISize (New-Object Drawing.Size(110, 20))
  $MainDDSToolCombo.Location = DPISize (New-Object Drawing.Point(10, 30))
  $MainDDSToolCombo.Name = 'DDSCreatorTool'
  $MainDDSToolCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainDDSToolCombo.Add_SelectedIndexChanged({ DDSToolSelection -ComboBox $this })
  $MainDDSToolCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainDDSToolCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainDDSToolCombo.Add_DrawItem({ RepopulateComboBox })
  $MainDDSOptionsPanel.Controls.Add($MainDDSToolCombo)

  # Format Options: DDS Options: DDS Tool - Create a label for the option.
  $global:MainDDSToolLabel = New-Object Windows.Forms.Label
  $MainDDSToolLabel.Size = DPISize (New-Object Drawing.Size(72, 16))
  $MainDDSToolLabel.Location = DPISize (New-Object Drawing.Point(121, 33))
  $MainDDSToolLabel.Text = 'DDS Tool'
  $MainDDSOptionsPanel.Controls.Add($MainDDSToolLabel)

  # Format Options: DDS Options: DDS Tool - Create a tooltip for the option.
  $MainDDSToolTip = New-Object Windows.Forms.ToolTip
  $MainDDSToolTip.InitialDelay = $ToolTipDelay
  $MainDDSToolTip.AutoPopDelay = $ToolTipDuration
  $MainDDSToolTipString  = 'Allows selecting the preferred program used to generate DDS textures.{0}'
  $MainDDSToolTipString += 'The script will usually select the appropriate program if available, but{0}'
  $MainDDSToolTipString += 'this option can be used to force a program in certain situations.{0}'
  $MainDDSToolTipString += '{0}'
  $MainDDSToolTipString += 'Compressonator: Uses CompressonatorCLI.exe to create DDS textures.{0}'
  $MainDDSToolTipString += 'Creates very high quality DDS textures in most cases. Can create BC1,{0}'
  $MainDDSToolTipString += 'BC3, BC7, and ARGB8 textures. Highest quality BC7 textures. Selecting{0}'
  $MainDDSToolTipString += 'Compressonator unlocks the "BC7 Quality" option found to the right.{0}'
  $MainDDSToolTipString += '{0}'
  $MainDDSToolTipString += 'TexConv: Uses texconv.exe to create textures. TexConv is much faster{0}'
  $MainDDSToolTipString += 'than the others when creating all types of DDS textures, the downside{0}'
  $MainDDSToolTipString += 'is at much lower quality. Quality of BC7 for environments is passable.{0}'
  $MainDDSToolTipString += 'This program is required to unlock the BC7 format for many reasons.{0}'
  $MainDDSToolTipString += '{0}'
  $MainDDSToolTipString += 'ImageMagick: Uses magick.exe to create DDS textures. It is not ideal{0}'
  $MainDDSToolTipString += 'using ImageMagick to create DDS textures as the quality is bad, the{0}'
  $MainDDSToolTipString += 'only reason it is included is because ImageMagick can create them,{0}'
  $MainDDSToolTipString += 'and the script requires it to create PNG textures, among other things.{0}'
  $MainDDSToolTipString += '{0}'
  $MainDDSToolTipString += 'All programs are useful depending on the users goals. If the selected{0}'
  $MainDDSToolTipString += 'program fails to generate an image, it will fall back to the next. The{0}'
  $MainDDSToolTipString += 'internal order is: Compressonator >> TexConv >> ImageMagick.'
  $MainDDSToolTipString = [String]::Format($MainDDSToolTipString, [Environment]::NewLine)
  $MainDDSToolTip.SetToolTip($MainDDSToolLabel, $MainDDSToolTipString)

  # Format Options: DDS Options: DDS Format - Combobox to select the DDS format.
  $global:MainDDSFormat = New-Object Windows.Forms.ComboBox
  $MainDDSFormat.Size = DPISize (New-Object Drawing.Size(110, 20))
  $MainDDSFormat.Location = DPISize (New-Object Drawing.Point(10, 55))
  $MainDDSFormat.Name = 'DDSBlkCompress'
  $MainDDSFormat.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainDDSFormat.Add_SelectedIndexChanged({ DDSFormatSelection })
  $MainDDSFormat.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainDDSFormat.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainDDSFormat.Add_DrawItem({ RepopulateComboBox })
  $MainDDSOptionsPanel.Controls.Add($MainDDSFormat)

  # Format Options: DDS Options: DDS Format - Create a label for the format.
  $global:MainDDSFormatLabel = New-Object Windows.Forms.Label
  $MainDDSFormatLabel.Size = DPISize (New-Object Drawing.Size(72, 16))
  $MainDDSFormatLabel.Location = DPISize (New-Object Drawing.Point(121, 58))
  $MainDDSFormatLabel.Text = 'DDS Format'
  $MainDDSOptionsPanel.Controls.Add($MainDDSFormatLabel)

  # Format Options: DDS Options: DDS Format - Create a tip for the format.
  $global:MainDDSFormatTip = New-Object Windows.Forms.ToolTip
  $MainDDSFormatTip.InitialDelay = $ToolTipDelay
  $MainDDSFormatTip.AutoPopDelay = $ToolTipDuration
  $MainDDSFormatTipString = 'Allows selecting the DDS block compression format.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC1/BC3: Textures without alpha are created as BC1 and{0}'
  $MainDDSFormatTipString += 'textures with an alpha channel are created with BC3.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC1: Create textures with BC1/DXT1 compression. Not{0}'
  $MainDDSFormatTipString += 'suggested for textures that contain an alpha channel.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC2: Create textures with BC2/DXT3 compression. Alpha is{0}'
  $MainDDSFormatTipString += 'defined in only 4-bits. It is not suggested to use this.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC3: Create textures with BC3/DXT5 compression. Supports{0}'
  $MainDDSFormatTipString += '64-bit alpha channel. Superior to BC2/DXT3.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC4: 2-channel grayscale format. Same requirements as{0}'
  $MainDDSFormatTipString += 'BC1/DXT1 but at much higher quality. Eliminates banding.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC5: High quality 2-channel format designed for tangent{0}'
  $MainDDSFormatTipString += 'space normal maps. Suggested over others if supported.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC6: High quality 3-channel HDR format. Requires DX11+{0}'
  $MainDDSFormatTipString += 'GPU for D3D or OGL 4.0+ for OpenGL. Does not support alpha.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'BC7: Highest quality 4-channel format. Requires DX11+{0}'
  $MainDDSFormatTipString += 'GPU for D3D or OGL 4.0+ for OpenGL. Supports alpha.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'ARGB8: Uncompressed format with BGRA color space. Quality{0}'
  $MainDDSFormatTipString += 'is equal to PNG, but faster to load into VRAM.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'RGBA8: Uncompressed format with RGBA color space. Quality{0}'
  $MainDDSFormatTipString += 'is equal to PNG, but faster to load into VRAM.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'L8: Single channel luminance texture.{0}'
  $MainDDSFormatTipString += 'A8: Single channel alpha texture.{0}'
  $MainDDSFormatTipString += 'LA8: Dual channel luminance + alpha texture.{0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'Search Flags: DDS format is specified by a flag in the name{0}' 
  $MainDDSFormatTipString += 'of the texture, or the path to it. (Ex: texture_BC7.png){0}'
  $MainDDSFormatTipString += '{0}'
  $MainDDSFormatTipString += 'Passthrough: If the input texture is DDS, use the same{0}' 
  $MainDDSFormatTipString += 'format for the output texture. Non-DDS uses the fallback.'
  $global:MainDDSFormatTipString = [String]::Format($MainDDSFormatTipString, [Environment]::NewLine)

  # Format Options: DDS Options: DDS Format - Create an alternate tip for the format for "Dolphin" mode.
  $MainDDSFormatTipStringB = 'Allows selecting the DDS block compression format.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'BC1/BC3: Textures without alpha are created as BC1 and{0}'
  $MainDDSFormatTipStringB += 'textures with an alpha channel are created with BC3.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'BC1: Create textures with BC1/DXT1 compression. Not{0}'
  $MainDDSFormatTipStringB += 'suggested for textures that contain an alpha channel.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'BC2: Create textures with BC2/DXT3 compression. Alpha is{0}'
  $MainDDSFormatTipStringB += 'defined in only 4-bits. It is not suggested to use this.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'BC3: Create textures with BC3/DXT5 compression. Supports{0}'
  $MainDDSFormatTipStringB += '64-bit alpha channel. Superior to BC2/DXT3.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'BC7: Highest quality 4-channel format. Requires DX11+{0}'
  $MainDDSFormatTipStringB += 'GPU for D3D or OGL 4.0+ for OpenGL. Supports alpha.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'ARGB8: Uncompressed format with BGRA color space. Quality{0}'
  $MainDDSFormatTipStringB += 'is equal to PNG, but faster to load into VRAM.{0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'Search Flags: DDS format is specified by a flag in the name{0}' 
  $MainDDSFormatTipStringB += 'of the texture, or the path to it. (Ex: texture_BC7.png){0}'
  $MainDDSFormatTipStringB += '{0}'
  $MainDDSFormatTipStringB += 'Passthrough: If the input texture is DDS, use the same{0}' 
  $MainDDSFormatTipStringB += 'format for the output texture. Non-DDS uses the fallback.'
  $global:MainDDSFormatTipStringB = [String]::Format($MainDDSFormatTipStringB, [Environment]::NewLine)

  # Format Options: DDS Options: DDS Fallback Format - Combobox to select the DDS fallback format.
  $global:MainDDSFallback = New-Object Windows.Forms.ComboBox
  $MainDDSFallback.Size = DPISize (New-Object Drawing.Size(110, 20))
  $MainDDSFallback.Location = DPISize (New-Object Drawing.Point(10, 80))
  $MainDDSFallback.Name = 'DDSFallbackCompress'
  $MainDDSFallback.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainDDSFallback.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $MainDDSFallback.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainDDSFallback.Enabled = (($DDSBlkCompress -eq '*Search Flags*') -or ($DDSBlkCompress -eq '*Passthrough*'))
  $MainDDSFallback.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainDDSFallback.Add_DrawItem({ RepopulateComboBox })
  $MainDDSOptionsPanel.Controls.Add($MainDDSFallback)

  # Format Options: DDS Options: DDS Fallback Format - A label for the fallback format.
  $global:MainDDSFallbackLabel = New-Object Windows.Forms.Label
  $MainDDSFallbackLabel.Size = DPISize (New-Object Drawing.Size(76, 16))
  $MainDDSFallbackLabel.Location = DPISize (New-Object Drawing.Point(121, 83))
  $MainDDSFallbackLabel.Text = 'DDS Fallback'
  $MainDDSFallbackLabel.Enabled = (($DDSBlkCompress -eq '*Search Flags*') -or ($DDSBlkCompress -eq '*Passthrough*'))
  $MainDDSOptionsPanel.Controls.Add($MainDDSFallbackLabel)

  # Format Options: DDS Options: DDS Fallback Format - Create a tooltip for the DDS fallback format.
  $global:MainDDSFallbackTip = New-Object Windows.Forms.ToolTip
  $MainDDSFallbackTip.InitialDelay = $ToolTipDelay
  $MainDDSFallbackTip.AutoPopDelay = $ToolTipDuration
  $MainDDSFallbackTipString = 'If a compression flag is not found in the input path,{0}'
  $MainDDSFallbackTipString += 'use the compression type specified here instead.{0}'
  $MainDDSFallbackTipString += '{0}'
  $MainDDSFallbackTipString += 'User Definable Flags:{0}'
  $MainDDSFallbackTipString += '_BCX: Works like the BC1/BC3 option.{0}'
  $MainDDSFallbackTipString += '_BC1: Creates textures with BC1 compression.{0}'
  $MainDDSFallbackTipString += '_BC2: Creates textures with BC2 compression.{0}'
  $MainDDSFallbackTipString += '_BC3: Creates textures with BC3 compression.{0}'
  $MainDDSFallbackTipString += '_BC4: Creates textures with BC4 compression.{0}'
  $MainDDSFallbackTipString += '_BC5: Creates textures with BC5 compression.{0}'
  $MainDDSFallbackTipString += '_BC6: Creates textures with BC6 compression.{0}'
  $MainDDSFallbackTipString += '_BC7: Creates textures with BC7 compression.{0}'
  $MainDDSFallbackTipString += '_ARGB8: Uncompressed DDS with BGRA color space.{0}'
  $MainDDSFallbackTipString += '_RGBA8: Uncompressed DDS with RGBA color space.{0}'
  $MainDDSFallbackTipString += '_L8: Single channel luminance texture.{0}'
  $MainDDSFallbackTipString += '_A8: Single channel alpha texture.{0}'
  $MainDDSFallbackTipString += '_LA8: Dual channel luminance + alpha texture.{0}'
  $MainDDSFallbackTipString += '_mm#: Force generating a set number of mipmaps.{0}'
  $MainDDSFallbackTipString += '{0}'
  $MainDDSFallbackTipString += 'Examples:{0}'
  $MainDDSFallbackTipString += 'C:\Textures\Environment_BC7\ - Convert to BC7.{0}'
  $MainDDSFallbackTipString += 'C:\Textures\UI_ARGB8\ - Convert to ARGB8.{0}'
  $MainDDSFallbackTipString += 'C:\Textures\_ARGB8\UI\ - Same effect as above.'
  $global:MainDDSFallbackTipString = [String]::Format($MainDDSFallbackTipString, [Environment]::NewLine)

  # Format Options: DDS Options: DDS Fallback Format - Create an alternate tip for the DDS fallback format for "Dolphin" mode.
  $MainDDSFallbackTipStringB = 'If a compression flag is not found in the input path,{0}'
  $MainDDSFallbackTipStringB += 'use the compression type specified here instead.{0}'
  $MainDDSFallbackTipStringB += '{0}'
  $MainDDSFallbackTipStringB += 'User Definable Flags:{0}'
  $MainDDSFallbackTipStringB += '_BCX: Works like the BC1/BC3 option.{0}'
  $MainDDSFallbackTipStringB += '_BC1: Creates textures with BC1 compression.{0}'
  $MainDDSFallbackTipStringB += '_BC2: Creates textures with BC2 compression.{0}'
  $MainDDSFallbackTipStringB += '_BC3: Creates textures with BC3 compression.{0}'
  $MainDDSFallbackTipStringB += '_BC7: Creates textures with BC7 compression.{0}'
  $MainDDSFallbackTipStringB += '_ARGB8: Uncompressed DDS with BGRA color space.{0}'
  $MainDDSFallbackTipStringB += '_mm#: Force generating a set number of mipmaps.{0}'
  $MainDDSFallbackTipStringB += '{0}'
  $MainDDSFallbackTipStringB += 'Examples:{0}'
  $MainDDSFallbackTipStringB += 'C:\Textures\Environment_BC7\ - Convert to BC7.{0}'
  $MainDDSFallbackTipStringB += 'C:\Textures\UI_ARGB8\ - Convert to ARGB8.{0}'
  $MainDDSFallbackTipStringB += 'C:\Textures\_ARGB8\UI\ - Same effect as above.'
  $global:MainDDSFallbackTipStringB = [String]::Format($MainDDSFallbackTipStringB, [Environment]::NewLine)

  # Format Options: DDS Options: DDS Tool - Tool Options - Button
  $global:MainDDSToolButton = New-Object Windows.Forms.Button
  $MainDDSToolButton.Size = DPISize (New-Object Drawing.Size(99, 21)) -Round
  $MainDDSToolButton.Location = DPISize (New-Object Drawing.Point(197, 29))
  $MainDDSToolButton.Add_MouseDown({ ShowDDSToolOptions -DDSTool $DDSCreatorTool })
  $MainDDSToolButton.Text = 'Configure Tool'
  $MainDDSToolButton.TextAlign = [System.Drawing.ContentAlignment]::MiddleLeft
  $MainDDSOptionsPanel.Controls.Add($MainDDSToolButton)

  # Format Options: DDS Options: DDS Tool - Create a label for the option.
  $global:MainDDSToolButtonLabel = New-Object Windows.Forms.Label
  $MainDDSToolButtonLabel.Size = DPISize (New-Object Drawing.Size(72, 16))
  $MainDDSToolButtonLabel.Location = DPISize (New-Object Drawing.Point(298, 33))
  $MainDDSToolButtonLabel.Text = 'Tool Options'
  $MainDDSOptionsPanel.Controls.Add($MainDDSToolButtonLabel)

  # Format Options: DDS Options: DDS Tool - Tool Options - Tip
  $MainDDSToolButtonTip = New-Object Windows.Forms.ToolTip
  $MainDDSToolButtonTip.InitialDelay = $ToolTipDelay
  $MainDDSToolButtonTip.AutoPopDelay = $ToolTipDuration
  $MainDDSToolButtonTipString =  'Open a configuration window for{0}'
  $MainDDSToolButtonTipString += 'the currently selected DDS Tool.'
  $MainDDSToolButtonTipString = [String]::Format($MainDDSToolButtonTipString, [Environment]::NewLine) 
  $MainDDSToolButtonTip.SetToolTip($MainDDSToolButtonLabel, $MainDDSToolButtonTipString)

  # Format Options: DDS Options: DDS Flag Removal - Create a combobox.
  $global:MainDDSFlagRemoval = New-Object Windows.Forms.ComboBox
  $MainDDSFlagRemoval.Size = DPISize (New-Object Drawing.Size(98, 20))
  $MainDDSFlagRemoval.Location = DPISize (New-Object Drawing.Point(198, 55))
  $MainDDSFlagRemoval.Name = 'DDSFlagRemoval'
  $MainDDSFlagRemoval.Items.Add('New & Base') | Out-Null
  $MainDDSFlagRemoval.Items.Add('New Pack') | Out-Null
  $MainDDSFlagRemoval.Items.Add('None') | Out-Null
  $MainDDSFlagRemoval.SelectedItem = $DDSFlagRemoval
  $MainDDSFlagRemoval.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainDDSFlagRemoval.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $MainDDSFlagRemoval.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainDDSFlagRemoval.Enabled = ($DDSBlkCompress -eq '*Search Flags*')
  $MainDDSFlagRemoval.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainDDSFlagRemoval.Add_DrawItem({ RepopulateComboBox })
  $MainDDSOptionsPanel.Controls.Add($MainDDSFlagRemoval)

  # Format Options: DDS Options: DDS Flag Removal - Create a label.
  $global:MainDDSFlagLabel = New-Object Windows.Forms.Label
  $MainDDSFlagLabel.Size = DPISize (New-Object Drawing.Size(78, 16))
  $MainDDSFlagLabel.Location = DPISize (New-Object Drawing.Point(298, 58))
  $MainDDSFlagLabel.Text = 'Flag Removal'
  $MainDDSFlagLabel.Enabled = ($DDSBlkCompress -eq '*Search Flags*')
  $MainDDSOptionsPanel.Controls.Add($MainDDSFlagLabel)

  # Format Options: DDS Options: DDS Flag Removal - Create a tooltip.
  $global:MainDDSFlagTip = New-Object Windows.Forms.ToolTip
  $MainDDSFlagTip.InitialDelay = $ToolTipDelay
  $MainDDSFlagTip.AutoPopDelay = $ToolTipDuration
  $MainDDSFlagTipString = 'Automatically remove user defined flags when the format is{0}'
  $MainDDSFlagTipString += 'set to "Search Flags". Flags are only removed when performing{0}'
  $MainDDSFlagTipString += 'the standard options to convert or rescale textures, and only if{0}'
  $MainDDSFlagTipString += 'the output format is set to DDS. No effect when creating PNG.{0}'
  $MainDDSFlagTipString += '{0}'
  $MainDDSFlagTipString += 'New & Base - Remove flags from the base and generated pack.{0}'
  $MainDDSFlagTipString += 'New Pack - Only remove flags from the generated pack.{0}'
  $MainDDSFlagTipString += 'None - Do not remove flags from either packs.{0}'
  $MainDDSFlagTipString += '{0}'
  $MainDDSFlagTipString += 'User Definable Flags:{0}'
  $MainDDSFlagTipString += '_BCX: Works like the BC1/BC3 option.{0}'
  $MainDDSFlagTipString += '_BC1: Creates textures with BC1 compression.{0}'
  $MainDDSFlagTipString += '_BC2: Creates textures with BC2 compression.{0}'
  $MainDDSFlagTipString += '_BC3: Creates textures with BC3 compression.{0}'
  $MainDDSFlagTipString += '_BC4: Creates textures with BC4 compression.{0}'
  $MainDDSFlagTipString += '_BC5: Creates textures with BC5 compression.{0}'
  $MainDDSFlagTipString += '_BC6: Creates textures with BC6 compression.{0}'
  $MainDDSFlagTipString += '_BC7: Creates textures with BC7 compression.{0}'
  $MainDDSFlagTipString += '_ARGB8: Uncompressed DDS with BGRA color space.{0}'
  $MainDDSFlagTipString += '_RGBA8: Uncompressed DDS with RGBA color space.{0}'
  $MainDDSFlagTipString += '_L8: Single channel luminance texture.{0}'
  $MainDDSFlagTipString += '_A8: Single channel alpha texture.{0}'
  $MainDDSFlagTipString += '_LA8: Dual channel luminance + alpha texture.{0}'
  $MainDDSFlagTipString += '_mm#: Force generating a specific number of mipmaps.{0}'
  $MainDDSFlagTipString += '{0}'
  $MainDDSFlagTipString += 'Examples:{0}'
  $MainDDSFlagTipString += 'With Flag: C:\Textures\Environment_BC7\{0}'
  $MainDDSFlagTipString += 'Removed: C:\Textures\Environment\{0}'
  $MainDDSFlagTipString += 'With Flag: C:\Textures\_ARGB8\UI\{0}'
  $MainDDSFlagTipString += 'Removed: C:\Textures\UI\'
  $global:MainDDSFlagTipString = [String]::Format($MainDDSFlagTipString, [Environment]::NewLine)

  # Format Options: DDS Options: DDS Flag Removal - Create an alternate tip for "Dolphin" mode.
  $MainDDSFlagTipStringB = 'Automatically remove user defined flags when the format is{0}'
  $MainDDSFlagTipStringB += 'set to "Search Flags". Flags are only removed when performing{0}'
  $MainDDSFlagTipStringB += 'the standard options to convert or rescale textures, and only if{0}'
  $MainDDSFlagTipStringB += 'the output format is set to DDS. No effect when creating PNG.{0}'
  $MainDDSFlagTipStringB += '{0}'
  $MainDDSFlagTipStringB += 'New & Base - Remove flags from the base and generated pack.{0}'
  $MainDDSFlagTipStringB += 'New Pack - Only remove flags from the generated pack.{0}'
  $MainDDSFlagTipStringB += 'None - Do not remove flags from either packs.{0}'
  $MainDDSFlagTipStringB += '{0}'
  $MainDDSFlagTipStringB += 'User Definable Flags:{0}'
  $MainDDSFlagTipStringB += '_BCX: Works like the BC1/BC3 option.{0}'
  $MainDDSFlagTipStringB += '_BC1: Creates textures with BC1 compression.{0}'
  $MainDDSFlagTipStringB += '_BC2: Creates textures with BC2 compression.{0}'
  $MainDDSFlagTipStringB += '_BC3: Creates textures with BC3 compression.{0}'
  $MainDDSFlagTipStringB += '_BC7: Creates textures with BC7 compression.{0}'
  $MainDDSFlagTipStringB += '_ARGB8: Uncompressed DDS with BGRA color space.{0}'
  $MainDDSFlagTipStringB += '_mm#: Force generating a set number of mipmaps.{0}'
  $MainDDSFlagTipStringB += '{0}'
  $MainDDSFlagTipStringB += 'Examples:{0}'
  $MainDDSFlagTipStringB += 'With Flag: C:\Textures\Environment_BC7\{0}'
  $MainDDSFlagTipStringB += 'Removed: C:\Textures\Environment\{0}'
  $MainDDSFlagTipStringB += 'With Flag: C:\Textures\_ARGB8\UI\{0}'
  $MainDDSFlagTipStringB += 'Removed: C:\Textures\UI\'
  $global:MainDDSFlagTipStringB = [String]::Format($MainDDSFlagTipStringB, [Environment]::NewLine)

  # Format Options: DDS Options: Force DX10 Header - Create a checkbox.
  $global:MainDDSDX10Check = New-Object Windows.Forms.CheckBox
  $MainDDSDX10Check.Size = DPISize (New-Object Drawing.Size(134, 18))
  $MainDDSDX10Check.Location = DPISize (New-Object Drawing.Point(198, 82))
  $MainDDSDX10Check.Name = 'DDSForceDX10Header'
  $MainDDSDX10Check.Text = 'Force DX10 Header'
  $MainDDSDX10Check.Checked = $DDSForceDX10Header
  $MainDDSDX10Check.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainDDSDX10Check.Visible = (($CTTPSSelectedMode -eq 'Expert Mode') -or  ($CTTPSSelectedMode -eq 'Database Mode'))
  $MainDDSOptionsPanel.Controls.Add($MainDDSDX10Check)

  # Format Options: DDS Options: Force DX10 Header - Create a tooltip for the option.
  $MainDDSDX10Tip = New-Object Windows.Forms.ToolTip
  $MainDDSDX10Tip.InitialDelay = $ToolTipDelay
  $MainDDSDX10Tip.AutoPopDelay = $ToolTipDuration
  $MainDDSDX10TipString =  'Forces the DX10 header when creating{0}'
  $MainDDSDX10TipString += 'DDS textures. Only create textures with{0}'
  $MainDDSDX10TipString += 'a DX10 header if the game requires it.{0}'
  $MainDDSDX10TipString += '{0}'
  $MainDDSDX10TipString += "If unsure, you probably don't need this."
  $MainDDSDX10TipString = [String]::Format($MainDDSDX10TipString, [Environment]::NewLine)
  $MainDDSDX10Tip.SetToolTip($MainDDSDX10Check, $MainDDSDX10TipString)

  # Format Options: PNG Options: Main Panel
  $global:MainPNGOptionsPanel = New-Object Windows.Forms.Panel
  $MainPNGOptionsPanel.Size = New-Object Drawing.Size($FormatMainPanelX, $FormatMainPanelY)
  $MainPNGOptionsPanel.Location = New-Object Drawing.Point(1, 1)
  $MainPNGOptionsPanel.Visible = ($StoredFormatMenu -eq 'PNG')
  $MainFormatTexGroup.Controls.Add($MainPNGOptionsPanel)

  # Format Options: PNG Options: Create an option to flip PNG textures.
  $global:MainPNGFlipResult = New-Object Windows.Forms.CheckBox
  $MainPNGFlipResult.Size = DPISize (New-Object Drawing.Size(180, 16))
  $MainPNGFlipResult.Location = DPISize (New-Object Drawing.Point(10, 33))
  $MainPNGFlipResult.Name = 'PNGFlipResult'
  $MainPNGFlipResult.Checked = $PNGFlipResult
  $MainPNGFlipResult.Text = ' Flip Resulting PNG Texture'
  $MainPNGFlipResult.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainPNGOptionsPanel.Controls.Add($MainPNGFlipResult)

  # Format Options: PNG Options: Create a tooltip for the option.
  $MainPNGFlipResultTip = New-Object Windows.Forms.ToolTip
  $MainPNGFlipResultTip.InitialDelay = $ToolTipDelay
  $MainPNGFlipResultTip.AutoPopDelay = $ToolTipDuration
  $MainPNGFlipResultTipString = 'When creating a PNG texture, this option will{0}'
  $MainPNGFlipResultTipString += 'flip the result. This is equal to rotating 180{0}'
  $MainPNGFlipResultTipString += 'degrees, then flipping horizontally. This can be{0}'
  $MainPNGFlipResultTipString += 'useful when converting flipped DDS textures.'
  $MainPNGFlipResultTipString = [String]::Format($MainPNGFlipResultTipString, [Environment]::NewLine)
  $MainPNGFlipResultTip.SetToolTip($MainPNGFlipResult, $MainPNGFlipResultTipString)

  # Format Options: PNG Options: Rotates PNG textures 180 degrees and flips them horizontally.
  $global:MainPNGPaletted = New-Object Windows.Forms.CheckBox
  $MainPNGPaletted.Size = DPISize (New-Object Drawing.Size(180, 16))
  $MainPNGPaletted.Location = DPISize (New-Object Drawing.Point(10, 58))
  $MainPNGPaletted.Name = 'PNGPalettedImage'
  $MainPNGPaletted.Checked = $PNGPalettedImage
  $MainPNGPaletted.Text = ' Paletted Image (Indexed)'
  $MainPNGPaletted.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainPNGOptionsPanel.Controls.Add($MainPNGPaletted)

  # Format Options: PNG Options: Create a tooltip for the option.
  $MainPNGPalettedTip = New-Object Windows.Forms.ToolTip
  $MainPNGPalettedTip.InitialDelay = $ToolTipDelay
  $MainPNGPalettedTip.AutoPopDelay = $ToolTipDuration
  $MainPNGPalettedTipString =  'Forces creating the image as a 256{0}'
  $MainPNGPalettedTipString += 'color paletted image, or 255 colors{0}'
  $MainPNGPalettedTipString += 'if it has transparency. This should{0}'
  $MainPNGPalettedTipString += 'not be used to create textures.'
  $MainPNGPalettedTipString = [String]::Format($MainPNGPalettedTipString, [Environment]::NewLine)
  $MainPNGPalettedTip.SetToolTip($MainPNGPaletted, $MainPNGPalettedTipString)

  # Format Options: PNG Options: Preferred BC7 to PNG Converter program. TexConv may have issues, so Compressonator is available to try.
  $global:MainPNGBC7Converter = New-Object Windows.Forms.ComboBox
  $MainPNGBC7Converter.Size = DPISize (New-Object Drawing.Size(114, 10))
  $MainPNGBC7Converter.Location = DPISize (New-Object Drawing.Point(10, 80))
  $MainPNGBC7Converter.Name = 'PNGBC7Converter'
  $MainPNGBC7Converter.Items.Add('TexConv') | Out-Null
  $MainPNGBC7Converter.Items.Add('Compressonator') | Out-Null
  $MainPNGBC7Converter.SelectedItem = $PNGBC7Converter
  $MainPNGBC7Converter.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MainPNGBC7Converter.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $MainPNGBC7Converter.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MainPNGBC7Converter.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MainPNGBC7Converter.Add_DrawItem({ RepopulateComboBox })
  $MainPNGOptionsPanel.Controls.Add($MainPNGBC7Converter)

  # Format Options: PNG Options: Create a label to accompany the combo box.
  $global:MainPNGBC7ConverterLabel = New-Object Windows.Forms.Label
  $MainPNGBC7ConverterLabel.Size = DPISize (New-Object Drawing.Size(124, 16))
  $MainPNGBC7ConverterLabel.Location = DPISize (New-Object Drawing.Point(128, 83))
  $MainPNGBC7ConverterLabel.Text = 'BC7 to PNG Converter'
  $MainPNGOptionsPanel.Controls.Add($MainPNGBC7ConverterLabel)

  # Format Options: PNG Options: Create a tooltip for the option.
  $MainPNGBC7ConverterTip = New-Object Windows.Forms.ToolTip
  $MainPNGBC7ConverterTip.InitialDelay = $ToolTipDelay
  $MainPNGBC7ConverterTip.AutoPopDelay = $ToolTipDuration
  $MainPNGBC7ConverterTipString = 'The program used when converting DDS BC7 to PNG.{0}'
  $MainPNGBC7ConverterTipString += '{0}'
  $MainPNGBC7ConverterTipString += 'TexConv works in most cases, but some users have{0}'
  $MainPNGBC7ConverterTipString += 'reported issues. If the result is not what is desired,{0}'
  $MainPNGBC7ConverterTipString += 'Compressonator can be used to do the conversion.'
  $MainPNGBC7ConverterTipString = [String]::Format($MainPNGBC7ConverterTipString, [Environment]::NewLine)
  $MainPNGBC7ConverterTip.SetToolTip($MainPNGBC7ConverterLabel, $MainPNGBC7ConverterTipString)

  # Format Options: PNG Options: Create an option to save color data in fully transparent pixels.
  $global:MainPNGAlphaPixels = New-Object Windows.Forms.CheckBox
  $MainPNGAlphaPixels.Size = DPISize (New-Object Drawing.Size(220, 16))
  $MainPNGAlphaPixels.Location = DPISize (New-Object Drawing.Point(198, 33))
  $MainPNGAlphaPixels.Name = 'PNGSaveAlphaPixels'
  $MainPNGAlphaPixels.Checked = $PNGSaveAlphaPixels
  $MainPNGAlphaPixels.Text = ' Save Fully Transparent Colors'
  $MainPNGAlphaPixels.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainPNGOptionsPanel.Controls.Add($MainPNGAlphaPixels)

  # Format Options: PNG Options: Create a tooltip for the option.
  $global:MainPNGAlphaPixelsTip = New-Object Windows.Forms.ToolTip
  $MainPNGAlphaPixelsTip.InitialDelay = $ToolTipDelay
  $MainPNGAlphaPixelsTip.AutoPopDelay = $ToolTipDuration
  $MainPNGAlphaPixelsTipString = 'Sometimes textures may contain color data in fully{0}'
  $MainPNGAlphaPixelsTipString += 'transparent pixels. While humans will not be able to{0}'
  $MainPNGAlphaPixelsTipString += 'see these colors, some games do make use of fully{0}'
  $MainPNGAlphaPixelsTipString += 'transparent colors. This option will save color data{0}'
  $MainPNGAlphaPixelsTipString += 'that is found in fully transparent pixels.{0}'
  $MainPNGAlphaPixelsTipString += '{0}'
  $MainPNGAlphaPixelsTipString += 'Note: Only use this option if necessary. ImageMagick{0}'
  $MainPNGAlphaPixelsTipString += 'is unfortunately terrible at resizing (some) images{0}'
  $MainPNGAlphaPixelsTipString += 'while preserving color data. Some textures that are a{0}'
  $MainPNGAlphaPixelsTipString += 'single color (such as text) with semi-transparent{0}'
  $MainPNGAlphaPixelsTipString += 'borders may have undesired results. Do thoroughly{0}'
  $MainPNGAlphaPixelsTipString += 'check any textures created using this option.'
  $MainPNGAlphaPixelsTipString = [String]::Format($MainPNGAlphaPixelsTipString, [Environment]::NewLine)
  $MainPNGAlphaPixelsTip.SetToolTip($MainPNGAlphaPixels, $MainPNGAlphaPixelsTipString)

  # Format Options: JPG Options: Main Panel
  $global:MainJPGOptionsPanel = New-Object Windows.Forms.Panel
  $MainJPGOptionsPanel.Size = New-Object Drawing.Size($FormatMainPanelX, $FormatMainPanelY)
  $MainJPGOptionsPanel.Location = New-Object Drawing.Point(1, 1)
  $MainJPGOptionsPanel.Visible = ($StoredFormatMenu -eq 'JPG')
  $MainFormatTexGroup.Controls.Add($MainJPGOptionsPanel)

  # Format Options: JPG Options: Allow selecting the quality of JPG textures.
  $global:MainJPGQualityNumBox = New-Object Windows.Forms.NumericUpDown
  $MainJPGQualityNumBox.Size = DPISize (New-Object Drawing.Size(60, 16))
  $MainJPGQualityNumBox.Location = DPISize (New-Object Drawing.Point(10, 30))
  $MainJPGQualityNumBox.Name = 'JPGQualityValue'
  $MainJPGQualityNumBox.DecimalPlaces = 0
  $MainJPGQualityNumBox.Minimum = 0
  $MainJPGQualityNumBox.Maximum = 100
  $MainJPGQualityNumBox.Increment = 1
  $MainJPGQualityNumBox.Value = $JPGQualityValue
  $MainJPGQualityNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $MainJPGOptionsPanel.Controls.Add($MainJPGQualityNumBox)

  # Format Options: JPG Options: Allow selecting the quality of JPG textures.
  $global:MainJPGQualityLabel = New-Object Windows.Forms.Label
  $MainJPGQualityLabel.Size = DPISize (New-Object Drawing.Size(120, 16))
  $MainJPGQualityLabel.Location = DPISize (New-Object Drawing.Point(74, 33))
  $MainJPGQualityLabel.Text = 'JPG Quality Level'
  $MainJPGOptionsPanel.Controls.Add($MainJPGQualityLabel)

  # Format Options: JPG Options: Create a tooltip for the option.
  $MainJPGQualityTip = New-Object Windows.Forms.ToolTip
  $MainJPGQualityTip.InitialDelay = $ToolTipDelay
  $MainJPGQualityTip.AutoPopDelay = $ToolTipDuration
  $MainJPGQualityTipString =  'Adjusts the output quality of JPG{0}'
  $MainJPGQualityTipString += 'images using a percentage value.'
  $MainJPGQualityTipString = [String]::Format($MainJPGQualityTipString, [Environment]::NewLine)
  $MainJPGQualityTip.SetToolTip($MainJPGQualityLabel, $MainJPGQualityTipString)

  # Format Options: BMP Options: Main Panel
  $global:MainBMPOptionsPanel = New-Object Windows.Forms.Panel
  $MainBMPOptionsPanel.Size = New-Object Drawing.Size($FormatMainPanelX, $FormatMainPanelY)
  $MainBMPOptionsPanel.Location = New-Object Drawing.Point(1, 1)
  $MainBMPOptionsPanel.Visible = ($StoredFormatMenu -eq 'BMP')
  $MainFormatTexGroup.Controls.Add($MainBMPOptionsPanel)

  # Format Options: BMP Options: Allow selecting the quality of JPG textures.
  $global:MainBMPVersionNumBox = New-Object Windows.Forms.NumericUpDown
  $MainBMPVersionNumBox.Size = DPISize (New-Object Drawing.Size(60, 16))
  $MainBMPVersionNumBox.Location = DPISize (New-Object Drawing.Point(10, 30))
  $MainBMPVersionNumBox.Name = 'BMPBitmapVersion'
  $MainBMPVersionNumBox.DecimalPlaces = 0
  $MainBMPVersionNumBox.Minimum = 2
  $MainBMPVersionNumBox.Maximum = 4
  $MainBMPVersionNumBox.Increment = 1
  $MainBMPVersionNumBox.Value = $BMPBitmapVersion
  $MainBMPVersionNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $MainBMPOptionsPanel.Controls.Add($MainBMPVersionNumBox)

  # Format Options: BMP Options: Create a label to accompany the combo box.
  $global:MainBMPVersionLabel = New-Object Windows.Forms.Label
  $MainBMPVersionLabel.Size = DPISize (New-Object Drawing.Size(124, 16))
  $MainBMPVersionLabel.Location = DPISize (New-Object Drawing.Point(74, 33))
  $MainBMPVersionLabel.Text = 'Bitmap Version'
  $MainBMPOptionsPanel.Controls.Add($MainBMPVersionLabel)

  # Format Options: BMP Options: Create a tooltip for the option.
  $MainBMPVersionTip = New-Object Windows.Forms.ToolTip
  $MainBMPVersionTip.InitialDelay = $ToolTipDelay
  $MainBMPVersionTip.AutoPopDelay = $ToolTipDuration
  $MainBMPVersionTipString = 'Sets the version of bitmap created. Usually this{0}'
  $MainBMPVersionTipString += 'should be set to "4" for most cases. Older versions{0}'
  $MainBMPVersionTipString += 'can be useful for compatibility for older software.'
  $MainBMPVersionTipString = [String]::Format($MainBMPVersionTipString, [Environment]::NewLine)
  $MainBMPVersionTip.SetToolTip($MainBMPVersionLabel, $MainBMPVersionTipString)

  # Format Options: BMP Options: Limits the colors of BMP images to 256 colors.
  $global:MainBMPLimitColor = New-Object Windows.Forms.CheckBox
  $MainBMPLimitColor.Size = DPISize (New-Object Drawing.Size(180, 16))
  $MainBMPLimitColor.Location = DPISize (New-Object Drawing.Point(10, 58))
  $MainBMPLimitColor.Name = 'BMPLimitColors'
  $MainBMPLimitColor.Checked = $BMPLimitColors
  $MainBMPLimitColor.Text = ' Limit Bitmap to 256 Colors'
  $MainBMPLimitColor.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainBMPOptionsPanel.Controls.Add($MainBMPLimitColor)

  # Format Options: BMP Options: Global - Create a tooltip for the option.
  $MainBMPLimitColorTip = New-Object Windows.Forms.ToolTip
  $MainBMPLimitColorTip.InitialDelay = $ToolTipDelay
  $MainBMPLimitColorTip.AutoPopDelay = $ToolTipDuration
  $MainBMPLimitColorTipString  = 'Reduces the number of colors in the{0}'
  $MainBMPLimitColorTipString += 'image to 256 colors. This can be useful{0}'
  $MainBMPLimitColorTipString += 'for situations where 256 color bitmaps{0}'
  $MainBMPLimitColorTipString += 'are required for whatever reason.'
  $MainBMPLimitColorTipString = [String]::Format($MainBMPLimitColorTipString, [Environment]::NewLine)
  $MainBMPLimitColorTip.SetToolTip($MainBMPLimitColor, $MainBMPLimitColorTipString)

  # Format Options: TIF Options: Main Panel
  $global:MainTIFOptionsPanel = New-Object Windows.Forms.Panel
  $MainTIFOptionsPanel.Size = New-Object Drawing.Size($FormatMainPanelX, $FormatMainPanelY)
  $MainTIFOptionsPanel.Location = New-Object Drawing.Point(1, 1)
  $MainTIFOptionsPanel.Visible = ($StoredFormatMenu -eq 'TIF')
  $MainFormatTexGroup.Controls.Add($MainTIFOptionsPanel)

  # Operations: Global - Disables GPU acceleration when creating textures with TexConv.
  $global:MainNoResizeTIFF = New-Object Windows.Forms.CheckBox
  $MainNoResizeTIFF.Size = DPISize (New-Object Drawing.Size(180, 16))
  $MainNoResizeTIFF.Location = DPISize (New-Object Drawing.Point(12, 33))
  $MainNoResizeTIFF.Name = 'TIFFNoResizeMipmap'
  $MainNoResizeTIFF.Checked = $TIFFNoResizeMipmap
  $MainNoResizeTIFF.Text = ' Do Not Resize TIFF Layers'
  $MainNoResizeTIFF.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainTIFOptionsPanel.Controls.Add($MainNoResizeTIFF)

  # Operations: Global - Create a tooltip for the option.
  $MainNoResizeTIFFTip = New-Object Windows.Forms.ToolTip
  $MainNoResizeTIFFTip.InitialDelay = $ToolTipDelay
  $MainNoResizeTIFFTip.AutoPopDelay = $ToolTipDuration
  $MainNoResizeTIFFTipString = 'Much like DDS textures, TIFF images can be created as{0}'
  $MainNoResizeTIFFTipString += 'multi-layer images. The difference is that TIFF can use{0}'
  $MainNoResizeTIFFTipString += 'any size image for a "lower level", while DDS textures{0}'
  $MainNoResizeTIFFTipString += 'must use progressively smaller images that are half of{0}'
  $MainNoResizeTIFFTipString += 'the resolution of the previous mipmap level.{0}'
  $MainNoResizeTIFFTipString += '{0}'
  $MainNoResizeTIFFTipString += 'Enabling this option creates all images in a multi-layer{0}'
  $MainNoResizeTIFFTipString += 'TIFF at the full size specified, rather than reducing the{0}'
  $MainNoResizeTIFFTipString += 'resolution of each "lower level". When this is disabled,{0}'
  $MainNoResizeTIFFTipString += 'multi-layer TIFFs will be treated like mipmap textures.{0}'
  $MainNoResizeTIFFTipString += '{0}'
  $MainNoResizeTIFFTipString += 'Do note that the mipmap layers must already exist with{0}'
  $MainNoResizeTIFFTipString += 'the base image. Basic mipmap rules apply, meaning{0}'
  $MainNoResizeTIFFTipString += 'CTT-PS looks for additional images with the "_mip#"{0}'
  $MainNoResizeTIFFTipString += 'suffix to add to the stack, and any omitted levels or a{0}'
  $MainNoResizeTIFFTipString += 'break in the chain will exclude all successive images.'
  $MainNoResizeTIFFTipString = [String]::Format($MainNoResizeTIFFTipString, [Environment]::NewLine)
  $MainNoResizeTIFFTip.SetToolTip($MainNoResizeTIFF, $MainNoResizeTIFFTipString)

  # Mipmap Options: The group that holds options specifically for mipmap options.
  $global:MainMipmapGroup = New-Object Windows.Forms.GroupBox
  $MainMipmapGroup.Size = DPISize (New-Object Drawing.Size(380, 84))
  $MainMipmapGroup.Location = DPISize (New-Object Drawing.Point(10, 462))
  $MainMipmapGroup.Text = ' Mipmap Options '
  $MainDialogPanel.Controls.Add($MainMipmapGroup)

  # Mipmap Options: Create a tip for the for the mipmap group.
  $MainMipmapGroupTip = New-Object Windows.Forms.ToolTip
  $MainMipmapGroupTip.InitialDelay = $ToolTipDelay
  $MainMipmapGroupTip.AutoPopDelay = $ToolTipDuration
  $MainMipmapGroupTipString =  'These options affect the way{0}'
  $MainMipmapGroupTipString += 'the script generates mipmaps.'
  $MainMipmapGroupTipString = [String]::Format($MainMipmapGroupTipString, [Environment]::NewLine)
  $MainMipmapGroupTip.SetToolTip($MainMipmapGroup, $MainMipmapGroupTipString)

  # Mipmap Options: Force New Mipmaps - Create a checkbox.
  $global:MainDisableMipmaps = New-Object Windows.Forms.CheckBox
  $MainDisableMipmaps.Size = DPISize (New-Object Drawing.Size(174, 16))
  $MainDisableMipmaps.Location = DPISize (New-Object Drawing.Point(10, 18))
  $MainDisableMipmaps.Name = 'DisableMipmaps'
  $MainDisableMipmaps.Text = ' Disable Mipmap Generation'
  $MainDisableMipmaps.Checked = $DisableMipmaps
  $MainDisableMipmaps.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleMipmapOptions })
  $MainDisableMipmaps.Enabled = !$MipmapTopLevelBase
  $MainMipmapGroup.Controls.Add($MainDisableMipmaps)

  # Mipmap Options: Force New Mipmaps - Create a tooltip.
  $MainDisableMipmapsTip = New-Object Windows.Forms.ToolTip
  $MainDisableMipmapsTip.InitialDelay = $ToolTipDelay
  $MainDisableMipmapsTip.AutoPopDelay = $ToolTipDuration
  $MainDisableMipmapsTipString = 'Disables mipmaps from being generated.'
  $MainDisableMipmapsTip.SetToolTip($MainDisableMipmaps, $MainDisableMipmapsTipString)

  # Mipmap Options: Force New Mipmaps - Create a checkbox.
  $global:MainForceNewMipmaps = New-Object Windows.Forms.CheckBox
  $MainForceNewMipmaps.Size = DPISize (New-Object Drawing.Size(130, 16))
  $MainForceNewMipmaps.Location = DPISize (New-Object Drawing.Point(10, 39))
  $MainForceNewMipmaps.Name = 'ForceNewMipmaps'
  $MainForceNewMipmaps.Text = ' Force New Mipmaps'
  $MainForceNewMipmaps.Checked = $ForceNewMipmaps
  $MainForceNewMipmaps.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleMipmapOptionConflicts })
  $MainForceNewMipmaps.Enabled = ((!$MipmapTopLevelBase) -and (!$DisableMipmaps))
  $MainMipmapGroup.Controls.Add($MainForceNewMipmaps)

  # Mipmap Options: Force New Mipmaps - Create a tooltip.
  $MainForceNewMipmapsTip = New-Object Windows.Forms.ToolTip
  $MainForceNewMipmapsTip.InitialDelay = $ToolTipDelay
  $MainForceNewMipmapsTip.AutoPopDelay = $ToolTipDuration
  $MainForceNewMipmapsTipString = 'When mipmaps are generated, this forces the script{0}'
  $MainForceNewMipmapsTipString += 'to ignore all mipmaps provided with the pack and{0}'
  $MainForceNewMipmapsTipString += 'generate new ones from the top level (base texture).{0}'
  $MainForceNewMipmapsTipString += '{0}'
  $MainForceNewMipmapsTipString += 'Note that this option will NOT preserve any arbitrary{0}'
  $MainForceNewMipmapsTipString += 'mipmap effects (different mipmaps on lower layers).'
  $MainForceNewMipmapsTipString = [String]::Format($MainForceNewMipmapsTipString, [Environment]::NewLine)
  $MainForceNewMipmapsTip.SetToolTip($MainForceNewMipmaps, $MainForceNewMipmapsTipString)

  # Mipmap Options: Create From Top Level - Create a checkbox.
  $global:MainTopLevelMipmap = New-Object Windows.Forms.CheckBox
  $MainTopLevelMipmap.Size = DPISize (New-Object Drawing.Size(150, 16))
  $MainTopLevelMipmap.Location = DPISize (New-Object Drawing.Point(10, 60))
  $MainTopLevelMipmap.Name = 'MipmapTopLevelBase'
  $MainTopLevelMipmap.Text = ' Create From Top Level'
  $MainTopLevelMipmap.Checked = $MipmapTopLevelBase
  $MainTopLevelMipmap.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleMipmapOptionConflicts })
  $MainTopLevelMipmap.Enabled = ((!$ForceNewMipmaps) -and (!$DisableMipmaps))
  $MainMipmapGroup.Controls.Add($MainTopLevelMipmap)

  # Mipmap Options: Create From Top Level - Create a tooltip.
  $MainTopLevelMipmapTip = New-Object Windows.Forms.ToolTip
  $MainTopLevelMipmapTip.InitialDelay = $ToolTipDelay
  $MainTopLevelMipmapTip.AutoPopDelay = $ToolTipDuration
  $MainTopLevelMipmapTipString = 'When missing mipmaps are generated, the script will{0}'
  $MainTopLevelMipmapTipString += 'use the lowest provided mipmap level as a base to{0}'
  $MainTopLevelMipmapTipString += 'generate the missing levels. This option will instead{0}'
  $MainTopLevelMipmapTipString += 'use the top level (base texture) as the mipmap base.{0}'
  $MainTopLevelMipmapTipString += '{0}'
  $MainTopLevelMipmapTipString += 'This option should not be used in most cases. Using{0}'
  $MainTopLevelMipmapTipString += "the top level can break the artist's intended design{0}"
  $MainTopLevelMipmapTipString += "if they are making use of arbitrary mipmap effects."
  $MainTopLevelMipmapTipString = [String]::Format($MainTopLevelMipmapTipString, [Environment]::NewLine)
  $MainTopLevelMipmapTip.SetToolTip($MainTopLevelMipmap, $MainTopLevelMipmapTipString)

  # Mipmap Options: Max Mipmap Levels - Create a checkbox.
  $global:MainMaxMipmapToggle = New-Object Windows.Forms.CheckBox
  $MainMaxMipmapToggle.Size = DPISize (New-Object Drawing.Size(130, 16))
  $MainMaxMipmapToggle.Location = DPISize (New-Object Drawing.Point(185, 18))
  $MainMaxMipmapToggle.Name = 'MaxMipmapEnabled'
  $MainMaxMipmapToggle.Text = ' Max Mipmap Levels'
  $MainMaxMipmapToggle.Checked = $MaxMipmapEnabled
  $MainMaxMipmapToggle.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleMaxMipmapOption -Checkbox $this })
  $MainMaxMipmapToggle.Enabled = !$DisableMipmaps
  $MainMipmapGroup.Controls.Add($MainMaxMipmapToggle)

  # Mipmap Options: Max Mipmap Levels - Create a number chooser.
  $global:MainMaxMipmapNumBox = New-Object Windows.Forms.NumericUpDown
  $MainMaxMipmapNumBox.Size = DPISize (New-Object Drawing.Size(40, 10))
  $MainMaxMipmapNumBox.Location = DPISize (New-Object Drawing.Point(330, 17))
  $MainMaxMipmapNumBox.Name = 'MaxMipmapLevels'
  $MainMaxMipmapNumBox.DecimalPlaces = 0
  $MainMaxMipmapNumBox.Minimum = 0
  $MainMaxMipmapNumBox.Maximum = 20
  $MainMaxMipmapNumBox.Increment = 1
  $MainMaxMipmapNumBox.Value = $MaxMipmapLevels
  $MainMaxMipmapNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $MainMaxMipmapNumBox.Enabled = $MaxMipmapEnabled
  $MainMipmapGroup.Controls.Add($MainMaxMipmapNumBox)

  # Mipmap Options: Max Mipmap Levels - Create a tooltip.
  $MainMaxMipmapTip = New-Object Windows.Forms.ToolTip
  $MainMaxMipmapTip.InitialDelay = $ToolTipDelay
  $MainMaxMipmapTip.AutoPopDelay = $ToolTipDuration
  $MainMaxMipmapTipString =  'Forces the maximum number of mipmap levels{0}'
  $MainMaxMipmapTipString += 'when enabled. The maximum can be configured{0}'
  $MainMaxMipmapTipString += 'to the right. The actual amount generated may{0}'
  $MainMaxMipmapTipString += 'be less for some images if a texture requires less{0}'
  $MainMaxMipmapTipString += 'mipmap levels than the amount specified.'
  $MainMaxMipmapTipString = [String]::Format($MainMaxMipmapTipString, [Environment]::NewLine)
  $MainMaxMipmapTip.SetToolTip($MainMaxMipmapToggle, $MainMaxMipmapTipString)
  $MainMaxMipmapTip.SetToolTip($MainMaxMipmapNumBox, $MainMaxMipmapTipString)

  # Mipmap Options: External Mipmaps - Create a checkbox.
  $global:MainExternalDDSMipmap = New-Object Windows.Forms.CheckBox
  $MainExternalDDSMipmap.Size = DPISize (New-Object Drawing.Size(185, 16))
  $MainExternalDDSMipmap.Location = DPISize (New-Object Drawing.Point(185, 39))
  $MainExternalDDSMipmap.Name = 'ExternalDDSMipmaps'
  $MainExternalDDSMipmap.Text = ' External Mipmaps'
  $MainExternalDDSMipmap.Checked = $ExternalDDSMipmaps
  $MainExternalDDSMipmap.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MainExternalDDSMipmap.Enabled = !$DisableMipmaps
  $MainMipmapGroup.Controls.Add($MainExternalDDSMipmap)

  # Mipmap Options: External Mipmaps - Create a tooltip.
  $MainExternalDDSMipmapTip = New-Object Windows.Forms.ToolTip
  $MainExternalDDSMipmapTip.InitialDelay = $ToolTipDelay
  $MainExternalDDSMipmapTip.AutoPopDelay = $ToolTipDuration
  $MainExternalDDSMipmapTipString = 'Creates all DDS/TIFF mipmaps in separate{0}'
  $MainExternalDDSMipmapTipString += 'DDS/TIFF files rather than a single file.'
  $MainExternalDDSMipmapTipString = [String]::Format($MainExternalDDSMipmapTipString, [Environment]::NewLine)
  $MainExternalDDSMipmapTip.SetToolTip($MainExternalDDSMipmap, $MainExternalDDSMipmapTipString)

  # Mipmap Options: Force Create Mipmaps - Create a checkbox.
  $global:MainForceMipmapsAll = New-Object Windows.Forms.CheckBox
  $MainForceMipmapsAll.Size = DPISize (New-Object Drawing.Size(145, 16))
  switch ($CTTPSSelectedMode -eq 'Phyre Mode')
  {
    $true  { $MainForceMipmapsAll.Location = DPISize (New-Object Drawing.Point(185, 39)) }
    $false { $MainForceMipmapsAll.Location = DPISize (New-Object Drawing.Point(185, 60)) }
  }
  $MainForceMipmapsAll.Name = 'ForceCreateMipmaps'
  $MainForceMipmapsAll.Text = ' Force Create Mipmaps'
  $MainForceMipmapsAll.Checked = $ForceCreateMipmaps
  $MainForceMipmapsAll.Enabled = !$DisableMipmaps
  $MainForceMipmapsAll.Add_CheckStateChanged({ CheckBoxStateToggled})
  $MainMipmapGroup.Controls.Add($MainForceMipmapsAll)

  # Mipmap Options: Force Create Mipmaps - Create a tooltip.
  $MainForceMipmapsAllTip = New-Object Windows.Forms.ToolTip
  $MainForceMipmapsAllTip.InitialDelay = $ToolTipDelay
  $MainForceMipmapsAllTip.AutoPopDelay = $ToolTipDuration
  $MainForceMipmapsAllTipString = 'Force creating mipmaps for all textures. It appears{0}'
  $MainForceMipmapsAllTipString += 'that Dolphin can make use of mipmaps in textures{0}'
  $MainForceMipmapsAllTipString += 'that are not mipmap textures ("m" in the filename).{0}'
  $MainForceMipmapsAllTipString += 'It is not suggested to use this option on entire packs{0}'
  $MainForceMipmapsAllTipString += 'as many textures will not need mipmaps (such as UI{0}'
  $MainForceMipmapsAllTipString += 'textures) and will only add file size to the pack.'
  $MainForceMipmapsAllTipString = [String]::Format($MainForceMipmapsAllTipString, [Environment]::NewLine)
  $MainForceMipmapsAllTip.SetToolTip($MainForceMipmapsAll, $MainForceMipmapsAllTipString)

  # Buttons: Start - The "Start" button runs the selected operation.
  $global:MainStartButton = New-Object Windows.Forms.Button
  $MainStartButton.Size = DPISize (New-Object Drawing.Size(72, 28))
  $MainStartButton.Location = DPISize (New-Object Drawing.Point(9, 554))
  $MainStartButton.Text = 'Start'
  $MainStartButton.Enabled = (TestPath -LiteralPath $ImageMagick)
  $MainStartButton.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $MainStartButton.Add_Click({ InitiateMasterLoop })
  $MainDialogPanel.Controls.Add($MainStartButton)

  # Buttons: Start - Create a tip for the start button.
  $MainStartTip = New-Object Windows.Forms.ToolTip
  $MainStartTip.InitialDelay = $ToolTipDelay
  $MainStartTip.AutoPopDelay = $ToolTipDuration
  $MainStartTipString = 'Begins processing all textures found in the{0}'
  $MainStartTipString += '"Input Path" with the selected operation.'
  $MainStartTipString = [String]::Format($MainStartTipString, [Environment]::NewLine)
  $MainStartTip.SetToolTip($MainStartButton, $MainStartTipString)

  # Buttons: Process Selected - The [!] button allows selecting specific textures to process.
  $global:MainProcessButton = New-Object Windows.Forms.Button
  $MainProcessButton.Size = DPISize (New-Object Drawing.Size(16, 28))
  $MainProcessButton.Location = DPISize (New-Object Drawing.Point(81, 554))
  $MainProcessButton.Text = '$'
  $MainProcessButton.Enabled = (TestPath -LiteralPath $ImageMagick)
  $MainProcessButton.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom)
  $MainProcessButton.Add_Click({ if (ProcessSelected_Dialog) { InitiateMasterLoop } })
  $MainDialogPanel.Controls.Add($MainProcessButton)

  # Buttons: Process Selected - Create a tip for the process selected button.
  $MainProcessTip = New-Object Windows.Forms.ToolTip
  $MainProcessTip.InitialDelay = 250
  $MainProcessTip.AutoPopDelay = $ToolTipDuration
  $MainProcessTipString = 'Opens the "Process Selected" dialog which allows bypassing the{0}'
  $MainProcessTipString += 'Input Path and selecting specific textures to process. Textures{0}'
  $MainProcessTipString += 'can be manually selected or added with a drag and drop. Only{0}'
  $MainProcessTipString += 'selected textures will be processed with the current operation.'
  $MainProcessTipString = [String]::Format($MainProcessTipString, [Environment]::NewLine)
  $MainProcessTip.SetToolTip($MainProcessButton, $MainProcessTipString)

  # Buttons: Options - Toggles the window that contains several options.
  $global:MainOptionsButton = New-Object Windows.Forms.Button
  $MainOptionsButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $MainOptionsButton.Location = DPISize (New-Object Drawing.Point(110, 554))
  $MainOptionsButton.Text = 'Options'
  $MainOptionsButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $MainOptionsButton.AllowDrop = $true
  $MainOptionsButton.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $MainOptionsButton.Add_Click({ PopulateSuperScalerModels ; $OptionsDialog.ShowDialog() })
  $MainOptionsButton.Add_DragDrop({ ImportAllGlobalVariables_DragAndDrop })
  $MainDialogPanel.Controls.Add($MainOptionsButton)

  # Buttons: Options - Create a tip for the button.
  $MainOptionsTip = New-Object Windows.Forms.ToolTip
  $MainOptionsTip.InitialDelay = $ToolTipDelay
  $MainOptionsTip.AutoPopDelay = $ToolTipDuration
  $MainOptionsTipString = 'Opens the Options menu.'
  $MainOptionsTip.SetToolTip($MainOptionsButton, $MainOptionsTipString)

  # Buttons: Help - Opens the help dialog.
  $global:MainHelpButton = New-Object Windows.Forms.Button
  $MainHelpButton.Size = DPISize (New-Object Drawing.Size(84, 28))
  $MainHelpButton.Location = DPISize (New-Object Drawing.Point(206, 554))
  $MainHelpButton.Name = 'Help'
  $MainHelpButton.Text = 'Help'
  $MainHelpButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $MainHelpButton.Add_Click({ if (!$HelpDialog.Visible) { $HelpDialog.Show() } else { $HelpDialog.Hide() } })
  $MainDialogPanel.Controls.Add($MainHelpButton)

  # Buttons: Help - Create a tip for the button.
  $MainHelpButtonTip = New-Object Windows.Forms.ToolTip
  $MainHelpButtonTip.InitialDelay = $ToolTipDelay
  $MainHelpButtonTip.AutoPopDelay = $ToolTipDuration
  $MainHelpButtonTipString =  'Opens the Help dialog which{0}'
  $MainHelpButtonTipString += 'covers how to use this script.'
  $MainHelpButtonTipString = [String]::Format($MainHelpButtonTipString, [Environment]::NewLine)
  $MainHelpButtonTip.SetToolTip($MainHelpButton, $MainHelpButtonTipString)

  # Buttons: Close - Exits the script.
  $global:MainCloseButton = New-Object Windows.Forms.Button
  $MainCloseButton.Size = DPISize (New-Object Drawing.Size(88, 28))
  $MainCloseButton.Location = DPISize (New-Object Drawing.Point(303, 554))
  $MainCloseButton.Text = 'Exit'
  $MainCloseButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $MainCloseButton.Add_Click({ $TexListDialog.Close ; $MainDialog.Close()  })
  $MainDialogPanel.Controls.Add($MainCloseButton)

  # Buttons: Close - Create a tip for the button.
  $MainCloseTip = New-Object Windows.Forms.ToolTip
  $MainCloseTip.InitialDelay = $ToolTipDelay
  $MainCloseTip.AutoPopDelay = $ToolTipDuration
  $MainCloseTipString  = 'Closes the GUI and exits{0}'
  $MainCloseTipString += 'Custom Texture Tool PS.'
  $MainCloseTipString = [String]::Format($MainCloseTipString, [Environment]::NewLine)
  $MainCloseTip.SetToolTip($MainCloseButton, $MainCloseTipString)

  # Buttons: No-Save Close - Exits the script.
  $global:MainNoSaveButton = New-Object Windows.Forms.Button
  $MainNoSaveButton.Size = DPISize (New-Object Drawing.Size(16, 28))
  $MainNoSaveButton.Location = DPISize (New-Object Drawing.Point(375, 554))
  $MainNoSaveButton.Text = '!'
  $MainNoSaveButton.Anchor = ([Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom)
  $MainNoSaveButton.Add_Click({ $global:NoSave = $true ; $TexListDialog.Close ; $MainDialog.Close() })
  $MainDialogPanel.Controls.Add($MainNoSaveButton)

  # Buttons: No-Save Close - Create a tip for the button.
  $MainNoSaveTip = New-Object Windows.Forms.ToolTip
  $MainNoSaveTip.InitialDelay = 250
  $MainNoSaveTip.AutoPopDelay = $ToolTipDuration
  $MainNoSaveTipString  = 'Closes the GUI and exits{0}'
  $MainNoSaveTipString += 'Custom Texture Tool PS{0}'
  $MainNoSaveTipString += 'without saving anything.'
  $MainNoSaveTipString = [String]::Format($MainNoSaveTipString, [Environment]::NewLine)
  $MainNoSaveTip.SetToolTip($MainNoSaveButton, $MainNoSaveTipString)
}
#==============================================================================================================================================================================================
#  CTT GUI: A GUI TO CONTROL OPTIONS FOR DDS TOOLS
#==============================================================================================================================================================================================
#  Show the DDS Tool options and adjust the form to show the currently selected tool.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowDDSToolOptions([string]$DDSTool)
{
  # Adjust the menu depending on which tool is selected.
  switch ($DDSTool)
  {
    'Compressonator'
    {
      # Set the size of the dialog.
      $DDSToolsDialog.Size = $DDSToolsDialog.MinimumSize = $DDSToolsDialog.MaximumSize = DPISize (New-Object Drawing.Size(280, 254))
      $DDSToolsDialog.Controls.Add($DDSToolsCompressPanel)
      $DDSToolsOKButton.Location = DPISize (New-Object Drawing.Point(171, 184)) -Round
    }
    'TexConv'
    {
      # Set the size of the dialog.
      $DDSToolsDialog.Size = $DDSToolsDialog.MinimumSize = $DDSToolsDialog.MaximumSize = DPISize (New-Object Drawing.Size(280, 224))
      $DDSToolsDialog.Controls.Add($DDSToolsTexConvPanel)
      $DDSToolsOKButton.Location = DPISize (New-Object Drawing.Point(171, 154)) -Round
    }
    'ImageMagick'
    {
      # Set the size of the dialog.
      $DDSToolsDialog.Size = $DDSToolsDialog.MinimumSize = $DDSToolsDialog.MaximumSize = DPISize (New-Object Drawing.Size(280, 126))
      $DDSToolsDialog.Controls.Add($DDSToolsImageMagickPanel)
      $DDSToolsOKButton.Location = DPISize (New-Object Drawing.Point(171, 58)) -Round
    }
  }
  # Show the dialog.
  $DDSToolsDialog.ShowDialog() | Out-Null

  # After the dialog is closed, remove the panels.
  $DDSToolsDialog.Controls.Remove($DDSToolsImageMagickPanel)
  $DDSToolsDialog.Controls.Remove($DDSToolsCompressPanel)
  $DDSToolsDialog.Controls.Remove($DDSToolsTexConvPanel)
}
#==============================================================================================================================================================================================
#  Create the GUI for the DDS Tool options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_DDSToolOptions()
{
  # Create the dialog and set up properties.
  $global:DDSToolsDialog = New-Object Windows.Forms.Form
  $DDSToolsDialog.Size = DPISize (New-Object Drawing.Size(280, 226))
  $DDSToolsDialog.MinimumSize = DPISize (New-Object Drawing.Size(280, 226))
  $DDSToolsDialog.MaximumSize = DPISize (New-Object Drawing.Size(280, 226))
  $DDSToolsDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $DDSToolsDialog.Text = 'CTT-PS DDS Tool Options'
  $DDSToolsDialog.MinimizeBox = $false
  $DDSToolsDialog.MaximizeBox = $false
  $DDSToolsDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $DDSToolsDialog.FormBorderStyle = GetFormBorderStyle
  $DDSToolsDialog.StartPosition = "CenterScreen"
  $DDSToolsDialog.Topmost = !$DisableTopMost
  $DDSToolsDialog.KeyPreview = $true
  $DDSToolsDialog.Add_KeyDown({ EscapeCloseDialog })
  $DDSToolsDialog.Add_FormClosing({ $DDSToolsDialog.Hide() ; $_.Cancel = $true })
  $DDSToolsDialog.Icon = $Icon_CTTPSGreen

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:DDSToolsFocusLabel = New-Object Windows.Forms.Label
  $DDSToolsFocusLabel.Size = New-Object Drawing.Size(1,1)
  $DDSToolsFocusLabel.Location = New-Object Drawing.Point(0,0)
  $DDSToolsDialog.Controls.Add($DDSToolsFocusLabel)

  #---------------------------------------------------------------------------------------------
  # Compressonator Options
  #---------------------------------------------------------------------------------------------
  # Create a panel to hold options for Compressonator.
  $global:DDSToolsCompressPanel = New-Object Windows.Forms.Panel
  $DDSToolsCompressPanel.Size = DPISize (New-Object Drawing.Size(264, 180))
  $DDSToolsCompressPanel.Location = DPISize (New-Object Drawing.Point(0, 0))

  # Create a groupbox to hold the Compressonator options.
  $global:DDSToolsCompressGroup = New-Object Windows.Forms.GroupBox
  $DDSToolsCompressGroup.Size = DPISize (New-Object Drawing.Size(248, 176))
  $DDSToolsCompressGroup.Location = DPISize (New-Object Drawing.Point(8, 4))
  $DDSToolsCompressGroup.Text = 'Compressonator Options'
  $DDSToolsCompressPanel.Controls.Add($DDSToolsCompressGroup)

  # BC7 Quality - Create a combobox.
  $global:CompressBC7QualityCombo = New-Object Windows.Forms.ComboBox
  $CompressBC7QualityCombo.Size = DPISize (New-Object Drawing.Size(76, 20))
  $CompressBC7QualityCombo.Location = DPISize (New-Object Drawing.Point(12, 18))
  $CompressBC7QualityCombo.Name = 'CompressBC7Quality'
  $CompressBC7QualityCombo.Items.Add('Auto') | Out-Null
  $CompressBC7QualityCombo.Items.Add('Low/Fast') | Out-Null
  $CompressBC7QualityCombo.Items.Add('Medium') | Out-Null
  $CompressBC7QualityCombo.Items.Add('High') | Out-Null
  $CompressBC7QualityCombo.Items.Add('Very High') | Out-Null
  $CompressBC7QualityCombo.Items.Add('*Ultra') | Out-Null
  $CompressBC7QualityCombo.Items.Add('*Extreme') | Out-Null
  $CompressBC7QualityCombo.SelectedItem = $CompressBC7Quality
  $CompressBC7QualityCombo.Add_SelectedIndexChanged({ $DDSToolsFocusLabel.Focus() })
  $CompressBC7QualityCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $CompressBC7QualityCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $CompressBC7QualityCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $CompressBC7QualityCombo.Add_DrawItem({ RepopulateComboBox })
  $DDSToolsCompressGroup.Controls.Add($CompressBC7QualityCombo)

  # BC7 Quality - Create a label for the option.
  $global:CompressBC7QualityLabel = New-Object Windows.Forms.Label
  $CompressBC7QualityLabel.Size = DPISize (New-Object Drawing.Size(120, 16))
  $CompressBC7QualityLabel.Location = DPISize (New-Object Drawing.Point(93, 21))
  $CompressBC7QualityLabel.Text = 'BC7 Quality Mode'
  $DDSToolsCompressGroup.Controls.Add($CompressBC7QualityLabel)

  # BC7 Quality - Create a tooltip for the option.
  $CompressBC7QualityTip = New-Object Windows.Forms.ToolTip
  $CompressBC7QualityTip.InitialDelay = $ToolTipDelay
  $CompressBC7QualityTip.AutoPopDelay = $ToolTipDuration
  $CompressBC7QualityTipString = 'Sets the output quality of DDS-BC7 textures when using{0}'
  $CompressBC7QualityTipString += 'Compressonator. Does not work for other programs.{0}'
  $CompressBC7QualityTipString += '{0}'
  $CompressBC7QualityTipString += '"Auto" should generally be used when converting an entire{0}'
  $CompressBC7QualityTipString += 'pack as it offers a good balance between speed and quality.{0}'
  $CompressBC7QualityTipString += 'Higher qualities are chosen for smaller images that contain{0}'
  $CompressBC7QualityTipString += 'transparency, and lower quality is chosen for larger images.{0}'
  $CompressBC7QualityTipString += '{0}'
  $CompressBC7QualityTipString += 'The compression speed impact is much greater with each{0}'
  $CompressBC7QualityTipString += 'step up in quality, and anything other than "Auto" applies{0}'
  $CompressBC7QualityTipString += 'the same level of quality to all images. This means manually{0}'
  $CompressBC7QualityTipString += 'setting the quality level is generally not a good idea when{0}'
  $CompressBC7QualityTipString += 'converting entire packs, unless a lower setting is chosen.{0}'
  $CompressBC7QualityTipString += '{0}'
  $CompressBC7QualityTipString += 'Ultra and Extreme are VERY CPU intensive, and will increase{0}'
  $CompressBC7QualityTipString += 'the conversion time exponentially. Expect it to take hours{0}'
  $CompressBC7QualityTipString += 'to even days depending on the size of the pack/textures.'
  $CompressBC7QualityTipString = [String]::Format($CompressBC7QualityTipString, [Environment]::NewLine)
  $CompressBC7QualityTip.SetToolTip($CompressBC7QualityLabel, $CompressBC7QualityTipString)

  # Texture Encoding - Create a combo for GPU encoding.
  $global:CompressGPUEncodeCombo = New-Object Windows.Forms.ComboBox
  $CompressGPUEncodeCombo.Size = DPISize (New-Object Drawing.Size(76, 20))
  $CompressGPUEncodeCombo.Location = DPISize (New-Object Drawing.Point(12, 44))
  $CompressGPUEncodeCombo.Name = 'CompressEncodeWith'
  $CompressGPUEncodeCombo.Items.Add('CPU') | Out-Null
  $CompressGPUEncodeCombo.Items.Add('HPC') | Out-Null
  $CompressGPUEncodeCombo.Items.Add('GPU') | Out-Null
  $CompressGPUEncodeCombo.Items.Add('DXC') | Out-Null
  $CompressGPUEncodeCombo.Items.Add('VLK') | Out-Null
  $CompressGPUEncodeCombo.Items.Add('OCL') | Out-Null
  $CompressGPUEncodeCombo.SelectedItem = $CompressEncodeWith
  $CompressGPUEncodeCombo.Add_SelectedIndexChanged({ $DDSToolsFocusLabel.Focus() })
  $CompressGPUEncodeCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $CompressGPUEncodeCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $CompressGPUEncodeCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $CompressGPUEncodeCombo.Add_DrawItem({ RepopulateComboBox })
  $DDSToolsCompressGroup.Controls.Add($CompressGPUEncodeCombo)

  # Texture Encoding - Create a label for the option.
  $global:CompressGPUEncodeLabel = New-Object Windows.Forms.Label
  $CompressGPUEncodeLabel.Size = DPISize (New-Object Drawing.Size(120, 16))
  $CompressGPUEncodeLabel.Location = DPISize (New-Object Drawing.Point(93, 47))
  $CompressGPUEncodeLabel.Text = 'Compression Encoder'
  $DDSToolsCompressGroup.Controls.Add($CompressGPUEncodeLabel)

  # Texture Encoding - Create a tooltip for the option.
  $CompressGPUEncodeTip = New-Object Windows.Forms.ToolTip
  $CompressGPUEncodeTip.InitialDelay = $ToolTipDelay
  $CompressGPUEncodeTip.AutoPopDelay = $ToolTipDuration
  $CompressGPUEncodeTipString =  'Set the compression method used when generating{0}'
  $CompressGPUEncodeTipString += 'textures. This can increase the speed significantly.{0}'
  $CompressGPUEncodeTipString += '{0}'
  $CompressGPUEncodeTipString += 'CPU - Compress using only the CPU.{0}'
  $CompressGPUEncodeTipString += 'HPC - Compress using CPU High Performance Compute.{0}'
  $CompressGPUEncodeTipString += 'GPU - Compress using OpenGL compute.{0}'
  $CompressGPUEncodeTipString += 'DXC - Compress using Direct-X compute.{0}'
  $CompressGPUEncodeTipString += 'VLK - Compress using Vulkan compute.{0}'
  $CompressGPUEncodeTipString += 'OCL - Compress using OpenCL compute.{0}'
  $CompressGPUEncodeTipString += '{0}'
  $CompressGPUEncodeTipString += 'What ends up being the fastest can vary from system{0}'
  $CompressGPUEncodeTipString += 'to sytem, but CPU should always be the slowest option.{0}'
  $CompressGPUEncodeTipString += 'HPC seems to be really fast on a CPU with many cores.'
  $CompressGPUEncodeTipString = [String]::Format($CompressGPUEncodeTipString, [Environment]::NewLine)
  $CompressGPUEncodeTip.SetToolTip($CompressGPUEncodeLabel, $CompressGPUEncodeTipString)

  # Texture Decoding - Create a combo for GPU decoding API.
  $global:CompressGPUDecodeCombo = New-Object Windows.Forms.ComboBox
  $CompressGPUDecodeCombo.Size = DPISize (New-Object Drawing.Size(76, 20))
  $CompressGPUDecodeCombo.Location = DPISize (New-Object Drawing.Point(12, 70))
  $CompressGPUDecodeCombo.Name = 'CompressDecodeWith'
  $CompressGPUDecodeCombo.Items.Add('CPU') | Out-Null
  $CompressGPUDecodeCombo.Items.Add('OpenGL') | Out-Null
  $CompressGPUDecodeCombo.Items.Add('DirectX') | Out-Null
  $CompressGPUDecodeCombo.Items.Add('Vulkan') | Out-Null
  $CompressGPUDecodeCombo.SelectedItem = $CompressDecodeWith
  $CompressGPUDecodeCombo.Add_SelectedIndexChanged({ $DDSToolsFocusLabel.Focus() })
  $CompressGPUDecodeCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $CompressGPUDecodeCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $CompressGPUDecodeCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $CompressGPUDecodeCombo.Add_DrawItem({ RepopulateComboBox })
  $DDSToolsCompressGroup.Controls.Add($CompressGPUDecodeCombo)

  # Texture Decoding - Create a label for the option.
  $global:CompressGPUDecodeLabel = New-Object Windows.Forms.Label
  $CompressGPUDecodeLabel.Size = DPISize (New-Object Drawing.Size(120, 16))
  $CompressGPUDecodeLabel.Location = DPISize (New-Object Drawing.Point(93, 73))
  $CompressGPUDecodeLabel.Text = 'Compression Decoder'
  $DDSToolsCompressGroup.Controls.Add($CompressGPUDecodeLabel)

  # Texture Decoding - Create a tooltip for the option.
  $CompressGPUDecodeTip = New-Object Windows.Forms.ToolTip
  $CompressGPUDecodeTip.InitialDelay = $ToolTipDelay
  $CompressGPUDecodeTip.AutoPopDelay = $ToolTipDuration
  $CompressGPUDecodeTipString =  'Compressonator uses the CPU by default when{0}'
  $CompressGPUDecodeTipString += 'decompressing BC7 textures. This option can{0}'
  $CompressGPUDecodeTipString += 'instead use the GPU using a graphics API. This{0}'
  $CompressGPUDecodeTipString += 'may provide a significant performance boost.{0}'
  $CompressGPUDecodeTipString += '{0}'
  $CompressGPUDecodeTipString += 'This option only takes effect when setting the{0}'
  $CompressGPUDecodeTipString += '"BC7 to PNG Converter" to "Compressonator"{0}'
  $CompressGPUDecodeTipString += 'found on the "PNG Options" menu. Note that{0}'
  $CompressGPUDecodeTipString += 'Vulkan appears to fail on systems that should{0}'
  $CompressGPUDecodeTipString += 'support it. I suggest DirectX or OGL.'
  $CompressGPUDecodeTipString = [String]::Format($CompressGPUDecodeTipString, [Environment]::NewLine)
  $CompressGPUDecodeTip.SetToolTip($CompressGPUDecodeLabel, $CompressGPUDecodeTipString)

  # CPU Threads - Create a number box that specifies the number of threads.
  $global:CompressNumThreadsNBox = New-Object Windows.Forms.NumericUpDown
  $CompressNumThreadsNBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $CompressNumThreadsNBox.Location = DPISize (New-Object Drawing.Point(12, 98))
  $CompressNumThreadsNBox.Name = 'CompressNumThreads'
  $CompressNumThreadsNBox.DecimalPlaces = 0
  $CompressNumThreadsNBox.Minimum = 0
  $CompressNumThreadsNBox.Maximum = 128
  $CompressNumThreadsNBox.Increment = 1
  $CompressNumThreadsNBox.Value = $CompressNumThreads
  $CompressNumThreadsNBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $DDSToolsCompressGroup.Controls.Add($CompressNumThreadsNBox)

  # CPU Threads - Create a label to accompany the numeric up/down.
  $global:CompressNumThreadsLabel = New-Object Windows.Forms.Label
  $CompressNumThreadsLabel.Size = DPISize (New-Object Drawing.Size(160, 16))
  $CompressNumThreadsLabel.Location = DPISize (New-Object Drawing.Point(66, 100))
  $CompressNumThreadsLabel.Text = 'BC7 CPU Encoding Threads'
  $DDSToolsCompressGroup.Controls.Add($CompressNumThreadsLabel)

  # CPU Threads - Create a tooltip for the option.
  $CompressNumThreadsTip = New-Object Windows.Forms.ToolTip
  $CompressNumThreadsTip.InitialDelay = $ToolTipDelay
  $CompressNumThreadsTip.AutoPopDelay = $ToolTipDuration
  $CompressNumThreadsTipString =  'This option only applies when "CPU" is chosen as{0}'
  $CompressNumThreadsTipString += 'the "Compression Encoder", and maybe "HPC".{0}'
  $CompressNumThreadsTipString += '{0}'
  $CompressNumThreadsTipString += 'The number of CPU threads used when creating{0}'
  $CompressNumThreadsTipString += 'BC6/BC7 textures. A maximum of 128 threads can{0}'
  $CompressNumThreadsTipString += 'be entered, but this should not exceed the number{0}'
  $CompressNumThreadsTipString += 'of logical threads your CPU supports. If the value{0}'
  $CompressNumThreadsTipString += 'exceeds the threads, it may end up being slower.{0}'
  $CompressNumThreadsTipString += '{0}'
  $CompressNumThreadsTipString += 'The fallback value is 8 threads if detection fails{0}'
  $CompressNumThreadsTipString += 'when manually entering the value, and entering{0}'
  $CompressNumThreadsTipString += '0 uses the total number of physical CPU cores.'
  $CompressNumThreadsTipString = [String]::Format($CompressNumThreadsTipString, [Environment]::NewLine)
  $CompressNumThreadsTip.SetToolTip($CompressNumThreadsLabel, $CompressNumThreadsTipString)

  # Swizzle Red/Blue - Create a checkbox for swizzling the red and blue channel.
  $global:CompressSwizzleCheck = New-Object Windows.Forms.CheckBox
  $CompressSwizzleCheck.Size = DPISize (New-Object Drawing.Size(190, 16))
  $CompressSwizzleCheck.Location = DPISize (New-Object Drawing.Point(12, 124))
  $CompressSwizzleCheck.Name = 'CompressSwizzle'
  $CompressSwizzleCheck.Checked = $CompressSwizzle
  $CompressSwizzleCheck.Text = ' Swizzle Red and Blue Channels'
  $CompressSwizzleCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DDSToolsCompressGroup.Controls.Add($CompressSwizzleCheck)

  # Swizzle Red/Blue - Create a tooltip for the option.
  $CompressSwizzleTip = New-Object Windows.Forms.ToolTip
  $CompressSwizzleTip.InitialDelay = $ToolTipDelay
  $CompressSwizzleTip.AutoPopDelay = $ToolTipDuration
  $CompressSwizzleTipString = 'Swizzle the source images Red and Blue channels.'
  $CompressSwizzleTip.SetToolTip($CompressSwizzleCheck, $CompressSwizzleTipString)

  # Peformance - Create a checkbox for swizzling the red and blue channel.
  $global:CompressPerformCheck = New-Object Windows.Forms.CheckBox
  $CompressPerformCheck.Size = DPISize (New-Object Drawing.Size(230, 16))
  $CompressPerformCheck.Location = DPISize (New-Object Drawing.Point(12, 148))
  $CompressPerformCheck.Name = 'CompressNoPerformance'
  $CompressPerformCheck.Checked = $CompressNoPerformance
  $CompressPerformCheck.Text = ' Disable BC7 "-Performance" Command'
  $CompressPerformCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DDSToolsCompressGroup.Controls.Add($CompressPerformCheck)

  # Performance - Create a tooltip for the option.
  $CompressPerformTip = New-Object Windows.Forms.ToolTip
  $CompressPerformTip.InitialDelay = $ToolTipDelay
  $CompressPerformTip.AutoPopDelay = $ToolTipDuration
  $CompressPerformTipString =  'The "-Performance" command gives a large boost{0}'
  $CompressPerformTipString += 'in speed when creating BC7 textures and slightly{0}'
  $CompressPerformTipString += 'affects the output quality. While you will probably{0}'
  $CompressPerformTipString += 'always want this to be enabled, it does not work{0}'
  $CompressPerformTipString += 'in several versions of Compressonator. This broke{0}'
  $CompressPerformTipString += 'after v3.0.3707 and it was fixed again in v4.2.518.'
  $CompressPerformTipString = [String]::Format($CompressPerformTipString, [Environment]::NewLine)
  $CompressPerformTip.SetToolTip($CompressPerformCheck, $CompressPerformTipString)

  #---------------------------------------------------------------------------------------------
  # TexConv Options
  #---------------------------------------------------------------------------------------------
  # Create a panel to hold options for TexConv.
  $global:DDSToolsTexConvPanel = New-Object Windows.Forms.Panel
  $DDSToolsTexConvPanel.Size = DPISize (New-Object Drawing.Size(264, 150))
  $DDSToolsTexConvPanel.Location = DPISize (New-Object Drawing.Point(0, 0))

  # Create a groupbox to hold the TexConv options.
  $global:DDSToolsTexConvGroup = New-Object Windows.Forms.GroupBox
  $DDSToolsTexConvGroup.Size = DPISize (New-Object Drawing.Size(248, 146))
  $DDSToolsTexConvGroup.Location = DPISize (New-Object Drawing.Point(8, 4))
  $DDSToolsTexConvGroup.Text = 'TexConv Options'
  $DDSToolsTexConvPanel.Controls.Add($DDSToolsTexConvGroup)

  # Create a combobox to select the compression mode.
  $global:TexConvCompSpeedCombo = New-Object Windows.Forms.ComboBox
  $TexConvCompSpeedCombo.Size = DPISize (New-Object Drawing.Size(92, 20))
  $TexConvCompSpeedCombo.Location = DPISize (New-Object Drawing.Point(12, 18))
  $TexConvCompSpeedCombo.Name = 'TexConvCompSpeed'
  $TexConvCompSpeedCombo.Items.Add('Quick') | Out-Null
  $TexConvCompSpeedCombo.Items.Add('Standard') | Out-Null
  $TexConvCompSpeedCombo.Items.Add('Maximum') | Out-Null
  $TexConvCompSpeedCombo.SelectedItem = $TexConvCompSpeed
  $TexConvCompSpeedCombo.Add_SelectedIndexChanged({ $DDSToolsFocusLabel.Focus() })
  $TexConvCompSpeedCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $TexConvCompSpeedCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $TexConvCompSpeedCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $TexConvCompSpeedCombo.Add_DrawItem({ RepopulateComboBox })
  $DDSToolsTexConvGroup.Controls.Add($TexConvCompSpeedCombo)

  # Create a label for the option.
  $global:TexConvCompSpeedLabel = New-Object Windows.Forms.Label
  $TexConvCompSpeedLabel.Size = DPISize (New-Object Drawing.Size(130, 16))
  $TexConvCompSpeedLabel.Location = DPISize (New-Object Drawing.Point(108, 21))
  $TexConvCompSpeedLabel.Text = 'BC7 Compression Mode'
  $DDSToolsTexConvGroup.Controls.Add($TexConvCompSpeedLabel)

  # Create a tooltip for the option.
  $TexConvCompSpeedTip = New-Object Windows.Forms.ToolTip
  $TexConvCompSpeedTip.InitialDelay = $ToolTipDelay
  $TexConvCompSpeedTip.AutoPopDelay = $ToolTipDuration
  $TexConvCompSpeedTipString =  'Sets the compression speed when creating{0}'
  $TexConvCompSpeedTipString += 'BC7 textures. Higher compression requires{0}'
  $TexConvCompSpeedTipString += 'more processing power and thus more time.'
  $TexConvCompSpeedTipString = [String]::Format($TexConvCompSpeedTipString, [Environment]::NewLine)
  $TexConvCompSpeedTip.SetToolTip($TexConvCompSpeedLabel, $TexConvCompSpeedTipString)

  # Create a combobox to select the compression mode.
  $global:TexConvAlphaCombo = New-Object Windows.Forms.ComboBox
  $TexConvAlphaCombo.Size = DPISize (New-Object Drawing.Size(92, 20))
  $TexConvAlphaCombo.Location = DPISize (New-Object Drawing.Point(12, 44))
  $TexConvAlphaCombo.Name = 'TexConvAlphaType'
  $TexConvAlphaCombo.Items.Add('No Force') | Out-Null
  $TexConvAlphaCombo.Items.Add('Straight') | Out-Null
  $TexConvAlphaCombo.Items.Add('Premultiplied') | Out-Null
  $TexConvAlphaCombo.SelectedItem = $TexConvAlphaType
  $TexConvAlphaCombo.Add_SelectedIndexChanged({ $DDSToolsFocusLabel.Focus() })
  $TexConvAlphaCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $TexConvAlphaCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $TexConvAlphaCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $TexConvAlphaCombo.Add_DrawItem({ RepopulateComboBox })
  $DDSToolsTexConvGroup.Controls.Add($TexConvAlphaCombo)

  # Create a label for the option.
  $global:TexConvAlphaLabel = New-Object Windows.Forms.Label
  $TexConvAlphaLabel.Size = DPISize (New-Object Drawing.Size(130, 16))
  $TexConvAlphaLabel.Location = DPISize (New-Object Drawing.Point(108, 47))
  $TexConvAlphaLabel.Text = 'Alpha Compositing'
  $DDSToolsTexConvGroup.Controls.Add($TexConvAlphaLabel)

  # Create a tooltip for the option.
  $TexConvAlphaTip = New-Object Windows.Forms.ToolTip
  $TexConvAlphaTip.InitialDelay = $ToolTipDelay
  $TexConvAlphaTip.AutoPopDelay = $ToolTipDuration
  $TexConvAlphaTipString =  'Allows forcing straight alpha or{0}'
  $TexConvAlphaTipString += 'premultiplied alpha. By default,{0}'
  $TexConvAlphaTipString += 'the type of alpha is not forced.'
  $TexConvAlphaTipString = [String]::Format($TexConvAlphaTipString, [Environment]::NewLine)
  $TexConvAlphaTip.SetToolTip($TexConvAlphaLabel, $TexConvAlphaTipString)

  # Create a combobox to select the compression mode.
  $global:TexConvFlipCombo = New-Object Windows.Forms.ComboBox
  $TexConvFlipCombo.Size = DPISize (New-Object Drawing.Size(92, 20))
  $TexConvFlipCombo.Location = DPISize (New-Object Drawing.Point(12, 70))
  $TexConvFlipCombo.Name = 'TexConvFlipImage'
  $TexConvFlipCombo.Items.Add('Disabled') | Out-Null
  $TexConvFlipCombo.Items.Add('Horizontal') | Out-Null
  $TexConvFlipCombo.Items.Add('Vertical') | Out-Null
  $TexConvFlipCombo.Items.Add('Both') | Out-Null
  $TexConvFlipCombo.SelectedItem = $TexConvFlipImage
  $TexConvFlipCombo.Add_SelectedIndexChanged({ $DDSToolsFocusLabel.Focus() })
  $TexConvFlipCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $TexConvFlipCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $TexConvFlipCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $TexConvFlipCombo.Add_DrawItem({ RepopulateComboBox })
  $DDSToolsTexConvGroup.Controls.Add($TexConvFlipCombo)

  # Create a label for the option.
  $global:TexConvFlipLabel = New-Object Windows.Forms.Label
  $TexConvFlipLabel.Size = DPISize (New-Object Drawing.Size(130, 16))
  $TexConvFlipLabel.Location = DPISize (New-Object Drawing.Point(108, 73))
  $TexConvFlipLabel.Text = 'Flip Texture'
  $DDSToolsTexConvGroup.Controls.Add($TexConvFlipLabel)

  # Create a tooltip for the option.
  $TexConvFlipTip = New-Object Windows.Forms.ToolTip
  $TexConvFlipTip.InitialDelay = $ToolTipDelay
  $TexConvFlipTip.AutoPopDelay = $ToolTipDuration
  $TexConvFlipTipString =  'Can be used to flip the texture{0}'
  $TexConvFlipTipString += 'horizontally, vertically, or both.'
  $TexConvFlipTipString = [String]::Format($TexConvFlipTipString, [Environment]::NewLine)
  $TexConvFlipTip.SetToolTip($TexConvFlipLabel, $TexConvFlipTipString)

  # Operations: Global - Disables GPU acceleration when creating textures.
  $global:TexConvDisableGPUCheck = New-Object Windows.Forms.CheckBox
  $TexConvDisableGPUCheck.Size = DPISize (New-Object Drawing.Size(160, 16))
  $TexConvDisableGPUCheck.Location = DPISize (New-Object Drawing.Point(12, 98))
  $TexConvDisableGPUCheck.Name = 'TexConvDisableGPU'
  $TexConvDisableGPUCheck.Checked = $TexConvDisableGPU
  $TexConvDisableGPUCheck.Text = ' Disable GPU Acceleration'
  $TexConvDisableGPUCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DDSToolsTexConvGroup.Controls.Add($TexConvDisableGPUCheck)

  # Operations: Global - Create a tooltip for the option.
  $TexConvDisableGPUTip = New-Object Windows.Forms.ToolTip
  $TexConvDisableGPUTip.InitialDelay = $ToolTipDelay
  $TexConvDisableGPUTip.AutoPopDelay = $ToolTipDuration
  $TexConvDisableGPUTipString  = 'This option forces using the CPU when creating BC7{0}'
  $TexConvDisableGPUTipString += 'textures with TexConv. It is not suggested to use{0}'
  $TexConvDisableGPUTipString += 'this option outside of troubleshooting issues such{0}'
  $TexConvDisableGPUTipString += 'as testing the CPU when the GPU causes corruption.'
  $TexConvDisableGPUTipString = [String]::Format($TexConvDisableGPUTipString, [Environment]::NewLine)
  $TexConvDisableGPUTip.SetToolTip($TexConvDisableGPUCheck, $TexConvDisableGPUTipString)

  # DDS Options: Force sRGB - Create a checkbox.
  $global:TexConvSRGBCheck = New-Object Windows.Forms.CheckBox
  $TexConvSRGBCheck.Size = DPISize (New-Object Drawing.Size(154, 18))
  $TexConvSRGBCheck.Location = DPISize (New-Object Drawing.Point(12, 120))
  $TexConvSRGBCheck.Name = 'TexConvForceSRGB'
  $TexConvSRGBCheck.Text = ' Force sRGB Colorspace'
  $TexConvSRGBCheck.Checked = $TexConvForceSRGB
  $TexConvSRGBCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DDSToolsTexConvGroup.Controls.Add($TexConvSRGBCheck)

  # DDS Options: Force sRGB - Create a tooltip for the option.
  $MainDDSSRGBTip = New-Object Windows.Forms.ToolTip
  $MainDDSSRGBTip.InitialDelay = $ToolTipDelay
  $MainDDSSRGBTip.AutoPopDelay = $ToolTipDuration
  $MainDDSSRGBTipString =  'Creates the SRGB DXGI variant of a DDS texture when{0}'
  $MainDDSSRGBTipString += 'creating textures with the DX10 header. For example,{0}'
  $MainDDSSRGBTipString += 'instead of creating "DXGI_FORMAT_BC3_UNORM", the{0}'
  $MainDDSSRGBTipString += 'resulting texture is "DXGI_FORMAT_BC3_UNORM_SRGB".{0}'
  $MainDDSSRGBTipString += '{0}'
  $MainDDSSRGBTipString += 'This is only true for BC1-BC3 and BC7. For BC4-BC5, the{0}'
  $MainDDSSRGBTipString += 'texture will use "SNORM" instead of "UNORM". For BC6,{0}'
  $MainDDSSRGBTipString += 'the texture will use "SF16" instead of "UF16". BC4-BC6{0}'
  $MainDDSSRGBTipString += 'use signed/unsigned values, the others will use SRGB.{0}'
  $MainDDSSRGBTipString += '{0}'
  $MainDDSSRGBTipString += 'This is a good option to try if textures created with{0}'
  $MainDDSSRGBTipString += 'TexConv come out as "too light" or "too dark" looking.'
  $MainDDSSRGBTipString = [String]::Format($MainDDSSRGBTipString, [Environment]::NewLine)
  $MainDDSSRGBTip.SetToolTip($TexConvSRGBCheck, $MainDDSSRGBTipString)

  #---------------------------------------------------------------------------------------------
  # ImageMagick Options
  #---------------------------------------------------------------------------------------------
  # Create a panel to hold options for ImageMagick.
  $global:DDSToolsImageMagickPanel = New-Object Windows.Forms.Panel
  $DDSToolsImageMagickPanel.Size = DPISize (New-Object Drawing.Size(264, 54))
  $DDSToolsImageMagickPanel.Location = DPISize (New-Object Drawing.Point(0, 0))

  # Create a groupbox to hold the ImageMagick options.
  $global:DDSToolsImageMagickGroup = New-Object Windows.Forms.GroupBox
  $DDSToolsImageMagickGroup.Size = DPISize (New-Object Drawing.Size(248, 50))
  $DDSToolsImageMagickGroup.Location = DPISize (New-Object Drawing.Point(8, 4))
  $DDSToolsImageMagickGroup.Text = 'ImageMagick Options'
  $DDSToolsImageMagickPanel.Controls.Add($DDSToolsImageMagickGroup)

  # Create an option to enable alpha weighting. 
  $global:ImageMagickAlphaCheck = New-Object Windows.Forms.CheckBox
  $ImageMagickAlphaCheck.Size = DPISize (New-Object Drawing.Size(154, 18))
  $ImageMagickAlphaCheck.Location = DPISize (New-Object Drawing.Point(12, 22))
  $ImageMagickAlphaCheck.Name = 'MagickAlphaWeight'
  $ImageMagickAlphaCheck.Text = ' DDS Alpha Weighting'
  $ImageMagickAlphaCheck.Checked = $MagickAlphaWeight
  $ImageMagickAlphaCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DDSToolsImageMagickGroup.Controls.Add($ImageMagickAlphaCheck)

  # Create a tooltip for the option.
  $ImageMagickAlphaTip = New-Object Windows.Forms.ToolTip
  $ImageMagickAlphaTip.InitialDelay = $ToolTipDelay
  $ImageMagickAlphaTip.AutoPopDelay = $ToolTipDuration
  $ImageMagickAlphaTipString = 'Enables DDS alpha weighting.'
  $ImageMagickAlphaTip.SetToolTip($ImageMagickAlphaCheck, $ImageMagickAlphaTipString)
  #---------------------------------------------------------------------------------------------
  # Final Stuff
  #---------------------------------------------------------------------------------------------
  # Create a button to close the window.
  $global:DDSToolsOKButton = New-Object Windows.Forms.Button
  $DDSToolsOKButton.Size = DPISize (New-Object Drawing.Size(86, 26))
  $DDSToolsOKButton.Location = DPISize (New-Object Drawing.Point(171, 164)) -Round
  $DDSToolsOKButton.Text = 'OK'
  $DDSToolsOKButton.Add_Click({ $DDSToolsDialog.Hide() })
  $DDSToolsDialog.Controls.Add($DDSToolsOKButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: WAIFU2X CONFIGURATION DIALOG
#==============================================================================================================================================================================================
#  Adjusts the dialog to show options for Waifu2x.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowWaifu2xDialog()
{
  # Show the dialog.
  $Waifu2xDialog.ShowDialog() | Out-Null
}
#==============================================================================================================================================================================================
#  Create the dialog for waifu2x options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_Waifu2xOptions()
{
  # Create the dialog and set up properties.
  $global:Waifu2xDialog = New-Object Windows.Forms.Form
  $Waifu2xDialog.Size = DPISize (New-Object Drawing.Size(310, 230))
  $Waifu2xDialog.MinimumSize = DPISize (New-Object Drawing.Size(310, 230))
  $Waifu2xDialog.MaximumSize = DPISize (New-Object Drawing.Size(310, 230))
  $Waifu2xDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $Waifu2xDialog.Text = 'Waifu2x Options'
  $Waifu2xDialog.MinimizeBox = $false
  $Waifu2xDialog.MaximizeBox = $false
  $Waifu2xDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $Waifu2xDialog.FormBorderStyle = GetFormBorderStyle
  $Waifu2xDialog.StartPosition = "CenterScreen"
  $Waifu2xDialog.Topmost = !$DisableTopMost
  $Waifu2xDialog.KeyPreview = $true
  $Waifu2xDialog.Add_KeyDown({ EscapeCloseDialog })
  $Waifu2xDialog.Add_FormClosing({ $Waifu2xDialog.Hide() ; $_.Cancel = $true })
  $Waifu2xDialog.Icon = $Icon_CTTPSGreen

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:Waifu2xFocusLabel = New-Object Windows.Forms.Label
  $Waifu2xFocusLabel.Size = New-Object Drawing.Size(1,1)
  $Waifu2xFocusLabel.Location = New-Object Drawing.Point(0,0)
  $Waifu2xDialog.Controls.Add($Waifu2xFocusLabel)

  # Operations: Waifu2x - General - Create a group box for "global" options.
  $global:OptionsWaifu2xGroup = New-Object Windows.Forms.GroupBox
  $OptionsWaifu2xGroup.Size = DPISize (New-Object Drawing.Size(278, 150))
  $OptionsWaifu2xGroup.Location = DPISize (New-Object Drawing.Point(8, 4))
  $OptionsWaifu2xGroup.Text = 'Waifu2x Options'
  $Waifu2xDialog.Controls.Add($OptionsWaifu2xGroup)

  # Operations: Waifu2x - Allows selecting the upscale model. Only available for Waifu2x-Caffe.
  $global:OptionsW2XModelCombo = New-Object Windows.Forms.ComboBox
  $OptionsW2XModelCombo.Size = DPISize (New-Object Drawing.Size(147, 10))
  $OptionsW2XModelCombo.Location = DPISize (New-Object Drawing.Point(12, 20))
  $OptionsW2XModelCombo.Name = 'Waifu2xModel'
  $OptionsW2XModelCombo.Items.Add('2D Illust (RGB)') | Out-Null
  $OptionsW2XModelCombo.Items.Add('2D Illust (UpRGB)') | Out-Null
  $OptionsW2XModelCombo.Items.Add('2D Illust (UpResNet10)') | Out-Null
  $OptionsW2XModelCombo.Items.Add('2D Illust (CUnet)') | Out-Null
  $OptionsW2XModelCombo.Items.Add('2D Illust (Y)') | Out-Null
  $OptionsW2XModelCombo.Items.Add('Photo (Standard)') | Out-Null
  $OptionsW2XModelCombo.Items.Add('Photo (UpPhoto)') | Out-Null
  $OptionsW2XModelCombo.SelectedItem = Waifu2x_FlipModelName -ModelName $Waifu2xModel
  $OptionsW2XModelCombo.Add_SelectedIndexChanged({ $Waifu2xFocusLabel.Focus() })
  $OptionsW2XModelCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Waifu2x_FlipModelName -ModelName $this.SelectedItem) })
  $OptionsW2XModelCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsW2XModelCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsW2XModelCombo.Add_DrawItem({ RepopulateComboBox })
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XModelCombo)

  # Operations: Waifu2x - Create a label for the combobox.
  $global:OptionsW2XModelLabel = New-Object Windows.Forms.Label
  $OptionsW2XModelLabel.Size = DPISize (New-Object Drawing.Size(94, 22))
  $OptionsW2XModelLabel.Location = DPISize (New-Object Drawing.Point(161, 23))
  $OptionsW2XModelLabel.Text = 'Upscale Model'
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XModelLabel)

  # Operations: Waifu2x - Create a tooltip for label.
  $OptionsW2XModelTip = New-Object Windows.Forms.ToolTip
  $OptionsW2XModelTip.InitialDelay = $ToolTipDelay
  $OptionsW2XModelTip.AutoPopDelay = $ToolTipDuration
  $OptionsW2XModelTipString = 'Allows selecting the model that waifu2x-Caffe uses. The names{0}'
  $OptionsW2XModelTipString += 'used on this GUI match those found on the GUI of waif2x-Caffe.{0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += '2D Illust (RGB): 2-dimensional image model for converting RGB.{0}'
  $OptionsW2XModelTipString += 'Internally uses the model "anime_style_art_rgb". {0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += '2D Illust (UpRGB): Higher quality than the previous. Uses more{0}'
  $OptionsW2XModelTipString += 'VRAM. Internally uses the model "upconv_7_anime_style_art_rgb".{0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += '2D Illust (UpResNet10): A model that converts with higher image{0}'
  $OptionsW2XModelTipString += 'quality than UpRGB. Internally uses the model "upresnet10".{0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += '2D Illust (CUnet): Highest quality model of all, claimed to be{0}'
  $OptionsW2XModelTipString += 'the best option. Internally uses the model "cunet".{0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += '2D Illust (Y): 2-dimensional illustration model that converts only{0}'
  $OptionsW2XModelTipString += 'the luminance. Internally uses the model "anime_style_art".{0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += 'Photo (Standard): Standard model for photography or animation.{0}'
  $OptionsW2XModelTipString += 'Internally uses the model "photo".{0}'
  $OptionsW2XModelTipString += '{0}'
  $OptionsW2XModelTipString += 'Photo (UpPhoto): Higher quality than the previous. Uses more{0}'
  $OptionsW2XModelTipString += 'VRAM. Internally uses the model "upconv_7_photo".'
  $OptionsW2XModelTipString = [String]::Format($OptionsW2XModelTipString, [Environment]::NewLine)
  $OptionsW2XModelTip.SetToolTip($OptionsW2XModelLabel, $OptionsW2XModelTipString)

  # Operations: Waifu2x - Controls whether to upscale with noise reduction, only apply scaling, or only apply noise reduction.
  $global:OptionsW2XModeCombo = New-Object Windows.Forms.ComboBox
  $OptionsW2XModeCombo.Size = DPISize (New-Object Drawing.Size(147, 10))
  $OptionsW2XModeCombo.Location = DPISize (New-Object Drawing.Point(12, 46))
  $OptionsW2XModeCombo.Name = 'Waifu2xCMode'
  $OptionsW2XModeCombo.Items.Add('Denoise & Scale') | Out-Null
  $OptionsW2XModeCombo.Items.Add('Scale Only') | Out-Null
  $OptionsW2XModeCombo.Items.Add('Denoise Only') | Out-Null
  $OptionsW2XModeCombo.Items.Add('Scale & Auto-Denoise') | Out-Null
  $OptionsW2XModeCombo.SelectedItem = Waifu2x_FlipConvertModeName -ModeName $Waifu2xCMode
  $OptionsW2XModeCombo.Add_SelectedIndexChanged({ $Waifu2xFocusLabel.Focus() })
  $OptionsW2XModeCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Waifu2x_FlipConvertModeName -ModeName $this.SelectedItem) ; Waif2x_ToggleNoiseValue })
  $OptionsW2XModeCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsW2XModeCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsW2XModeCombo.Add_DrawItem({ RepopulateComboBox })
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XModeCombo)

  # Operations: Waifu2x - Create a label for the combobox.
  $global:OptionsW2XModeLabel = New-Object Windows.Forms.Label
  $OptionsW2XModeLabel.Size = DPISize (New-Object Drawing.Size(96, 22))
  $OptionsW2XModeLabel.Location = DPISize (New-Object Drawing.Point(161, 49))
  $OptionsW2XModeLabel.Text = 'Conversion Mode'
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XModeLabel)

  # Operations: Waifu2x - Create a tooltip for the label.
  $OptionsW2XModeTip = New-Object Windows.Forms.ToolTip
  $OptionsW2XModeTip.InitialDelay = $ToolTipDelay
  $OptionsW2XModeTip.AutoPopDelay = $ToolTipDuration
  $OptionsW2XModeTipString = 'This option tells waifu2x when to upscale and when to apply noise reduction. {0}'
  $OptionsW2XModeTipString += '{0}'
  $OptionsW2XModeTipString += 'Denoise & Scale: Upscale and apply noise reduction to the image.{0}'
  $OptionsW2XModeTipString += 'Scale Only: Upscale the image, but do not apply noise reduction.{0}'
  $OptionsW2XModeTipString += 'Denoise Only: Apply noise reduction, but do not upscale the image.{0}'
  $OptionsW2XModeTipString += 'Scale & Auto-Denoise: Upscales and auto-detects the noise reduction.{0}'
  $OptionsW2XModeTipString += '{0}'
  $OptionsW2XModeTipString += 'Upscale Factor/Noise Reduction only work in the respective modes.'
  $OptionsW2XModeTipString = [String]::Format($OptionsW2XModeTipString, [Environment]::NewLine)
  $OptionsW2XModeTip.SetToolTip($OptionsW2XModeLabel, $OptionsW2XModeTipString)

  # Operations: Waifu2x - Create a number box that specifies the amount of noise reduction.
  $global:OptionsW2XNoiseNumBox = New-Object Windows.Forms.NumericUpDown
  $OptionsW2XNoiseNumBox.Size = DPISize (New-Object Drawing.Size(147, 10))
  $OptionsW2XNoiseNumBox.Location = DPISize (New-Object Drawing.Point(12, 72))
  $OptionsW2XNoiseNumBox.Name = 'Waifu2xNoise'
  $OptionsW2XNoiseNumBox.DecimalPlaces = 0
  $OptionsW2XNoiseNumBox.Minimum = 0
  $OptionsW2XNoiseNumBox.Maximum = 3
  $OptionsW2XNoiseNumBox.Increment = 1
  $OptionsW2XNoiseNumBox.Value = $Waifu2xNoise
  $OptionsW2XNoiseNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptionsW2XNoiseNumBox.Enabled = (($Waifu2xCMode -ne 'scale') -and ($Waifu2xCMode -ne 'auto_scale'))
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XNoiseNumBox)

  # Operations: Waifu2x - Create a label for the noise reduction.
  $global:OptionsW2XNoiseLabel = New-Object Windows.Forms.Label
  $OptionsW2XNoiseLabel.Size = DPISize (New-Object Drawing.Size(94, 22))
  $OptionsW2XNoiseLabel.Location = DPISize (New-Object Drawing.Point(161, 75))
  $OptionsW2XNoiseLabel.Text = 'Noise Reduction'
  $OptionsW2XNoiseLabel.Enabled = (($Waifu2xCMode -ne 'scale') -and ($Waifu2xCMode -ne 'auto_scale'))
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XNoiseLabel)

  # Operations: Waifu2x - Create a tooltip for the noise reduction.
  $OptionsW2XNoiseTip = New-Object Windows.Forms.ToolTip
  $OptionsW2XNoiseTip.InitialDelay = $ToolTipDelay
  $OptionsW2XNoiseTip.AutoPopDelay = $ToolTipDuration
  $OptionsW2XNoiseTipString = 'The amount of noise reduction to apply to the image. The higher the value, the{0}'
  $OptionsW2XNoiseTipString += 'smoother the resulting image will be. Waifu2x-CPP only supports a value up to 2,{0}'
  $OptionsW2XNoiseTipString += 'while Waifu2x-Caffe supports a value of 3. If 3 is selected when using this with{0}'
  $OptionsW2XNoiseTipString += 'Waifu2x-CPP, it will automatically set the value back to 2 before processing the{0}'
  $OptionsW2XNoiseTipString += 'textures. This option has no effect when the "Conversion Mode" is set to "Scale".'
  $OptionsW2XNoiseTipString = [String]::Format($OptionsW2XNoiseTipString, [Environment]::NewLine)
  $OptionsW2XNoiseTip.SetToolTip($OptionsW2XNoiseLabel, $OptionsW2XNoiseTipString)
 
  # Operations: Global - Disables GPU acceleration when creating textures.
  $global:OptionsW2XDisableGPU = New-Object Windows.Forms.CheckBox
  $OptionsW2XDisableGPU.Size = DPISize (New-Object Drawing.Size(160, 16))
  $OptionsW2XDisableGPU.Location = DPISize (New-Object Drawing.Point(12, 98))
  $OptionsW2XDisableGPU.Name = 'Waifu2xDisableGPU'
  $OptionsW2XDisableGPU.Checked = $Waifu2xDisableGPU
  $OptionsW2XDisableGPU.Text = 'Disable GPU Acceleration'
  $OptionsW2XDisableGPU.Add_CheckStateChanged({ ToggleUseOpenCL })
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XDisableGPU)

  # Operations: Global - Create a tooltip for the option.
  $OptionsW2XDisableGPUTip = New-Object Windows.Forms.ToolTip
  $OptionsW2XDisableGPUTip.InitialDelay = $ToolTipDelay
  $OptionsW2XDisableGPUTip.AutoPopDelay = $ToolTipDuration
  $OptionsW2XDisableGPUTipString  = 'This option forces using the CPU when upscaling{0}'
  $OptionsW2XDisableGPUTipString += 'textures. Waifu2x uses nvidia CUDA to apply the{0}'
  $OptionsW2XDisableGPUTipString += 'upscale, and is not supported on AMD cards. Note{0}'
  $OptionsW2XDisableGPUTipString += 'that AMD card owners can use Waifu2x-CPP which{0}'
  $OptionsW2XDisableGPUTipString += 'offers an OpenCL implementation which is much{0}'
  $OptionsW2XDisableGPUTipString += 'faster than upscaling using the CPU. '
  $OptionsW2XDisableGPUTipString = [String]::Format($OptionsW2XDisableGPUTipString, [Environment]::NewLine)
  $OptionsW2XDisableGPUTip.SetToolTip($OptionsW2XDisableGPU, $OptionsW2XDisableGPUTipString)

  # Operations: Waifu2x - Enable OpenCL when generating images. Only available when using Waifu2x-CPP.
  $global:OptionsW2XOpenCLBox = New-Object Windows.Forms.CheckBox
  $OptionsW2XOpenCLBox.Size = DPISize (New-Object Drawing.Size(168, 16))
  $OptionsW2XOpenCLBox.Location = DPISize (New-Object Drawing.Point(12, 120))
  $OptionsW2XOpenCLBox.Name = 'Waifu2xOpenCL'
  $OptionsW2XOpenCLBox.Checked = $Waifu2xOpenCL
  $OptionsW2XOpenCLBox.Text = 'Use OpenCL (Waifu2x-CPP)'
  $OptionsW2XOpenCLBox.Add_CheckStateChanged({ ToggleDisableGPU })
  $OptionsWaifu2xGroup.Controls.Add($OptionsW2XOpenCLBox)

  # Operations: Waifu2x - Create a tip for the option.
  $OptionsW2XOpenCLTip = New-Object Windows.Forms.ToolTip
  $OptionsW2XOpenCLTip.InitialDelay = $ToolTipDelay
  $OptionsW2XOpenCLTip.AutoPopDelay = $ToolTipDuration
  $OptionsW2XOpenCLTipString = 'If a nvidia GPU is not available, Waifu2x-CPP can{0}'
  $OptionsW2XOpenCLTipString += 'attempt to use OpenCL instead of the CPU to speed{0}'
  $OptionsW2XOpenCLTipString += 'up the upscaling process. This option should be{0}'
  $OptionsW2XOpenCLTipString += 'enabled if the system is using an AMD GPU, and{0}'
  $OptionsW2XOpenCLTipString += 'it may work with some Intel integrated chipsets.'
  $OptionsW2XOpenCLTipString = [String]::Format($OptionsW2XOpenCLTipString, [Environment]::NewLine)
  $OptionsW2XOpenCLTip.SetToolTip($OptionsW2XOpenCLBox, $OptionsW2XOpenCLTipString)
  
  # Create a button to close the window.
  $global:Waifu2xOkayButton = New-Object Windows.Forms.Button
  $Waifu2xOkayButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $Waifu2xOkayButton.Location = DPISize (New-Object Drawing.Point(207, 158))
  $Waifu2xOkayButton.Text = 'Close'
  $Waifu2xOkayButton.Anchor = ([Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Right)
  $Waifu2xOkayButton.Add_Click({ $Waifu2xDialog.Hide() })
  $Waifu2xDialog.Controls.Add($Waifu2xOkayButton)
  $Waifu2xDialog.AcceptButton = $Waifu2xOkayButton
}
#==============================================================================================================================================================================================
#  CTT GUI: ESRGAN/SFTGAN CONFIGURATION DIALOG - APPLY UPSCALING FILTER TO TEXTURES - ESRGAN/SFTGAN OPTIONS WINDOWS
#==============================================================================================================================================================================================
#  Shows options for ESRGAN and SFTGAN.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowESRGANDialog([switch]$CombineScalers)
{
  # SETUP: If opening from the options menu, both ESRGAN and SFTGAN must be visible.
  if ($CombineScalers)
  {
    # Adjust the dialog size.
    $ESRGANConfigDialog.Size           = DPISize (New-Object Drawing.Size(300, 306))
    $ESRGANConfigDialog.MinimumSize    = DPISize (New-Object Drawing.Size(300, 306))
    $ESRGANConfigDialog.MaximumSize    = DPISize (New-Object Drawing.Size(300, 306))
    $ESRGANConfigDialog.Text           = "ESRGAN/SFTGAN Options"

    # Resize the groupbox so it fits the new format.
    $OptionsSuperScalerGroup.Size      = DPISize (New-Object Drawing.Size(268, 226))
    $OptionsSuperScalerGroup.Text      = "ESRGAN/SFTGAN Options"

    # Both model selectors are visible when entered from options.
    $OptionsESRGANModelCombo.Visible   = $true
    $OptionsESRGANModelButton.Visible  = $true
    $OptionsESRGANModelLabel.Visible   = $true
    $OptionsSFTGANModelCombo.Visible   = $true
    $OptionsSFTGANModelButton.Visible  = $true
    $OptionsSFTGANModelLabel.Visible   = $true

    # SFTGAN must be moved down a notch.
    $OptionsSFTGANModelCombo.Location  = DPISize (New-Object Drawing.Point(12, 46)) -AddY $DPIOffsetFix
    $OptionsSFTGANModelLabel.Location  = DPISize (New-Object Drawing.Point(176, 49))
    $OptionsSFTGANModelButton.Location = DPISize (New-Object Drawing.Point(152, 45))

    # Move everything to a new location.
    $OptionsSSAlpha.Location           = DPISize (New-Object Drawing.Point(12, 98))
    $OptionsSSSegments.Location        = DPISize (New-Object Drawing.Point(12, 121))
    $OptionsSSMultiplier.Location      = DPISize (New-Object Drawing.Point(12, 144))
    $OptionsSSMultiplierLabel.Location = DPISize (New-Object Drawing.Point(98, 147))
    $OptionsSSPixels.Location          = DPISize (New-Object Drawing.Point(12, 169))
    $OptionsSSPixelsLabel.Location     = DPISize (New-Object Drawing.Point(98, 172))
    $OptionsSSBorder.Location          = DPISize (New-Object Drawing.Point(12, 194))
    $OptionsSSBorderLabel.Location     = DPISize (New-Object Drawing.Point(98, 197))
    $OptionsESRGANNoGPUCheck.Location  = DPISize (New-Object Drawing.Point(12, 76))

    # Move the location of the Okay button.
    $ESRGANOkayButton.Location         = DPISize (New-Object Drawing.Point(197, 234))
  }
  # SETUP: If opening from the operation's menu, either ESRGAN or SFTGAN will be visible.
  else
  {
    # Adjust the dialog size.
    $ESRGANConfigDialog.Size           = DPISize (New-Object Drawing.Size(300, 286))
    $ESRGANConfigDialog.MinimumSize    = DPISize (New-Object Drawing.Size(300, 286))
    $ESRGANConfigDialog.MaximumSize    = DPISize (New-Object Drawing.Size(300, 286))
    $ESRGANConfigDialog.Text           = $FilterSelected + " Options"

    # Resize the groupbox so it fits the new format.
    $OptionsSuperScalerGroup.Size      = DPISize (New-Object Drawing.Size(268, 196))
    $OptionsSuperScalerGroup.Text      = $FilterSelected + " Options"

    # Show the appropriate model selector.
    $OptionsESRGANModelCombo.Visible   = ($FilterSelected -eq 'ESRGAN')
    $OptionsESRGANModelButton.Visible  = ($FilterSelected -eq 'ESRGAN')
    $OptionsESRGANModelLabel.Visible   = ($FilterSelected -eq 'ESRGAN')
    $OptionsSFTGANModelCombo.Visible   = ($FilterSelected -eq 'SFTGAN')
    $OptionsSFTGANModelButton.Visible  = ($FilterSelected -eq 'SFTGAN')
    $OptionsSFTGANModelLabel.Visible   = ($FilterSelected -eq 'SFTGAN')

    # SFTGAN should take the default position.
    $OptionsSFTGANModelCombo.Location  = DPISize (New-Object Drawing.Size(12, 20)) -AddY $DPIOffsetFix
    $OptionsSFTGANModelLabel.Location  = DPISize (New-Object Drawing.Size(176, 23))
    $OptionsSFTGANModelButton.Location = DPISize (New-Object Drawing.Point(152, 19))

    # Move everything to the default position.
    $OptionsSSAlpha.Location           = DPISize (New-Object Drawing.Size(12, 70))
    $OptionsSSSegments.Location        = DPISize (New-Object Drawing.Size(12, 92))
    $OptionsSSMultiplier.Location      = DPISize (New-Object Drawing.Size(12, 114))
    $OptionsSSMultiplierLabel.Location = DPISize (New-Object Drawing.Point(98, 117))
    $OptionsSSPixels.Location          = DPISize (New-Object Drawing.Size(12, 140))
    $OptionsSSPixelsLabel.Location     = DPISize (New-Object Drawing.Size(98, 143))
    $OptionsSSBorder.Location          = DPISize (New-Object Drawing.Size(12, 166))
    $OptionsSSBorderLabel.Location     = DPISize (New-Object Drawing.Size(98, 169))
    $OptionsESRGANNoGPUCheck.Location  = DPISize (New-Object Drawing.Size(12, 48))

    # Move the location of the Okay button.
    $ESRGANOkayButton.Location         = DPISize (New-Object Drawing.Size(197, 210))
  }
  # Show the dialog.
  $ESRGANConfigDialog.ShowDialog() | Out-Null
}
#==============================================================================================================================================================================================
#  Toggles all options that deal with segments.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleESRGANSegmentOptions()
{
  $OptionsSSMultiplier.Enabled       = $this.Checked
  $OptionsSSMultiplierLabel.Enabled  = $this.Checked
  $OptionsSSPixels.Enabled           = $this.Checked
  $OptionsSSPixelsLabel.Enabled      = $this.Checked
  $OptionsSSBorder.Enabled           = $this.Checked
  $OptionsSSBorderLabel.Enabled      = $this.Checked
}
#==============================================================================================================================================================================================
#  Create the dialog for ESRGAN/SFTGAN options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ESRGANDialog()
{
  # Create the dialog and set up properties.
  $global:ESRGANConfigDialog = New-Object Windows.Forms.Form
  $ESRGANConfigDialog.Size = DPISize (New-Object Drawing.Size(300, 306))
  $ESRGANConfigDialog.MinimumSize = DPISize (New-Object Drawing.Size(300, 306))
  $ESRGANConfigDialog.MaximumSize = DPISize (New-Object Drawing.Size(300, 306))
  $ESRGANConfigDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ESRGANConfigDialog.Text = 'ESRGAN/SFTGAN Options'
  $ESRGANConfigDialog.MinimizeBox = $false
  $ESRGANConfigDialog.MaximizeBox = $false
  $ESRGANConfigDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $ESRGANConfigDialog.FormBorderStyle = GetFormBorderStyle
  $ESRGANConfigDialog.StartPosition = "CenterScreen"
  $ESRGANConfigDialog.Topmost = !$DisableTopMost
  $ESRGANConfigDialog.KeyPreview = $true
  $ESRGANConfigDialog.Add_KeyDown({ EscapeCloseDialog })
  $ESRGANConfigDialog.Add_FormClosing({ $ESRGANConfigDialog.Hide() ; $_.Cancel = $true })
  $ESRGANConfigDialog.Icon = $Icon_CTTPSGreen

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:ESRGANFocusLabel = New-Object Windows.Forms.Label
  $ESRGANFocusLabel.Size = New-Object Drawing.Size(1,1)
  $ESRGANFocusLabel.Location = New-Object Drawing.Point(0,0)
  $ESRGANConfigDialog.Controls.Add($ESRGANFocusLabel)

  # Operations: ESRGAN/SFTGAN - Create a group box for "global" options.
  $global:OptionsSuperScalerGroup = New-Object Windows.Forms.GroupBox
  $OptionsSuperScalerGroup.Size = DPISize (New-Object Drawing.Size(268, 226))
  $OptionsSuperScalerGroup.Location = DPISize (New-Object Drawing.Point(8, 4))
  $OptionsSuperScalerGroup.Text = 'ESRGAN/SFTGAN Options'
  $ESRGANConfigDialog.Controls.Add($OptionsSuperScalerGroup)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Allows selecting the upscale model.
  $global:OptionsESRGANModelCombo = New-Object Windows.Forms.ComboBox
  $OptionsESRGANModelCombo.Size = DPISize (New-Object Drawing.Size(138, 10))
  $OptionsESRGANModelCombo.Location = DPISize (New-Object Drawing.Point(12, 20)) -AddY $DPIOffsetFix
  $OptionsESRGANModelCombo.Name = 'ESRGANModel'
  $OptionsESRGANModelCombo.Add_SelectedIndexChanged({ $ESRGANFocusLabel.Focus() })
  $OptionsESRGANModelCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $OptionsESRGANModelCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsESRGANModelCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsESRGANModelCombo.Add_DrawItem({ RepopulateComboBox })
  $OptionsSuperScalerGroup.Controls.Add($OptionsESRGANModelCombo)

  # Operations: ESRGAN/SFTGAN - ESRGAN Models Button - Opens the models folder for ESRGAN. 
  $global:OptionsESRGANModelButton = New-Object Windows.Forms.Button
  $OptionsESRGANModelButton.Size = DPISize (New-Object Drawing.Size(23, 23))
  $OptionsESRGANModelButton.Location = DPISize (New-Object Drawing.Point(152, 19)) -AddY $DPIOffsetFix
  $OptionsESRGANModelButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#E1E1E1')
  $OptionsESRGANModelButton.Image = $Image_Folder
  $OptionsESRGANModelButton.Add_Click({ if (TestPath -LiteralPath ($ESRGANBasePath + '\models')) { Start-Process -FilePath ($ESRGANBasePath + '\models') } })
  $OptionsSuperScalerGroup.Controls.Add($OptionsESRGANModelButton)

  # Operations: ESRGAN/SFTGAN - ESRGAN Models Button - Create a tooltip.
  $OptionsESRGANModelButtonTip = New-Object Windows.Forms.ToolTip
  $OptionsESRGANModelButtonTip.InitialDelay = $ToolTipDelay
  $OptionsESRGANModelButtonTip.AutoPopDelay = $ToolTipDuration
  $OptionsESRGANModelButtonTipString = 'Opens the ESRGAN models folder.'
  $OptionsESRGANModelButtonTip.SetToolTip($OptionsESRGANModelButton, $OptionsESRGANModelButtonTipString)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Create a label.
  $global:OptionsESRGANModelLabel = New-Object Windows.Forms.Label
  $OptionsESRGANModelLabel.Size = DPISize (New-Object Drawing.Size(89, 22))
  $OptionsESRGANModelLabel.Location = DPISize (New-Object Drawing.Point(176, 23))
  $OptionsESRGANModelLabel.Text = 'ESRGAN Model'
  $OptionsSuperScalerGroup.Controls.Add($OptionsESRGANModelLabel)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Create a tip for the option.
  $OptionsESRGANModelTip = New-Object Windows.Forms.ToolTip
  $OptionsESRGANModelTip.InitialDelay = $ToolTipDelay
  $OptionsESRGANModelTip.AutoPopDelay = $ToolTipDuration
  $OptionsESRGANModelTipString = 'This is the model that ESRGAN will use to{0}'
  $OptionsESRGANModelTipString += 'upscale the image. To add models, click{0}'
  $OptionsESRGANModelTipString += 'the folder icon and drop new ones in. To{0}'
  $OptionsESRGANModelTipString += 'refresh the list, close/reopen this window.'
  $OptionsESRGANModelTipString = [String]::Format($OptionsESRGANModelTipString, [Environment]::NewLine)
  $OptionsESRGANModelTip.SetToolTip($OptionsESRGANModelLabel, $OptionsESRGANModelTipString)

  # Operations: ESRGAN/SFTGAN - SFTGAN Model - Allows selecting the upscale model.
  $global:OptionsSFTGANModelCombo = New-Object Windows.Forms.ComboBox
  $OptionsSFTGANModelCombo.Size = DPISize (New-Object Drawing.Size(138, 10))
  $OptionsSFTGANModelCombo.Location = DPISize (New-Object Drawing.Point(12, 20)) -AddY $DPIOffsetFix
  $OptionsSFTGANModelCombo.Name = 'SFTGANModel'
  $OptionsSFTGANModelCombo.Add_SelectedIndexChanged({ $ESRGANFocusLabel.Focus() })
  $OptionsSFTGANModelCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; UpdateSFTGANModel -Model $this.SelectedItem })
  $OptionsSFTGANModelCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsSFTGANModelCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsSFTGANModelCombo.Add_DrawItem({ RepopulateComboBox })
  $OptionsSuperScalerGroup.Controls.Add($OptionsSFTGANModelCombo)

  # Operations: ESRGAN/SFTGAN - SFTGAN Models Button - Opens the models folder for SFTGAN. 
  $global:OptionsSFTGANModelButton = New-Object Windows.Forms.Button
  $OptionsSFTGANModelButton.Size = DPISize (New-Object Drawing.Size(23, 23))
  $OptionsSFTGANModelButton.Location = DPISize (New-Object Drawing.Point(152, 19)) -AddY $DPIOffsetFix
  $OptionsSFTGANModelButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $OptionsSFTGANModelButton.Image = $Image_Folder
  $OptionsSFTGANModelButton.Add_Click({ if (TestPath -LiteralPath ($SFTGANBasePath + '\pretrained_models')) { Start-Process -FilePath ($SFTGANBasePath + '\pretrained_models') } })
  $OptionsSuperScalerGroup.Controls.Add($OptionsSFTGANModelButton)

  # Operations: ESRGAN/SFTGAN - SFTGAN Models Button - Create a tooltip.
  $OptionsSFTGANModelButtonTip = New-Object Windows.Forms.ToolTip
  $OptionsSFTGANModelButtonTip.InitialDelay = $ToolTipDelay
  $OptionsSFTGANModelButtonTip.AutoPopDelay = $ToolTipDuration
  $OptionsSFTGANModelButtonTipString = 'Opens the SFTGAN models folder.'
  $OptionsSFTGANModelButtonTip.SetToolTip($OptionsSFTGANModelButton, $OptionsSFTGANModelButtonTipString)

  # Operations: ESRGAN/SFTGAN - SFTGAN Model - Create a label.
  $global:OptionsSFTGANModelLabel = New-Object Windows.Forms.Label
  $OptionsSFTGANModelLabel.Size = DPISize (New-Object Drawing.Size(89, 22))
  $OptionsSFTGANModelLabel.Location = DPISize (New-Object Drawing.Point(176, 23))
  $OptionsSFTGANModelLabel.Text = 'SFTGAN Model'
  $OptionsSuperScalerGroup.Controls.Add($OptionsSFTGANModelLabel)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Create a tip for the option.
  $OptionsSFTGANModelTip = New-Object Windows.Forms.ToolTip
  $OptionsSFTGANModelTip.InitialDelay = $ToolTipDelay
  $OptionsSFTGANModelTip.AutoPopDelay = $ToolTipDuration
  $OptionsSFTGANModelTipString = 'This is the model that SFTGAN will use to{0}'
  $OptionsSFTGANModelTipString += 'upscale the image. To add models, click{0}'
  $OptionsSFTGANModelTipString += 'the folder icon and drop new ones in. To{0}'
  $OptionsSFTGANModelTipString += 'refresh the list, close/reopen this window.'
  $OptionsSFTGANModelTipString = [String]::Format($OptionsSFTGANModelTipString, [Environment]::NewLine)
  $OptionsSFTGANModelTip.SetToolTip($OptionsSFTGANModelLabel, $OptionsSFTGANModelTipString)

  # Operations: Global - Disables GPU acceleration when creating textures with TexConv.
  $global:OptionsESRGANNoGPUCheck = New-Object Windows.Forms.CheckBox
  $OptionsESRGANNoGPUCheck.Size = DPISize (New-Object Drawing.Size(160, 16))
  $OptionsESRGANNoGPUCheck.Location = DPISize (New-Object Drawing.Point(12, 98))
  $OptionsESRGANNoGPUCheck.Name = 'ESRGANDisableGPU'
  $OptionsESRGANNoGPUCheck.Checked = $ESRGANDisableGPU
  $OptionsESRGANNoGPUCheck.Text = 'Disable GPU Acceleration'
  $OptionsESRGANNoGPUCheck.Add_CheckStateChanged({ AttemptEditSuperScalerScripts })
  $OptionsSuperScalerGroup.Controls.Add($OptionsESRGANNoGPUCheck)

  # Operations: Global - Create a tooltip for the option.
  $OptionsESRGANNoGPUTip = New-Object Windows.Forms.ToolTip
  $OptionsESRGANNoGPUTip.InitialDelay = $ToolTipDelay
  $OptionsESRGANNoGPUTip.AutoPopDelay = $ToolTipDuration
  $OptionsESRGANNoGPUTipString = 'This option forces ESRGAN and SFTGAN to upscale using{0}'
  $OptionsESRGANNoGPUTipString += 'the CPU instead of nvidia CUDA. This is much slower, but{0}'
  $OptionsESRGANNoGPUTipString += "it is the only option for AMD GPUs that don't support it."
  $OptionsESRGANNoGPUTipString = [String]::Format($OptionsESRGANNoGPUTipString, [Environment]::NewLine)
  $OptionsESRGANNoGPUTip.SetToolTip($OptionsESRGANNoGPUCheck, $OptionsESRGANNoGPUTipString)

  # Operations: ESRGAN/SFTGAN - Create a toggle for preserving the alpha channel.
  $global:OptionsSSAlpha = New-Object Windows.Forms.CheckBox
  $OptionsSSAlpha.Size = DPISize (New-Object Drawing.Size(150, 16))
  $OptionsSSAlpha.Location = DPISize (New-Object Drawing.Point(12, 70))
  $OptionsSSAlpha.Name = 'ESRGANSaveAlpha'
  $OptionsSSAlpha.Checked = $ESRGANSaveAlpha
  $OptionsSSAlpha.Text = 'Preserve Alpha Channel'
  $OptionsSSAlpha.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSAlpha)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Create a tip for the option.
  $OptionsSSAlphaTip = New-Object Windows.Forms.ToolTip
  $OptionsSSAlphaTip.InitialDelay = $ToolTipDelay
  $OptionsSSAlphaTip.AutoPopDelay = $ToolTipDuration
  $OptionsSSAlphaTipString = 'Extracts the alpha channel to a separate image{0}'
  $OptionsSSAlphaTipString += 'before upscaling. After the image is upscaled,{0}'
  $OptionsSSAlphaTipString += 'the alpha channel will also be upscaled, which{0}'
  $OptionsSSAlphaTipString += 'is then applied to the upscaled image. This will{0}'
  $OptionsSSAlphaTipString += 'double the time it takes to upscale the image.'
  $OptionsSSAlphaTipString = [String]::Format($OptionsSSAlphaTipString, [Environment]::NewLine)
  $OptionsSSAlphaTip.SetToolTip($OptionsSSAlpha, $OptionsSSAlphaTipString)

  # Operations: ESRGAN/SFTGAN - Create a toggle for using the segmented method.
  $global:OptionsSSSegments = New-Object Windows.Forms.CheckBox
  $OptionsSSSegments.Size = DPISize (New-Object Drawing.Size(180, 16))
  $OptionsSSSegments.Location = DPISize (New-Object Drawing.Point(12, 92))
  $OptionsSSSegments.Name = 'ESRGANUseSegments'
  $OptionsSSSegments.Checked = $ESRGANUseSegments
  $OptionsSSSegments.Text = 'Upscale Images in Segments'
  $OptionsSSSegments.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleESRGANSegmentOptions })
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSSegments)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Create a tip for the option.
  $OptionsSSSegmentsTip = New-Object Windows.Forms.ToolTip
  $OptionsSSSegmentsTip.InitialDelay = $ToolTipDelay
  $OptionsSSSegmentsTip.AutoPopDelay = $ToolTipDuration
  $OptionsSSSegmentsTipString = 'ESRGAN/SFTGAN requires a lot of VRAM. This option{0}'
  $OptionsSSSegmentsTipString += 'bypasses the VRAM limitation by splitting images into{0}'
  $OptionsSSSegmentsTipString += 'segments before upscaling. Each segment has a few{0}'
  $OptionsSSSegmentsTipString += 'pixels of overhead to keep each tile seamless. The{0}'
  $OptionsSSSegmentsTipString += 'amount of pixels kept can be configured below.'
  $OptionsSSSegmentsTipString = [String]::Format($OptionsSSSegmentsTipString, [Environment]::NewLine)
  $OptionsSSSegmentsTip.SetToolTip($OptionsSSSegments, $OptionsSSSegmentsTipString)

  # Operations: ESRGAN/SFTGAN - Create a number box that specifies the segment multiplier.
  $global:OptionsSSMultiplier = New-Object Windows.Forms.ComboBox
  $OptionsSSMultiplier.Size = DPISize (New-Object Drawing.Size(84, 10))
  $OptionsSSMultiplier.Location = DPISize (New-Object Drawing.Point(12, 114))
  $OptionsSSMultiplier.Name = 'ESRGANMaxSegment'
  $OptionsSSMultiplier.Items.Add('256x256') | Out-Null
  $OptionsSSMultiplier.Items.Add('512x512') | Out-Null
  $OptionsSSMultiplier.Items.Add('1024x1024') | Out-Null
  $OptionsSSMultiplier.SelectedItem = $ESRGANMaxSegment
  $OptionsSSMultiplier.Add_SelectedIndexChanged({ $ESRGANFocusLabel.Focus() })
  $OptionsSSMultiplier.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $OptionsSSMultiplier.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsSSMultiplier.Enabled = $ESRGANUseSegments
  $OptionsSSMultiplier.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsSSMultiplier.Add_DrawItem({ RepopulateComboBox })
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSMultiplier)

  # Operations: ESRGAN/SFTGAN - Create a label for the multiplier.
  $global:OptionsSSMultiplierLabel = New-Object Windows.Forms.Label
  $OptionsSSMultiplierLabel.Size = DPISize (New-Object Drawing.Size(116, 22))
  $OptionsSSMultiplierLabel.Location = DPISize (New-Object Drawing.Point(98, 117))
  $OptionsSSMultiplierLabel.Text = 'Max Segment Size'
  $OptionsSSMultiplierLabel.Enabled = $ESRGANUseSegments
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSMultiplierLabel)

  # Operations: ESRGAN/SFTGAN - Create a tip for the option.
  $OptionsSSMultiplierTip = New-Object Windows.Forms.ToolTip
  $OptionsSSMultiplierTip.InitialDelay = $ToolTipDelay
  $OptionsSSMultiplierTip.AutoPopDelay = $ToolTipDuration
  $OptionsSSMultiplierTipString = 'By default, the max segment dimensions are 256x256{0}'
  $OptionsSSMultiplierTipString += 'which should be okay for most GPUs. This option can{0}'
  $OptionsSSMultiplierTipString += 'double or even quadruple the maximum segment size.{0}'
  $OptionsSSMultiplierTipString += '{0}'
  $OptionsSSMultiplierTipString += 'Note that increasing the segment size will greatly{0}'
  $OptionsSSMultiplierTipString += 'decrease the time to upscale, but also greatly increase{0}'
  $OptionsSSMultiplierTipString += 'VRAM requirements! If VRAM errors appear during the{0}'
  $OptionsSSMultiplierTipString += 'upscale process, try setting this to the lowest setting.'
  $OptionsSSMultiplierTipString = [String]::Format($OptionsSSMultiplierTipString, [Environment]::NewLine)
  $OptionsSSMultiplierTip.SetToolTip($OptionsSSMultiplierLabel, $OptionsSSMultiplierTipString)

  # Operations: ESRGAN/SFTGAN - Create a number box that specifies the number of extra pixels.
  $global:OptionsSSPixels = New-Object Windows.Forms.NumericUpDown
  $OptionsSSPixels.Size = DPISize (New-Object Drawing.Size(84, 10))
  $OptionsSSPixels.Location = DPISize (New-Object Drawing.Point(12, 140))
  $OptionsSSPixels.Name = 'ESRGANExtraPixels'
  $OptionsSSPixels.DecimalPlaces = 0
  $OptionsSSPixels.Minimum = 8
  $OptionsSSPixels.Maximum = 32
  $OptionsSSPixels.Increment = 2
  $OptionsSSPixels.Value = $ESRGANExtraPixels
  $OptionsSSPixels.Add_ValueChanged({ NumericUpDownEnforceEven })
  $OptionsSSPixels.Enabled = $ESRGANUseSegments
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSPixels)

  # Operations: ESRGAN/SFTGAN - Create a label for the pixel selection.
  $global:OptionsSSPixelsLabel = New-Object Windows.Forms.Label
  $OptionsSSPixelsLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsSSPixelsLabel.Location = DPISize (New-Object Drawing.Point(98, 143))
  $OptionsSSPixelsLabel.Text = 'Pixel Buffer Width'
  $OptionsSSPixelsLabel.Enabled = $ESRGANUseSegments
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSPixelsLabel)

  # Operations: ESRGAN/SFTGAN - ESRGAN Model - Create a tip for the option.
  $OptionsSSPixelsLabelTip = New-Object Windows.Forms.ToolTip
  $OptionsSSPixelsLabelTip.InitialDelay = $ToolTipDelay
  $OptionsSSPixelsLabelTip.AutoPopDelay = $ToolTipDuration
  $OptionsSSPixelsLabelTipString = 'Configures the number of rows/columns of pixels{0}'
  $OptionsSSPixelsLabelTipString += 'that are added to segments before upscaling. The{0}'
  $OptionsSSPixelsLabelTipString += 'more pixels added, the higher the chance the tiles{0}'
  $OptionsSSPixelsLabelTipString += 'will remain seamless. But increasing this value will{0}'
  $OptionsSSPixelsLabelTipString += 'greatly impact the total amount of processing time.'
  $OptionsSSPixelsLabelTipString = [String]::Format($OptionsSSPixelsLabelTipString, [Environment]::NewLine)
  $OptionsSSPixelsLabelTip.SetToolTip($OptionsSSPixelsLabel, $OptionsSSPixelsLabelTipString)

  # Operations: ESRGAN/SFTGAN - Create a number box that specifies the segment multiplier.
  $global:OptionsSSBorder = New-Object Windows.Forms.ComboBox
  $OptionsSSBorder.Size = DPISize (New-Object Drawing.Size(84, 10))
  $OptionsSSBorder.Location = DPISize (New-Object Drawing.Point(12, 166))
  $OptionsSSBorder.Name = 'ESRGANPixelBuffer'
  $OptionsSSBorder.Items.Add('Standard') | Out-Null
  $OptionsSSBorder.Items.Add('Seamless') | Out-Null
  $OptionsSSBorder.SelectedItem = $ESRGANPixelBuffer
  $OptionsSSBorder.Add_SelectedIndexChanged({ $ESRGANFocusLabel.Focus() })
  $OptionsSSBorder.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $OptionsSSBorder.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptionsSSBorder.Enabled = $ESRGANUseSegments
  $OptionsSSBorder.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptionsSSBorder.Add_DrawItem({ RepopulateComboBox })
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSBorder)

  # Operations: ESRGAN/SFTGAN - Create a label for the multiplier.
  $global:OptionsSSBorderLabel = New-Object Windows.Forms.Label
  $OptionsSSBorderLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $OptionsSSBorderLabel.Location = DPISize (New-Object Drawing.Point(98, 169))
  $OptionsSSBorderLabel.Text = 'Pixel Buffer Type'
  $OptionsSSBorderLabel.Enabled = $ESRGANUseSegments
  $OptionsSuperScalerGroup.Controls.Add($OptionsSSBorderLabel)

  # Operations: ESRGAN/SFTGAN - Create a tip for the option.
  $OptionsSSBorderTip = New-Object Windows.Forms.ToolTip
  $OptionsSSBorderTip.InitialDelay = $ToolTipDelay
  $OptionsSSBorderTip.AutoPopDelay = $ToolTipDuration
  $OptionsSSBorderTipString = 'When upscaling using segments, a border is created around the{0}'
  $OptionsSSBorderTipString += 'image with a thickness equal to the "Pixel Buffer Width". This{0}'
  $OptionsSSBorderTipString += 'border is necessary to keep all segments equal in size and to keep{0}'
  $OptionsSSBorderTipString += 'the segments seamless with one another. The pixels in the border{0}'
  $OptionsSSBorderTipString += 'can be configured for the type of texture that is being created.{0}'
  $OptionsSSBorderTipString += '{0}'
  $OptionsSSBorderTipString += 'Standard: Use this method for non-seamless textures. The edges{0}'
  $OptionsSSBorderTipString += 'of the image are duplicated, inverted, and used as the border.{0}'
  $OptionsSSBorderTipString += '{0}'
  $OptionsSSBorderTipString += 'Seamless: Use this method for seamless textures. The extra pixels{0}'
  $OptionsSSBorderTipString += "act as tiles around the image using the image's outer borders.{0}"
  $OptionsSSBorderTipString += '{0}'
  $OptionsSSBorderTipString += 'Unfortunately the Seamless method can cause colors to bleed{0}'
  $OptionsSSBorderTipString += 'into the edges of the image due to the border (which is why this{0}'
  $OptionsSSBorderTipString += 'option exists). The "Standard" method should be good enough{0}'
  $OptionsSSBorderTipString += 'when upscaling non-seamless images, but might not be perfect.'
  $OptionsSSBorderTipString = [String]::Format($OptionsSSBorderTipString, [Environment]::NewLine)
  $OptionsSSBorderTip.SetToolTip($OptionsSSBorderLabel, $OptionsSSBorderTipString)
  
  # Create a button to close the window.
  $global:ESRGANOkayButton = New-Object Windows.Forms.Button
  $ESRGANOkayButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ESRGANOkayButton.Location = DPISize (New-Object Drawing.Point(197, 234))
  $ESRGANOkayButton.Text = 'Close'
  $ESRGANOkayButton.Anchor = ([Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Right)
  $ESRGANOkayButton.Add_Click({ $ESRGANConfigDialog.Hide() })
  $ESRGANConfigDialog.Controls.Add($ESRGANOkayButton)
  $ESRGANConfigDialog.AcceptButton = $ESRGANOkayButton
}


#==============================================================================================================================================================================================
#  CTT GUI: TEXTUREEXTRACTION TOOL CONFIGURATION DIALOG - EXTRACT TEXTURES WITH TEXTUREEXTRACTION TOOL
#==============================================================================================================================================================================================
#  Toggles the arrow and the numeric up/down for cleanup options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleTasksOptions()
{
  $TexExtractThreadLabel.Enabled  = $this.Checked
  $TexExtractThreadNumBox.Enabled = $this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the arrow and the numeric up/down for cleanup options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleCleanupOptions()
{
  $TexExtractCleanLabelB.Enabled = ($this.SelectedItem -eq "Custom")
  $TexExtractCleanNumBox.Enabled = ($this.SelectedItem -eq "Custom")
}
#==============================================================================================================================================================================================
#  Create the dialog for ESRGAN/SFTGAN options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_TextureExtraction()
{
  # Create the dialog and set up properties.
  $global:TexExtractDialog = New-Object Windows.Forms.Form
  $TexExtractDialog.Size = DPISize (New-Object Drawing.Size(400, 400))
  $TexExtractDialog.MinimumSize = DPISize (New-Object Drawing.Size(400, 400))
  $TexExtractDialog.MaximumSize = DPISize (New-Object Drawing.Size(400, 400))
  $TexExtractDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $TexExtractDialog.Text = 'Dolphin TextureExtraction Tool'
  $TexExtractDialog.MinimizeBox = $false
  $TexExtractDialog.MaximizeBox = $false
  $TexExtractDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $TexExtractDialog.FormBorderStyle = GetFormBorderStyle
  $TexExtractDialog.StartPosition = "CenterScreen"
  $TexExtractDialog.Topmost = !$DisableTopMost
  $TexExtractDialog.KeyPreview = $true
  $TexExtractDialog.Add_KeyDown({ EscapeCloseDialog })
  $TexExtractDialog.Add_FormClosing({ $TexExtractDialog.Hide() ; $_.Cancel = $true })
  $TexExtractDialog.Icon = $Icon_CTTPSGreen

  # Create a dummy label to focus on. This works around an issue with comboboxes and their ugly selection.
  $global:TexExtractFocusLabel = New-Object Windows.Forms.Label
  $TexExtractFocusLabel.Size = New-Object Drawing.Size(1,1)
  $TexExtractFocusLabel.Location = New-Object Drawing.Point(0,0)
  $TexExtractDialog.Controls.Add($TexExtractFocusLabel)

  # Extract Textures From Files - Create a groupbox for the path.
  $global:TexExtractToolGroup = New-Object Windows.Forms.GroupBox
  $TexExtractToolGroup.Size = DPISize (New-Object Drawing.Size(365, 60))
  $TexExtractToolGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $TexExtractToolGroup.Text = 'TextureExtraction Tool Path:'
  $TexExtractDialog.Controls.Add($TexExtractToolGroup)

  # Extract Textures From Files - The tooltip is recycled from the "Paths" menu tooltip.
  $TexExtractProgramTip = New-Object Windows.Forms.ToolTip
  $TexExtractProgramTip.InitialDelay = $ToolTipDelay
  $TexExtractProgramTip.AutoPopDelay = $ToolTipDuration
  $TexExtractProgramTipString = 'The path to TextureExtraction Tool by Venomalia.{0}'
  $TexExtractProgramTipString += 'This program extracts textures and converts them{0}'
  $TexExtractProgramTipString += 'to PNGs renamed to match Dolphin texture format.{0}'
  $TexExtractProgramTipString += '{0}'
  $TexExtractProgramTipString += 'Required to extract Dolphin textures from discs.'
  $TexExtractProgramTipString = [String]::Format($TexExtractProgramTipString, [Environment]::NewLine)
  $TexExtractProgramTip.SetToolTip($TexExtractToolGroup, $TexExtractProgramTipString)

  # Extract Textures From Files - Create a tooltip.
  $global:TexExtractProgramTextBox = New-Object Windows.Forms.TextBox
  $TexExtractProgramTextBox.Size = DPISize (New-Object Drawing.Size(320, 22))
  $TexExtractProgramTextBox.Location = DPISize (New-Object Drawing.Point(10, 24)) -AddY $DPIOffsetFix
  $TexExtractProgramTextBox.Name = 'TexExtractTool'
  $TexExtractProgramTextBox.Text = $TexExtractTool
  $TexExtractProgramTextBox.AllowDrop = $true
  $TexExtractProgramTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $TexExtractProgramTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('DolphinTextureExtraction tool.exe','DolphinTextureExtraction.tool.exe') })
  $TexExtractProgramTextBox.Add_Click({ ClearTextBox })
  $TexExtractProgramTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('DolphinTextureExtraction tool.exe','DolphinTextureExtraction.tool.exe') })
  $TexExtractToolGroup.Controls.Add($TexExtractProgramTextBox)

  # Extract Textures From Files - Create a button.
  $global:TexExtractProgramButton = New-Object Windows.Forms.Button
  $TexExtractProgramButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $TexExtractProgramButton.Location = DPISize (New-Object Drawing.Point(334, 23))
  $TexExtractProgramButton.Name = 'TexExtractTool'
  $TexExtractProgramButton.Text = '...'
  $TexExtractProgramButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $TexExtractProgramTextBox -FileName @('DolphinTextureExtraction tool.exe','DolphinTextureExtraction.tool.exe') -Description @('Dolphin TextureExtraction Tool') })
  $TexExtractToolGroup.Controls.Add($TexExtractProgramButton)

  # Extract Textures From Files - Create a groupbox for general options.
  $global:TexExtractGeneralGroup = New-Object Windows.Forms.GroupBox
  $TexExtractGeneralGroup.Size = DPISize (New-Object Drawing.Size(365, 146))
  $TexExtractGeneralGroup.Location = DPISize (New-Object Drawing.Point(10, 70))
  $TexExtractGeneralGroup.Text = 'General Options'
  $TexExtractDialog.Controls.Add($TexExtractGeneralGroup)

  # Extract Textures From Files - Create a checkbox for unknown formats.
  $global:TexExtractForceCheckBox = New-Object Windows.Forms.CheckBox
  $TexExtractForceCheckBox.Size = DPISize (New-Object Drawing.Size(178, 16))
  $TexExtractForceCheckBox.Location = DPISize (New-Object Drawing.Point(10, 20))
  $TexExtractForceCheckBox.Name = 'ExtractForceUnknown'
  $TexExtractForceCheckBox.Checked = $ExtractForceUnknown
  $TexExtractForceCheckBox.Text = ' Force Unknown File Formats'
  $TexExtractForceCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexExtractGeneralGroup.Controls.Add($TexExtractForceCheckBox)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractForceTip = New-Object Windows.Forms.ToolTip
  $TexExtractForceTip.InitialDelay = $ToolTipDelay
  $TexExtractForceTip.AutoPopDelay = $ToolTipDuration
  $TexExtractForceTipString  = 'Tries to extract textures files from{0}'
  $TexExtractForceTipString += 'unknown file formats. This can be{0}'
  $TexExtractForceTipString += 'an important option to enable if{0}'
  $TexExtractForceTipString += 'not many textures are extracted{0}'
  $TexExtractForceTipString += 'from the selected game disc.'
  $TexExtractForceTipString = [String]::Format($TexExtractForceTipString, [Environment]::NewLine)
  $TexExtractForceTip.SetToolTip($TexExtractForceCheckBox, $TexExtractForceTipString)

  # Extract Textures From Files - Create a checkbox to extract raw images.
  $global:TexExtractRawCheckBox = New-Object Windows.Forms.CheckBox
  $TexExtractRawCheckBox.Size = DPISize (New-Object Drawing.Size(178, 16))
  $TexExtractRawCheckBox.Location = DPISize (New-Object Drawing.Point(10, 45))
  $TexExtractRawCheckBox.Name = 'ExtractRawImages'
  $TexExtractRawCheckBox.Checked = $ExtractRawImages
  $TexExtractRawCheckBox.Text = ' Extract Raw Images'
  $TexExtractRawCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexExtractGeneralGroup.Controls.Add($TexExtractRawCheckBox)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractRawTip = New-Object Windows.Forms.ToolTip
  $TexExtractRawTip.InitialDelay = $ToolTipDelay
  $TexExtractRawTip.AutoPopDelay = $ToolTipDuration
  $TexExtractRawTipString  = 'Extracts raw texture files instead of PNG files.'
  $TexExtractRawTipString = [String]::Format($TexExtractRawTipString, [Environment]::NewLine)
  $TexExtractRawTip.SetToolTip($TexExtractRawCheckBox, $TexExtractRawTipString)

  # Extract Textures From Files - Create a checkbox to extract raw images.
  $global:TexExtractRGBACheckBox = New-Object Windows.Forms.CheckBox
  $TexExtractRGBACheckBox.Size = DPISize (New-Object Drawing.Size(178, 16))
  $TexExtractRGBACheckBox.Location = DPISize (New-Object Drawing.Point(10, 70))
  $TexExtractRGBACheckBox.Name = 'ExtractCombineRGBA'
  $TexExtractRGBACheckBox.Checked = $ExtractCombineRGBA
  $TexExtractRGBACheckBox.Text = ' Combine Split-RGBA Images'
  $TexExtractRGBACheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexExtractGeneralGroup.Controls.Add($TexExtractRGBACheckBox)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractRGBATip = New-Object Windows.Forms.ToolTip
  $TexExtractRGBATip.InitialDelay = $ToolTipDelay
  $TexExtractRGBATip.AutoPopDelay = $ToolTipDuration
  $TexExtractRGBATipString  = 'Some textures are dumped as dual grayscale{0}'
  $TexExtractRGBATipString += 'textures that look similar but slightly differ{0}'
  $TexExtractRGBATipString += 'in some ways. These are really a single texture{0}'
  $TexExtractRGBATipString += 'with the RGBA channels split across two files.{0}'
  $TexExtractRGBATipString += '{0}'
  $TexExtractRGBATipString += 'This option dumps them as a single image with{0}'
  $TexExtractRGBATipString += 'the channels recombined, but they will need to{0}'
  $TexExtractRGBATipString += 'be split for Dolphin to recognize them. CTT-PS{0}'
  $TexExtractRGBATipString += 'auto-splits these images when encountered.'
  $TexExtractRGBATipString = [String]::Format($TexExtractRGBATipString, [Environment]::NewLine)
  $TexExtractRGBATip.SetToolTip($TexExtractRGBACheckBox, $TexExtractRGBATipString)

  # Extract Textures From Files - Create a checkbox for multithreading.
  $global:TexExtractThreadCheckBox = New-Object Windows.Forms.CheckBox
  $TexExtractThreadCheckBox.Size = DPISize (New-Object Drawing.Size(150, 16))
  $TexExtractThreadCheckBox.Location = DPISize (New-Object Drawing.Point(10, 95))
  $TexExtractThreadCheckBox.Name = 'ExtractTasksEnable'
  $TexExtractThreadCheckBox.Checked = $ExtractTasksEnable
  $TexExtractThreadCheckBox.Text = ' Parallel Task Threads'
  $TexExtractThreadCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleTasksOptions })
  $TexExtractGeneralGroup.Controls.Add($TexExtractThreadCheckBox)

  # Extract Textures From Files - Create a checkbox for multithreading.
  $global:TexExtractThreadLabel = New-Object Windows.Forms.Label
  $TexExtractThreadLabel.Size = DPISize (New-Object Drawing.Size(100, 16))
  $TexExtractThreadLabel.Location = DPISize (New-Object Drawing.Point(190, 95))
  $TexExtractThreadLabel.Text = "=============>"
  $TexExtractThreadLabel.Enabled = $ExtractTasksEnable
  $TexExtractGeneralGroup.Controls.Add($TexExtractThreadLabel)

  # Extract Textures From Files - Create a numeric up/down to select the thread count.
  $global:TexExtractThreadNumBox = New-Object Windows.Forms.NumericUpDown
  $TexExtractThreadNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $TexExtractThreadNumBox.Location = DPISize (New-Object Drawing.Point(300, 92)) -AddY $DPIOffsetFix
  $TexExtractThreadNumBox.Name = 'ExtractTasksCount'
  $TexExtractThreadNumBox.DecimalPlaces = 0
  $TexExtractThreadNumBox.Minimum = 1
  $TexExtractThreadNumBox.Maximum = 16
  $TexExtractThreadNumBox.Increment = 1
  $TexExtractThreadNumBox.Value = $ExtractTasksCount
  $TexExtractThreadNumBox.Enabled = $ExtractTasksEnable
  $TexExtractThreadNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $TexExtractGeneralGroup.Controls.Add($TexExtractThreadNumBox)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractThreadTip = New-Object Windows.Forms.ToolTip
  $TexExtractThreadTip.InitialDelay = $ToolTipDelay
  $TexExtractThreadTip.AutoPopDelay = $ToolTipDuration
  $TexExtractThreadTipString  = 'The number of threads used to extract{0}'
  $TexExtractThreadTipString += 'textures. More threads can be faster if{0}'
  $TexExtractThreadTipString += 'you have multiple CPU cores available.'
  $TexExtractThreadTipString = [String]::Format($TexExtractThreadTipString, [Environment]::NewLine)
  $TexExtractThreadTip.SetToolTip($TexExtractThreadCheckBox, $TexExtractThreadTipString)

  # Extract Textures From Files - Create a combobox to select the cleanup type.
  $global:TexExtractCleanCombo = New-Object Windows.Forms.ComboBox
  $TexExtractCleanCombo.Size = DPISize (New-Object Drawing.Size(84, 10))
  $TexExtractCleanCombo.Location = DPISize (New-Object Drawing.Point(10, 117))
  $TexExtractCleanCombo.Name = 'ExtractCleanType'
  $TexExtractCleanCombo.Items.Add('Simple') | Out-Null
  $TexExtractCleanCombo.Items.Add('Default') | Out-Null
  $TexExtractCleanCombo.Items.Add('Compact') | Out-Null
  $TexExtractCleanCombo.Items.Add('Custom') | Out-Null
  $TexExtractCleanCombo.Items.Add('None') | Out-Null
  $TexExtractCleanCombo.SelectedItem = $ExtractCleanType
  $TexExtractCleanCombo.Add_SelectedIndexChanged({ $TexExtractFocusLabel.Focus() })
  $TexExtractCleanCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; ToggleCleanupOptions})
  $TexExtractCleanCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $TexExtractCleanCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $TexExtractCleanCombo.Add_DrawItem({ RepopulateComboBox })
  $TexExtractGeneralGroup.Controls.Add($TexExtractCleanCombo)

  # Extract Textures From Files - Create a label for the cleanup type.
  $global:TexExtractCleanLabel = New-Object Windows.Forms.Label
  $TexExtractCleanLabel.Size = DPISize (New-Object Drawing.Size(90, 20))
  $TexExtractCleanLabel.Location = DPISize (New-Object Drawing.Point(98, 120))
  $TexExtractCleanLabel.Text = 'Cleanup Type'
  $TexExtractGeneralGroup.Controls.Add($TexExtractCleanLabel)

  # Extract Textures From Files - Create a checkbox for multithreading.
  $global:TexExtractCleanLabelB = New-Object Windows.Forms.Label
  $TexExtractCleanLabelB.Size = DPISize (New-Object Drawing.Size(100, 16))
  $TexExtractCleanLabelB.Location = DPISize (New-Object Drawing.Point(190, 120))
  $TexExtractCleanLabelB.Text = "=============>"
  $TexExtractCleanLabelB.Enabled = ($ExtractCleanType -eq "Custom")
  $TexExtractGeneralGroup.Controls.Add($TexExtractCleanLabelB)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractCleanupTip = New-Object Windows.Forms.ToolTip
  $TexExtractCleanupTip.InitialDelay = $ToolTipDelay
  $TexExtractCleanupTip.AutoPopDelay = $ToolTipDuration
  $TexExtractCleanupTipString  = 'Cleans up the output textures & folders.{0}'
  $TexExtractCleanupTipString += '{0}'
  $TexExtractCleanupTipString += 'Simple: Moves all files to a single folder.{0}'
  $TexExtractCleanupTipString += 'Default: Shortens the path by deleting unnecessary folders.{0}'
  $TexExtractCleanupTipString += 'Compact: Same as Default but to a more significant effect.{0}'
  $TexExtractCleanupTipString += 'Custom: Shortens the path by a custom number of folders.{0}'
  $TexExtractCleanupTipString += 'None: No cleanup. Retains the original folder structure.{0}'
  $TexExtractCleanupTipString += '{0}'
  $TexExtractCleanupTipString += 'The default selection is most likely the preferrable option.'
  $TexExtractCleanupTipString = [String]::Format($TexExtractCleanupTipString, [Environment]::NewLine)
  $TexExtractCleanupTip.SetToolTip($TexExtractCleanLabel, $TexExtractCleanupTipString)

  # Extract Textures From Files - Create a numeric up/down to select the cleanup count.
  $global:TexExtractCleanNumBox = New-Object Windows.Forms.NumericUpDown
  $TexExtractCleanNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $TexExtractCleanNumBox.Location = DPISize (New-Object Drawing.Point(300, 117)) -AddY $DPIOffsetFix
  $TexExtractCleanNumBox.Name = 'ExtractCleanCount'
  $TexExtractCleanNumBox.DecimalPlaces = 0
  $TexExtractCleanNumBox.Minimum = 1
  $TexExtractCleanNumBox.Maximum = 10
  $TexExtractCleanNumBox.Increment = 1
  $TexExtractCleanNumBox.Value = $ExtractCleanCount
  $TexExtractCleanNumBox.Enabled = ($ExtractCleanType -eq "Custom")
  $TexExtractCleanNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $TexExtractGeneralGroup.Controls.Add($TexExtractCleanNumBox)

  # Extract Textures From Files - Create a groupbox for mipmap options.
  $global:TexExtractMipmapGroup = New-Object Windows.Forms.GroupBox
  $TexExtractMipmapGroup.Size = DPISize (New-Object Drawing.Size(365, 98))
  $TexExtractMipmapGroup.Location = DPISize (New-Object Drawing.Point(10, 222))
  $TexExtractMipmapGroup.Text = 'Mipmap Options'
  $TexExtractDialog.Controls.Add($TexExtractMipmapGroup)

  # Extract Textures From Files - Create a checkbox to extract texture mipmaps.
  $global:TexExtractMipmapCheck = New-Object Windows.Forms.CheckBox
  $TexExtractMipmapCheck.Size = DPISize (New-Object Drawing.Size(178, 16))
  $TexExtractMipmapCheck.Location = DPISize (New-Object Drawing.Point(10, 20))
  $TexExtractMipmapCheck.Name = 'ExtractTexMipmaps'
  $TexExtractMipmapCheck.Checked = $ExtractTexMipmaps
  $TexExtractMipmapCheck.Text = ' Extract Texture Mipmaps'
  $TexExtractMipmapCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexExtractMipmapGroup.Controls.Add($TexExtractMipmapCheck)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractMipmapTip = New-Object Windows.Forms.ToolTip
  $TexExtractMipmapTip.InitialDelay = $ToolTipDelay
  $TexExtractMipmapTip.AutoPopDelay = $ToolTipDuration
  $TexExtractMipmapTipString  = 'Extract mipmaps that are included with{0}'
  $TexExtractMipmapTipString += 'the texture into separate PNG files.'
  $TexExtractMipmapTipString = [String]::Format($TexExtractMipmapTipString, [Environment]::NewLine)
  $TexExtractMipmapTip.SetToolTip($TexExtractMipmapCheck, $TexExtractMipmapTipString)

  # Extract Textures From Files - Create a checkbox to extract texture mipmaps.
  $global:TexExtractDolphinCheck = New-Object Windows.Forms.CheckBox
  $TexExtractDolphinCheck.Size = DPISize (New-Object Drawing.Size(178, 16))
  $TexExtractDolphinCheck.Location = DPISize (New-Object Drawing.Point(10, 45))
  $TexExtractDolphinCheck.Name = 'ExtractDolphinMipmap'
  $TexExtractDolphinCheck.Checked = $ExtractDolphinMipmap
  $TexExtractDolphinCheck.Text = ' Dolphin Mipmap Detection'
  $TexExtractDolphinCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexExtractMipmapGroup.Controls.Add($TexExtractDolphinCheck)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractDolphinTip = New-Object Windows.Forms.ToolTip
  $TexExtractDolphinTip.InitialDelay = $ToolTipDelay
  $TexExtractDolphinTip.AutoPopDelay = $ToolTipDuration
  $TexExtractDolphinTipString  = 'Attempts to add the mipmap "_m_" flag{0}'
  $TexExtractDolphinTipString += 'to textures that do not actually contain{0}'
  $TexExtractDolphinTipString += 'mipmaps but Dolphin flags them as such.'
  $TexExtractDolphinTipString = [String]::Format($TexExtractDolphinTipString, [Environment]::NewLine)
  $TexExtractDolphinTip.SetToolTip($TexExtractDolphinCheck, $TexExtractDolphinTipString)

  # Extract Textures From Files - Create a checkbox to extract texture mipmaps.
  $global:TexExtractArbMipCheck = New-Object Windows.Forms.CheckBox
  $TexExtractArbMipCheck.Size = DPISize (New-Object Drawing.Size(178, 16))
  $TexExtractArbMipCheck.Location = DPISize (New-Object Drawing.Point(10, 70))
  $TexExtractArbMipCheck.Name = 'ExtractArbMipmap'
  $TexExtractArbMipCheck.Checked = $ExtractArbMipmap
  $TexExtractArbMipCheck.Text = ' Arbitrary Mipmap Detection'
  $TexExtractArbMipCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $TexExtractMipmapGroup.Controls.Add($TexExtractArbMipCheck)

  # Extract Textures From Files - Create a tooltip.
  $TexExtractArbMipTip = New-Object Windows.Forms.ToolTip
  $TexExtractArbMipTip.InitialDelay = $ToolTipDelay
  $TexExtractArbMipTip.AutoPopDelay = $ToolTipDuration
  $TexExtractArbMipTipString  = 'Detects and extracts mipmaps from textures{0}'
  $TexExtractArbMipTipString += 'that contain arbitrary mipmaps, which are{0}'
  $TexExtractArbMipTipString += 'mipmap textures with differing images.'
  $TexExtractArbMipTipString = [String]::Format($TexExtractArbMipTipString, [Environment]::NewLine)
  $TexExtractArbMipTip.SetToolTip($TexExtractArbMipCheck, $TexExtractArbMipTipString)
  
  # Extract Textures From Files - Create a button to close the window.
  $global:TexExtractOkayButton = New-Object Windows.Forms.Button
  $TexExtractOkayButton.Size = DPISize (New-Object Drawing.Size(100, 28))
  $TexExtractOkayButton.Location = DPISize (New-Object Drawing.Point(276, 326))
  $TexExtractOkayButton.Text = 'Close'
  $TexExtractOkayButton.Add_Click({ $TexExtractDialog.Hide() })
  $TexExtractDialog.Controls.Add($TexExtractOkayButton)
  $TexExtractDialog.AcceptButton = $TexExtractOkayButton
}
#==============================================================================================================================================================================================
#  CTT GUI: PNG ALPHA PIXEL MANIPULATION DIALOG
#==============================================================================================================================================================================================
#  Adjusts the percentages on the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AdjustRGBAPercent()
{
  # Calculate the percentage value.
  $Percent = FormatDecimal -Value ($this.Value / 255 * 100)

  # Update the appropriate label.
  switch -wildcard ($this.Name)
  {
    'CAlphaRed'  { $CustomAlphaRedPLabel.Text = '(' + $Percent + '%)' }
    'CAlphaGrn'  { $CustomAlphaGrnPLabel.Text = '(' + $Percent + '%)' }
    'CAlphaBlu'  { $CustomAlphaBluPLabel.Text = '(' + $Percent + '%)' }
    'CAlphaAlp'  { $CustomAlphaAlpPLabel.Text = '(' + $Percent + '%)' }
    '*Threshold' { $CustomThresholdLabel.Text = '(' + $Percent + '%)' }
  }
}
#==============================================================================================================================================================================================
#  Toggles alpha elements.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleAlphaElements()
{
  # Get the checkstate.
  $Checked = $this.Checked

  # Toggle the appropriate elements.
  switch -wildcard ($this.Name)
  {
    # Toggle the red stuff.
    'BAlphaRed' {
                  $CustomAlphaRedLabel.Enabled = $Checked
                  $CustomAlphaRedNumBox.Enabled = $Checked
                  $CustomAlphaRedPLabel.Enabled = $Checked
                }
    # Toggle the green stuff.
    'BAlphaGrn' {
                  $CustomAlphaGrnLabel.Enabled = $Checked
                  $CustomAlphaGrnNumBox.Enabled = $Checked
                  $CustomAlphaGrnPLabel.Enabled = $Checked
                }
    # Toggle the blue stuff.
    'BAlphaBlu' {
                  $CustomAlphaBluLabel.Enabled = $Checked
                  $CustomAlphaBluNumBox.Enabled = $Checked
                  $CustomAlphaBluPLabel.Enabled = $Checked
                }
    # Toggle the alpha stuff.
    'BAlphaAlp' {
                  $CustomAlphaAlpLabel.Enabled = $Checked
                  $CustomAlphaAlpNumBox.Enabled = $Checked
                  $CustomAlphaAlpPLabel.Enabled = $Checked
                }
  }
}
#==============================================================================================================================================================================================
#  Resets the values on the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResetAlphaRGBValues()
{
  # Simply set them to zero. The changed values triggers the associated events.
  $CustomAlphaRedNumBox.Value  = 0
  $CustomAlphaGrnNumBox.Value  = 0
  $CustomAlphaBluNumBox.Value  = 0
  $CustomAlphaAlpNumBox.Value  = 0
  $CustomThresholdNumBox.Value = 0
}
#==============================================================================================================================================================================================
#  Create the dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_AlphaManipulation()
{
  # Create the dialog and set up properties.
  $global:PNGAlphaDialog = New-Object Windows.Forms.Form
  $PNGAlphaDialog.Size = DPISize (New-Object Drawing.Size(280, 310))
  $PNGAlphaDialog.MinimumSize = DPISize (New-Object Drawing.Size(280, 310))
  $PNGAlphaDialog.MaximumSize = DPISize (New-Object Drawing.Size(280, 310))
  $PNGAlphaDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $PNGAlphaDialog.Text = 'Customize Alpha Pixels'
  $PNGAlphaDialog.MinimizeBox = $false
  $PNGAlphaDialog.MaximizeBox = $false
  $PNGAlphaDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $PNGAlphaDialog.FormBorderStyle = GetFormBorderStyle
  $PNGAlphaDialog.StartPosition = "CenterScreen"
  $PNGAlphaDialog.Topmost = !$DisableTopMost
  $PNGAlphaDialog.KeyPreview = $true
  $PNGAlphaDialog.Add_KeyDown({ EscapeCloseDialog })
  $PNGAlphaDialog.Add_FormClosing({ $PNGAlphaDialog.Hide() ; $_.Cancel = $true })
  $PNGAlphaDialog.Icon = $Icon_CTTPSGreen

  # Alpha Pixel Manipulation - Create a groupbox to hold the new values.
  $global:CustomAlphaSearchGroup = New-Object Windows.Forms.GroupBox
  $CustomAlphaSearchGroup.Size = DPISize (New-Object Drawing.Size(244, 48))
  $CustomAlphaSearchGroup.Location = DPISize (New-Object Drawing.Point(10, 5))
  $CustomAlphaSearchGroup.Text = 'Search Type'
  $PNGAlphaDialog.Controls.Add($CustomAlphaSearchGroup)

  # Alpha Pixel Manipulation - Create a tooltip to for the label.
  $CustomAlphaSearchGroupTip = New-Object Windows.Forms.ToolTip
  $CustomAlphaSearchGroupTip.InitialDelay = $ToolTipDelay
  $CustomAlphaSearchGroupTip.AutoPopDelay = $ToolTipDuration
  $CustomAlphaSearchGroupTipString  = 'This section affects which pixels are selected.{0}'
  $CustomAlphaSearchGroupTipString += '{0}'
  $CustomAlphaSearchGroupTipString += "No Color Data: The pixel's RGB values must be 0.{0}"
  $CustomAlphaSearchGroupTipString += 'Allow Color Data: RGB values can be anything 0-255.'
  $CustomAlphaSearchGroupTipString = [String]::Format($CustomAlphaSearchGroupTipString, [Environment]::NewLine)
  $CustomAlphaSearchGroupTip.SetToolTip($CustomAlphaSearchGroup, $CustomAlphaSearchGroupTipString)

  # Alpha Pixel Manipulation - Create a panel to hold the radio buttons.
  $global:CustomAlphaSearchPanel = New-Object Windows.Forms.Panel
  $CustomAlphaSearchPanel.Size = DPISize (New-Object Drawing.Size(220, 18))
  $CustomAlphaSearchPanel.Location = DPISize (New-Object Drawing.Point(10, 20))
  $CustomAlphaSearchGroup.Controls.Add($CustomAlphaSearchPanel)

  # Alpha Pixel Manipulation - Add the radio button.
  $global:CustomAlphaSearchOn = New-Object Windows.Forms.RadioButton
  $CustomAlphaSearchOn.Size = DPISize (New-Object Drawing.Size(100, 18))
  $CustomAlphaSearchOn.Location = DPISize (New-Object Drawing.Point(0, 0))
  $CustomAlphaSearchOn.Name = 'AlphaSearch'
  $CustomAlphaSearchOn.Text = 'No Color Data'
  $CustomAlphaSearchOn.Checked = ($AlphaSearch -eq 'No Color Data')
  $CustomAlphaSearchOn.Add_CheckedChanged({ if ($this.Checked) { Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' } } )
  $CustomAlphaSearchPanel.Controls.Add($CustomAlphaSearchOn)

  # Alpha Pixel Manipulation - Add another radio button.
  $global:CustomAlphaSearchOff = New-Object Windows.Forms.RadioButton
  $CustomAlphaSearchOff.Size = DPISize (New-Object Drawing.Size(120, 18))
  $CustomAlphaSearchOff.Location = DPISize (New-Object Drawing.Point(106, 0))
  $CustomAlphaSearchOff.Name = 'AlphaSearch'
  $CustomAlphaSearchOff.Text = 'Allow Color Data'
  $CustomAlphaSearchOff.Checked = ($AlphaSearch -eq 'Allow Color Data')
  $CustomAlphaSearchOff.Add_CheckedChanged({ if ($this.Checked) { Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' } })
  $CustomAlphaSearchPanel.Controls.Add($CustomAlphaSearchOff)

  # Alpha Pixel Manipulation - Create a groupbox to hold the new values.
  $global:CustomAlphaThresholdGroup = New-Object Windows.Forms.GroupBox
  $CustomAlphaThresholdGroup.Size = DPISize (New-Object Drawing.Size(244, 48))
  $CustomAlphaThresholdGroup.Location = DPISize (New-Object Drawing.Point(10, 56))
  $CustomAlphaThresholdGroup.Text = 'Search Threshold'
  $PNGAlphaDialog.Controls.Add($CustomAlphaThresholdGroup)

  # Alpha Pixel Manipulation - Create a tooltip to for the label.
  $CustomAlphaThresholdTip = New-Object Windows.Forms.ToolTip
  $CustomAlphaThresholdTip.InitialDelay = $ToolTipDelay
  $CustomAlphaThresholdTip.AutoPopDelay = $ToolTipDuration
  $CustomAlphaThresholdTipString  = 'The maximum alpha value a pixel can have{0}'
  $CustomAlphaThresholdTipString += 'to be selected for the custom fill values.'
  $CustomAlphaThresholdTipString = [String]::Format($CustomAlphaThresholdTipString, [Environment]::NewLine)
  $CustomAlphaThresholdTip.SetToolTip($CustomAlphaThresholdGroup, $CustomAlphaThresholdTipString)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomThresholdALabel = New-Object Windows.Forms.Label
  $CustomThresholdALabel.Size = DPISize (New-Object Drawing.Size(10, 16))
  $CustomThresholdALabel.Location = DPISize (New-Object Drawing.Point(10, 23))
  $CustomThresholdALabel.Text = 'A'
  $CustomAlphaThresholdGroup.Controls.Add($CustomThresholdALabel)

  # Alpha Pixel Manipulation - Create a number box to adjust the color.
  $global:CustomThresholdNumBox = New-Object Windows.Forms.NumericUpDown
  $CustomThresholdNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $CustomThresholdNumBox.Location = DPISize (New-Object Drawing.Point(28, 20)) -AddY $DPIOffsetFix
  $CustomThresholdNumBox.Name = 'AlphaThreshold'
  $CustomThresholdNumBox.DecimalPlaces = 0
  $CustomThresholdNumBox.Minimum = 0
  $CustomThresholdNumBox.Maximum = 255
  $CustomThresholdNumBox.Increment = 1
  $CustomThresholdNumBox.Value = $AlphaThreshold
  $CustomThresholdNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; AdjustRGBAPercent })
  $CustomAlphaThresholdGroup.Controls.Add($CustomThresholdNumBox)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomThresholdLabel = New-Object Windows.Forms.Label
  $CustomThresholdLabel.Size = DPISize (New-Object Drawing.Size(60, 16))
  $CustomThresholdLabel.Location = DPISize (New-Object Drawing.Point(80, 23))
  $CustomThresholdLabel.Name = 'AlphaThreshold'
  $CustomThresholdLabel.Text = '(' + (FormatDecimal -Value ($AlphaThreshold / 255 * 100)) + '%)'
  $CustomAlphaThresholdGroup.Controls.Add($CustomThresholdLabel)

  # Alpha Pixel Manipulation - Create a groupbox to hold the new values.
  $global:CustomAlphaColorGroup = New-Object Windows.Forms.GroupBox
  $CustomAlphaColorGroup.Size = DPISize (New-Object Drawing.Size(244, 124))
  $CustomAlphaColorGroup.Location = DPISize (New-Object Drawing.Point(10, 108))
  $CustomAlphaColorGroup.Text = 'Custom RGBA Fill Values'
  $PNGAlphaDialog.Controls.Add($CustomAlphaColorGroup)

  # Alpha Pixel Manipulation - Create a tooltip to for the label.
  $CustomAlphaColorGroupTip = New-Object Windows.Forms.ToolTip
  $CustomAlphaColorGroupTip.InitialDelay = $ToolTipDelay
  $CustomAlphaColorGroupTip.AutoPopDelay = $ToolTipDuration
  $CustomAlphaColorGroupTipString = 'Defines the new values used for selected pixels.'
  $CustomAlphaColorGroupTip.SetToolTip($CustomAlphaColorGroup, $CustomAlphaColorGroupTipString)

  # Alpha Pixel Manipulation - Create a checkbox to enable/disable the color.
  $global:CustomAlphaRedCheck = New-Object Windows.Forms.CheckBox
  $CustomAlphaRedCheck.Size = DPISize (New-Object Drawing.Size(16, 16))
  $CustomAlphaRedCheck.Location = DPISize (New-Object Drawing.Point(10, 22))
  $CustomAlphaRedCheck.Name = 'BAlphaRed'
  $CustomAlphaRedCheck.Checked = $BAlphaRed
  $CustomAlphaRedCheck.Text = ''
  $CustomAlphaRedCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleAlphaElements })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaRedCheck)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaRedLabel = New-Object Windows.Forms.Label
  $CustomAlphaRedLabel.Size = DPISize (New-Object Drawing.Size(10, 16))
  $CustomAlphaRedLabel.Location = DPISize (New-Object Drawing.Point(30, 23))
  $CustomAlphaRedLabel.Text = 'R'
  $CustomAlphaRedLabel.Enabled = $BAlphaRed
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaRedLabel)

  # Alpha Pixel Manipulation - Create a number box to adjust the color.
  $global:CustomAlphaRedNumBox = New-Object Windows.Forms.NumericUpDown
  $CustomAlphaRedNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $CustomAlphaRedNumBox.Location = DPISize (New-Object Drawing.Point(48, 20)) -AddY $DPIOffsetFix
  $CustomAlphaRedNumBox.Name = 'CAlphaRed'
  $CustomAlphaRedNumBox.DecimalPlaces = 0
  $CustomAlphaRedNumBox.Minimum = 0
  $CustomAlphaRedNumBox.Maximum = 255
  $CustomAlphaRedNumBox.Increment = 1
  $CustomAlphaRedNumBox.Value = $CAlphaRed
  $CustomAlphaRedNumBox.Enabled = $BAlphaRed
  $CustomAlphaRedNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; AdjustRGBAPercent })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaRedNumBox)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaRedPLabel = New-Object Windows.Forms.Label
  $CustomAlphaRedPLabel.Size = DPISize (New-Object Drawing.Size(60, 16))
  $CustomAlphaRedPLabel.Location = DPISize (New-Object Drawing.Point(100, 23)) -AddY $DPIOffsetFix
  $CustomAlphaRedPLabel.Name = 'CAlphaRed'
  $CustomAlphaRedPLabel.Text = '(' + (FormatDecimal -Value ($CAlphaRed / 255 * 100)) + '%)'
  $CustomAlphaRedPLabel.Enabled = $BAlphaRed
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaRedPLabel)

  # Alpha Pixel Manipulation - Create a checkbox to enable/disable the color.
  $global:CustomAlphaGrnCheck = New-Object Windows.Forms.CheckBox
  $CustomAlphaGrnCheck.Size = DPISize (New-Object Drawing.Size(16, 16))
  $CustomAlphaGrnCheck.Location = DPISize (New-Object Drawing.Point(10, 47))
  $CustomAlphaGrnCheck.Name = 'BAlphaGrn'
  $CustomAlphaGrnCheck.Checked = $BAlphaGrn
  $CustomAlphaGrnCheck.Text = ''
  $CustomAlphaGrnCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleAlphaElements })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaGrnCheck)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaGrnLabel = New-Object Windows.Forms.Label
  $CustomAlphaGrnLabel.Size = DPISize (New-Object Drawing.Size(10, 16))
  $CustomAlphaGrnLabel.Location = DPISize (New-Object Drawing.Point(30, 48))
  $CustomAlphaGrnLabel.Text = 'G'
  $CustomAlphaGrnLabel.Enabled = $BAlphaGrn
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaGrnLabel)

  # Alpha Pixel Manipulation - Create a number box to adjust the color.
  $global:CustomAlphaGrnNumBox = New-Object Windows.Forms.NumericUpDown
  $CustomAlphaGrnNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $CustomAlphaGrnNumBox.Location = DPISize (New-Object Drawing.Point(48, 45)) -AddY $DPIOffsetFix
  $CustomAlphaGrnNumBox.Name = 'CAlphaGrn'
  $CustomAlphaGrnNumBox.DecimalPlaces = 0
  $CustomAlphaGrnNumBox.Minimum = 0
  $CustomAlphaGrnNumBox.Maximum = 255
  $CustomAlphaGrnNumBox.Increment = 1
  $CustomAlphaGrnNumBox.Value = $CAlphaGrn
  $CustomAlphaGrnNumBox.Enabled = $BAlphaGrn
  $CustomAlphaGrnNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; AdjustRGBAPercent })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaGrnNumBox)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaGrnPLabel = New-Object Windows.Forms.Label
  $CustomAlphaGrnPLabel.Size = DPISize (New-Object Drawing.Size(60, 16))
  $CustomAlphaGrnPLabel.Location = DPISize (New-Object Drawing.Point(100, 48))
  $CustomAlphaGrnPLabel.Name = 'CAlphaGrn'
  $CustomAlphaGrnPLabel.Text = '(' + (FormatDecimal -Value ($CAlphaGrn / 255 * 100)) + '%)'
  $CustomAlphaGrnPLabel.Enabled = $BAlphaGrn
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaGrnPLabel)

  # Alpha Pixel Manipulation - Create a checkbox to enable/disable the color.
  $global:CustomAlphaBluCheck = New-Object Windows.Forms.CheckBox
  $CustomAlphaBluCheck.Size = DPISize (New-Object Drawing.Size(16, 16))
  $CustomAlphaBluCheck.Location = DPISize (New-Object Drawing.Point(10, 72))
  $CustomAlphaBluCheck.Name = 'BAlphaBlu'
  $CustomAlphaBluCheck.Checked = $BAlphaBlu
  $CustomAlphaBluCheck.Text = ''
  $CustomAlphaBluCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleAlphaElements })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaBluCheck)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaBluLabel = New-Object Windows.Forms.Label
  $CustomAlphaBluLabel.Size = DPISize (New-Object Drawing.Size(10, 16))
  $CustomAlphaBluLabel.Location = DPISize (New-Object Drawing.Point(30, 73))
  $CustomAlphaBluLabel.Text = 'B'
  $CustomAlphaBluLabel.Enabled = $BAlphaBlu
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaBluLabel)

  # Alpha Pixel Manipulation - Create a number box to adjust the color.
  $global:CustomAlphaBluNumBox = New-Object Windows.Forms.NumericUpDown
  $CustomAlphaBluNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $CustomAlphaBluNumBox.Location = DPISize (New-Object Drawing.Point(48, 70)) -AddY $DPIOffsetFix
  $CustomAlphaBluNumBox.Name = 'CAlphaBlu'
  $CustomAlphaBluNumBox.DecimalPlaces = 0
  $CustomAlphaBluNumBox.Minimum = 0
  $CustomAlphaBluNumBox.Maximum = 255
  $CustomAlphaBluNumBox.Increment = 1
  $CustomAlphaBluNumBox.Value = $CAlphaBlu
  $CustomAlphaBluNumBox.Enabled = $BAlphaBlu
  $CustomAlphaBluNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; AdjustRGBAPercent })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaBluNumBox)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaBluPLabel = New-Object Windows.Forms.Label
  $CustomAlphaBluPLabel.Size = DPISize (New-Object Drawing.Size(60, 16))
  $CustomAlphaBluPLabel.Location = DPISize (New-Object Drawing.Point(100, 73))
  $CustomAlphaBluPLabel.Name = 'CAlphaBlu'
  $CustomAlphaBluPLabel.Text = '(' + (FormatDecimal -Value ($CAlphaBlu / 255 * 100)) + '%)'
  $CustomAlphaBluPLabel.Enabled = $BAlphaBlu
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaBluPLabel)

  # Alpha Pixel Manipulation - Create a checkbox to enable/disable the color.
  $global:CustomAlphaAlpCheck = New-Object Windows.Forms.CheckBox
  $CustomAlphaAlpCheck.Size = DPISize (New-Object Drawing.Size(16, 16))
  $CustomAlphaAlpCheck.Location = DPISize (New-Object Drawing.Point(10, 97))
  $CustomAlphaAlpCheck.Name = 'BAlphaAlp'
  $CustomAlphaAlpCheck.Checked = $BAlphaAlp
  $CustomAlphaAlpCheck.Text = ''
  $CustomAlphaAlpCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleAlphaElements })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaAlpCheck)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaAlpLabel = New-Object Windows.Forms.Label
  $CustomAlphaAlpLabel.Size = DPISize (New-Object Drawing.Size(10, 16))
  $CustomAlphaAlpLabel.Location = DPISize (New-Object Drawing.Point(30, 98))
  $CustomAlphaAlpLabel.Text = 'A'
  $CustomAlphaAlpLabel.Enabled = $BAlphaAlp
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaAlpLabel)

  # Alpha Pixel Manipulation - Create a number box to adjust the color.
  $global:CustomAlphaAlpNumBox = New-Object Windows.Forms.NumericUpDown
  $CustomAlphaAlpNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $CustomAlphaAlpNumBox.Location = DPISize (New-Object Drawing.Point(48, 95)) -AddY $DPIOffsetFix
  $CustomAlphaAlpNumBox.Name = 'CAlphaAlp'
  $CustomAlphaAlpNumBox.DecimalPlaces = 0
  $CustomAlphaAlpNumBox.Minimum = 0
  $CustomAlphaAlpNumBox.Maximum = 255
  $CustomAlphaAlpNumBox.Increment = 1
  $CustomAlphaAlpNumBox.Value = $CAlphaAlp
  $CustomAlphaAlpNumBox.Enabled = $BAlphaAlp
  $CustomAlphaAlpNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; AdjustRGBAPercent })
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaAlpNumBox)

  # Alpha Pixel Manipulation - Create a label to adjust the color.
  $global:CustomAlphaAlpPLabel = New-Object Windows.Forms.Label
  $CustomAlphaAlpPLabel.Size = DPISize (New-Object Drawing.Size(60, 16))
  $CustomAlphaAlpPLabel.Location = DPISize (New-Object Drawing.Point(100, 98))
  $CustomAlphaAlpPLabel.Name = 'CAlphaAlp'
  $CustomAlphaAlpPLabel.Text = '(' + (FormatDecimal -Value ($CAlphaAlp / 255 * 100)) + '%)'
  $CustomAlphaAlpPLabel.Enabled = $BAlphaAlp
  $CustomAlphaColorGroup.Controls.Add($CustomAlphaAlpPLabel)

  # Alpha Pixel Manipulation - Create a reset button.
  $global:CustomAlphaResetButton = New-Object Windows.Forms.Button
  $CustomAlphaResetButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $CustomAlphaResetButton.Location = DPISize (New-Object Drawing.Point(10, 237))
  $CustomAlphaResetButton.Text = 'Reset'
  $CustomAlphaResetButton.Add_Click({ ResetAlphaRGBValues })
  $PNGAlphaDialog.Controls.Add($CustomAlphaResetButton)

  # Create a button to close the window.
  $global:AlphaOkayButton = New-Object Windows.Forms.Button
  $AlphaOkayButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $AlphaOkayButton.Location = DPISize (New-Object Drawing.Point(175, 237))
  $AlphaOkayButton.Text = 'Close'
  $AlphaOkayButton.Add_Click({ $PNGAlphaDialog.Hide() })
  $PNGAlphaDialog.Controls.Add($AlphaOkayButton)
  $PNGAlphaDialog.AcceptButton = $AlphaOkayButton
}
#==============================================================================================================================================================================================
#  CTT GUI: METROID PRIME 2 - LOAD BASE TEXTURE FILES
#==============================================================================================================================================================================================
#  Not so apparent globals that store various things about the MP2 font dialog.
#  XX: 00-12, "MetroidPreview" can be 97-99 for "drag & drop" images
#==============================================================================================================================================================================================
#  MetroidBaseXX               - Stores the paths to the "base" images the user imported that serve as the replacement images.
#  MetroidPreviewXX            - Images generated from base64 strings that show the font textures. 97-99 references the drag & drop images.
#  MetroidGroupBoxXX           - The groupboxes for each image that houses everything.
#  MetroidConsoleLabelXX       - Label that shows which console the texture dumps from.
#  MetroidRegionLabelXX        - Label that shows which region the texture dumps from.
#  MetroidCompareLabelXX       - A label that displays Pac-Man's mouth > between the textures.
#  MetroidTextBoxXX            - Shows the path to the texture the user imported; displays the corresponding "MetroidBaseXX" path.
#  MetroidButtonXX             - Allows importing the path using an "Open Folder" dialog.
#  MetroidExampleImageXX       - Pictureboxes which hold the preview images generated from base64 strings.
#  MetroidExampleBorderXX      - A border that surrounds the above picturebox. Useful to reference for positioning.
#  MetroidExampleFillXX  - A border that surrounds the above picturebox. Useful to reference for positioning.
#  MetroidPreviewImageXX       - Pictureboxes which hold the preview images generated from base64 strings.
#  MetroidPreviewBorderXX      - A border that surrounds the above picturebox. Useful to reference for positioning.
#  MetroidPreviewFillXX  - A border that surrounds the above picturebox. Useful to reference for positioning.
#==============================================================================================================================================================================================
#  The final function to add a Metroid Prime 2 base image, used by all other functions.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadMetroidBase([Windows.Forms.TextBox]$TextBox=$null, [int]$Index, [string]$TexturePath)
{
  # Update the global variable that tracks the full path as a string.
  $global:MetroidBase[$Index] = $TexturePath

  # Update the text box with the new path.
  $TextBox.Text = $TexturePath

  # Import the new image into an object and create a bitmap from it.
  $ImgObject = [Drawing.Image]::FromFile($TexturePath)
  $TempBitMap = New-Object Drawing.Bitmap($ImgObject, $MetroidPreviewImage[$Index].Size.Width, $MetroidPreviewImage[$Index].Size.Height)
  $ImgObject.Dispose()

  # Replace the picturebox with the new image.
  $MetroidPreviewImage[$Index].Image = $TempBitMap

  # Set the focus to the okay button.
  $MetroidOkayButton.Focus()
}
#==============================================================================================================================================================================================
#  Loads a Metroid Prime 2 image with a button.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadMetroidBase_Button()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)

  # Get the starting path when pressing the button.
  $GetFilePath = GetFileStartPath -StartPath $MetroidTextBox[$Index].Text

  # Display an "Open Folder" menu to get the path.
  $SelectedPath = Get-FileName -StartPath $GetFilePath -FileName '*.png' -Description 'MP2 Texture'

  # Check to see if a folder was selected from the Open menu and test if that path exists.
  if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
  {
    # Add the selected tool to the script. The name of the button should hold the triggering index.
    LoadMetroidBase -TextBox $MetroidTextBox[$Index] -Index $Index -TexturePath $SelectedPath 
  }
}
#==============================================================================================================================================================================================
#  Loads a Metroid Prime 2 image with a drag and drop operation.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadMetroidBase_DragAndDrop()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)

  # Assume a textbox triggered this.
  $TextBox = $this

  # But detect when dropped onto an image.
  if ($TextBox.GetType() -ne 'System.Windows.Forms.TextBox')
  {
    # Retrieve the textbox from a global variable.
    $TextBox = $MetroidTextBox[$Index]
  }
  # Make sure there is data present before actually doing anything.
  if ($_.Data.GetDataPresent([Windows.Forms.DataFormats]::FileDrop))
  {
    # Create a list of the data to select the first item from the list.
    $DroppedFile = $_.Data.GetData([Windows.Forms.DataFormats]::FileDrop)

    # Make sure the path is a file (defined by type "leaf").
    if ((TestPath -LiteralPath $DroppedFile -PathType 'Leaf') -and ($DroppedFile -like '*.png'))
    {
      # Add the selected tool to the script.
      LoadMetroidBase -TextBox $TextBox -Index $Index -TexturePath $DroppedFile 
    }
  }
}
#==============================================================================================================================================================================================
#  Loads a Metroid Prime 2 image using the textbox when inserting a path.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function LoadMetroidBase_TextBox()
{
  # Convert the name into an integer which is the index of the triggering object.
  $Index = [Convert]::ToInt32($this.Name)

  # Get the current value of the variable by pulling it from textbox name.
  $EnteredText = $this.Text

  # To avoid updating constantly, check to see if the text actually changed.
  if (($EnteredText -ne $MetroidBase[$Index]) -and ($EnteredText -ne ''))
  {
    # Don't allow a final backslash in the path since it will be added manually.
    $EnteredText = PathTruncateSlash -Path $EnteredText

    # Make sure the path is a file.
    if ((TestPath -LiteralPath $EnteredText -PathType 'Leaf') -and ($EnteredText -like '*.png'))
    {
      # Add the selected tool to the script.
      LoadMetroidBase -TextBox $this -Index $Index -TexturePath $EnteredText 
    }
    else
    {
      # If the entered text was empty or invalid, set the textbox text back to what it was.
      $this.Text = $MetroidBase[$Index]
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: METROID PRIME 2 - STORE / LOAD BASE IMAGE PATHS IMPORTED BY USER
#==============================================================================================================================================================================================
#  Imports paths saved when the user loaded images and closed the menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MetroidLoadBaseImages()
{
  # Create a new string array to hold the paths.
  $NewContent = New-Object Collections.Generic.List[string]

  # The path to where the INI will be located.
  $PrimeTwoINI = $TextureToolData + '\Prime2\MP2FontPaths.ini'

  # Create a global variable to store the paths.
  $global:MetroidBase = New-Object string[] $MP2MD5HashA.Count

  # See if the INI file exists.
  if (TestPath -LiteralPath $PrimeTwoINI)
  {
    # Store that it does so it doesn't have to be checked again.
    $PrimeExists = $true

    # Load the INI file into a collection variable.
    $OldContent = Get-Content -LiteralPath $PrimeTwoINI
  }
  # Loop through the number of images there are in the array.
  for ($i = 0 ; $i -lt $MP2MD5HashA.Count ; $i++)
  {
    # The INI file is there, but it may not have enough lines if things changed.
    if (($PrimeExists) -and ($i -lt $OldContent.Count))
    {
      # The criteria was met so add the INI line.
      $NewContent.Add($OldContent[$i])
    }
    # The INI file doesn't exist or have enough lines.
    else
    {
      # Store a blank path in the new content.
      $NewContent.Add('')
    }
  }
  # Loop through each line of the new content.
  for ($i = 0 ; $i -lt $NewContent.Count ; $i++)
  {
    # Test to see if the path exists.
    switch (TestPath -LiteralPath $NewContent[$i])
    {
      # Only store the path if it exists, otherwise it's an empty string.
      $true  { $global:MetroidBase[$i] = $NewContent[$i] }
      $false { $global:MetroidBase[$i] = '' }
    }
  }
}
#==============================================================================================================================================================================================
#  Stores the image paths the user imporated into an external file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MetroidStoreBaseImages()
{
  # An array list to store all the image paths the user imported.
  $NewContent = New-Object Collections.Generic.List[string]

  # Loop through all the texture indexes.
  for ($i = 0 ; $i -lt $MP2MD5HashA.Count ; $i++)
  {
    # Test if it exists.
    switch (TestPath -LiteralPath $MetroidBase[$i])
    {
      # Add it to the INI if it exists, add empty line if it doesn't.
      $true  { $NewContent.Add($MetroidBase[$i]) }
      $false { $NewContent.Add('') }
    }
  }
  # Create the Prime2 folder if it doesn't exist.
  $PrimeTwoPath = CreatePath -LiteralPath ($TextureToolData + '\Prime2')

  # Set the path to the INI file.
  $PrimeTwoINI = $PrimeTwoPath + '\MP2FontPaths.ini'

  # Using Set-Content should overwrite the file but delete it just to make sure... tee hee.
  RemovePath -LiteralPath $PrimeTwoINI

  # Write the changes to the INI file.
  Set-Content -LiteralPath $PrimeTwoINI -Value $NewContent
}
#==============================================================================================================================================================================================
#  CTT GUI: METROID PRIME 2 - TEXTURE SELECTION WINDOW
#==============================================================================================================================================================================================
#  Shows the metroid texture selection window that allows the user to select font textures that match up with examples for easy replacement.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowMetroidPreview()
{
  # See if the dialog has been created yet.
  if ($MetroidDialog -eq $null)
  {
    # Load the Metroid Prime 2 bytemap hashes if they haven't been yet.
    InitiatePrime2Hashes

    # Set the dialog into limbo while the previews are generated.
    ToggleDialogStates -State $false

    # Attempt to load user imported image paths.
    MetroidLoadBaseImages
  
    # If it hasn't, then create it now.
    CreateDialog_MetroidPreview

    # Set the dialog into limbo while the previews are generated.
    ToggleDialogStates -State $true
  }
  # If the dialog has already been created then just update the images.
  else
  {
    # Get the necessary data to set up the previews.
    $Metroid = GetMetroidPreviewDatabase

    # Loop through all the texture indexes.
    for ($i = 0 ; $i -lt $MP2MD5HashA.Count ; $i++)
    {
      # Calculate the DPI adjusted size of the image.
      $ImageWidth  = DPISize $Metroid[$i].PbWidth
      $ImageHeight = DPISize $Metroid[$i].PbHeight

      # Get the image that will be shown on the example preview.
      $MetroidImage = GetMetroidBitmapImage -Position 'Left' -Index $i -PbIndex $Metroid[$i].PbIndex -Width $ImageWidth -Height $ImageHeight

      # Update the image on the example.
      $MetroidExampleImage[$i].Image = $MetroidImage
    }
  }  
  # Show the dialog to the user.
  $MetroidDialog.ShowDialog() | Out-Null
}
#==============================================================================================================================================================================================
#  Sets the background color behind the fonts.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MetroidFontBackgroundColor([Windows.Forms.Panel[]]$Background)
{
  # Create and show a color dialog to the user.
  $ColorSelect = $ColorDialog.ShowDialog()

  # Check to see if the color selection passed when the dialog was closed.
  if ($ColorSelect -eq 'OK')
  {
    # Compile the color into HTML format by converting each value to hexadecimal.
    $NewColor = '#' + $ColorDialog.Color.R.ToString('X2') + $ColorDialog.Color.G.ToString('X2') + $ColorDialog.Color.B.ToString('X2')

    # Update the color displayed on the button.
    $this.BackColor = $NewColor

    # Loop through all the texture indexes.
    for ($i = 0 ; $i -lt $MP2MD5HashA.Count ; $i++)
    {
      # Set the background color to the selected color.
      $Background[$i].BackColor = $NewColor
    }
  }
}
#==============================================================================================================================================================================================
#  This got unnecessarily complicating and specific to getting the bitmap image so branch it off into...this I guess.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMetroidBitmapImage([string]$Position, [int]$Index, [int]$PbIndex, [int]$Width, [int]$Height)
{
  # This is useful to have.
  $i = $Index
  $IndexDD = IntToStringDoubleDigit -Value $Index
 
  # The generated texture paths are referenced a few times so set them here and now.
  $DPIScaledPath = CreatePath -LiteralPath ($TextureToolData + '\Prime2\' + $Monitor.DPI.ToString() + 'DPI')
  $DPIScaledName = 'Image' + $IndexDD + '.png'
  $DPIScaledFile = $DPIScaledPath + '\' + $DPIScaledName

  # Left image is the example image.
  if ($Position -eq 'Left')
  {
    # Get the example [Drawing.Bitmap] image generated from a Base64 string.
    $MetroidPreview = Get-Variable -Name ('MetroidPreview' + $IndexDD) -ValueOnly

    # The user wants to generate high quality previews.
    if (($MetroidHighQuality) -and (TestPath -LiteralPath $ImageMagick))
    {
      # If it doesn't exist it needs to be created.
      if (!(TestPath -LiteralPath $DPIScaledFile))
      {
        # Extract the original image from the Base64 string to an actual PNG file.
        $MetroidPreviewPath = CreatePath -LiteralPath ($TempFolder + '\MetroidPreview')
        $MetroidPreviewFile = $MetroidPreviewPath + '\' + $DPIScaledName
        $MetroidPreview.Save($MetroidPreviewFile, [Drawing.Imaging.ImageFormat]::Png)

        # Combine the dimensions into a string.
        $Dimensions  = $Width.ToString() + 'x' + $Height.ToString()

        # Create a list of arguments to feed into ImageMagick.
        $Arguments = @('-filter','point','-resize',$Dimensions,'-define','png:color-type=6')

        # ImageMagick gobbles up arguments and spits out a resized image.
        Magick-Convert -ImageFile $MetroidPreviewFile -Arguments $Arguments -OutputFile $DPIScaledFile
      }
      # Import the new image into an object and create a bitmap from it.
      $ImgObject = [Drawing.Image]::FromFile($DPIScaledFile)
      $MetroidBitmap = New-Object Drawing.Bitmap($ImgObject, $Width, $Height)
      $ImgObject.Dispose()
    }
    # If high quality is disabled then just use the bitmap directly.
    else
    {
      # Quickly resize it using .NET framework.
      $MetroidBitmap = New-Object Drawing.Bitmap($MetroidPreview, $Width, $Height)
    }
  }
  # Right image is the preview image.
  elseif ($Position -eq 'Right')
  {
    # If "MP2FontPaths.ini" file existed then this will contain a value.
    if (TestPath -LiteralPath $MetroidBase[$i])
    {
      # Import the new image into an object and create a bitmap from it.
      $ImgObject = [Drawing.Image]::FromFile($MetroidBase[$i])
      $MetroidBitmap = New-Object Drawing.Bitmap($ImgObject, $Width, $Height)
      $ImgObject.Dispose()
    }
    # Use the Base64 image for the preview.
    else
    {
      # Get the example [Drawing.Bitmap] image generated from a Base64 string.
      $MetroidDragDrop = Get-Variable -Name ('MetroidPreview' + $PbIndex) -ValueOnly

      # Quickly resize it using .NET framework.
      $MetroidBitmap = New-Object Drawing.Bitmap($MetroidDragDrop, $Width, $Height)
    }
  }
  # Whatever it is, give it to me.
  return $MetroidBitmap
}
#==============================================================================================================================================================================================
#  Saves me a bunch of headache by creating a picturebox, a panel for a border, and an inner panel for the background.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateMetroidPictureBox([string]$Position, [int]$Index, [int]$PbIndex, [int]$Width, [int]$Height, [int]$X, [int]$Y)
{
  # This is useful to have.
  $i = $Index

  # Calculate the DPI adjusted size of the image.
  $ImageWidth  = DPISize $Width
  $ImageHeight = DPISize $Height

  # Get the bitmap that will be applied to this picturebox.
  $MetroidImage = GetMetroidBitmapImage -Position $Position -Index $i -PbIndex $PbIndex -Width $ImageWidth -Height $ImageHeight

  # Left image is the example image.
  if ($Position -eq 'Left')
  {
    # Create a picturebox to hold the image.
    $global:MetroidExampleImage[$i] = New-Object Windows.Forms.PictureBox
    $MetroidExampleImage[$i].Size = New-Object Drawing.Size($ImageWidth, $ImageHeight)
    $MetroidExampleImage[$i].Location = New-Object Drawing.Point(2, 2)
    $MetroidExampleImage[$i].Image = $MetroidImage
    $MetroidExampleImage[$i].Name = $Index

    # Create a panel to serve as the picturebox border.
    $BorderW = $MetroidExampleImage[$i].Size.Width + 4
    $BorderH = $MetroidExampleImage[$i].Size.Height + 4
    $global:MetroidExampleBorder[$i] = New-Object Windows.Forms.Panel
    $MetroidExampleBorder[$i].Size = New-Object Drawing.Size($BorderW, $BorderH)
    $MetroidExampleBorder[$i].Location = New-Object Drawing.Point($X, $Y)
    $MetroidExampleBorder[$i].BackColor = '#7a7a7a'

    # Create a panel to serve as the picturebox background.
    $PanelW = $MetroidExampleImage[$i].Size.Width
    $PanelH = $MetroidExampleImage[$i].Size.Height
    $global:MetroidExampleFill[$i] = New-Object Windows.Forms.Panel
    $MetroidExampleFill[$i].Size = New-Object Drawing.Size($PanelW, $PanelH)
    $MetroidExampleFill[$i].Location = New-Object Drawing.Point(2, 2)
    $MetroidExampleFill[$i].BackColor = '#e0e0e0'

    # Add the border to the groupbox, the fill to the border, and the image to the fill.
    $MetroidGroupBox[$i].Controls.Add($MetroidExampleBorder[$i])
    $MetroidExampleBorder[$i].Controls.Add($MetroidExampleFill[$i])
    $MetroidExampleFill[$i].Controls.Add($MetroidExampleImage[$i])
  }
  # Right image is the preview image.
  elseif ($Position -eq 'Right')
  {
    # Create a picturebox to hold the image.
    $global:MetroidPreviewImage[$i] = New-Object Windows.Forms.PictureBox
    $MetroidPreviewImage[$i].Size = New-Object Drawing.Size($ImageWidth, $ImageHeight)
    $MetroidPreviewImage[$i].Location = New-Object Drawing.Point(2, 2)
    $MetroidPreviewImage[$i].Image = $MetroidImage
    $MetroidPreviewImage[$i].Name = $Index
    $MetroidPreviewImage[$i].AllowDrop = $true
    $MetroidPreviewImage[$i].Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
    $MetroidPreviewImage[$i].Add_DragDrop({ LoadMetroidBase_DragAndDrop })

    # Create a panel to serve as the picturebox border.
    $BorderW = $MetroidPreviewImage[$i].Size.Width + 4
    $BorderH = $MetroidPreviewImage[$i].Size.Height + 4
    $global:MetroidPreviewBorder[$i] = New-Object Windows.Forms.Panel
    $MetroidPreviewBorder[$i].Size = New-Object Drawing.Size($BorderW, $BorderH)
    $MetroidPreviewBorder[$i].Location = New-Object Drawing.Point($X, $Y)
    $MetroidPreviewBorder[$i].BackColor = '#7a7a7a'

    # Create a panel to serve as the picturebox background.
    $PanelW = $MetroidPreviewImage[$i].Size.Width
    $PanelH = $MetroidPreviewImage[$i].Size.Height
    $global:MetroidPreviewFill[$i] = New-Object Windows.Forms.Panel
    $MetroidPreviewFill[$i].Size = New-Object Drawing.Size($PanelW, $PanelH)
    $MetroidPreviewFill[$i].Location = New-Object Drawing.Point(2, 2)
    $MetroidPreviewFill[$i].BackColor = '#e0e0e0'

    # Add the border to the groupbox, the fill to the border, and the image to the fill.
    $MetroidGroupBox[$i].Controls.Add($MetroidPreviewBorder[$i])
    $MetroidPreviewBorder[$i].Controls.Add($MetroidPreviewFill[$i])
    $MetroidPreviewFill[$i].Controls.Add($MetroidPreviewImage[$i])
  }
}
#==============================================================================================================================================================================================
#  Creates a hashtable array to hold various properties.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetMetroidPreviewDatabase()
{
  # Create the hashtable object.
  $M = New-Object hashtable[] $MP2MD5HashA.Count

  # Can't do much without first initializing it.
  for ($i = 0 ; $i -lt $M.Count ; $i++) { $M[$i] = @{} }

  # While this is unsightly, store an array of values that define everything we need for the buttons/previews.
  $M[0].GbWidth  = 330 ; $M[0].GbHeight  = 256 ; $M[0].GbXOffset  = 10  ; $M[0].PbWidth  = 128 ; $M[0].PbHeight  = 160 ; $M[0].PbIndex  = 97 ; $M[0].FCSize  = 107 ; $M[0].ExtraXOffset  = 0
  $M[1].GbWidth  = 330 ; $M[1].GbHeight  = 256 ; $M[1].GbXOffset  = 360 ; $M[1].PbWidth  = 128 ; $M[1].PbHeight  = 160 ; $M[1].PbIndex  = 97 ; $M[1].FCSize  = 128 ; $M[1].ExtraXOffset  = 0
  $M[2].GbWidth  = 330 ; $M[2].GbHeight  = 256 ; $M[2].GbXOffset  = 10  ; $M[2].PbWidth  = 128 ; $M[2].PbHeight  = 160 ; $M[2].PbIndex  = 97 ; $M[2].FCSize  = 107 ; $M[2].ExtraXOffset  = 0
  $M[3].GbWidth  = 330 ; $M[3].GbHeight  = 256 ; $M[3].GbXOffset  = 360 ; $M[3].PbWidth  = 128 ; $M[3].PbHeight  = 160 ; $M[3].PbIndex  = 97 ; $M[3].FCSize  = 128 ; $M[3].ExtraXOffset  = 0
  $M[4].GbWidth  = 330 ; $M[4].GbHeight  = 256 ; $M[4].GbXOffset  = 10  ; $M[4].PbWidth  = 128 ; $M[4].PbHeight  = 160 ; $M[4].PbIndex  = 97 ; $M[4].FCSize  = 107 ; $M[4].ExtraXOffset  = 0
  $M[5].GbWidth  = 330 ; $M[5].GbHeight  = 256 ; $M[5].GbXOffset  = 360 ; $M[5].PbWidth  = 128 ; $M[5].PbHeight  = 160 ; $M[5].PbIndex  = 97 ; $M[5].FCSize  = 128 ; $M[5].ExtraXOffset  = 0
  $M[6].GbWidth  = 330 ; $M[6].GbHeight  = 256 ; $M[6].GbXOffset  = 10  ; $M[6].PbWidth  = 128 ; $M[6].PbHeight  = 160 ; $M[6].PbIndex  = 97 ; $M[6].FCSize  = 107 ; $M[6].ExtraXOffset  = 0
  $M[7].GbWidth  = 330 ; $M[7].GbHeight  = 256 ; $M[7].GbXOffset  = 360 ; $M[7].PbWidth  = 128 ; $M[7].PbHeight  = 160 ; $M[7].PbIndex  = 97 ; $M[7].FCSize  = 128 ; $M[7].ExtraXOffset  = 0
  $M[8].GbWidth  = 680 ; $M[8].GbHeight  = 320 ; $M[8].GbXOffset  = 10  ; $M[8].PbWidth  = 240 ; $M[8].PbHeight  = 224 ; $M[8].PbIndex  = 98 ; $M[8].FCSize  = 107 ; $M[8].ExtraXOffset  = 80
  $M[9].GbWidth  = 680 ; $M[9].GbHeight  = 320 ; $M[9].GbXOffset  = 10  ; $M[9].PbWidth  = 240 ; $M[9].PbHeight  = 224 ; $M[9].PbIndex  = 98 ; $M[9].FCSize  = 128 ; $M[9].ExtraXOffset  = 80
  $M[10].GbWidth = 680 ; $M[10].GbHeight = 320 ; $M[10].GbXOffset = 10  ; $M[10].PbWidth = 240 ; $M[10].PbHeight = 224 ; $M[10].PbIndex = 98 ; $M[10].FCSize = 107 ; $M[10].ExtraXOffset = 80
  $M[11].GbWidth = 680 ; $M[11].GbHeight = 320 ; $M[11].GbXOffset = 10  ; $M[11].PbWidth = 240 ; $M[11].PbHeight = 224 ; $M[11].PbIndex = 98 ; $M[11].FCSize = 128 ; $M[11].ExtraXOffset = 80
  $M[12].GbWidth = 680 ; $M[12].GbHeight = 352 ; $M[12].GbXOffset = 10  ; $M[12].PbWidth = 208 ; $M[12].PbHeight = 256 ; $M[12].PbIndex = 99 ; $M[12].FCSize = 70  ; $M[12].ExtraXOffset = 110
  $M[13].GbWidth = 680 ; $M[13].GbHeight = 352 ; $M[13].GbXOffset = 10  ; $M[13].PbWidth = 208 ; $M[13].PbHeight = 256 ; $M[13].PbIndex = 99 ; $M[13].FCSize = 70  ; $M[13].ExtraXOffset = 110

  # The data was running off the screen, so continue setting up the string portion of it here.
  $M[0].FTitle  = 'Main Font 01-A'   ; $M[0].FConsole  = 'Console: Gamecube'     ; $M[0].FRegion  = 'Region: NTSC'           
  $M[1].FTitle  = 'Main Font 01-B'   ; $M[1].FConsole  = 'Console: Gamecube/Wii' ; $M[1].FRegion  = 'Region: PAL/NTSC(Wii)' 
  $M[2].FTitle  = 'Main Font 02-A'   ; $M[2].FConsole  = 'Console: Gamecube'     ; $M[2].FRegion  = 'Region: NTSC'
  $M[3].FTitle  = 'Main Font 02-B'   ; $M[3].FConsole  = 'Console: Gamecube/Wii' ; $M[3].FRegion  = 'Region: PAL/NTSC(Wii)'
  $M[4].FTitle  = 'Main Font 03-A'   ; $M[4].FConsole  = 'Console: Gamecube'     ; $M[4].FRegion  = 'Region: NTSC'  
  $M[5].FTitle  = 'Main Font 03-B'   ; $M[5].FConsole  = 'Console: Gamecube/Wii' ; $M[5].FRegion  = 'Region: PAL/NTSC(Wii)'
  $M[6].FTitle  = 'Main Font 04-A'   ; $M[6].FConsole  = 'Console: Gamecube'     ; $M[6].FRegion  = 'Region: NTSC' 
  $M[7].FTitle  = 'Main Font 04-B'   ; $M[7].FConsole  = 'Console: Gamecube/Wii' ; $M[7].FRegion  = 'Region: PAL/NTSC(Wii)'
  $M[8].FTitle  = 'Ammo Font 01-A'   ; $M[8].FConsole  = 'Console: Gamecube'     ; $M[8].FRegion  = 'Region: NTSC'   
  $M[9].FTitle  = 'Ammo Font 01-B'   ; $M[9].FConsole  = 'Console: Gamecube/Wii' ; $M[9].FRegion  = 'Region: PAL'    
  $M[10].FTitle = 'Ammo Font 02-A'   ; $M[10].FConsole = 'Console: Gamecube'     ; $M[10].FRegion = 'Region: NTSC'  
  $M[11].FTitle = 'Ammo Font 02-B'   ; $M[11].FConsole = 'Console: Gamecube/Wii' ; $M[11].FRegion = 'Region: PAL'      
  $M[12].FTitle = 'Ammo Font Wii-01' ; $M[12].FConsole = 'Console: Wii'          ; $M[12].FRegion = 'Region: NTSC' 
  $M[13].FTitle = 'Ammo Font Wii-02' ; $M[13].FConsole = 'Console: Wii'          ; $M[13].FRegion = 'Region: NTSC' 

  # Return the hashtable so we can actually use it.
  return $M
}
#==============================================================================================================================================================================================
#  Create the window for the watermark preview using the universal dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_MetroidPreview()
{
  # Create the dialog and set up properties.
  $global:MetroidDialog = New-Object Windows.Forms.Form
  $MetroidDialog.Size = DPISize (New-Object Drawing.Size(740, 880))
  $MetroidDialog.MinimumSize = DPISize (New-Object Drawing.Size(740, 880))
  $MetroidDialog.MaximumSize = DPISize (New-Object Drawing.Size(740, 880))
  $MetroidDialog.Text = 'Metroid Prime 2: Font Texture Selection'
  $MetroidDialog.MinimizeBox = $true
  $MetroidDialog.MaximizeBox = $false
  $MetroidDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $MetroidDialog.FormBorderStyle = [Windows.Forms.FormBorderStyle]::Sizable
  $MetroidDialog.StartPosition = "CenterScreen"
  $MetroidDialog.Topmost = !$DisableTopMost
  $MetroidDialog.KeyPreview = $true
  $MetroidDialog.Add_KeyDown({ EscapeCloseDialog })
  $MetroidDialog.Add_FormClosing({ $MetroidDialog.Hide() ; $_.Cancel = $true })
  $MetroidDialog.Icon = $Icon_CTTPSGreen

  # Create a panel to serve as the picturebox border.
  $MetroidMainPanel = New-Object Windows.Forms.Panel
  $MetroidMainPanel.Size = DPISize (New-Object Drawing.Size(720, 800))
  $MetroidMainPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $MetroidMainPanel.AutoScroll = $true
  $MetroidMainPanel.Anchor = ([Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Top, [Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Right)
  $MetroidDialog.Controls.Add($MetroidMainPanel)

  # The number of images that have an example picture on the GUI.
  $ImageCount = $MP2MD5HashA.Count

  # To keep track of these, create them now and update their values in the loop.
  $global:MetroidGroupBox      = New-Object Windows.Forms.GroupBox[]   $ImageCount
  $global:MetroidConsoleLabel  = New-Object Windows.Forms.Label[]      $ImageCount
  $global:MetroidRegionLabel   = New-Object Windows.Forms.Label[]      $ImageCount
  $global:MetroidCompareLabel  = New-Object Windows.Forms.Label[]      $ImageCount
  $global:MetroidTextBox       = New-Object Windows.Forms.TextBox[]    $ImageCount
  $global:MetroidButton        = New-Object Windows.Forms.Button[]     $ImageCount
  $global:MetroidExampleImage  = New-Object Windows.Forms.PictureBox[] $ImageCount
  $global:MetroidExampleBorder = New-Object Windows.Forms.Panel[]      $ImageCount
  $global:MetroidExampleFill   = New-Object Windows.Forms.Panel[]      $ImageCount
  $global:MetroidPreviewImage  = New-Object Windows.Forms.PictureBox[] $ImageCount
  $global:MetroidPreviewBorder = New-Object Windows.Forms.Panel[]      $ImageCount
  $global:MetroidPreviewFill   = New-Object Windows.Forms.Panel[]      $ImageCount

  # Get the necessary data to set up the previews.
  $Metroid = GetMetroidPreviewDatabase

  # Set the initial "Y" offset, which is updated at the end of the loop.
  $YOffset = DPISize 10

  # Loop through all the texture indexes.
  for ($i = 0 ; $i -lt $ImageCount ; $i++)
  {
    # Create a groupbox to hold the new values.
    $MetroidGroupBox[$i] = New-Object Windows.Forms.GroupBox
    $MetroidGroupBox[$i].Size = DPISize (New-Object Drawing.Size($Metroid[$i].GbWidth, $Metroid[$i].GbHeight))
    $MetroidGroupBox[$i].Location = New-Object Drawing.Point((DPISize $Metroid[$i].GbXOffset), $YOffset)
    $MetroidGroupBox[$i].Text = $Metroid[$i].FTitle
    $MetroidGroupBox[$i].Name = $i
    $MetroidMainPanel.Controls.Add($MetroidGroupBox[$i])

    # Create a picturebox with the current image and another with a drag and drop image.
    CreateMetroidPictureBox -Position 'Left'  -Index $i -PbIndex $Metroid[$i].PbIndex -Width $Metroid[$i].PbWidth -Height $Metroid[$i].PbHeight -X ((DPISize 16) + (DPISize $Metroid[$i].ExtraXOffset)) -Y (DPISize 48)
    CreateMetroidPictureBox -Position 'Right' -Index $i -PbIndex $Metroid[$i].PbIndex -Width $Metroid[$i].PbWidth -Height $Metroid[$i].PbHeight -X ($MetroidExampleBorder[$i].Right + (DPISize 40)) -Y (DPISize 48)

    # Create a label to display the console the texture comes from.
    $CLabelLocX = $MetroidExampleBorder[$i].Right - (DPISize $Metroid[$i].FCSize)
    $CLabelLocY = DPISize 22
    $MetroidConsoleLabel[$i] = New-Object Windows.Forms.Label
    $MetroidConsoleLabel[$i].Size = DPISize (New-Object Drawing.Size($Metroid[$i].FCSize, 16))
    $MetroidConsoleLabel[$i].Location = New-Object Drawing.Point($CLabelLocX, $CLabelLocY)
    $MetroidConsoleLabel[$i].Text = $Metroid[$i].FConsole
    $MetroidGroupBox[$i].Controls.Add($MetroidConsoleLabel[$i])

    # Create a label to display the region the texture comes from.
    $RLabelLocX = $MetroidPreviewBorder[$i].Left + (DPISize 6)
    $RLabelLocY = DPISize 22
    $MetroidRegionLabel[$i] = New-Object Windows.Forms.Label
    $MetroidRegionLabel[$i].Size = DPISize (New-Object Drawing.Size(130, 16))
    $MetroidRegionLabel[$i].Location = New-Object Drawing.Point($RLabelLocX, $RLabelLocY)
    $MetroidRegionLabel[$i].Text = $Metroid[$i].FRegion
    $MetroidGroupBox[$i].Controls.Add($MetroidRegionLabel[$i])

    # Create an arrow to point to the next image.
    $LabelLocX = $MetroidExampleBorder[$i].Right + 4
    $LabelLocY = $MetroidExampleBorder[$i].Bottom / 2
    $MetroidCompareLabel[$i] = New-Object Windows.Forms.Label
    $MetroidCompareLabel[$i].Size = DPISize (New-Object Drawing.Size(30, 40))
    $MetroidCompareLabel[$i].Location = New-Object Drawing.Point($LabelLocX, $LabelLocY)
    $MetroidCompareLabel[$i].Font = New-Object Drawing.Font('Courier New', 30, [Drawing.FontStyle]::Bold)
    $MetroidCompareLabel[$i].Name = $i
    $MetroidCompareLabel[$i].Text = '>'
    $MetroidGroupBox[$i].Controls.Add($MetroidCompareLabel[$i])

    # Create a textbox to show the path to the base texture.
    $TextBoxLocX = $MetroidExampleBorder[$i].Left + $Metroid[$i].ExtraXOffset
    $TextBoxLocY = $MetroidExampleBorder[$i].Bottom + (DPISize 14)
    $MetroidTextBox[$i] = New-Object Windows.Forms.TextBox
    $MetroidTextBox[$i].Size = DPISize (New-Object Drawing.Size(280, 22))
    $MetroidTextBox[$i].Location = New-Object Drawing.Point($TextBoxLocX, $TextBoxLocY)
    $MetroidTextBox[$i].Name = $i
    $MetroidTextBox[$i].Text = $MetroidBase[$i]
    $MetroidTextBox[$i].AllowDrop = $true
    $MetroidTextBox[$i].Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
    $MetroidTextBox[$i].Add_DragDrop({ LoadMetroidBase_DragAndDrop })
    $MetroidTextBox[$i].Add_Leave({ LoadMetroidBase_TextBox })
    $MetroidGroupBox[$i].Controls.Add($MetroidTextBox[$i])

    # Create a button to update the path.
    $ButtonLocX = $MetroidTextBox[$i].Right + 8
    $ButtonLocY = $MetroidExampleBorder[$i].Bottom + (DPISize 12)
    $MetroidButton[$i] = New-Object Windows.Forms.Button
    $MetroidButton[$i].Size = DPISize (New-Object Drawing.Size(22, 22))
    $MetroidButton[$i].Location = New-Object Drawing.Point($ButtonLocX, $ButtonLocY)
    $MetroidButton[$i].Name = $i
    $MetroidButton[$i].Text = '...'
    $MetroidButton[$i].Add_Click({ LoadMetroidBase_Button })
    $MetroidGroupBox[$i].Controls.Add($MetroidButton[$i])

    # To stack the first eight groupboxes into 2 rows, increasing the Y offset needs to be skipped.
    if (($i -ne 0) -and ($i -ne 2) -and ($i -ne 4) -and ($i -ne 6))
    {
      # During most loops, the Y offset is set.
      $YOffset = $MetroidGroupBox[$i].Bottom + (DPISize 12)
    }
  }
  # Create a button to select the left color.
  $global:MetroidColorButtonL = New-Object Windows.Forms.Button
  $MetroidColorButtonL.Size = DPISize (New-Object Drawing.Size(30, 30))
  $MetroidColorButtonL.Location = DPISize (New-Object Drawing.Point(12, 806))
  $MetroidColorButtonL.BackColor = '#e0e0e0'
  $MetroidColorButtonL.Add_Click({ MetroidFontBackgroundColor -Background $MetroidExampleFill })
  $MetroidDialog.Controls.Add($MetroidColorButtonL)

  # Create a button to select the right color.
  $global:MetroidColorButtonR = New-Object Windows.Forms.Button
  $MetroidColorButtonR.Size = DPISize (New-Object Drawing.Size(30, 30))
  $MetroidColorButtonR.Location = DPISize (New-Object Drawing.Point(46, 806))
  $MetroidColorButtonR.BackColor = '#e0e0e0'
  $MetroidColorButtonR.Add_Click({ MetroidFontBackgroundColor -Background $MetroidPreviewFill })
  $MetroidDialog.Controls.Add($MetroidColorButtonR)

  # Create a label to show what the buttons actually do.
  $global:MetroidColorLabel = New-Object Windows.Forms.Label
  $MetroidColorLabel.Size = DPISize (New-Object Drawing.Size(150, 20))
  $MetroidColorLabel.Location = DPISize (New-Object Drawing.Point(80, 816))
  $MetroidColorLabel.Text = 'Preview Background Color'
  $MetroidDialog.Controls.Add($MetroidColorLabel)

  # Create a button to close the window.
  $global:MetroidOkayButton = New-Object Windows.Forms.Button
  $MetroidOkayButton.Size = DPISize (New-Object Drawing.Size(100, 30))
  $MetroidOkayButton.Location = DPISize (New-Object Drawing.Point(614, 806))
  $MetroidOkayButton.Text = 'Accept'
  $MetroidOkayButton.Add_Click({ MetroidStoreBaseImages ; $MetroidDialog.Hide() })
  $MetroidDialog.Controls.Add($MetroidOkayButton)
  $MetroidDialog.AcceptButton = $MetroidOkayButton

  # Put focus on the button for no reason other than convenience.
  $MetroidOkayButton.Focus()
}
#==============================================================================================================================================================================================
#  CTT GUI: CREATE IDENTIFYING WATERMARK ON TEXTURES - WATERMARK PREVIEW WINDOW
#==============================================================================================================================================================================================
#  Create the window for the watermark preview.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_WatermarkPreview()
{
  # Create the dialog and set up properties.
  $global:WatermarkDialog = New-Object Windows.Forms.Form
  $WatermarkDialog.Size = DPISize (New-Object Drawing.Size(274, 324))
  $WatermarkDialog.MinimumSize = DPISize (New-Object Drawing.Size(274, 324))
  $WatermarkDialog.MaximumSize = DPISize (New-Object Drawing.Size(274, 324))
  $WatermarkDialog.Text = 'Watermark Preview'
  $WatermarkDialog.MinimizeBox = $false
  $WatermarkDialog.MaximizeBox = $false
  $WatermarkDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $WatermarkDialog.FormBorderStyle = GetFormBorderStyle
  $WatermarkDialog.StartPosition = "CenterScreen"
  $WatermarkDialog.Topmost = !$DisableTopMost
  $WatermarkDialog.KeyPreview = $true
  $WatermarkDialog.Add_KeyDown({ EscapeCloseDialog })
  $WatermarkDialog.Add_FormClosing({ $WatermarkDialog.Hide() ; $_.Cancel = $true })
  $WatermarkDialog.Icon = $Icon_CTTPSGreen

  # Create a panel to hold all the shit.
  $global:WatermarkPreviewPanel = New-Object Windows.Forms.Panel
  $WatermarkPreviewPanel.Size = DPISize (New-Object Drawing.Size(258, 258))
  $WatermarkPreviewPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $WatermarkDialog.Controls.Add($WatermarkPreviewPanel)

  # Create a picturebox to hold the image.
  $global:WatermarkPreviewImage = New-Object Windows.Forms.PictureBox
  $WatermarkPreviewImage.Size = DPISize (New-Object Drawing.Size(256, 256))
  $WatermarkPreviewImage.Location = DPISize (New-Object Drawing.Point(1, 1))
  $WatermarkPreviewPanel.Controls.Add($WatermarkPreviewImage)

  # Create a button to close the window.
  $global:WatermarkButton = New-Object Windows.Forms.Button
  $WatermarkButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $WatermarkButton.Location = DPISize (New-Object Drawing.Point(178, 257))
  $WatermarkButton.Text = 'Close'
  $WatermarkButton.Add_Click({ $WatermarkDialog.Hide() })
  $WatermarkDialog.Controls.Add($WatermarkButton)
  $WatermarkDialog.AcceptButton = $WatermarkButton
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - CREATE OPERATION GROUPS
#==============================================================================================================================================================================================
#  Toggles the visibility of the icon size options when converting textures to another format.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleIconSizeVisibility([string]$SelectedItem)
{
  # Set the visibility of the icon option.
  $ConvertIconSizeLabel.Visible   = ($SelectedItem -eq 'ICO')
  $ConvertIconSizeTextBox.Visible = ($SelectedItem -eq 'ICO')
  $ConvertIconSizeButton.Visible  = ($SelectedItem -eq 'ICO')

  # The icon format was selected.
  if ((($CTTPSSelectedMode -eq 'Expert Mode') -or ($CTTPSSelectedMode -eq 'Database Mode')) -and ($SelectedItem -eq 'ICO'))
  {
    # Scrunch these options together a bit to make room for it.
    $ConvertCopyNonTex.Location     = DPISize (New-Object Drawing.Point(10, 46))
    $ConvertEnableSharpen.Location  = DPISize (New-Object Drawing.Point(10, 66))
  }
  # Another format was selected.
  else
  {
    # Instead of having a bunch of empty space, spread the options out a bit.
    $ConvertCopyNonTex.Location     = DPISize (New-Object Drawing.Point(10, 50))
    $ConvertEnableSharpen.Location  = DPISize (New-Object Drawing.Point(10, 74))
  }
}
#==============================================================================================================================================================================================
#  Returns a list of default icon size values.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetDefaultIconList()
{
  # A list of default icon size values.
  $DefaultList = New-Object Collections.Generic.List[string]

  # Populate the list with default values.
  $DefaultList.Add("16")
  $DefaultList.Add("24")
  $DefaultList.Add("32")
  $DefaultList.Add("48")
  $DefaultList.Add("64")
  $DefaultList.Add("128")
  $DefaultList.Add("256")

  # Return the list.
  return $DefaultList
}
#==============================================================================================================================================================================================
#  Only allows numeric values from 1-256 to be entered for icon sizes.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateAcceptedScalesTextBox()
{
  # Create a newly curated list to avoid user error.
  $NewList = New-Object Collections.Generic.List[string]

  # Split the string by its commas.
  $SplitComma = $this.Text.Split(',')

  # Loop through each value that was split.
  foreach ($Value in $SplitComma)
  {
    # Trim any spaces from the value.
    $Value = $Value.Trim()

    # Check to see if the value is an integer.
    if (($Value -as [int] -is [int]) -and ($Value -as [int] -gt 0) -and ($NewList -notcontains $Value -as [int]))
    {
      # Add the value to the curated list.
      $NewList.Add($Value)
    }
    # If there was nothing but invalid values.
    if ($NewList.Count -eq 0)
    {
      # Reset the textbox.
      $this.Text = ""

      # Reset the accepted scales.
      $global:AcceptedScales = ""

      # We are done here.
      return
    }    
  }
  # Add the first value in the list.
  $global:AcceptedScales = $NewList[0]

  # Add the rest of the values to the list separated by commas.
  for ($i = 1 ; $i -lt $NewList.Count ; $i++)
  {
    # For some reason empty values get by the int check.
    if (($NewList[$i] -eq '') -or ($NewList[$i] -eq $null)) { continue }

    # Add a comma to the string followed by the next value.
    $global:AcceptedScales += ','
    $global:AcceptedScales += $NewList[$i]
  }
  # Update the textbox with the new values.
  $this.Text = $AcceptedScales
}
#==============================================================================================================================================================================================
#  Sets the name of the database file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetDatabaseNameTextBox()
{
  # Get the text from this textbox and remove any illegal characters.
  $DatabaseTemp = RemoveIllegalCharacters -Value $this.Text.Replace(' ','_')

  # Add the extension if not present.
  if ($DatabaseTemp -notlike '*.tdb') { $DatabaseTemp += ".tdb" }

  # Update the value of the variables.
  $global:DatabaseName = $DatabaseTemp
  $global:DatabaseFile = $DatabasePath + '\' + $DatabaseName

  # Update the textbox text.
  $this.Text = $DatabaseName
}
#==============================================================================================================================================================================================
#  Sets the name of the database file by selecting a file.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetDatabaseNameButton()
{
  # Allow selecting a file to get the name of it.
  $DatabaseTempA = Get-FileName -StartPath $DatabasePath -FileName '*.tdb' -Description "Texture Tool Database"

  # Cancel doing anything if the user just closed the window.
  if (!$DatabaseTempA) { return }

  # We need the name of the file.
  $DatabaseTempB = (Get-Item -LiteralPath $DatabaseTempA).Name

  # Update the value of the variable.
  $global:DatabaseName = $DatabaseTempB
  $global:DatabaseFile = $DatabasePath + '\' + $DatabaseName

  # Update the textbox text.
  $DatabaseNameTextBox.Text = $DatabaseName
}
#==============================================================================================================================================================================================
#  Only allows numeric values from 1-256 to be entered for icon sizes.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateIconSizesTextBox()
{
  # If the string is empty, then use the default values.
  if ($this.Text -eq "")
  {
    # Get a list that contains default icon sizes.
    $NewList = GetDefaultIconList
  }
  # Otherwise do everything that needs to be done.
  else
  {
    # Create a newly curated list to avoid user error.
    $NewList = New-Object Collections.Generic.List[string]
    
    # Split the string by its commas.
    $SplitComma = $this.Text.Split(',')

    # Loop through each value that was split.
    foreach ($Value in $SplitComma)
    {
      # Trim any spaces from the value.
      $Value = $Value.Trim()

      # Check to see if the value is an integer.
      if (($Value -as [int] -is [int]) -and ($Value -as [int] -gt 0) -and ($Value -as [int] -le 256))
      {
        # Add the value to the curated list.
        $NewList.Add($Value)
      }
    }
    # If there was nothing but invalid values, repopulate list with default values.
    if ($NewList.Count -eq 0)
    {
      # Get a list that contains default icon sizes.
      $NewList = GetDefaultIconList
    }    
  }
  # Add the first value in the list.
  $global:ConvertIconSizes = $NewList[0]

  # Add the rest of the values to the list separated by commas.
  for ($i = 1 ; $i -lt $NewList.Count ; $i++)
  {
    # For some reason empty values get by the int check.
    if (($NewList[$i] -eq '') -or ($NewList[$i] -eq $null)) { continue }

    # Add a comma to the string followed by the next value.
    $global:ConvertIconSizes += ','
    $global:ConvertIconSizes += $NewList[$i]
  }
  # Update the textbox with the new values.
  $this.Text = $ConvertIconSizes
}
#==============================================================================================================================================================================================
#  Resets the icons on the textbox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ResetIconSizesTextBox()
{
  # Update the textbox with the new values.
  $ConvertIconSizeTextBox.Text = ""
  $global:ConvertIconSizes = ""

  # Get a list that contains default icon sizes.
  $NewList = GetDefaultIconList

  # Add the first value in the list.
  $global:ConvertIconSizes = $NewList[0]

  # Add the values to the list separated by commas.
  for ($i = 1 ; $i -lt $NewList.Count ; $i++)
  {
    # Add a comma to the string followed by the next value.
    $global:ConvertIconSizes += ','
    $global:ConvertIconSizes += $NewList[$i]
  }
  # Update the textbox with the new values.
  $ConvertIconSizeTextBox.Text = $ConvertIconSizes
}
#==============================================================================================================================================================================================
#  Toggles the state of the format for Material Map Generator.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleIshiirukaFormatCombo()
{
  # Toggle both the combobox and the label.
  $MaterialsFormatCombo.Enabled = $this.Checked
  $MaterialsFormatLabel.Enabled = $this.Checked

  # Update the variable with the new value that was fed to the parameter.
  Set-Variable -Name $this.Name -Value $this.Checked -Scope 'Global'
}
#==============================================================================================================================================================================================
#  When the combobox is changed for either Material Map Generator or Ishiiruka Tool, update the other.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateIshiirukaFormat()
{
  # The combobox from Material Map generator was changed.
  if ($this -eq $MaterialsFormatCombo)
  {
    # Change the Ishiiruka Tool combobox.
    $MaterialFormatCombo.SelectedItem = ExtensionToText -Extension $IshiirukaFormat
  }
  # The combobox from Create Material Maps with Ishiiruka Tool was changed.
  else
  {
    # Change the Material Map Generator combobox.
    $MaterialsFormatCombo.SelectedItem = ExtensionToText -Extension $IshiirukaFormat
  }
}
#==============================================================================================================================================================================================
#  Checks to make sure that everything is installed to create material with Material Map Generator.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckMaterialDependencies()
{
  # Disable all dialog states.
  ToggleDialogStates -State $false

  # Store if the user has the PS console enabled.
  $ConsoleEnabled = $EnableThePSConsole

  # Show the console. Python will force the PS console black, so make it black now for consistency.
  $Host.UI.RawUI.BackgroundColor = 'Black'
  ShowPowerShellConsole -ShowConsole $true

  # Show me some messages.
  Clear-Host
  Write-Host '-----------------------------------------------------------------------------'
  Write-Host (' Material Map Generator Python Modules Check/Install')
  Write-Host '-----------------------------------------------------------------------------'
  Write-Host ' Checking for Material Map Generator...' -NoNewLine

  # The full path to the material map generation script.
  $TestMatMapPath = $MatMapGenPath + '\generate.py'

  # First and foremost we need the material map generator.
  if (TestPath -LiteralPath $TestMatMapPath)
  {
    # Add this to the above line.
    Write-Host '    Found'

    # Let the user see we want python.
    Write-Host ' Checking for Python Installation...' -NoNewLine

    # And of course we need python.
    if (TestPath -LiteralPath $Python)
    {
      # Add this to the above line.
      Write-Host '       Found'

      # Track if we updated anything.
      $StuffHappened = $false

      # Update pip because why not.
      PythonUpdatePip

      # Get a list of all modules installed.
      $InstallList = PythonGetModules

      # Create an empty list to store cropped versions of the modules.
      $NewList = New-Object Collections.Generic.List[string]

      # The first two lines are garbage, but loop through all lines after them.
      for ($i = 2 ; $i -lt $InstallList.Count ; $i++)
      {
        # The module contains the version, we only want the name so split on the first space.
        $SplitModule = $InstallList[$i].Split(' ', 2)

        # Now grab only the name and add it to the list.
        $NewList.Add($SplitModule[0])
      }
      # Show some information on the PS console.
      Write-Host ' Checking for opencv-python and numpy...' -NoNewLine

      # Check to see if OpenCV is installed.
      if (($NewList -notcontains 'numpy') -or ($NewList -notcontains 'opencv-python'))
      {
        # Show some information on the PS Console.
        Write-Host ' Missing'
        Write-Host ' '
        Write-Host ' Downloading and installing OpenCV...' 
        Write-Host ' '

        # Install OpenCV for python using pip.
        PythonInstallModules -Modules @('numpy','opencv-python')

        # Remember that stuff happened.
        $StuffHappened = $true
      }
      # If it was found then just attach that to the end.
      else { Write-Host '   Found' }

      # Show some information on the PS Console.
      Write-Host ' Checking for pytorch...' -NoNewLine

      # Check to see if pytorch is installed.
      if ($NewList -notcontains 'torch')
      {
        # Show some information on the PS Console.
        Write-Host ' Missing'
        Write-Host ' '
        Write-Host ' Downloading and installing PyTorch...'
        Write-Host ' This could take several minutes to an hour. Please be patient!'
        Write-Host ' '

        # Download and install PyTorch.
        PythonInstallTorch

        # Remember that stuff happened.
        $StuffHappened = $true
      }
      # If it was found then just attach that to the end.
      else { Write-Host '                   Found' }

      # Show some information on the PS Console.
      Write-Host ' Checking for Ishiiruka Tool...' -NoNewLine

      # Finally check to see if Ishiiruka Tool is installed.
      if (TestPath -LiteralPath $IshiirukaTool) { Write-Host '            Found' }
      else { Write-Host '            Missing' }

      # Let us know if anything happened.
      if ($StuffHappened)
      {
        Write-Host '-----------------------------------------------------------------------------'
        Write-Host ' '
        Write-Host ' Missing dependencies have been installed. '
        if (!(TestPath -LiteralPath $IshiirukaTool))
        {
          Write-Host " Ishiiruka Tool is not required to generate"
          Write-Host ' materials, but you will be unable to generate directly to material maps. '
        }
        $Title   = 'Dependencies Installed'
        $Message = 'Some of the missing dependencies have been installed. The Material Map Generator should now be good to go!'
        ShowOKDialog -Title $Title -SizeX (DPISize 290) -SizeY (DPISize 30) -OffsetX (DPISize 10) -OffsetY (DPISize 12) -Message $Message
      }
      # If everything was found then awesome!
      else
      {
        Write-Host '-----------------------------------------------------------------------------'
        Write-Host ' '
        Write-Host ' All dependencies have been located. ' -NoNewLine
        if (!(TestPath -LiteralPath $IshiirukaTool))
        {
          Write-Host " Ishiiruka Tool is not required to generate"
          Write-Host ' materials, but you will be unable to generate directly to material maps. '
        }
        $Title   = 'Dependencies OK'
        $Message = 'Python and all of its dependencies have been located. The Material Map Generator should be good to go!'
        ShowOKDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 14) -OffsetY (DPISize 12) -Message $Message 
      }
    }
    # If Python wasn't found then warn the user.
    else
    {
      Write-Host ' Missing'
      $Title   = 'Warning: Python Not Found'
      $Message = 'Python v3.9.x could not be found. This is required to create materials with Material Map Generator.'
      ShowOKDialog -Title $Title -SizeX (DPISize 280) -SizeY (DPISize 30) -OffsetX (DPISize 24) -OffsetY (DPISize 12) -Message $Message 
    }
  }
  # If the script itself wasn't found then show this error message.
  else
  {
    Write-Host ' Missing'
    $Title   = 'Warning: Material Generator Not Found'
    $Message = 'Material Generator could not be found. This is required to create materials, so go download it!'
    ShowOKDialog -Title $Title -SizeX (DPISize 260) -SizeY (DPISize 30) -OffsetX (DPISize 30) -OffsetY (DPISize 12) -Message $Message 
  }
  # Hide the console if it was hidden before, and revert back to the "DarkMagenta" color.
  ShowPowerShellConsole -ShowConsole $ConsoleEnabled
  $Host.UI.RawUI.BackgroundColor = 'DarkMagenta'
  Clear-Host

  # Enable all dialog states.
  ToggleDialogStates -State $true
}
#==============================================================================================================================================================================================
#  Populates the ESRGAN and SFTGAN models lists.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateSuperScalerModels_AddLoop([string]$ModelPath, [Windows.Forms.ComboBox]$ComboBox, [string]$SelectedItem)
{
  # Make sure the path actually exists.
  if (TestPath -LiteralPath $ModelPath)
  {
    # Loop through all files in the path.
    foreach ($Model in EnumerateFiles -LiteralPath $ModelPath)
    {
      # Get the model as an item so we can get properties.
      $ModelItem = Get-Item -LiteralPath $Model
    
      # Start a list just in case I want to exclude more models later.
      $Exclude = @('segmentation_OST_bic')

      # Models have a ".pth" extension.
      if (($ModelItem.Extension -eq '.pth') -and ($Exclude -notcontains $ModelItem.BaseName))
      {
        # Add the model to the list.
        $ComboBox.Items.Add($ModelItem.BaseName) | Out-Null

        # Select the item that is stored.
        $ComboBox.SelectedItem = $SelectedItem
      }
    }
  }
}
#==============================================================================================================================================================================================
#  A launch point function for the above function which populates ESRGAN/SFTGAN models lists.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateSuperScalerModels()
{
  # Remove all current models from the lists.
  $OptionsESRGANModelCombo.Items.Clear() | Out-Null
  $OptionsSFTGANModelCombo.Items.Clear() | Out-Null

  # Cut down on code by providing a universal function.
  PopulateSuperScalerModels_AddLoop -ModelPath ($ESRGANBasePath + '\models') -ComboBox $OptionsESRGANModelCombo -SelectedItem $ESRGANModel
  PopulateSuperScalerModels_AddLoop -ModelPath ($SFTGANBasePath + '\pretrained_models') -ComboBox $OptionsSFTGANModelCombo -SelectedItem $SFTGANModel
}
#==============================================================================================================================================================================================
#  Handles when the "Additional Options" button is pressed on Waifu2x and ESRGAN/SFTGAN menus.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AdditionalOptionsButton()
{
  # Launch the proper menu or play the proper animation depending on the selected filter.
  switch -wildcard ($FilterSelected)
  {
    'Waifu2x' { ShowWaifu2xDialog }
    '*GAN'    { PopulateSuperScalerModels ; ShowESRGANDialog }
  }
}
#==============================================================================================================================================================================================
#  Generates a preview image of what the watermark will look like.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GenerateWatermarkPreview()
{
  # Set the preview size of the image based on the DPI.
  $PreviewSizeSmall = DPISize 68
  $PreviewSizeLarge = DPISize 256

  # Disable all dialog states so the user can't fuck anything up.
  ToggleDialogStates -State $false
  $WatermarkImageGroup.Enabled = $false

  # Create the folder to hold the preview image.
  $PreviewPath = CreatePath -LiteralPath ($TempFolder + '\WatermarkPreview')

  # Set the path to the base "black" texture.
  $PreviewFile = $PreviewPath + '\tex1_128x128_0123456789abcdef_10.png' 

  # Create the "black" texture with ImageMagick.
  $PreviewSize = $PreviewSizeLarge.ToString() + 'x' + $PreviewSizeLarge.ToString()
  Magick-Convert -Arguments @('-size', $PreviewSize, '-define', 'png:color-type=6', 'xc:#323232') -OutputFile $PreviewFile

  # Create information about the texture and set it to the global scope.
  $global:PreviewInfo = CreateTextureInfo -ImageFile $PreviewFile -Extended

  # Create the caption that will be applied to the base texture.
  $CaptionFile = CreateWatermarkCaption -TextureInfo $PreviewInfo -Width $PreviewInfo.Width -OutputPath $PreviewPath

  # Create the full path to the final image. 
  $FinalPreview = $PreviewPath + '\' + $PreviewInfo.Name + $PNG

  # Apply the caption to the texture using the composite command.
  Magick-Convert -ImageFile $PreviewFile -Arguments @('-define', 'png:color-type=6', $CaptionFile, '-gravity', 'center', '-composite') -OutputFile $FinalPreview

  # Generate the small version of the image.
  $ImgObject = [Drawing.Image]::FromFile($FinalPreview)
  $WatermarkSmallPreview = New-Object Drawing.Bitmap($ImgObject, $PreviewSizeSmall, $PreviewSizeSmall)
  $WatermarkLargePreview = New-Object Drawing.Bitmap($ImgObject, $PreviewSizeLarge, $PreviewSizeLarge)
  $ImgObject.Dispose()

  # Set the image to the preview window.
  $WatermarkPreviewBox.Image   = $WatermarkSmallPreview
  $WatermarkPreviewImage.Image = $WatermarkLargePreview

  # Clean up the garbage that is laying around.
  RemovePath -LiteralPath $PreviewPath

  # Enable the dialog state.
  ToggleDialogStates -State $true
  $WatermarkImageGroup.Enabled = $true
}
#==============================================================================================================================================================================================
#  Gets the name of the optimizer tool based on the path that it's currently set to.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetOptimizerPath()
{
  # Use the selected tool as a switch.
  switch -wildcard ($OptimizerTool)
  {
    # Return the program name.
    'OptiPNG' { return $OptiPNGPath }
    'OxiPNG'  { return $OxiPNGPath  }
    'Pingo'   { return $PingoPath   }
    'ECT'     { return $ECTPath     }
  }
  # If there is no path, return null.
  return $null
}
#==============================================================================================================================================================================================
#  Populates the optimizer list with the each tool if the path is valid.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function PopulateOptimizerList()
{
  # Remove all current tools from the list.
  $OptimizerProgramCombo.Items.Clear() | Out-Null

  # Add the external tools if they have been found.
  if (TestPath -LiteralPath $OptiPNGPath) { $OptimizerProgramCombo.Items.Add('OptiPNG') | Out-Null }
  if (TestPath -LiteralPath $OxiPNGPath)  { $OptimizerProgramCombo.Items.Add('OxiPNG')  | Out-Null }
  if (TestPath -LiteralPath $PingoPath)   { $OptimizerProgramCombo.Items.Add('Pingo')   | Out-Null }
  if (TestPath -LiteralPath $ECTPath)     { $OptimizerProgramCombo.Items.Add('ECT')     | Out-Null }

  # If any tool is not found, then add the "Add Tool..." option to the list.
  $AddToolConditions = New-Object Collections.Generic.List[bool]
  $AddToolConditions.Add((!(TestPath -LiteralPath $OptiPNGPath)))
  $AddToolConditions.Add((!(TestPath -LiteralPath $OxiPNGPath)))
  $AddToolConditions.Add((!(TestPath -LiteralPath $PingoPath)))
  $AddToolConditions.Add((!(TestPath -LiteralPath $ECTPath)))

  # Test the array of conditions. If it fails, add the item to allow adding more tools.
  if (TestBooleanArray -Or -Array $AddToolConditions) { $OptimizerProgramCombo.Items.Add('Add Tool...') | Out-Null }

  # Check to see if the selected tool has been added to the list.
  if ($OptimizerProgramCombo.Items.Contains($OptimizerTool))
  {
    # If it has been added to the list already, then select it.
    $OptimizerProgramCombo.SelectedItem = $OptimizerTool 
  }
  # The tool has not been already added to the list, then select the first tool found.
  else
  {
    # Check to see if the only item is not the option to add a tool.
    if ($OptimizerProgramCombo.Items[0] -ne 'Add Tool...')
    {
      # Select the first item in the list.
      $OptimizerProgramCombo.SelectedItem = $global:OptimizerTool = $OptimizerProgramCombo.Items[0]
    }
  }
  # Update the path for the currently selected optimizer.
  $global:OptimizerPath = GetOptimizerPath
}
#==============================================================================================================================================================================================
#  The function for when a tool is selected on the Optimizer menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function OptimizerToolSelection([Windows.Forms.ComboBox]$ComboBox)
{
  # Get the item that was selected from the combobox.
  $SelectedTool = $ComboBox.SelectedItem

  # If the user wants to add a new tool to the list.
  if ($SelectedTool -eq 'Add Tool...')
  {
    # Create empty arrays for the tools that aren't already added.
    $FileNameArray    = New-Object Collections.Generic.List[string]
    $DescriptionArray = New-Object Collections.Generic.List[string]

    # Add the tools that are not found to the list.
    if (!(TestPath -LiteralPath $OptiPNGPath)) { $FileNameArray.Add('optipng.exe') ; $DescriptionArray.Add('OptiPNG') }
    if (!(TestPath -LiteralPath $OxiPNGPath))  { $FileNameArray.Add('oxipng.exe')  ; $DescriptionArray.Add('OxiPNG')  }
    if (!(TestPath -LiteralPath $PingoPath))   { $FileNameArray.Add('pingo.exe')   ; $DescriptionArray.Add('Pingo')   }
    if (!(TestPath -LiteralPath $ECTPath))     { $FileNameArray.Add('ect*.exe')    ; $DescriptionArray.Add('ECT')     }

    # Display an "Open File" menu to get the path. Get-FileName already handles arrays so no need to worry about extra shit.
    $SelectedPath = Get-FileName -StartPath $BaseFolder -FileName $FileNameArray -Description $DescriptionArray

    # Check to see if a folder was selected from the Open menu and test if that path exists.
    if (($SelectedPath -ne '') -and (TestPath -LiteralPath $SelectedPath))
    {
      # Get the name of the tool so parameters for it can be set up.
      $ToolName = (Get-Item -LiteralPath $SelectedPath).BaseName

      # Set up parameters based on the selected tool.
      switch -wildcard ($ToolName)
      {
        # Set the values for OptiPNG.
        'optipng*'  {
                      $ToolName = 'OptiPNG'
                      $TextBox  = $OptionsOptiPNGTextBox
                      $VarName  = 'OptiPNGPath'
                    }
        # Set the values for OxiPNG.
        'oxipng*'   {
                      $ToolName = 'OxiPNG'
                      $TextBox  = $OptionsOxiPNGTextBox
                      $VarName  = 'OxiPNGPath'
                    }
        # Set the values for Pingo.
        'pingo*'    {
                      $ToolName = 'Pingo'
                      $TextBox  = $OptionsPingoTextBox
                      $VarName  = 'PingoPath'
                    }
        # Set the values for Efficient Compression Tool.
        'ect*'      {
                      $ToolName = 'ECT'
                      $TextBox  = $OptionsECTTextBox
                      $VarName  = 'ECTPath'
                    }
      }
      # Make sure the tool is not already on the list.
      if (!($ComboBox.Items.Contains($ToolName)))
      {
        # Call the function that is used when updating paths.
        LoadExternalFile -TextBox $TextBox -ToolPathName $VarName -ToolPath $SelectedPath
      }
      # Force the selected item to recently added tool.
      $ComboBox.SelectedItem = $SelectedTool = $ToolName
    }
    # If nothing was selected.
    else
    {
      # Check to see if the only item is not the option to add a tool.
      if ($ComboBox.Items[0] -ne 'Add Tool...')
      {
        # Select the first item in the list.
        $ComboBox.SelectedItem = $SelectedTool = $ComboBox.Items[0]
      }
    }
  }
  # Call the function that fires when a tool is selected.
  ComboBoxStateChanged -NewValue $SelectedTool

  # Update the options on the Optimizer menu.
  UpdateOptimizerOptions
}
#==============================================================================================================================================================================================
#  When selecting the optimizer tool, update the options to reflect what the current tool is capable of.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateOptimizerOptions()
{
  # Use the program name as a switch.
  switch ($OptimizerTool)
  {
    # OptiPNG Setup
    'OptiPNG'
    {
      # Adjust the number of tests, change the option text, and set the tooltip.
      $OptimizeTestsNumBox.Minimum = 0
      $OptimizeTestsNumBox.Maximum = 7
      $OptimizeTestsLabel.Text = 'Optimization Level'
      $OptimizeTestsTip.SetToolTip($OptimizeTestsLabel, $OptimizeTestsTipStringA)

      # Disable multi-threading for OptiPNG.
      $OptimizeThreadsNumBox.Enabled = $false
      $OptimizeThreadsLabel.Enabled  = $false

      # This option is not available.
      $OptimizeStrictLosslessCheck.Enabled = $false
    }
    # OxiPNG Setup
    'OxiPNG'
    {
      # Adjust the number of tests, change the option text, and set the tooltip.
      $OptimizeTestsNumBox.Minimum = 0
      $OptimizeTestsNumBox.Maximum = 7
      $OptimizeTestsLabel.Text = 'Optimization Level'
      $OptimizeTestsTip.SetToolTip($OptimizeTestsLabel, $OptimizeTestsTipStringA)

      # Enable multi-threading for this program.
      $OptimizeThreadsNumBox.Enabled = $true
      $OptimizeThreadsLabel.Enabled  = $true

      # This option is not available.
      $OptimizeStrictLosslessCheck.Enabled = $false
    }
    # Pingo Setup
    'Pingo'
    {
      # Adjust the compression level, change the option text, and set the tooltip.
      $OptimizeTestsNumBox.Minimum = 1
      $OptimizeTestsNumBox.Maximum = 9 
      $OptimizeTestsLabel.Text = 'Compression Level'
      $OptimizeTestsTip.SetToolTip($OptimizeTestsLabel, $OptimizeTestsTipStringB)

      # Enable multi-threading for this program.
      $OptimizeThreadsNumBox.Enabled = $true
      $OptimizeThreadsLabel.Enabled  = $true

      # Enable for compression based programs.
      $OptimizeStrictLosslessCheck.Enabled = $true
    }
    # ECT Setup
    'ECT'
    {
      # Adjust the compression level, change the option text, and set the tooltip.
      $OptimizeTestsNumBox.Minimum = 1
      $OptimizeTestsNumBox.Maximum = 9 
      $OptimizeTestsLabel.Text = 'Compression Level'
      $OptimizeTestsTip.SetToolTip($OptimizeTestsLabel, $OptimizeTestsTipStringB)

      # Enable multi-threading for this program.
      $OptimizeThreadsNumBox.Enabled = $true
      $OptimizeThreadsLabel.Enabled  = $true

      # Enable for compression based programs.
      $OptimizeStrictLosslessCheck.Enabled = $true
    }
  }
}
#==============================================================================================================================================================================================
#  Toggles showing the button for custom alpha pixels shit. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleAlphaPixelButton()
{
  $AlphaPixelCustomButton.Visible = ($this.SelectedIndex -eq 5)
}
#==============================================================================================================================================================================================
#  Clears the currently selected command from the CLI command list.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CLIClearSelectedCommand()
{
  # Loop through all the selected commands.
  foreach ($Cell in $CLIGridView.SelectedCells)
  {
    # Check to see if it's selected and the value is not null.
    if (($Cell.Selected) -and ($Cell.Value -ne $null))
    {
      # Remove the selected rows.
      $CLIGridView.Rows.RemoveAt($Cell.RowIndex)
    }
  }
}
#==============================================================================================================================================================================================
#  Toggles the Split Textures options for single or batch mode.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleSplitSingleMode()
{
  # Simply just toggle them based on the checkbox state.
  $SplitTextureColsNumBox.Enabled = !$this.Checked
  $SplitXLabel.Enabled            = !$this.Checked
  $SplitTextureRowsNumBox.Enabled = !$this.Checked
  $SplitGridArrayLabel.Enabled    = !$this.Checked
  $SplitTextureTextBox.Enabled    = !$this.Checked
  $SplitLoadTextureButton.Enabled = !$this.Checked
  $SplitTextureCTTButton.Enabled  = !$this.Checked
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - PHYRE MODE OPERATION SUPPORT
#==============================================================================================================================================================================================
#  Performs various actions when selecting items on the extract PKA file menu.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToCSPKAComboHandleSelected()
{
  # If one of the "Extract Specific File" options are selected.
  if ($this.SelectedIndex -gt 0)
  {
    # This will take a second so disable the dialogs.
    ToggleDialogStates -State $false

    # Populate the file selection combobox.
    ToCSPKASpecificCombo_Populate -Index $this.SelectedIndex

    # Show this combobox.
    $ToCSPKASpecificCombo.Visible = $true

    # Set everything back to normal.
    ToggleDialogStates -State $true
  }
  # We also need to detect when it's not these options.
  else
  {
    # Hide this combobox.
    $ToCSPKASpecificCombo.Visible = $false
  }
}
#==============================================================================================================================================================================================
#  Populates the PKA file selection list depending on which combobox is selected.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToCSPKASpecificCombo_Populate([int]$Index)
{
  # Clear whatever is on the combobox at this time.
  $ToCSPKASpecificCombo.Items.Clear()

  # Use the selected index of the combobox. 
  switch ($Index.ToString())
  {
    # Set the path to the INI. If it doesn't exist then create it using a Base64 string in this script.
    '1' { $PKGFileIni = $CS3PKGFileList ; if (!(TestPath -LiteralPath $PKGFileIni)) { UnpackCS3PKABase64ZIP -OutputFile $PKGFileIni } }
    '2' { $PKGFileIni = $CS4PKGFileList ; if (!(TestPath -LiteralPath $PKGFileIni)) { UnpackCS4PKABase64ZIP -OutputFile $PKGFileIni } }
  }
  # Get the files from the INI list.
  $PKGList = Get-Content -LiteralPath $PKGFileIni

  # Add all of the entries to the combobox.
  foreach ($Entry in $PKGList) { $ToCSPKASpecificCombo.Items.Add($Entry) | Out-Null }

  # Check to see if an item has already been selected. If an item has been selected then check the current list to see if it's there.
  if (($PhyrePKASelected -ne $null) -and ($PhyrePKASelected -ne '') -and ($ToCSPKASpecificCombo.Items -contains $PhyrePKASelected))
  {
    # If the entry is on the list, then select it.
    $ToCSPKASpecificCombo.SelectedItem = $PhyrePKASelected
  }
  # If nothing has been selected then just select the first item.
  else
  {
    # Select the first entry in the list.
    $ToCSPKASpecificCombo.SelectedIndex = 0
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: MAIN DIALOG - CREATE
#==============================================================================================================================================================================================
#  Because there are so many operations and code, it has been split into its own function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_MainDialogOps()
{
  # 00: Scan Textures - Create the groupbox that will hold the scan texture options.
  $global:ScanDolphinTexGroup = New-Object Windows.Forms.GroupBox
  $ScanDolphinTexGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ScanDolphinTexGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ScanDolphinTexGroup.Text = ' Scan Textures Options '
  $MainDialogPanel.Controls.Add($ScanDolphinTexGroup)

  # 00: Scan Textures - Attempt Repairs - Attempts to auto-repair textures. Unlocks the scale-fix and aspect-fix thresholds.
  $global:ScanRepairCheck = New-Object Windows.Forms.CheckBox
  $ScanRepairCheck.Size = DPISize (New-Object Drawing.Size(162, 16))
  $ScanRepairCheck.Location = DPISize (New-Object Drawing.Point(10, 20))
  $ScanRepairCheck.Text = ' Attempt Repairs  ------->'
  $ScanRepairCheck.Name = 'RepairTextures'
  $ScanRepairCheck.Checked = $RepairTextures
  $ScanRepairCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; ScanTextures_ToggleFixThresholds })
  $ScanDolphinTexGroup.Controls.Add($ScanRepairCheck)

  # 00: Scan Textures - Attempt Repairs - Create a tooltip.
  $ScanRepairTip = New-Object Windows.Forms.ToolTip
  $ScanRepairTip.InitialDelay = $ToolTipDelay
  $ScanRepairTip.AutoPopDelay = $ToolTipDuration
  $ScanRepairTipString = 'Attempts to repair textures with issues. Repaired textures can{0}'
  $ScanRepairTipString += 'be found in the Output Path in the folder "RepairedTextures".{0}'
  $ScanRepairTipString += '{0}'
  $ScanRepairTipString += 'Issues that can be fixed with this option are:{0}'
  $ScanRepairTipString += '- Uneven Scale - Scaling value mismatch between width/height.{0}'
  $ScanRepairTipString += "- Bad Width/Height - Dimensions don't match calculated values.{0}"
  $ScanRepairTipString += "- Bad Aspect Ratio - Texture aspect doesn't match original.{0}"
  $ScanRepairTipString += '- Bad Mipmap Scale - Mipmap dimensions are incorrect.{0}'
  $ScanRepairTipString += '- Missing Mipmaps - Some or all Mipmap levels are missing.{0}'
  $ScanRepairTipString += '{0}'
  $ScanRepairTipString += 'By default, the script error checks DDS internal mipmaps. It will{0}'
  $ScanRepairTipString += 'check external mipmaps if "External Mipmaps" is checked.'
  $ScanRepairTipString = [String]::Format($ScanRepairTipString, [Environment]::NewLine)
  $ScanRepairTip.SetToolTip($ScanRepairCheck, $ScanRepairTipString)

  # 00: Scan Textures - Copy Bad Textures - Create a checkbox.
  $global:ScanCopyBadTextures = New-Object Windows.Forms.CheckBox
  $ScanCopyBadTextures.Size = DPISize (New-Object Drawing.Size(125, 16))
  $ScanCopyBadTextures.Location = DPISize (New-Object Drawing.Point(10, 40))
  $ScanCopyBadTextures.Name = 'CopyBadTextures'
  $ScanCopyBadTextures.Checked = $CopyBadTextures
  $ScanCopyBadTextures.Text = ' Copy Bad Textures'
  $ScanCopyBadTextures.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ScanDolphinTexGroup.Controls.Add($ScanCopyBadTextures)

  # 00: Scan Textures - Copy Bad Textures - Create a tooltip.
  $ScanCopyBadTip = New-Object Windows.Forms.ToolTip
  $ScanCopyBadTip.InitialDelay = $ToolTipDelay
  $ScanCopyBadTip.AutoPopDelay = $ToolTipDuration
  $ScanCopyBadTipString = 'Copies textures with issues to the Output{0}'
  $ScanCopyBadTipString += 'Path in a folder named "BrokenTextures".{0}'
  $ScanCopyBadTipString += '{0}'
  $ScanCopyBadTipString += 'If the option "Attempt Repairs" is enabled{0}'
  $ScanCopyBadTipString += 'and a texture is successfully repaired, then{0}'
  $ScanCopyBadTipString += 'the "broken" texture will not be copied.'
  $ScanCopyBadTipString = [String]::Format($ScanCopyBadTipString, [Environment]::NewLine)
  $ScanCopyBadTip.SetToolTip($ScanCopyBadTextures, $ScanCopyBadTipString)

  # 00: Scan Textures - Hide OK Textures - Create a checkbox.
  $global:ScanHideOKTextures = New-Object Windows.Forms.CheckBox
  $ScanHideOKTextures.Size = DPISize (New-Object Drawing.Size(120, 16))
  $ScanHideOKTextures.Location = DPISize (New-Object Drawing.Point(10, 60))
  $ScanHideOKTextures.Name = 'HideOKTextures'
  $ScanHideOKTextures.Checked = $HideOKTextures
  $ScanHideOKTextures.Text = ' Hide OK Textures'
  $ScanHideOKTextures.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleOKTextures })
  $ScanDolphinTexGroup.Controls.Add($ScanHideOKTextures)

  # 00: Scan Textures - Hide OK Textures - Create a tooltip.
  $ScanHideOKTip = New-Object Windows.Forms.ToolTip
  $ScanHideOKTip.InitialDelay = $ToolTipDelay
  $ScanHideOKTip.AutoPopDelay = $ToolTipDuration
  $ScanHideOKTipString = 'Textures that are found to have no issues{0}'
  $ScanHideOKTipString += 'are flagged as "OK". This option prevents{0}'
  $ScanHideOKTipString += 'these textures from showing up in the log.'
  $ScanHideOKTipString = [String]::Format($ScanHideOKTipString, [Environment]::NewLine)
  $ScanHideOKTip.SetToolTip($ScanHideOKTextures, $ScanHideOKTipString)

  # 00: Scan Textures - Ignore Duplicates - Create a checkbox.
  $global:ScanIgnoreDuplicates = New-Object Windows.Forms.CheckBox
  $ScanIgnoreDuplicates.Size = DPISize (New-Object Drawing.Size(120, 16))
  $ScanIgnoreDuplicates.Location = DPISize (New-Object Drawing.Point(10, 80))
  $ScanIgnoreDuplicates.Name = 'IgnoreDuplicates'
  $ScanIgnoreDuplicates.Checked = $IgnoreDuplicates
  $ScanIgnoreDuplicates.Text = ' Ignore Duplicates'
  $ScanIgnoreDuplicates.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ScanDolphinTexGroup.Controls.Add($ScanIgnoreDuplicates)

  # 00: Scan Textures - Ignore Duplicates - Create a tooltip.
  $ScanIgnoreDuplicatesTip = New-Object Windows.Forms.ToolTip
  $ScanIgnoreDuplicatesTip.InitialDelay = $ToolTipDelay
  $ScanIgnoreDuplicatesTip.AutoPopDelay = $ToolTipDuration
  $ScanIgnoreDuplicatesTipString = 'This option disables the script from finding{0}'
  $ScanIgnoreDuplicatesTipString += 'duplicate textures and printing them to the{0}'
  $ScanIgnoreDuplicatesTipString += 'log. It can be useful to hide duplicates to{0}'
  $ScanIgnoreDuplicatesTipString += 'prevent log spam if a pack contains several{0}'
  $ScanIgnoreDuplicatesTipString += 'textures with the same dumped name/hash.'
  $ScanIgnoreDuplicatesTipString = [String]::Format($ScanIgnoreDuplicatesTipString, [Environment]::NewLine)
  $ScanIgnoreDuplicatesTip.SetToolTip($ScanIgnoreDuplicates, $ScanIgnoreDuplicatesTipString)

  # 00: Scan Textures - Allow Not-HD Textures - Create a checkbox.
  $global:ScanAllowNotHD = New-Object Windows.Forms.CheckBox
  $ScanAllowNotHD.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ScanAllowNotHD.Location = DPISize (New-Object Drawing.Point(10, 100))
  $ScanAllowNotHD.Name = 'AllowNotHD'
  $ScanAllowNotHD.Checked = $AllowNotHD
  $ScanAllowNotHD.Text = ' Allow Not-HD Textures'
  $ScanAllowNotHD.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ScanDolphinTexGroup.Controls.Add($ScanAllowNotHD)

  # 00: Scan Textures - Allow Not-HD Textures - Create a tooltip.
  $ScanAllowNotHDTip = New-Object Windows.Forms.ToolTip
  $ScanAllowNotHDTip.InitialDelay = $ToolTipDelay
  $ScanAllowNotHDTip.AutoPopDelay = $ToolTipDuration
  $ScanAllowNotHDTipString = 'Allows processing custom textures{0}'
  $ScanAllowNotHDTipString += 'that have the original dimensions{0}'
  $ScanAllowNotHDTipString += 'as they were dumped with Dolphin.'
  $ScanAllowNotHDTipString = [String]::Format($ScanAllowNotHDTipString, [Environment]::NewLine)
  $ScanAllowNotHDTip.SetToolTip($ScanAllowNotHD, $ScanAllowNotHDTipString)

  # 00: Scan Textures - Scale-Fix Threshold - Create a number selector.
  $global:ScanScaleFixNumBox = New-Object Windows.Forms.NumericUpDown
  $ScanScaleFixNumBox.Size = DPISize (New-Object Drawing.Size(70, 10))
  $ScanScaleFixNumBox.Location = DPISize (New-Object Drawing.Point(174, 18))
  $ScanScaleFixNumBox.Name = 'ScaleThreshold'
  $ScanScaleFixNumBox.DecimalPlaces = 2
  $ScanScaleFixNumBox.Minimum = 0.00
  $ScanScaleFixNumBox.Maximum = 0.99
  $ScanScaleFixNumBox.Increment = 0.01
  $ScanScaleFixNumBox.Value = $ScaleThreshold
  $ScanScaleFixNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'decimal' ; Operations_UpdateScaleFixThreshold })
  $ScanScaleFixNumBox.Enabled = $RepairTextures
  $ScanDolphinTexGroup.Controls.Add($ScanScaleFixNumBox)

  # 00: Scan Textures - Scale-Fix Threshold - Create a label.
  $global:ScanScaleFixLabel = New-Object Windows.Forms.Label
  $ScanScaleFixLabel.Size = DPISize (New-Object Drawing.Size(120, 22))
  $ScanScaleFixLabel.Location = DPISize (New-Object Drawing.Point(248, 20))
  $ScanScaleFixLabel.Text = 'Scale-Fix Threshold'
  $ScanScaleFixLabel.Enabled = $RepairTextures
  $ScanDolphinTexGroup.Controls.Add($ScanScaleFixLabel)

  # 00: Scan Textures - Scale-Fix Threshold - Create a tooltip.
  $ScanScaleFixTip = New-Object Windows.Forms.ToolTip
  $ScanScaleFixTip.InitialDelay = $ToolTipDelay
  $ScanScaleFixTip.AutoPopDelay = $ToolTipDuration
  $ScanScaleFixTipString = 'The minimum decimal value of the{0}'
  $ScanScaleFixTipString += 'scale required to auto-repair textures{0}'
  $ScanScaleFixTipString += 'to the next highest integer scale.{0}'
  $ScanScaleFixTipString += '{0}'
  $ScanScaleFixTipString += 'Example:{0}'
  $ScanScaleFixTipString += 'Scale-Fix Threshold = 0.45{0}'
  $ScanScaleFixTipString += 'Scale of 4.01-4.44 downscales to 4x{0}'
  $ScanScaleFixTipString += 'Scale of 4.45-4.99 upscales to 5x'
  $ScanScaleFixTipString = [String]::Format($ScanScaleFixTipString, [Environment]::NewLine)
  $ScanScaleFixTip.SetToolTip($ScanScaleFixLabel, $ScanScaleFixTipString)

  # 00: Scan Textures - Aspect-Fix Threshold - Create a number selector.
  $global:ScanAspectFixNumBox = New-Object Windows.Forms.NumericUpDown
  $ScanAspectFixNumBox.Size = DPISize (New-Object Drawing.Size(70, 10))
  $ScanAspectFixNumBox.Location = DPISize (New-Object Drawing.Point(174, 42))
  $ScanAspectFixNumBox.Name = 'AspectThreshold'
  $ScanAspectFixNumBox.DecimalPlaces = 2
  $ScanAspectFixNumBox.Minimum = 0.00
  $ScanAspectFixNumBox.Maximum = 0.99
  $ScanAspectFixNumBox.Increment = 0.01
  $ScanAspectFixNumBox.Value = $AspectThreshold
  $ScanAspectFixNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'decimal' })
  $ScanAspectFixNumBox.Enabled = $RepairTextures
  $ScanDolphinTexGroup.Controls.Add($ScanAspectFixNumBox)

  # 00: Scan Textures - Aspect-Fix Threshold - Create a label.
  $global:ScanAspectFixLabel = New-Object Windows.Forms.Label
  $ScanAspectFixLabel.Size = DPISize (New-Object Drawing.Size(120, 22))
  $ScanAspectFixLabel.Location = DPISize (New-Object Drawing.Point(248, 44))
  $ScanAspectFixLabel.Text = 'Aspect-Fix Threshold'
  $ScanAspectFixLabel.Enabled = $RepairTextures
  $ScanDolphinTexGroup.Controls.Add($ScanAspectFixLabel)

  # 00: Scan Textures - Aspect-Fix Threshold - Create a tooltip.
  $ScanAspectFixTip = New-Object Windows.Forms.ToolTip
  $ScanAspectFixTip.InitialDelay = $ToolTipDelay
  $ScanAspectFixTip.AutoPopDelay = $ToolTipDuration
  $ScanAspectFixTipString = 'Sets a minimum limit of aspect ratio{0}'
  $ScanAspectFixTipString += 'difference between the original and{0}'
  $ScanAspectFixTipString += 'custom texture to attempt repairs.{0}'
  $ScanAspectFixTipString += '{0}'
  $ScanAspectFixTipString += 'Example: {0}'
  $ScanAspectFixTipString += 'Original = 200x32  - Aspect 6.25{0}'
  $ScanAspectFixTipString += 'Custom = 800x130 - Aspect 6.15{0}'
  $ScanAspectFixTipString += '0.10 Aspect Difference{0}'
  $ScanAspectFixTipString += 'Minimum = 0.10 to Auto-Repair'
  $ScanAspectFixTipString = [String]::Format($ScanAspectFixTipString, [Environment]::NewLine)
  $ScanAspectFixTip.SetToolTip($ScanAspectFixLabel, $ScanAspectFixTipString)

  # 00: Scan Textures - User Accepted Scale Values - Create a checkbox.
  $global:ScanUserScaleValues = New-Object Windows.Forms.CheckBox
  $ScanUserScaleValues.Size = DPISize (New-Object Drawing.Size(180, 16))
  $ScanUserScaleValues.Location = DPISize (New-Object Drawing.Point(174, 75))
  $ScanUserScaleValues.Name = 'UserScaleValues'
  $ScanUserScaleValues.Checked = $UserScaleValues
  $ScanUserScaleValues.Text = ' User Accepted Scale Values'
  $ScanUserScaleValues.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleUserScaleValue })
  $ScanDolphinTexGroup.Controls.Add($ScanUserScaleValues)

  # 00: Scan Textures - User Accepted Scale Values - Create a tooltip.
  $ScanUserScaleTip = New-Object Windows.Forms.ToolTip
  $ScanUserScaleTip.InitialDelay = $ToolTipDelay
  $ScanUserScaleTip.AutoPopDelay = $ToolTipDuration
  $ScanUserScaleTipString =  'Determines which scaling values are accepted{0}'
  $ScanUserScaleTipString += 'and are not flagged as an "issue". If trying{0}'
  $ScanUserScaleTipString += 'to create a specific type of pack, this can{0}'
  $ScanUserScaleTipString += 'help identify undesired scaling values. Add{0}'
  $ScanUserScaleTipString += 'scale values below separated by commas.{0}'
  $ScanUserScaleTipString += '{0}'
  $ScanUserScaleTipString += 'Example:{0}'
  $ScanUserScaleTipString += 'Accept only 4x upscale factor{0}'
  $ScanUserScaleTipString += '4{0}'
  $ScanUserScaleTipString += '{0}'
  $ScanUserScaleTipString += 'Example:{0}'
  $ScanUserScaleTipString += 'Anything as or under 8x upscale factor{0}'
  $ScanUserScaleTipString += '1,2,3,4,5,6,7,8{0}'
  $ScanUserScaleTipString += '{0}'
  $ScanUserScaleTipString += 'Example:{0}'
  $ScanUserScaleTipString += 'Power of two upscale factor{0}'
  $ScanUserScaleTipString += '2,4,8,16,32,64,128,256,512,1024,2048'
  $ScanUserScaleTipString = [String]::Format($ScanUserScaleTipString, [Environment]::NewLine)
  $ScanUserScaleTip.SetToolTip($ScanUserScaleValues, $ScanUserScaleTipString)

  # 00: Scan Textures - User Accepted Scale Values - Create a textbox to enter the accepted scales.
  $global:ScanAcceptedScalesTextBox = New-Object Windows.Forms.TextBox
  $ScanAcceptedScalesTextBox.Size = DPISize (New-Object Drawing.Size(200, 20))
  $ScanAcceptedScalesTextBox.Location = DPISize (New-Object Drawing.Point(174, 95)) -AddY $DPIOffsetFix
  $ScanAcceptedScalesTextBox.Name = 'AcceptedScales'
  $ScanAcceptedScalesTextBox.Text = $AcceptedScales
  $ScanAcceptedScalesTextBox.Enabled = $UserScaleValues
  $ScanAcceptedScalesTextBox.Add_Leave({ UpdateAcceptedScalesTextBox })
  $ScanDolphinTexGroup.Controls.Add($ScanAcceptedScalesTextBox)

  # 01: Create Size Database - Create the groupbox that will hold the remove alpha channel description.
  $global:DatabaseTextureGroup = New-Object Windows.Forms.GroupBox
  $DatabaseTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $DatabaseTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $DatabaseTextureGroup.Text = ' Description '
  $MainDialogPanel.Controls.Add($DatabaseTextureGroup)

  # 01: Create Size Database - Create a checkbox to enable database usage.
  $global:DatabaseOverwriteCheck = New-Object Windows.Forms.CheckBox
  $DatabaseOverwriteCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $DatabaseOverwriteCheck.Location = DPISize (New-Object Drawing.Point(10, 20))
  $DatabaseOverwriteCheck.Name = 'DatabaseOverwrite'
  $DatabaseOverwriteCheck.Checked = $DatabaseOverwrite
  $DatabaseOverwriteCheck.Text = ' Overwrite Existing Entries'
  $DatabaseOverwriteCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DatabaseTextureGroup.Controls.Add($DatabaseOverwriteCheck)

  # 01: Create Size Database - The tooltip for the label.
  $DatabaseOverwriteTip = New-Object Windows.Forms.ToolTip
  $DatabaseOverwriteTip.InitialDelay = $ToolTipDelay
  $DatabaseOverwriteTip.AutoPopDelay = $ToolTipDuration
  $DatabaseOverwriteTipString =  'When generating a database, if the list already{0}'
  $DatabaseOverwriteTipString += 'contains the texture name it will be skipped. If{0}'
  $DatabaseOverwriteTipString += 'this option is enabled, the entry will instead be{0}'
  $DatabaseOverwriteTipString += 'overwritten with the new texture dimensions.'
  $DatabaseOverwriteTipString = [String]::Format($DatabaseOverwriteTipString, [Environment]::NewLine)
  $DatabaseOverwriteTip.SetToolTip($DatabaseOverwriteCheck, $DatabaseOverwriteTipString)

  # 01: Create Size Database - Create a checkbox to log textures missing from the database.
  $global:DatabaseMissingCheck = New-Object Windows.Forms.CheckBox
  $DatabaseMissingCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $DatabaseMissingCheck.Location = DPISize (New-Object Drawing.Point(10, 40))
  $DatabaseMissingCheck.Name = 'DatabaseMissing'
  $DatabaseMissingCheck.Checked = $DatabaseMissing
  $DatabaseMissingCheck.Text = ' Create Missing Entries Log'
  $DatabaseMissingCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DatabaseTextureGroup.Controls.Add($DatabaseMissingCheck)

  # 01: Create Size Database - The tooltip for the label.
  $DatabaseMissingTip = New-Object Windows.Forms.ToolTip
  $DatabaseMissingTip.InitialDelay = $ToolTipDelay
  $DatabaseMissingTip.AutoPopDelay = $ToolTipDuration
  $DatabaseMissingTipString =  'Creates a log file of textures that are not{0}'
  $DatabaseMissingTipString += 'currently found in the database. This helps{0}'
  $DatabaseMissingTipString += 'to keep track of textures that you may want{0}'
  $DatabaseMissingTipString += 'to eventually add. The log file will only be{0}'
  $DatabaseMissingTipString += 'generated when using the operations: Scan,{0}'
  $DatabaseMissingTipString += 'Convert, Rescale, Resize, and Upscale Filter.'
  $DatabaseMissingTipString = [String]::Format($DatabaseMissingTipString, [Environment]::NewLine)
  $DatabaseMissingTip.SetToolTip($DatabaseMissingCheck, $DatabaseMissingTipString)

  # 01: Create Size Database - Create a checkbox to copy textures missing from the database.
  $global:DatabaseMissCopyCheck = New-Object Windows.Forms.CheckBox
  $DatabaseMissCopyCheck.Size = DPISize (New-Object Drawing.Size(180, 16))
  $DatabaseMissCopyCheck.Location = DPISize (New-Object Drawing.Point(10, 60))
  $DatabaseMissCopyCheck.Name = 'DatabaseMissCopy'
  $DatabaseMissCopyCheck.Checked = $DatabaseMissCopy
  $DatabaseMissCopyCheck.Text = ' Create Missing Entries Copy'
  $DatabaseMissCopyCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $DatabaseTextureGroup.Controls.Add($DatabaseMissCopyCheck)

  # 01: Create Size Database - The tooltip for the label.
  $DatabaseMissCopyTip = New-Object Windows.Forms.ToolTip
  $DatabaseMissCopyTip.InitialDelay = $ToolTipDelay
  $DatabaseMissCopyTip.AutoPopDelay = $ToolTipDuration
  $DatabaseMissCopyTipString =  'If the texture is missing from the database file{0}'
  $DatabaseMissCopyTipString += 'it is copied to a "DatabaseMissing" folder in the{0}'
  $DatabaseMissCopyTipString += 'output path. Works with the operations: Scan,{0}'
  $DatabaseMissCopyTipString += 'Convert, Rescale, Resize, and Upscale Filter.'
  $DatabaseMissCopyTipString = [String]::Format($DatabaseMissCopyTipString, [Environment]::NewLine)
  $DatabaseMissCopyTip.SetToolTip($DatabaseMissCopyCheck, $DatabaseMissCopyTipString)

  # 01: Create Size Database - Create a label for the textbox.
  $global:DatabaseNameLabel = New-Object Windows.Forms.Label
  $DatabaseNameLabel.Size = DPISize (New-Object Drawing.Size(140, 14))
  $DatabaseNameLabel.Location = DPISize (New-Object Drawing.Point(192, 20))
  $DatabaseNameLabel.Text = 'Database Filename:'
  $DatabaseTextureGroup.Controls.Add($DatabaseNameLabel)

  # 01: Create Size Database - The tooltip for the label.
  $DatabaseNameTip = New-Object Windows.Forms.ToolTip
  $DatabaseNameTip.InitialDelay = $ToolTipDelay
  $DatabaseNameTip.AutoPopDelay = $ToolTipDuration
  $DatabaseNameTipString =  'Sets the name of the current database file. A{0}'
  $DatabaseNameTipString += 'file can also be selected with the [...] button to{0}'
  $DatabaseNameTipString += 'update the currently used name. Do note that{0}'
  $DatabaseNameTipString += 'this only updates the name and not the path.'
  $DatabaseNameTipString = [String]::Format($DatabaseNameTipString, [Environment]::NewLine)
  $DatabaseNameTip.SetToolTip($DatabaseNameLabel, $DatabaseNameTipString)

  # 01: Create Size Database - Create a textbox to show the name of the database.
  $global:DatabaseNameTextBox = New-Object Windows.Forms.TextBox
  $DatabaseNameTextBox.Size = DPISize (New-Object Drawing.Size(130, 20))
  $DatabaseNameTextBox.Location = DPISize (New-Object Drawing.Point(192, 38)) -AddY $DPIOffsetFix
  $DatabaseNameTextBox.Name = 'DatabaseName'
  $DatabaseNameTextBox.Text = $DatabaseName
  $DatabaseNameTextBox.Add_Click({ ClearTextBox })
  $DatabaseNameTextBox.Add_Leave({ SetDatabaseNameTextBox })
  $DatabaseTextureGroup.Controls.Add($DatabaseNameTextBox)

  # Tool Paths: CTT-PS Data Folder - Create an open folder button.
  $global:DatabaseOpenButton = New-Object Windows.Forms.Button
  $DatabaseOpenButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $DatabaseOpenButton.Location = DPISize (New-Object Drawing.Point(325, 37))
  $DatabaseOpenButton.Image = $Image_Folder
  $DatabaseOpenButton.Add_Click({ if (TestPath -LiteralPath $DatabasePath) { Invoke-Item -LiteralPath $DatabasePath } })
  $DatabaseTextureGroup.Controls.Add($DatabaseOpenButton)

  # 01: Create Size Database - Create a button to select the file.
  $global:DatabaseNameButton = New-Object Windows.Forms.Button
  $DatabaseNameButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $DatabaseNameButton.Location = DPISize (New-Object Drawing.Point(349, 37))
  $DatabaseNameButton.Name = 'DatabaseName'
  $DatabaseNameButton.Text = '...'
  $DatabaseNameButton.Add_Click({ SetDatabaseNameButton })
  $DatabaseTextureGroup.Controls.Add($DatabaseNameButton)

  # 01: Create Size Database - Create a label for the folder selection textbox.
  $global:DatabaseLocLabel = New-Object Windows.Forms.Label
  $DatabaseLocLabel.Size = DPISize (New-Object Drawing.Size(140, 14))
  $DatabaseLocLabel.Location = DPISize (New-Object Drawing.Point(10, 80))
  $DatabaseLocLabel.Text = 'Texture Database Folder:'
  $DatabaseTextureGroup.Controls.Add($DatabaseLocLabel)

  # 01: Create Size Database - The tooltip for the label.
  $DatabaseLocTip = New-Object Windows.Forms.ToolTip
  $DatabaseLocTip.InitialDelay = $ToolTipDelay
  $DatabaseLocTip.AutoPopDelay = $ToolTipDuration
  $DatabaseLocTipString =  'The location where texture database files{0}'
  $DatabaseLocTipString += 'will be stored. The default location where{0}'
  $DatabaseLocTipString += 'they are stored is the CTT-PS Data Folder,{0}'
  $DatabaseLocTipString += 'but the location can be changed here.'
  $DatabaseLocTipString = [String]::Format($DatabaseLocTipString, [Environment]::NewLine)
  $DatabaseLocTip.SetToolTip($DatabaseLocLabel, $DatabaseLocTipString)

  # 01: Create Size Database - Create a textbox to show the location.
  $global:DatabaseLocTextBox = New-Object Windows.Forms.TextBox
  $DatabaseLocTextBox.Size = DPISize (New-Object Drawing.Size(334, 22))
  $DatabaseLocTextBox.Location = DPISize (New-Object Drawing.Point(10, 95)) -AddY $DPIOffsetFix
  $DatabaseLocTextBox.Name = 'DatabasePath'
  $DatabaseLocTextBox.Text = $DatabasePath
  $DatabaseLocTextBox.AllowDrop = $true
  $DatabaseLocTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $DatabaseLocTextBox.Add_DragDrop({ LoadExternalFolder_DragDrop -TextBox $this })
  $DatabaseLocTextBox.Add_Click({ ClearTextBox })
  $DatabaseLocTextBox.Add_Leave({ LoadExternalFolder_TextBox -TextBox $this })
  $DatabaseTextureGroup.Controls.Add($DatabaseLocTextBox)

  # 01: Create Size Database - Create a button to select a database file.
  $global:DatabaseLocButton = New-Object Windows.Forms.Button
  $DatabaseLocButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $DatabaseLocButton.Location = DPISize (New-Object Drawing.Point(347, 94))
  $DatabaseLocButton.Name = 'DatabasePath'
  $DatabaseLocButton.Text = '...'
  $DatabaseLocButton.Add_Click({ LoadExternalFolder_Button -TextBox $DatabaseLocTextBox -Message 'Select the folder to where database files will be stored and retrieved.' })
  $DatabaseTextureGroup.Controls.Add($DatabaseLocButton)

  # 02: Convert Textures - Create the groupbox that will hold the convert texture options.
  $global:ConvertTextureGroup = New-Object Windows.Forms.GroupBox
  $ConvertTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ConvertTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ConvertTextureGroup.Text = ' Convert Textures Options '
  $MainDialogPanel.Controls.Add($ConvertTextureGroup)

  # 02: Convert Textures - Output Format - Create a combobox.
  $global:ConvertFormatCombo = New-Object Windows.Forms.ComboBox
  $ConvertFormatCombo.Size = DPISize (New-Object Drawing.Size(80, 10))
  $ConvertFormatCombo.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $ConvertFormatCombo.Name = 'ConvertFormat'
  $ConvertFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ConvertFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $ConvertFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Get-Variable -Name $this.SelectedItem -ValueOnly) ; ToggleIconSizeVisibility -SelectedItem $this.SelectedItem })
  $ConvertFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ConvertFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $ConvertTextureGroup.Controls.Add($ConvertFormatCombo)

  # 02: Convert Textures - Output Format - Create a label.
  $global:ConvertFormatLabel = New-Object Windows.Forms.Label
  $ConvertFormatLabel.Size = DPISize (New-Object Drawing.Size(80, 22))
  $ConvertFormatLabel.Location = DPISize (New-Object Drawing.Point(92, 23))
  $ConvertFormatLabel.Text = 'Output Format'
  $ConvertTextureGroup.Controls.Add($ConvertFormatLabel)

  # 02: Convert Textures - Output Format - Create a tooltip.
  $ConvertFormatTip = New-Object Windows.Forms.ToolTip
  $ConvertFormatTip.InitialDelay = $ToolTipDelay
  $ConvertFormatTip.AutoPopDelay = $ToolTipDuration
  $ConvertFormatTipString = 'The file extension/output format{0}'
  $ConvertFormatTipString += 'that textures will be created with.'
  $ConvertFormatTipString = [String]::Format($ConvertFormatTipString, [Environment]::NewLine)
  $ConvertFormatTip.SetToolTip($ConvertFormatLabel, $ConvertFormatTipString)

  # 02: Convert Textures - Copy Non-Textures - Create a checkbox.
  $global:ConvertCopyNonTex = New-Object Windows.Forms.CheckBox
  $ConvertCopyNonTex.Size = DPISize (New-Object Drawing.Size(130, 16))
  $ConvertCopyNonTex.Location = DPISize (New-Object Drawing.Point(10, 48))
  $ConvertCopyNonTex.Name = 'CopyNonTextures'
  $ConvertCopyNonTex.Checked = $CopyNonTextures
  $ConvertCopyNonTex.Text = ' Copy Non-Textures'
  $ConvertCopyNonTex.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleCopyNonTextures })
  $ConvertTextureGroup.Controls.Add($ConvertCopyNonTex)

  # 02: Convert Textures - Copy Non-Textures - Create a tooltip.
  $ConvertCopyNonTexTip = New-Object Windows.Forms.ToolTip
  $ConvertCopyNonTexTip.InitialDelay = $ToolTipDelay
  $ConvertCopyNonTexTip.AutoPopDelay = $ToolTipDuration
  $ConvertCopyNonTexTipString = 'Copies files that are not images such{0}'
  $ConvertCopyNonTexTipString += 'as (.txt) into the newly generated pack.'
  $ConvertCopyNonTexTipString = [String]::Format($ConvertCopyNonTexTipString, [Environment]::NewLine)
  $ConvertCopyNonTexTip.SetToolTip($ConvertCopyNonTex, $ConvertCopyNonTexTipString)

  # 02: Convert Textures - Enable AutoSharpen - Create a checkbox.
  $global:ConvertEnableSharpen = New-Object Windows.Forms.CheckBox
  $ConvertEnableSharpen.Size = DPISize (New-Object Drawing.Size(130, 16))
  $ConvertEnableSharpen.Location = DPISize (New-Object Drawing.Point(10, 70))
  $ConvertEnableSharpen.Name = 'EnableSharpen'
  $ConvertEnableSharpen.Checked = $EnableSharpen
  $ConvertEnableSharpen.Text = ' Enable Sharpening'
  $ConvertEnableSharpen.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleEnableSharpen })
  $ConvertTextureGroup.Controls.Add($ConvertEnableSharpen)

  # 02: Convert Textures - Enable AutoSharpen - Create a tooltip.
  $ConvertEnableSharpenTip = New-Object Windows.Forms.ToolTip
  $ConvertEnableSharpenTip.InitialDelay = $ToolTipDelay
  $ConvertEnableSharpenTip.AutoPopDelay = $ToolTipDuration
  $ConvertEnableSharpenTipString =  'Applies a sharpening filter to all textures{0}'
  $ConvertEnableSharpenTipString += 'when they are resized for any reason. The{0}'
  $ConvertEnableSharpenTipString += 'amount of sharpening is calculated based{0}'
  $ConvertEnableSharpenTipString += 'on the amount of change in resolution. It{0}'
  $ConvertEnableSharpenTipString += 'affects resized textures and all mipmaps,{0}'
  $ConvertEnableSharpenTipString += 'material maps, and generated icons.{0}'
  $ConvertEnableSharpenTipString += '{0}'
  $ConvertEnableSharpenTipString += 'In the past, this was always applied. This{0}'
  $ConvertEnableSharpenTipString += 'option was added in v50.0 as sharpening{0}'
  $ConvertEnableSharpenTipString += 'may not look so good for certain images.{0}'
  $ConvertEnableSharpenTipString += 'If unsure, keep enabled for texture packs{0}'
  $ConvertEnableSharpenTipString += 'and disable it when creating icon files.'
  $ConvertEnableSharpenTipString = [String]::Format($ConvertEnableSharpenTipString, [Environment]::NewLine)
  $ConvertEnableSharpenTip.SetToolTip($ConvertEnableSharpen, $ConvertEnableSharpenTipString)

  # 02: Convert Textures - Icon Sizes - Create a label.
  $global:ConvertIconSizeLabel = New-Object Windows.Forms.Label
  $ConvertIconSizeLabel.Size = DPISize (New-Object Drawing.Size(80, 14))
  $ConvertIconSizeLabel.Location = DPISize (New-Object Drawing.Point(10, 84))
  $ConvertIconSizeLabel.Text = 'Icon Sizes:'
  $ConvertTextureGroup.Controls.Add($ConvertIconSizeLabel)

  # 02: Convert Textures - Icon Sizes - Create a tooltip for the label.
  $ConvertIconSizeTip = New-Object Windows.Forms.ToolTip
  $ConvertIconSizeTip.InitialDelay = $ToolTipDelay
  $ConvertIconSizeTip.AutoPopDelay = $ToolTipDuration
  $ConvertIconSizeTipString =  'Icon files can contain various sizes of the{0}'
  $ConvertIconSizeTipString += 'same image, that display depending on{0}'
  $ConvertIconSizeTipString += 'the current "zoom" of the icon. This field{0}'
  $ConvertIconSizeTipString += "allows specifying which sizes are created{0}"
  $ConvertIconSizeTipString += "as a square, separated by commas. The{0}"
  $ConvertIconSizeTipString += "maximum size can be 256x256 pixels."
  $ConvertIconSizeTipString = [String]::Format($ConvertIconSizeTipString, [Environment]::NewLine)
  $ConvertIconSizeTip.SetToolTip($ConvertIconSizeLabel, $ConvertIconSizeTipString)

  # 02: Convert Textures - Icon Sizes - Create a textbox to hold the icon sizes.
  $global:ConvertIconSizeTextBox = New-Object Windows.Forms.TextBox
  $ConvertIconSizeTextBox.Size = DPISize (New-Object Drawing.Size(145, 20))
  $ConvertIconSizeTextBox.Location = DPISize (New-Object Drawing.Point(10, 98)) -AddY $DPIOffsetFix
  $ConvertIconSizeTextBox.Name = 'ConvertIconSizes'
  $ConvertIconSizeTextBox.Text = $ConvertIconSizes
  $ConvertIconSizeTextBox.Add_Leave({ UpdateIconSizesTextBox })
  $ConvertTextureGroup.Controls.Add($ConvertIconSizeTextBox)

  # 02: Convert Textures - Icon Sizes - Create a button to reset the textbox.
  $global:ConvertIconSizeButton = New-Object Windows.Forms.Button
  $ConvertIconSizeButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $ConvertIconSizeButton.Location = DPISize (New-Object Drawing.Point(157, 97))
  $ConvertIconSizeButton.Text = '-'
  $ConvertIconSizeButton.Enabled = $true
  $ConvertIconSizeButton.Add_Click({ ResetIconSizesTextBox })
  $ConvertTextureGroup.Controls.Add($ConvertIconSizeButton)

  # 02: Convert Textures - Icon Sizes - Create a tooltip for the button.
  $ConvertIconSizeButtonTip = New-Object Windows.Forms.ToolTip
  $ConvertIconSizeButtonTip.InitialDelay = $ToolTipDelay
  $ConvertIconSizeButtonTip.AutoPopDelay = $ToolTipDuration
  $ConvertIconSizeButtonTipString =  "Resets the icon sizes textbox to default{0}"
  $ConvertIconSizeButtonTipString += "values: 16, 24, 32, 48, 64, 128, 256."
  $ConvertIconSizeButtonTipString = [String]::Format($ConvertIconSizeButtonTipString, [Environment]::NewLine)
  $ConvertIconSizeButtonTip.SetToolTip($ConvertIconSizeButton, $ConvertIconSizeButtonTipString)

  # 02: Convert Textures - Location for Copy Non-Textures and Disable Sharpening checkboxes.
  ToggleIconSizeVisibility -SelectedItem $ConvertFormatCombo.SelectedItem

  # 02: Convert Textures - Auto-Repair Dimensions - Create a checkbox.
  $global:ConvertAutoRepair = New-Object Windows.Forms.CheckBox
  $ConvertAutoRepair.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ConvertAutoRepair.Location = DPISize (New-Object Drawing.Point(192, 22))
  $ConvertAutoRepair.Name = 'ConvertRepair'
  $ConvertAutoRepair.Checked = $ConvertRepair
  $ConvertAutoRepair.Text = ' Auto-Repair Dimensions'
  $ConvertAutoRepair.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleScaleFixThreshold })
  $ConvertTextureGroup.Controls.Add($ConvertAutoRepair)

  # 02: Convert Textures - Auto-Repair Dimensions - Create a tooltip.
  $ConvertAutoRepairTip = New-Object Windows.Forms.ToolTip
  $ConvertAutoRepairTip.InitialDelay = $ToolTipDelay
  $ConvertAutoRepairTip.AutoPopDelay = $ToolTipDuration
  $ConvertAutoRepairTipString =  'Attempt to repair textures that have decimal{0}'
  $ConvertAutoRepairTipString += 'scaling values to whole numbers. Scale-Fix{0}'
  $ConvertAutoRepairTipString += 'Threshold determines if the scale is rounded{0}'
  $ConvertAutoRepairTipString += 'up or down based on the decimal value.{0}'
  $ConvertAutoRepairTipString += '{0}'
  $ConvertAutoRepairTipString += 'Auto-Repair Enabled Example:{0}'
  $ConvertAutoRepairTipString += 'Original: 24x24, Custom: 75x75{0}'
  $ConvertAutoRepairTipString += 'PNG-New: 72x72, DDS-New: 72x72{0}'
  $ConvertAutoRepairTipString += '{0}'
  $ConvertAutoRepairTipString += 'Auto-Repair Disabled Example:{0}'
  $ConvertAutoRepairTipString += 'Original: 24x24, Custom: 75x75{0}'
  $ConvertAutoRepairTipString += 'PNG-New: 75x75, DDS-New: 76x76{0}'
  $ConvertAutoRepairTipString += '{0}'
  $ConvertAutoRepairTipString += 'The correct dimensions should be 72x72.'
  $ConvertAutoRepairTipString = [String]::Format($ConvertAutoRepairTipString, [Environment]::NewLine)
  $ConvertAutoRepairTip.SetToolTip($ConvertAutoRepair, $ConvertAutoRepairTipString)

  # 02: Convert Textures - Scale-Fix Threshold - Create a number selector.
  $global:ConvertScaleFixNumBox = New-Object Windows.Forms.NumericUpDown
  $ConvertScaleFixNumBox.Size = DPISize (New-Object Drawing.Size(50, 10))
  $ConvertScaleFixNumBox.Location = DPISize (New-Object Drawing.Point(192, 45)) -AddY $DPIOffsetFix
  $ConvertScaleFixNumBox.Name = 'ScaleThreshold'
  $ConvertScaleFixNumBox.DecimalPlaces = 2
  $ConvertScaleFixNumBox.Minimum = 0.00
  $ConvertScaleFixNumBox.Maximum = 0.99
  $ConvertScaleFixNumBox.Increment = 0.01
  $ConvertScaleFixNumBox.Value = $ScaleThreshold
  $ConvertScaleFixNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'decimal' ; Operations_UpdateScaleFixThreshold })
  $ConvertScaleFixNumBox.Enabled = $ConvertRepair
  $ConvertTextureGroup.Controls.Add($ConvertScaleFixNumBox)

  # 02: Convert Textures - Scale-Fix Threshold - Create a label.
  $global:ConvertScaleFixLabel = New-Object Windows.Forms.Label
  $ConvertScaleFixLabel.Size = DPISize (New-Object Drawing.Size(108, 22))
  $ConvertScaleFixLabel.Location = DPISize (New-Object Drawing.Point(244, 48))
  $ConvertScaleFixLabel.Text = 'Scale-Fix Threshold'
  $ConvertScaleFixLabel.Enabled = $ConvertRepair
  $ConvertTextureGroup.Controls.Add($ConvertScaleFixLabel)

  # 02: Convert Textures - Scale-Fix Threshold - Create a tooltip.
  $ConvertScaleFixTip = New-Object Windows.Forms.ToolTip
  $ConvertScaleFixTip.InitialDelay = $ToolTipDelay
  $ConvertScaleFixTip.AutoPopDelay = $ToolTipDuration
  $ConvertScaleFixTipString = 'The minimum decimal value of the{0}'
  $ConvertScaleFixTipString += 'scale required to auto-repair textures{0}'
  $ConvertScaleFixTipString += 'to the next highest integer scale.{0}'
  $ConvertScaleFixTipString += '{0}'
  $ConvertScaleFixTipString += 'Example:{0}'
  $ConvertScaleFixTipString += 'Scale-Fix Threshold = 0.45{0}'
  $ConvertScaleFixTipString += 'Scale of 4.01-4.44 downscales to 4x{0}'
  $ConvertScaleFixTipString += 'Scale of 4.45-4.99 upscales to 5x'
  $ConvertScaleFixTipString = [String]::Format($ConvertScaleFixTipString, [Environment]::NewLine)
  $ConvertScaleFixTip.SetToolTip($ConvertScaleFixLabel, $ConvertScaleFixTipString)

  # 02: Convert Textures - Auto-Rename Output - Create a checkbox.
  $global:ConvertAutoRename = New-Object Windows.Forms.Checkbox
  $ConvertAutoRename.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ConvertAutoRename.Location = DPISize (New-Object Drawing.Point(192, 80))
  $ConvertAutoRename.Name = 'AutoRenameCheck'
  $ConvertAutoRename.Checked = $false
  $ConvertAutoRename.Text = ' Auto-Rename Output:'
  $ConvertAutoRename.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_EnableAutoRenameOutput })
  $ConvertTextureGroup.Controls.Add($ConvertAutoRename)

  # 02: Convert Textures - Auto-Rename Output - Create a tooltip.
  $ConvertAutoRenameTip = New-Object Windows.Forms.ToolTip
  $ConvertAutoRenameTip.InitialDelay = $ToolTipDelay
  $ConvertAutoRenameTip.AutoPopDelay = $ToolTipDuration
  $ConvertAutoRenameTipString =  'Auto-rename the "ConvertedTextures"{0}'
  $ConvertAutoRenameTipString += 'folder to the specified text entered here.{0}'
  $ConvertAutoRenameTipString += 'This should usually be the first 3 letters{0}'
  $ConvertAutoRenameTipString += "of the texture pack's GameID. If the field{0}"
  $ConvertAutoRenameTipString += "is left empty, it will not be renamed."
  $ConvertAutoRenameTipString = [String]::Format($ConvertAutoRenameTipString, [Environment]::NewLine)
  $ConvertAutoRenameTip.SetToolTip($ConvertAutoRename, $ConvertAutoRenameTipString)

  # 02: Convert Textures - Auto-Rename Output - Create a textbox to hold the auto-rename.
  $global:ConvertAutoRenameTextBox = New-Object Windows.Forms.TextBox
  $ConvertAutoRenameTextBox.Size = DPISize (New-Object Drawing.Size(154, 20))
  $ConvertAutoRenameTextBox.Location = DPISize (New-Object Drawing.Point(192, 98)) -AddY $DPIOffsetFix
  $ConvertAutoRenameTextBox.Name = 'AutoRenameValue'
  $ConvertAutoRenameTextBox.Text = ''
  $ConvertAutoRenameTextBox.Enabled = $false
  $ConvertAutoRenameTextBox.Add_Click({ ClearTextBox })
  $ConvertAutoRenameTextBox.Add_Leave({ Operations_VerifyAutoRenameOutput })
  $ConvertTextureGroup.Controls.Add($ConvertAutoRenameTextBox)

  # 02: Convert Textures - Auto-Rename Output - Create a button to reset the textbox.
  $global:ConvertAutoRenameButton = New-Object Windows.Forms.Button
  $ConvertAutoRenameButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $ConvertAutoRenameButton.Location = DPISize (New-Object Drawing.Point(349, 97))
  $ConvertAutoRenameButton.Text = '-'
  $ConvertAutoRenameButton.Enabled = $false
  $ConvertAutoRenameButton.Add_Click({ Operations_ClearAutoRenameOutput })
  $ConvertTextureGroup.Controls.Add($ConvertAutoRenameButton)

  # 03: Rescale Textures - Create the groupbox that will hold the rescale texture options.
  $global:RescaleTextureGroup = New-Object Windows.Forms.GroupBox
  $RescaleTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $RescaleTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $RescaleTextureGroup.Text = ' Rescale Textures Options '
  $MainDialogPanel.Controls.Add($RescaleTextureGroup)

  # 03: Rescale Textures - Rescale Factor - Create a number selector.
  $global:RescaleFactorNumBox = New-Object Windows.Forms.NumericUpDown
  $RescaleFactorNumBox.Size = DPISize (New-Object Drawing.Size(80, 10))
  $RescaleFactorNumBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $RescaleFactorNumBox.Name = 'RescaleFactor'
  $RescaleFactorNumBox.DecimalPlaces = 2
  $RescaleFactorNumBox.Minimum = 0.01
  $RescaleFactorNumBox.Maximum = 16.00
  $RescaleFactorNumBox.Increment = 1.00
  $RescaleFactorNumBox.Value = $RescaleFactor
  $RescaleFactorNumBox.Add_ValueChanged({ RescaleUpDownModified -TypeDefinition 'decimal' })
  $RescaleTextureGroup.Controls.Add($RescaleFactorNumBox)

  # 03: Rescale Textures - Rescale Factor - Create a label.
  $global:RescaleFactorLabel = New-Object Windows.Forms.Label
  $RescaleFactorLabel.Size = DPISize (New-Object Drawing.Size(90, 22))
  $RescaleFactorLabel.Location = DPISize (New-Object Drawing.Point(92, 23))
  $RescaleFactorLabel.Text = 'Rescale Factor'
  $RescaleTextureGroup.Controls.Add($RescaleFactorLabel)

  # 03: Rescale Textures - Rescale Factor - Create a tooltip.
  $RescaleFactorTip = New-Object Windows.Forms.ToolTip
  $RescaleFactorTip.InitialDelay = $ToolTipDelay
  $RescaleFactorTip.AutoPopDelay = $ToolTipDuration
  $RescaleFactorTipString = 'The factor used to calculate the{0}'
  $RescaleFactorTipString += 'rescaled dimensions. The formula{0}'
  $RescaleFactorTipString += 'is simply the original dimensions{0}'
  $RescaleFactorTipString += 'multiplied by the rescale factor.{0}'
  $RescaleFactorTipString += '{0}'
  $RescaleFactorTipString += 'Decimal values work but should{0}'
  $RescaleFactorTipString += 'not be used for Dolphin textures.'
  $RescaleFactorTipString = [String]::Format($RescaleFactorTipString, [Environment]::NewLine)
  $RescaleFactorTip.SetToolTip($RescaleFactorLabel, $RescaleFactorTipString)

  # 03: Rescale Textures - Rescale Format - Create a combobox.
  $global:RescaleFormatCombo = New-Object Windows.Forms.ComboBox
  $RescaleFormatCombo.Size = DPISize (New-Object Drawing.Size(80, 28))
  $RescaleFormatCombo.Location = DPISize (New-Object Drawing.Point(10, 45)) -AddY $DPIOffsetFix
  $RescaleFormatCombo.Name = 'RescaleFormat'
  $RescaleFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $RescaleFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $RescaleFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Get-Variable -Name $this.SelectedItem -ValueOnly) })
  $RescaleFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $RescaleFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $RescaleTextureGroup.Controls.Add($RescaleFormatCombo)

  # 03: Rescale Textures - Rescale Format - Create a label.
  $global:RescaleFormatLabel = New-Object Windows.Forms.Label
  $RescaleFormatLabel.Size = DPISize (New-Object Drawing.Size(80, 22))
  $RescaleFormatLabel.Location = DPISize (New-Object Drawing.Point(92, 48))
  $RescaleFormatLabel.Text = 'Output Format'
  $RescaleTextureGroup.Controls.Add($RescaleFormatLabel)

  # 03: Rescale Textures - Rescale Format - Create a tooltip.
  $RescaleFormatTip = New-Object Windows.Forms.ToolTip
  $RescaleFormatTip.InitialDelay = $ToolTipDelay
  $RescaleFormatTip.AutoPopDelay = $ToolTipDuration
  $RescaleFormatTipString = 'The file extension/output format{0}'
  $RescaleFormatTipString += 'that textures will be created with.'
  $RescaleFormatTipString = [String]::Format($RescaleFormatTipString, [Environment]::NewLine)
  $RescaleFormatTip.SetToolTip($RescaleFormatLabel, $RescaleFormatTipString)

  # 03: Rescale Textures - Copy Non-Textures - Create a checkbox.
  $global:RescaleCopyNonTex = New-Object Windows.Forms.CheckBox
  $RescaleCopyNonTex.Size = DPISize (New-Object Drawing.Size(130, 16))
  $RescaleCopyNonTex.Location = DPISize (New-Object Drawing.Point(10, 74))
  $RescaleCopyNonTex.Name = 'CopyNonTextures'
  $RescaleCopyNonTex.Checked = $CopyNonTextures
  $RescaleCopyNonTex.Text = ' Copy Non-Textures'
  $RescaleCopyNonTex.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleCopyNonTextures })
  $RescaleTextureGroup.Controls.Add($RescaleCopyNonTex)

  # 03: Rescale Textures - Copy Non-Textures - Create a tooltip.
  $RescaleCopyNonTip = New-Object Windows.Forms.ToolTip
  $RescaleCopyNonTip.InitialDelay = $ToolTipDelay
  $RescaleCopyNonTip.AutoPopDelay = $ToolTipDuration
  $RescaleCopyNonTipString = 'Copies files that are not images such{0}'
  $RescaleCopyNonTipString += 'as (.txt) into the newly generated pack.'
  $RescaleCopyNonTipString = [String]::Format($RescaleCopyNonTipString, [Environment]::NewLine)
  $RescaleCopyNonTip.SetToolTip($RescaleCopyNonTex, $RescaleCopyNonTipString)

  # 03: Rescale Textures - Enable AutoSharpen - Create a checkbox.
  $global:RescaleEnableSharpen = New-Object Windows.Forms.CheckBox
  $RescaleEnableSharpen.Size = DPISize (New-Object Drawing.Size(130, 16))
  $RescaleEnableSharpen.Location = DPISize (New-Object Drawing.Point(10, 98))
  $RescaleEnableSharpen.Name = 'EnableSharpen'
  $RescaleEnableSharpen.Checked = $EnableSharpen
  $RescaleEnableSharpen.Text = ' Enable Sharpening'
  $RescaleEnableSharpen.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleEnableSharpen })
  $RescaleTextureGroup.Controls.Add($RescaleEnableSharpen)

  # 03: Rescale Textures - Enable AutoSharpen - Create a tooltip.
  $RescaleEnableSharpenTip = New-Object Windows.Forms.ToolTip
  $RescaleEnableSharpenTip.InitialDelay = $ToolTipDelay
  $RescaleEnableSharpenTip.AutoPopDelay = $ToolTipDuration
  $RescaleEnableSharpenTipString =  'Applies a sharpening filter to all textures{0}'
  $RescaleEnableSharpenTipString += 'when they are resized for any reason. The{0}'
  $RescaleEnableSharpenTipString += 'amount of sharpening is calculated based{0}'
  $RescaleEnableSharpenTipString += 'on the amount of change in resolution. It{0}'
  $RescaleEnableSharpenTipString += 'affects resized textures and all mipmaps,{0}'
  $RescaleEnableSharpenTipString += 'material maps, and generated icons.{0}'
  $RescaleEnableSharpenTipString += '{0}'
  $RescaleEnableSharpenTipString += 'In the past, this was always applied. This{0}'
  $RescaleEnableSharpenTipString += 'option was added in v50.0 as sharpening{0}'
  $RescaleEnableSharpenTipString += 'may not look so good for certain images.{0}'
  $RescaleEnableSharpenTipString += 'If unsure, keep enabled for texture packs{0}'
  $RescaleEnableSharpenTipString += 'and disable it when creating icon files.'
  $RescaleEnableSharpenTipString = [String]::Format($RescaleEnableSharpenTipString, [Environment]::NewLine)
  $RescaleEnableSharpenTip.SetToolTip($RescaleEnableSharpen, $RescaleEnableSharpenTipString)

  # 03: Rescale Textures - Rescale Condition - Create a combobox.
  $global:RescaleCondCombo = New-Object Windows.Forms.ComboBox
  $RescaleCondCombo.Size = DPISize (New-Object Drawing.Size(80, 28))
  $RescaleCondCombo.Location = DPISize (New-Object Drawing.Point(192, 16)) -AddY $DPIOffsetFix
  $RescaleCondCombo.Name = 'RescaleScaling'
  $RescaleCondCombo.Items.Add('Always') | Out-Null
  $RescaleCondCombo.Items.Add('Downscale') | Out-Null
  $RescaleCondCombo.Items.Add('Upscale') | Out-Null
  $RescaleCondCombo.SelectedItem = $RescaleScaling
  $RescaleCondCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $RescaleCondCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $RescaleCondCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $RescaleCondCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $RescaleCondCombo.Add_DrawItem({ RepopulateComboBox })
  $RescaleTextureGroup.Controls.Add($RescaleCondCombo)

  # 03: Rescale Textures - Rescale Condition - Create a label.
  $global:RescaleCondLabel = New-Object Windows.Forms.Label
  $RescaleCondLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $RescaleCondLabel.Location = DPISize (New-Object Drawing.Point(275, 19))
  $RescaleCondLabel.Text = 'Rescale Condition'
  $RescaleTextureGroup.Controls.Add($RescaleCondLabel)

  # 03: Rescale Textures - Rescale Condition - Create a tooltip.
  $RescaleCondTip = New-Object Windows.Forms.ToolTip
  $RescaleCondTip.InitialDelay = $ToolTipDelay
  $RescaleCondTip.AutoPopDelay = $ToolTipDuration
  $RescaleCondTipString =  'Filters which textures are rescaled. The value that is{0}'
  $RescaleCondTipString += 'entered for the "Rescale Factor" is compared to the{0}'
  $RescaleCondTipString += "texture's current scale, and the texture will only be{0}"
  $RescaleCondTipString += 'rescaled if the selected "Rescale Condition" is met.{0}'
  $RescaleCondTipString += '{0}'
  $RescaleCondTipString += 'Always: Textures will always be rescaled.{0}'
  $RescaleCondTipString += "Downscale: Scale must exceed the Rescale Factor.{0}"
  $RescaleCondTipString += "Upscale: Scale must be less than the Rescale Factor."
  $RescaleCondTipString = [String]::Format($RescaleCondTipString, [Environment]::NewLine)
  $RescaleCondTip.SetToolTip($RescaleCondLabel, $RescaleCondTipString)

  # 03: Rescale Textures - Dolphin Dimensions - Create a checkbox.
  $global:RescaleDolphinDimCheck = New-Object Windows.Forms.CheckBox
  $RescaleDolphinDimCheck.Size = DPISize (New-Object Drawing.Size(186, 16))
  $RescaleDolphinDimCheck.Location = DPISize (New-Object Drawing.Point(192, 40))
  $RescaleDolphinDimCheck.Name = 'RescaleDolphinReal'
  $RescaleDolphinDimCheck.Checked = $RescaleDolphinReal
  $RescaleDolphinDimCheck.Text = ' Use Real Dimensions (Dolphin)'
  $RescaleDolphinDimCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $RescaleTextureGroup.Controls.Add($RescaleDolphinDimCheck)

  # 03: Rescale Textures - Dolphin Dimensions - Create a tooltip.
  $RescaleDolphinDimTip = New-Object Windows.Forms.ToolTip
  $RescaleDolphinDimTip.InitialDelay = $ToolTipDelay
  $RescaleDolphinDimTip.AutoPopDelay = $ToolTipDuration
  $RescaleDolphinDimTipString  = 'Scales Dolphin textures using the current dimensions{0}'
  $RescaleDolphinDimTipString += 'of textures instead of the original dimensions. For an{0}'
  $RescaleDolphinDimTipString += 'example, if a "tex1" texture has an original resolution{0}'
  $RescaleDolphinDimTipString += 'of 64x64, is scaled 8x to 512x512, the Rescale Factor{0}'
  $RescaleDolphinDimTipString += 'is set to 4x, and this option is disabled, then the texture{0}'
  $RescaleDolphinDimTipString += "output resolution is 256x256 (64*4). When it's enabled,{0}"
  $RescaleDolphinDimTipString += 'the output would be 2048x2048 (512*4). Non-Dolphin{0}'
  $RescaleDolphinDimTipString += 'textures always use the current dimensions as there is{0}'
  $RescaleDolphinDimTipString += 'no way to determine the original dimensions.{0}'
  $RescaleDolphinDimTipString += '{0}'
  $RescaleDolphinDimTipString += 'An example of when this could be useful is creating a{0}'
  $RescaleDolphinDimTipString += 'downscaled pack that halves the current resolution of{0}'
  $RescaleDolphinDimTipString += 'all textures. This can be achieved by enabling this and{0}'
  $RescaleDolphinDimTipString += 'setting Rescale Factor to 0.50 (dimensions * 0.50).'
  $RescaleDolphinDimTipString = [String]::Format($RescaleDolphinDimTipString, [Environment]::NewLine)
  $RescaleDolphinDimTip.SetToolTip($RescaleDolphinDimCheck, $RescaleDolphinDimTipString)

  # 03: Rescale Textures - Manual Rescale - Create a checkbox.
  $global:RescaleManualCheck = New-Object Windows.Forms.CheckBox
  $RescaleManualCheck.Size = DPISize (New-Object Drawing.Size(130, 16))
  $RescaleManualCheck.Location = DPISize (New-Object Drawing.Point(192, 60))
  $RescaleManualCheck.Name = 'ManualRescale'
  $RescaleManualCheck.Checked = $ManualRescale
  $RescaleManualCheck.Text = ' Manual Rescale'
  $RescaleManualCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $RescaleTextureGroup.Controls.Add($RescaleManualCheck)

  # 03: Rescale Textures - Manual Rescale - Create a tooltip.
  $RescaleManualTip = New-Object Windows.Forms.ToolTip
  $RescaleManualTip.InitialDelay = $ToolTipDelay
  $RescaleManualTip.AutoPopDelay = $ToolTipDuration
  $RescaleManualTipString = 'This option allows rescaling each texture{0}'
  $RescaleManualTipString += 'individually. Large scaling values ranging{0}'
  $RescaleManualTipString += "from 1-100 can be used. The amount that{0}"
  $RescaleManualTipString += 'is entered in Rescale Factor acts as default.{0}'
  $RescaleManualTipString += '{0}'
  $RescaleManualTipString += 'It is NOT suggested to use this option on{0}'
  $RescaleManualTipString += 'packs with a lot of textures. This is a niche{0}'
  $RescaleManualTipString += 'option designed to scale a few textures.'
  $RescaleManualTipString = [String]::Format($RescaleManualTipString, [Environment]::NewLine)
  $RescaleManualTip.SetToolTip($RescaleManualCheck, $RescaleManualTipString)

  # 03: Rescale Textures - Auto-Rename Output - Create a checkbox.
  $global:RescaleAutoRename = New-Object Windows.Forms.Checkbox
  $RescaleAutoRename.Size = DPISize (New-Object Drawing.Size(150, 16))
  $RescaleAutoRename.Location = DPISize (New-Object Drawing.Point(192, 80))
  $RescaleAutoRename.Name = 'AutoRenameCheck'
  $RescaleAutoRename.Checked = $false
  $RescaleAutoRename.Text = ' Auto-Rename Output:'
  $RescaleAutoRename.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_EnableAutoRenameOutput })
  $RescaleTextureGroup.Controls.Add($RescaleAutoRename)

  # 03: Rescale Textures - Auto-Rename Output - Create a tooltip.
  $RescaleAutoRenameTip = New-Object Windows.Forms.ToolTip
  $RescaleAutoRenameTip.InitialDelay = $ToolTipDelay
  $RescaleAutoRenameTip.AutoPopDelay = $ToolTipDuration
  $RescaleAutoRenameTipString =  'Auto-rename the "RescaledTextures"{0}'
  $RescaleAutoRenameTipString += 'folder to the specified text entered here.{0}'
  $RescaleAutoRenameTipString += 'This should usually be the first 3 letters{0}'
  $RescaleAutoRenameTipString += "of the texture pack's GameID. If the field{0}"
  $RescaleAutoRenameTipString += "is left empty, it will not be renamed."
  $RescaleAutoRenameTipString = [String]::Format($RescaleAutoRenameTipString, [Environment]::NewLine)
  $RescaleAutoRenameTip.SetToolTip($RescaleAutoRename, $RescaleAutoRenameTipString)

  # 03: Rescale Textures - Auto-Rename Output - Create a textbox.
  $global:RescaleAutoRenameTextBox = New-Object Windows.Forms.TextBox
  $RescaleAutoRenameTextBox.Size = DPISize (New-Object Drawing.Size(154, 20))
  $RescaleAutoRenameTextBox.Location = DPISize (New-Object Drawing.Point(192, 98)) -AddY $DPIOffsetFix
  $RescaleAutoRenameTextBox.Name = 'AutoRenameValue'
  $RescaleAutoRenameTextBox.Text = ''
  $RescaleAutoRenameTextBox.Enabled = $false
  $RescaleAutoRenameTextBox.Add_Click({ ClearTextBox })
  $RescaleAutoRenameTextBox.Add_Leave({ Operations_VerifyAutoRenameOutput })
  $RescaleTextureGroup.Controls.Add($RescaleAutoRenameTextBox)

  # 03: Rescale Textures - Auto-Rename Output - Create a checkbox.
  $global:RescaleAutoRenameButton = New-Object Windows.Forms.Button
  $RescaleAutoRenameButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $RescaleAutoRenameButton.Location = DPISize (New-Object Drawing.Point(349, 97))
  $RescaleAutoRenameButton.Text = '-'
  $RescaleAutoRenameButton.Enabled = $false
  $RescaleAutoRenameButton.Add_Click({ Operations_ClearAutoRenameOutput })
  $RescaleTextureGroup.Controls.Add($RescaleAutoRenameButton)

  # 04: Resize Textures - Create the groupbox that will hold the resize texture options.
  $global:ResizeTextureGroup = New-Object Windows.Forms.GroupBox
  $ResizeTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ResizeTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ResizeTextureGroup.Text = ' Resize Textures Options '
  $MainDialogPanel.Controls.Add($ResizeTextureGroup)

  # 04: Resize Textures - Resize Dimensions - Width - Controls the new width of the texture.
  $global:ResizeWidthNumBox = New-Object Windows.Forms.NumericUpDown
  $ResizeWidthNumBox.Size = DPISize (New-Object Drawing.Size(54, 10))
  $ResizeWidthNumBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $ResizeWidthNumBox.Name = 'ResizeWidth'
  $ResizeWidthNumBox.DecimalPlaces = 0
  $ResizeWidthNumBox.Minimum = 1
  $ResizeWidthNumBox.Maximum = 32768
  $ResizeWidthNumBox.Increment = 1
  $ResizeWidthNumBox.Value = $ResizeWidth
  $ResizeWidthNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $ResizeTextureGroup.Controls.Add($ResizeWidthNumBox)

  # 04: Resize Textures - Resize Dimensions - A label to separate width and height using an "x".
  $global:ResizeDimensionsLabelX = New-Object Windows.Forms.Label
  $ResizeDimensionsLabelX.Size = DPISize (New-Object Drawing.Size(10, 20))
  $ResizeDimensionsLabelX.Location = DPISize (New-Object Drawing.Point(66, 22))
  $ResizeDimensionsLabelX.Text = 'x'
  $ResizeTextureGroup.Controls.Add($ResizeDimensionsLabelX)

  # 04: Resize Textures - Resize Dimensions - Height - Controls the new height of the texture.
  $global:ResizeHeightNumBox = New-Object Windows.Forms.NumericUpDown
  $ResizeHeightNumBox.Size = DPISize (New-Object Drawing.Size(54, 10))
  $ResizeHeightNumBox.Location = DPISize (New-Object Drawing.Point(78, 20)) -AddY $DPIOffsetFix
  $ResizeHeightNumBox.Name = 'ResizeHeight'
  $ResizeHeightNumBox.DecimalPlaces = 0
  $ResizeHeightNumBox.Minimum = 1
  $ResizeHeightNumBox.Maximum = 32768
  $ResizeHeightNumBox.Increment = 1
  $ResizeHeightNumBox.Value = $ResizeHeight
  $ResizeHeightNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $ResizeTextureGroup.Controls.Add($ResizeHeightNumBox)

  # 04: Resize Textures - Resize Dimensions - The label for the resolution.
  $global:ResizeDimensionsLabel = New-Object Windows.Forms.Label
  $ResizeDimensionsLabel.Size = DPISize (New-Object Drawing.Size(70, 22))
  $ResizeDimensionsLabel.Location = DPISize (New-Object Drawing.Point(136, 23))
  $ResizeDimensionsLabel.Text = 'Dimensions'
  $ResizeTextureGroup.Controls.Add($ResizeDimensionsLabel)

  # 04: Resize Textures - Resize Format - Create a tooltip.
  $ResizeDimensionsTip = New-Object Windows.Forms.ToolTip
  $ResizeDimensionsTip.InitialDelay = $ToolTipDelay
  $ResizeDimensionsTip.AutoPopDelay = $ToolTipDuration
  $ResizeDimensionsTipString = 'Dimensions that all images will be created.'
  $ResizeDimensionsTip.SetToolTip($ResizeDimensionsLabel, $ResizeDimensionsTipString)

  # 04: Resize Textures - Resize Format - Create a combobox.
  $global:ResizeFormatCombo = New-Object Windows.Forms.ComboBox
  $ResizeFormatCombo.Size = DPISize (New-Object Drawing.Size(122, 28))
  $ResizeFormatCombo.Location = DPISize (New-Object Drawing.Point(10, 45)) -AddY $DPIOffsetFix
  $ResizeFormatCombo.Name = 'ResizeFormat'
  $ResizeFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ResizeFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $ResizeFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Get-Variable -Name $this.SelectedItem -ValueOnly) })
  $ResizeFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ResizeFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $ResizeTextureGroup.Controls.Add($ResizeFormatCombo)

  # 04: Resize Textures - Resize Format - Create a label.
  $global:ResizeFormatLabel = New-Object Windows.Forms.Label
  $ResizeFormatLabel.Size = DPISize (New-Object Drawing.Size(80, 22))
  $ResizeFormatLabel.Location = DPISize (New-Object Drawing.Point(136, 48))
  $ResizeFormatLabel.Text = 'Output Format'
  $ResizeTextureGroup.Controls.Add($ResizeFormatLabel)

  # 04: Resize Textures - Resize Format - Create a tooltip.
  $ResizeFormatTip = New-Object Windows.Forms.ToolTip
  $ResizeFormatTip.InitialDelay = $ToolTipDelay
  $ResizeFormatTip.AutoPopDelay = $ToolTipDuration
  $ResizeFormatTipString = 'The file extension/output format{0}'
  $ResizeFormatTipString += 'that textures will be created with.'
  $ResizeFormatTipString = [String]::Format($ResizeFormatTipString, [Environment]::NewLine)
  $ResizeFormatTip.SetToolTip($ResizeFormatLabel, $ResizeFormatTipString)

  # 04: Resize Textures - Copy Non-Textures - Create a checkbox.
  $global:ResizeCopyNonTex = New-Object Windows.Forms.CheckBox
  $ResizeCopyNonTex.Size = DPISize (New-Object Drawing.Size(130, 16))
  $ResizeCopyNonTex.Location = DPISize (New-Object Drawing.Point(10, 74))
  $ResizeCopyNonTex.Name = 'CopyNonTextures'
  $ResizeCopyNonTex.Checked = $CopyNonTextures
  $ResizeCopyNonTex.Text = ' Copy Non-Textures'
  $ResizeCopyNonTex.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleCopyNonTextures })
  $ResizeTextureGroup.Controls.Add($ResizeCopyNonTex)

  # 04: Resize Textures - Copy Non-Textures - Create a tooltip.
  $ResizeCopyNonTip = New-Object Windows.Forms.ToolTip
  $ResizeCopyNonTip.InitialDelay = $ToolTipDelay
  $ResizeCopyNonTip.AutoPopDelay = $ToolTipDuration
  $ResizeCopyNonTipString = 'Copies files that are not images such{0}'
  $ResizeCopyNonTipString += 'as (.txt) into the newly generated pack.'
  $ResizeCopyNonTipString = [String]::Format($ResizeCopyNonTipString, [Environment]::NewLine)
  $ResizeCopyNonTip.SetToolTip($ResizeCopyNonTex, $ResizeCopyNonTipString)

  # 04: Resize Textures - Enable AutoSharpen - Create a checkbox.
  $global:ResizeEnableSharpen = New-Object Windows.Forms.CheckBox
  $ResizeEnableSharpen.Size = DPISize (New-Object Drawing.Size(130, 16))
  $ResizeEnableSharpen.Location = DPISize (New-Object Drawing.Point(10, 98))
  $ResizeEnableSharpen.Name = 'EnableSharpen'
  $ResizeEnableSharpen.Checked = $EnableSharpen
  $ResizeEnableSharpen.Text = ' Enable Sharpening'
  $ResizeEnableSharpen.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleEnableSharpen })
  $ResizeTextureGroup.Controls.Add($ResizeEnableSharpen)

  # 04: Resize Textures - Enable AutoSharpen - Create a tooltip.
  $ResizeEnableSharpenTip = New-Object Windows.Forms.ToolTip
  $ResizeEnableSharpenTip.InitialDelay = $ToolTipDelay
  $ResizeEnableSharpenTip.AutoPopDelay = $ToolTipDuration
  $ResizeEnableSharpenTipString =  'Applies a sharpening filter to all textures{0}'
  $ResizeEnableSharpenTipString += 'when they are resized for any reason. The{0}'
  $ResizeEnableSharpenTipString += 'amount of sharpening is calculated based{0}'
  $ResizeEnableSharpenTipString += 'on the amount of change in resolution. It{0}'
  $ResizeEnableSharpenTipString += 'affects resized textures and all mipmaps,{0}'
  $ResizeEnableSharpenTipString += 'material maps, and generated icons.{0}'
  $ResizeEnableSharpenTipString += '{0}'
  $ResizeEnableSharpenTipString += 'In the past, this was always applied. This{0}'
  $ResizeEnableSharpenTipString += 'option was added in v50.0 as sharpening{0}'
  $ResizeEnableSharpenTipString += 'may not look so good for certain images.{0}'
  $ResizeEnableSharpenTipString += 'If unsure, keep enabled for texture packs{0}'
  $ResizeEnableSharpenTipString += 'and disable it when creating icon files.'
  $ResizeEnableSharpenTipString = [String]::Format($ResizeEnableSharpenTipString, [Environment]::NewLine)
  $ResizeEnableSharpenTip.SetToolTip($ResizeEnableSharpen, $ResizeEnableSharpenTipString)

  # 04: Resize Textures - Auto-Rename Output - Create a checkbox.
  $global:ResizeAutoRename = New-Object Windows.Forms.Checkbox
  $ResizeAutoRename.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ResizeAutoRename.Location = DPISize (New-Object Drawing.Point(192, 80))
  $ResizeAutoRename.Name = 'AutoRenameCheck'
  $ResizeAutoRename.Checked = $false
  $ResizeAutoRename.Text = ' Auto-Rename Output:'
  $ResizeAutoRename.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_EnableAutoRenameOutput })
  $ResizeTextureGroup.Controls.Add($ResizeAutoRename)

  # 04: Resize Textures - Auto-Rename Output - Create a tooltip.
  $ResizeAutoRenameTip = New-Object Windows.Forms.ToolTip
  $ResizeAutoRenameTip.InitialDelay = $ToolTipDelay
  $ResizeAutoRenameTip.AutoPopDelay = $ToolTipDuration
  $ResizeAutoRenameTipString =  'Auto-rename the "ResizedTextures"{0}'
  $ResizeAutoRenameTipString += 'folder to the specified text entered here.{0}'
  $ResizeAutoRenameTipString += 'This should usually be the first 3 letters{0}'
  $ResizeAutoRenameTipString += "of the texture pack's GameID. If the field{0}"
  $ResizeAutoRenameTipString += "is left empty, it will not be renamed."
  $ResizeAutoRenameTipString = [String]::Format($ResizeAutoRenameTipString, [Environment]::NewLine)
  $ResizeAutoRenameTip.SetToolTip($ResizeAutoRename, $ResizeAutoRenameTipString)

  # 04: Resize Textures - Auto-Rename Output - Create a textbox.
  $global:ResizeAutoRenameTextBox = New-Object Windows.Forms.TextBox
  $ResizeAutoRenameTextBox.Size = DPISize (New-Object Drawing.Size(154, 20))
  $ResizeAutoRenameTextBox.Location = DPISize (New-Object Drawing.Point(192, 98)) -AddY $DPIOffsetFix
  $ResizeAutoRenameTextBox.Name = 'AutoRenameValue'
  $ResizeAutoRenameTextBox.Text = ''
  $ResizeAutoRenameTextBox.Enabled = $false
  $ResizeAutoRenameTextBox.Add_Click({ ClearTextBox })
  $ResizeAutoRenameTextBox.Add_Leave({ Operations_VerifyAutoRenameOutput })
  $ResizeTextureGroup.Controls.Add($ResizeAutoRenameTextBox)

  # 04: Resize Textures - Auto-Rename Output - Create a checkbox.
  $global:ResizeAutoRenameButton = New-Object Windows.Forms.Button
  $ResizeAutoRenameButton.Size = DPISize (New-Object Drawing.Size(22, 22))
  $ResizeAutoRenameButton.Location = DPISize (New-Object Drawing.Point(349, 97))
  $ResizeAutoRenameButton.Text = '-'
  $ResizeAutoRenameButton.Enabled = $false
  $ResizeAutoRenameButton.Add_Click({ Operations_ClearAutoRenameOutput })
  $ResizeTextureGroup.Controls.Add($ResizeAutoRenameButton)

  # 05: Create Watermark - Create the groupbox that will hold the watermark texture options.
  $global:WatermarkImageGroup = New-Object Windows.Forms.GroupBox
  $WatermarkImageGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $WatermarkImageGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $WatermarkImageGroup.Text = ' Watermark Options '
  $MainDialogPanel.Controls.Add($WatermarkImageGroup)

  # 05: Create Watermark - Text Length - Controls how many characters are displayed in the watermark.
  $global:WatermarkLengthNumBox = New-Object Windows.Forms.NumericUpDown
  $WatermarkLengthNumBox.Size = DPISize (New-Object Drawing.Size(72, 10))
  $WatermarkLengthNumBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $WatermarkLengthNumBox.Name = 'WM_Length'
  $WatermarkLengthNumBox.DecimalPlaces = 0
  $WatermarkLengthNumBox.Minimum = 0
  $WatermarkLengthNumBox.Maximum = 22
  $WatermarkLengthNumBox.Increment = 1
  $WatermarkLengthNumBox.Value = $WM_Length
  $WatermarkLengthNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $WatermarkImageGroup.Controls.Add($WatermarkLengthNumBox)

  # 05: Create Watermark - Text Length - Create a label.
  $global:WatermarkLengthLabel = New-Object Windows.Forms.Label
  $WatermarkLengthLabel.Size = DPISize (New-Object Drawing.Size(70, 22))
  $WatermarkLengthLabel.Location = DPISize (New-Object Drawing.Point(85, 23))
  $WatermarkLengthLabel.Text = 'Text Length'
  $WatermarkImageGroup.Controls.Add($WatermarkLengthLabel)

  # 05: Create Watermark - Text Length - Create a tooltip.
  $WatermarkLengthTip = New-Object Windows.Forms.ToolTip
  $WatermarkLengthTip.InitialDelay = $ToolTipDelay
  $WatermarkLengthTip.AutoPopDelay = $ToolTipDuration
  $WatermarkLengthTipString = 'Defines how many characters to pull{0}'
  $WatermarkLengthTipString += 'from the end of the texture name to{0}'
  $WatermarkLengthTipString += 'show as a watermark over the image.{0}'
  $WatermarkLengthTipString += '{0}'
  $WatermarkLengthTipString += 'A value of 0 uses the entire name.{0}'
  $WatermarkLengthTipString += 'A value of 1-5 forces the value 6.'
  $WatermarkLengthTipString = [String]::Format($WatermarkLengthTipString, [Environment]::NewLine)
  $WatermarkLengthTip.SetToolTip($WatermarkLengthLabel, $WatermarkLengthTipString)

  # 05: Create Watermark - Font Size - Determines the font size of the watermark.
  $global:WatermarkFontSizeNumBox = New-Object Windows.Forms.NumericUpDown
  $WatermarkFontSizeNumBox.Size = DPISize (New-Object Drawing.Size(72, 10))
  $WatermarkFontSizeNumBox.Location = DPISize (New-Object Drawing.Point(10, 44)) -AddY $DPIOffsetFix
  $WatermarkFontSizeNumBox.Name = 'WM_FontSize'
  $WatermarkFontSizeNumBox.DecimalPlaces = 0
  $WatermarkFontSizeNumBox.Minimum = 1
  $WatermarkFontSizeNumBox.Maximum = 20
  $WatermarkFontSizeNumBox.Increment = 1
  $WatermarkFontSizeNumBox.Value = $WM_FontSize
  $WatermarkFontSizeNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $WatermarkImageGroup.Controls.Add($WatermarkFontSizeNumBox)

  # 05: Create Watermark - Font Size - Create a label.
  $global:WatermarkFontSizeLabel = New-Object Windows.Forms.Label
  $WatermarkFontSizeLabel.Size = DPISize (New-Object Drawing.Size(60, 22))
  $WatermarkFontSizeLabel.Location = DPISize (New-Object Drawing.Point(85, 47))
  $WatermarkFontSizeLabel.Text = 'Font Size'
  $WatermarkImageGroup.Controls.Add($WatermarkFontSizeLabel)

  # 05: Create Watermark - Font Size - Create a tooltip.
  $WatermarkFontSizeTip = New-Object Windows.Forms.ToolTip
  $WatermarkFontSizeTip.InitialDelay = $ToolTipDelay
  $WatermarkFontSizeTip.AutoPopDelay = $ToolTipDuration
  $WatermarkFontSizeTipString = 'The font size of the watermark. The{0}'
  $WatermarkFontSizeTipString += 'actual font size is calculated with the{0}'
  $WatermarkFontSizeTipString += 'formula (NewWidth / 128 * FontSize).{0}'
  $WatermarkFontSizeTipString += 'This ensures that the font remains a{0}'
  $WatermarkFontSizeTipString += 'constant size across all textures.'
  $WatermarkFontSizeTipString = [String]::Format($WatermarkFontSizeTipString, [Environment]::NewLine)
  $WatermarkFontSizeTip.SetToolTip($WatermarkFontSizeLabel, $WatermarkFontSizeTipString)

  # 05: Create Watermark - Font FG Color - Determines the color of the font.
  $global:WatermarkFontColor = New-Object Windows.Forms.Button
  $WatermarkFontColor.Size = DPISize (New-Object Drawing.Size(74, 22))
  $WatermarkFontColor.Location = DPISize (New-Object Drawing.Point(9, 68))
  $WatermarkFontColor.Name = 'WM_FontColor'
  $WatermarkFontColor.BackColor = [Drawing.ColorTranslator]::FromHtml($WM_FontColor)
  $WatermarkFontColor.Add_Click({ Watermark_ShowColorDialog })
  $WatermarkImageGroup.Controls.Add($WatermarkFontColor)

  # 05: Create Watermark - Font FG Color - Create a label.
  $global:WatermarkFontColorLabel = New-Object Windows.Forms.Label
  $WatermarkFontColorLabel.Size = DPISize (New-Object Drawing.Size(80, 22))
  $WatermarkFontColorLabel.Location = DPISize (New-Object Drawing.Point(85, 72))
  $WatermarkFontColorLabel.Text = 'Font FG Color'
  $WatermarkImageGroup.Controls.Add($WatermarkFontColorLabel)

  # 05: Create Watermark - Font FG Color - Create a tooltip.
  $WatermarkFontColorTip = New-Object Windows.Forms.ToolTip
  $WatermarkFontColorTip.InitialDelay = $ToolTipDelay
  $WatermarkFontColorTip.AutoPopDelay = $ToolTipDuration
  $WatermarkFontColorTipString =  'Defines the color of the font{0}'
  $WatermarkFontColorTipString += 'used for the watermark text.'
  $WatermarkFontColorTipString = [String]::Format($WatermarkFontColorTipString, [Environment]::NewLine)
  $WatermarkFontColorTip.SetToolTip($WatermarkFontColorLabel, $WatermarkFontColorTipString)

  # 05: Create Watermark - Font BG Color - Determines the background color of the font.
  $global:WatermarkBGColor = New-Object Windows.Forms.Button
  $WatermarkBGColor.Size = DPISize (New-Object Drawing.Size(74, 22))
  $WatermarkBGColor.Location = DPISize (New-Object Drawing.Point(9, 94))
  $WatermarkBGColor.Name = 'WM_BGColor'
  $WatermarkBGColor.BackColor = [Drawing.ColorTranslator]::FromHtml($WM_BGColor)
  $WatermarkBGColor.Add_Click({ Watermark_ShowColorDialog })
  $WatermarkImageGroup.Controls.Add($WatermarkBGColor)

  # 05: Create Watermark - Font FG Color - Create a label.
  $global:WatermarkBGColorLabel = New-Object Windows.Forms.Label
  $WatermarkBGColorLabel.Size = DPISize (New-Object Drawing.Size(80, 20))
  $WatermarkBGColorLabel.Location = DPISize (New-Object Drawing.Point(85, 98))
  $WatermarkBGColorLabel.Text = 'Font BG Color'
  $WatermarkImageGroup.Controls.Add($WatermarkBGColorLabel)

  # 05: Create Watermark - Font FG Color - Create a tooltip.
  $WatermarkBGColorTip = New-Object Windows.Forms.ToolTip
  $WatermarkBGColorTip.InitialDelay = $ToolTipDelay
  $WatermarkBGColorTip.AutoPopDelay = $ToolTipDuration
  $WatermarkBGColorTipString =  'Defines the color of the background{0}'
  $WatermarkBGColorTipString += 'that surrounds the watermark text.'
  $WatermarkBGColorTipString = [String]::Format($WatermarkBGColorTipString, [Environment]::NewLine)
  $WatermarkBGColorTip.SetToolTip($WatermarkBGColorLabel, $WatermarkBGColorTipString)

  # 05: Create Watermark - Font Face - Selects the font for the watermark.
  $global:WatermarkFontCombo = New-Object Windows.Forms.ComboBox
  $WatermarkFontCombo.Size = DPISize (New-Object Drawing.Size(120, 10))
  $WatermarkFontCombo.Location = DPISize (New-Object Drawing.Point(192, 20))
  $WatermarkFontCombo.Name = 'WM_FontFace'
  $WatermarkFontCombo.Items.Add('Arial-Bold') | Out-Null
  $WatermarkFontCombo.Items.Add('Comic-Sans-MS-Bold') | Out-Null
  $WatermarkFontCombo.Items.Add('Courier-New-Bold') | Out-Null
  $WatermarkFontCombo.Items.Add('Georgia-Bold') | Out-Null
  $WatermarkFontCombo.Items.Add('Lucida-Console') | Out-Null
  $WatermarkFontCombo.Items.Add('Sylfaen') | Out-Null
  $WatermarkFontCombo.Items.Add('Times-New-Roman-Bold') | Out-Null
  $WatermarkFontCombo.Items.Add('Trebuchet-MS-Bold') | Out-Null
  $WatermarkFontCombo.Items.Add('Verdana-Bold') | Out-Null 
  $WatermarkFontCombo.SelectedItem = $WM_FontFace
  $WatermarkFontCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $WatermarkFontCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $WatermarkFontCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $WatermarkFontCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $WatermarkFontCombo.Add_DrawItem({ RepopulateComboBox })
  $WatermarkImageGroup.Controls.Add($WatermarkFontCombo)

  # 05: Create Watermark - Font Face - Create a label.
  $global:WatermarkFontFaceLabel = New-Object Windows.Forms.Label
  $WatermarkFontFaceLabel.Size = DPISize (New-Object Drawing.Size(60, 16))
  $WatermarkFontFaceLabel.Location = DPISize (New-Object Drawing.Point(315, 23))
  $WatermarkFontFaceLabel.Text = 'Font Face'
  $WatermarkImageGroup.Controls.Add($WatermarkFontFaceLabel)

  # 05: Create Watermark - Font Face - Create a tooltip.
  $WatermarkFontFaceTip = New-Object Windows.Forms.ToolTip
  $WatermarkFontFaceTip.InitialDelay = $ToolTipDelay
  $WatermarkFontFaceTip.AutoPopDelay = $ToolTipDuration
  $WatermarkFontFaceTipString =  'Defines the font that will be{0}'
  $WatermarkFontFaceTipString += 'used for the watermark overlay.'
  $WatermarkFontFaceTipString = [String]::Format($WatermarkFontFaceTipString, [Environment]::NewLine)
  $WatermarkFontFaceTip.SetToolTip($WatermarkFontFaceLabel, $WatermarkFontFaceTipString)

  # 05: Create Watermark - Preview - Create a border for the picturebox.
  $global:WatermarkPreviewBorder = New-Object Windows.Forms.Panel
  $WatermarkPreviewBorder.Size = DPISize (New-Object Drawing.Size(68, 68))
  $WatermarkPreviewBorder.Location = DPISize (New-Object Drawing.Point(192, 48))
  $WatermarkPreviewBorder.BackColor = [Drawing.ColorTranslator]::FromHtml('#adadad')
  $WatermarkImageGroup.Controls.Add($WatermarkPreviewBorder)

  # 05: Create Watermark - Preview - Create a picturebox to hold the preview.
  $global:WatermarkPreviewBox = New-Object Windows.Forms.PictureBox
  $WatermarkPreviewBox.Size = New-Object Drawing.Size(($WatermarkPreviewBorder.Size.Width - 2), ($WatermarkPreviewBorder.Size.Height -2))
  $WatermarkPreviewBox.Location = New-Object Drawing.Point(1, 1)
  $WatermarkPreviewBox.BackColor = [Drawing.ColorTranslator]::FromHtml('#dedede')
  $WatermarkPreviewBox.Add_Click({ $WatermarkDialog.ShowDialog() | Out-Null })
  $WatermarkPreviewBorder.Controls.Add($WatermarkPreviewBox)

  # 05: Create Watermark - Preview - Create a button to generate the preview.
  $global:WatermarkPreviewMake = New-Object Windows.Forms.Button
  $WatermarkPreviewMake.Size = DPISize (New-Object Drawing.Size(106, 24))
  $WatermarkPreviewMake.Location = DPISize (New-Object Drawing.Point(266, 47))
  $WatermarkPreviewMake.Text = '< Create Preview'
  $WatermarkPreviewMake.Add_Click({ GenerateWatermarkPreview })
  $WatermarkImageGroup.Controls.Add($WatermarkPreviewMake)

  # 05: Create Watermark - Preview - Create a label.
  $global:WatermarkPreviewHint = New-Object Windows.Forms.Label
  $WatermarkPreviewHint.Size = DPISize (New-Object Drawing.Size(100, 40))
  $WatermarkPreviewHint.Location = DPISize (New-Object Drawing.Point(274, 76))
  $WatermarkPreviewHint.Text = 'Click the preview window to view a larger version.'
  $WatermarkImageGroup.Controls.Add($WatermarkPreviewHint)

  # 06: Material Generator - Create the groupbox that will hold the material map options.
  $global:MaterialTexGroup = New-Object Windows.Forms.GroupBox
  $MaterialTexGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $MaterialTexGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $MaterialTexGroup.Text = ' Material Generator Options '
  $MainDialogPanel.Controls.Add($MaterialTexGroup)

  # 06: Material Generator - Tile Size - Create a combo to select the tile size.
  $global:MaterialTileSizeCombo = New-Object Windows.Forms.ComboBox
  $MaterialTileSizeCombo.Size = DPISize (New-Object Drawing.Size(80, 10))
  $MaterialTileSizeCombo.Location = DPISize (New-Object Drawing.Point(10, 20))
  $MaterialTileSizeCombo.Name = 'MatMapTileSize'
  $MaterialTileSizeCombo.Items.Add('128x128')   | Out-Null
  $MaterialTileSizeCombo.Items.Add('256x256')   | Out-Null
  $MaterialTileSizeCombo.Items.Add('512x512')   | Out-Null
  $MaterialTileSizeCombo.Items.Add('1024x1024') | Out-Null
  $MaterialTileSizeCombo.SelectedItem = $MatMapTileSize
  $MaterialTileSizeCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MaterialTileSizeCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $MaterialTileSizeCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MaterialTileSizeCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MaterialTileSizeCombo.Add_DrawItem({ RepopulateComboBox })
  $MaterialTexGroup.Controls.Add($MaterialTileSizeCombo)

  # 06: Material Generator - Tile Size - Create a label.
  $global:MaterialTileSizeLabel = New-Object Windows.Forms.Label
  $MaterialTileSizeLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $MaterialTileSizeLabel.Location = DPISize (New-Object Drawing.Point(92, 23))
  $MaterialTileSizeLabel.Text = 'Tile Size'
  $MaterialTexGroup.Controls.Add($MaterialTileSizeLabel)

  # 06: Material Generator - Tile Size - Create a tooltip.
  $MaterialTileSizeTip = New-Object Windows.Forms.ToolTip
  $MaterialTileSizeTip.InitialDelay = $ToolTipDelay
  $MaterialTileSizeTip.AutoPopDelay = $ToolTipDuration
  $MaterialTileSizeTipString =  'Splits the texture into tiles which will{0}'
  $MaterialTileSizeTipString += "take a bit longer but can avoid 'GPU{0}"
  $MaterialTileSizeTipString += "out of VRAM' errors with smaller sizes."
  $MaterialTileSizeTipString = [String]::Format($MaterialTileSizeTipString, [Environment]::NewLine)
  $MaterialTileSizeTip.SetToolTip($MaterialTileSizeLabel, $MaterialTileSizeTipString)

  # 06: Material Generator - Edge Pixels - Create a combo to select the tile size.
  $global:MaterialEdgePixelCombo = New-Object Windows.Forms.ComboBox
  $MaterialEdgePixelCombo.Size = DPISize (New-Object Drawing.Size(80, 10))
  $MaterialEdgePixelCombo.Location = DPISize (New-Object Drawing.Point(10, 44))
  $MaterialEdgePixelCombo.Name = 'MatMapEdgePixels'
  $MaterialEdgePixelCombo.Items.Add('None')   | Out-Null
  $MaterialEdgePixelCombo.Items.Add('Seamless')   | Out-Null
  $MaterialEdgePixelCombo.Items.Add('Mirror')   | Out-Null
  $MaterialEdgePixelCombo.Items.Add('Replicate') | Out-Null
  $MaterialEdgePixelCombo.SelectedItem = $MatMapEdgePixels
  $MaterialEdgePixelCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MaterialEdgePixelCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $MaterialEdgePixelCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MaterialEdgePixelCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MaterialEdgePixelCombo.Add_DrawItem({ RepopulateComboBox })
  $MaterialTexGroup.Controls.Add($MaterialEdgePixelCombo)

  # 06: Material Generator - Edge Pixels - Create a label.
  $global:MaterialEdgePixelLabel = New-Object Windows.Forms.Label
  $MaterialEdgePixelLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $MaterialEdgePixelLabel.Location = DPISize (New-Object Drawing.Point(92, 47))
  $MaterialEdgePixelLabel.Text = 'Edge Pixels'
  $MaterialTexGroup.Controls.Add($MaterialEdgePixelLabel)

  # 06: Material Generator - Edge Pixels - Create a tooltip.
  $MaterialEdgePixelTip = New-Object Windows.Forms.ToolTip
  $MaterialEdgePixelTip.InitialDelay = $ToolTipDelay
  $MaterialEdgePixelTip.AutoPopDelay = $ToolTipDuration
  $MaterialEdgePixelTipString = 'Determines how the edges of textures{0}'
  $MaterialEdgePixelTipString += 'are handled. None will generate the{0}'
  $MaterialEdgePixelTipString += 'materials without employing special{0}'
  $MaterialEdgePixelTipString += 'techniques. Seamless treats the edges{0}'
  $MaterialEdgePixelTipString += 'as if the texture was tiled. Mirror is{0}'
  $MaterialEdgePixelTipString += 'another seamless technique (I think),{0}'
  $MaterialEdgePixelTipString += "I'm not 100% sure what Replicate does."
  $MaterialEdgePixelTipString = [String]::Format($MaterialEdgePixelTipString, [Environment]::NewLine)
  $MaterialEdgePixelTip.SetToolTip($MaterialEdgePixelLabel, $MaterialEdgePixelTipString)

  # 06: Material Generator - Disables GPU acceleration when creating textures.
  $global:MaterialDisableGPUCheck = New-Object Windows.Forms.CheckBox
  $MaterialDisableGPUCheck.Size = DPISize (New-Object Drawing.Size(160, 16))
  $MaterialDisableGPUCheck.Location = DPISize (New-Object Drawing.Point(10, 72))
  $MaterialDisableGPUCheck.Name = 'MatMapDisableGPU'
  $MaterialDisableGPUCheck.Checked = $MatMapDisableGPU
  $MaterialDisableGPUCheck.Text = 'Disable GPU Acceleration'
  $MaterialDisableGPUCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MaterialTexGroup.Controls.Add($MaterialDisableGPUCheck)

  # 06: Material Generator - Create a tooltip for the option.
  $MaterialDisableGPUTip = New-Object Windows.Forms.ToolTip
  $MaterialDisableGPUTip.InitialDelay = $ToolTipDelay
  $MaterialDisableGPUTip.AutoPopDelay = $ToolTipDuration
  $MaterialDisableGPUTipString  = 'This option forces using the CPU when{0}'
  $MaterialDisableGPUTipString += 'creating materials instead of creating{0}'
  $MaterialDisableGPUTipString += 'them using CUDA. This is much slower{0}'
  $MaterialDisableGPUTipString += 'but is the only option for AMD GPUs.'
  $MaterialDisableGPUTipString = [String]::Format($MaterialDisableGPUTipString, [Environment]::NewLine)
  $MaterialDisableGPUTip.SetToolTip($MaterialDisableGPUCheck, $MaterialDisableGPUTipString)

  # 06: Material Generator - Convert directly to material maps.
  $global:MaterialCreateMapsCheck = New-Object Windows.Forms.CheckBox
  $MaterialCreateMapsCheck.Size = DPISize (New-Object Drawing.Size(180, 16))
  $MaterialCreateMapsCheck.Location = DPISize (New-Object Drawing.Point(192, 22))
  $MaterialCreateMapsCheck.Name = 'MatMapCreateMaps'
  $MaterialCreateMapsCheck.Checked = (($MatMapCreateMaps) -and (TestPath -LiteralPath $IshiirukaTool))
  $MaterialCreateMapsCheck.Text = 'Auto-Convert to Material Maps'
  $MaterialCreateMapsCheck.Add_CheckStateChanged({ ToggleIshiirukaFormatCombo })
  $MaterialCreateMapsCheck.Enabled = (TestPath -LiteralPath $IshiirukaTool)
  $MaterialTexGroup.Controls.Add($MaterialCreateMapsCheck)

  # 06: Material Generator - Toggle the variable off if it's enabled and Ishiiruka Tool is not found.
  if (($MatMapCreateMaps) -and (!(TestPath -LiteralPath $IshiirukaTool))) { $global:MatMapCreateMaps = $false }

  # 06: Material Generator - Create a tooltip for the option.
  $MaterialCreateMapsTip = New-Object Windows.Forms.ToolTip
  $MaterialCreateMapsTip.InitialDelay = $ToolTipDelay
  $MaterialCreateMapsTip.AutoPopDelay = $ToolTipDuration
  $MaterialCreateMapsTipString += 'This option will convert the generated{0}'
  $MaterialCreateMapsTipString += 'materials directly into material maps.{0}'
  $MaterialCreateMapsTipString  = 'Requires a valid path to Ishiirua Tool.'
  $MaterialCreateMapsTipString = [String]::Format($MaterialCreateMapsTipString, [Environment]::NewLine)
  $MaterialCreateMapsTip.SetToolTip($MaterialCreateMapsCheck, $MaterialCreateMapsTipString)

  # 06: Material Generator - Output Format - Set the output format of material maps.
  $global:MaterialsFormatCombo = New-Object Windows.Forms.ComboBox
  $MaterialsFormatCombo.Size = DPISize (New-Object Drawing.Size(72, 10))
  $MaterialsFormatCombo.Location = DPISize (New-Object Drawing.Point(192, 44))
  $MaterialsFormatCombo.Name = 'IshiirukaFormat'
  $MaterialsFormatCombo.Items.Add('PNG') | Out-Null
  $MaterialsFormatCombo.Items.Add('DDS') | Out-Null
  $MaterialsFormatCombo.SelectedItem = ExtensionToText -Extension $IshiirukaFormat
  $MaterialsFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MaterialsFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Get-Variable -Name $this.SelectedItem -ValueOnly) ; UpdateIshiirukaFormat })
  $MaterialsFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MaterialsFormatCombo.Enabled = (($MatMapCreateMaps) -and (TestPath -LiteralPath $IshiirukaTool))
  $MaterialsFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MaterialsFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $MaterialTexGroup.Controls.Add($MaterialsFormatCombo)

  # 06: Material Generator - Output Format - Create a label.
  $global:MaterialsFormatLabel = New-Object Windows.Forms.Label
  $MaterialsFormatLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $MaterialsFormatLabel.Location = DPISize (New-Object Drawing.Point(266, 47))
  $MaterialsFormatLabel.Text = 'Output Format'
  $MaterialsFormatLabel.Enabled = (($MatMapCreateMaps) -and (TestPath -LiteralPath $IshiirukaTool))
  $MaterialTexGroup.Controls.Add($MaterialsFormatLabel)

  # 06: Material Generator - Output Format - Create a tooltip.
  $MaterialsFormatTip = New-Object Windows.Forms.ToolTip
  $MaterialsFormatTip.InitialDelay = $ToolTipDelay
  $MaterialsFormatTip.AutoPopDelay = $ToolTipDuration
  $MaterialsFormatTipTipString = 'The file extension/output format{0}'
  $MaterialsFormatTipTipString += 'that textures and material maps{0}'
  $MaterialsFormatTipTipString += 'are created with Ishiiruka Tool.'
  $MaterialsFormatTipTipString = [String]::Format($MaterialsFormatTipTipString, [Environment]::NewLine)
  $MaterialsFormatTip.SetToolTip($MaterialsFormatLabel, $MaterialsFormatTipTipString)

  # 06: Material Generator - Dependencies - Create a button to check dependencies.
  $global:MaterialDependencies = New-Object Windows.Forms.Button
  $MaterialDependencies.Size = DPISize (New-Object Drawing.Size(140, 24))
  $MaterialDependencies.Location = DPISize (New-Object Drawing.Point(120, 94))
  $MaterialDependencies.Text = 'Check Dependencies'
  $MaterialDependencies.Add_Click({ CheckMaterialDependencies })
  $MaterialTexGroup.Controls.Add($MaterialDependencies)

  # 06: Material Generator - Dependencies - Create a tooltip.
  $MaterialDependenciesTip = New-Object Windows.Forms.ToolTip
  $MaterialDependenciesTip.InitialDelay = $ToolTipDelay
  $MaterialDependenciesTip.AutoPopDelay = $ToolTipDuration
  $MaterialDependenciesTipString  = 'Checks for python and any missing{0}'
  $MaterialDependenciesTipString += 'dependencies that are used when{0}'
  $MaterialDependenciesTipString += 'creating materials. Dependencies{0}'
  $MaterialDependenciesTipString += 'missing are automatically installed.'
  $MaterialDependenciesTipString = [String]::Format($MaterialDependenciesTipString, [Environment]::NewLine)
  $MaterialDependenciesTip.SetToolTip($MaterialDependencies, $MaterialDependenciesTipString)

  # 07: Material Maps - Create the groupbox that will hold the material map options.
  $global:MaterialMapsGroup = New-Object Windows.Forms.GroupBox
  $MaterialMapsGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $MaterialMapsGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $MaterialMapsGroup.Text = ' Ishiiruka Tool Options '
  $MainDialogPanel.Controls.Add($MaterialMapsGroup)

  # 07: Material Maps - Output Format - Set the output format of material maps.
  $global:MaterialFormatCombo = New-Object Windows.Forms.ComboBox
  $MaterialFormatCombo.Size = DPISize (New-Object Drawing.Size(72, 10))
  $MaterialFormatCombo.Location = DPISize (New-Object Drawing.Point(10, 20))
  $MaterialFormatCombo.Name = 'IshiirukaFormat'
  $MaterialFormatCombo.Items.Add('PNG') | Out-Null
  $MaterialFormatCombo.Items.Add('DDS') | Out-Null
  $MaterialFormatCombo.SelectedItem = ExtensionToText -Extension $IshiirukaFormat
  $MaterialFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $MaterialFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Get-Variable -Name $this.SelectedItem -ValueOnly) ; UpdateIshiirukaFormat })
  $MaterialFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $MaterialFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $MaterialFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $MaterialMapsGroup.Controls.Add($MaterialFormatCombo)

  # 07: Material Maps - Output Format - Create a label.
  $global:MaterialFormatLabel = New-Object Windows.Forms.Label
  $MaterialFormatLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $MaterialFormatLabel.Location = DPISize (New-Object Drawing.Point(84, 23))
  $MaterialFormatLabel.Text = 'Output Format'
  $MaterialMapsGroup.Controls.Add($MaterialFormatLabel)

  # 07: Material Maps - Output Format - Create a tooltip.
  $MaterialFormatTip = New-Object Windows.Forms.ToolTip
  $MaterialFormatTip.InitialDelay = $ToolTipDelay
  $MaterialFormatTip.AutoPopDelay = $ToolTipDuration
  $MaterialFormatTipString = 'The file extension/output format{0}'
  $MaterialFormatTipString += 'that textures and material maps{0}'
  $MaterialFormatTipString += 'are created with Ishiiruka Tool.'
  $MaterialFormatTipString = [String]::Format($MaterialFormatTipString, [Environment]::NewLine)
  $MaterialFormatTip.SetToolTip($MaterialFormatLabel, $MaterialFormatTipString)

  # 07: Material Maps - Create In-Place - Create material maps in-place which destroys the material textures.
  $global:MaterialInPlaceCheck = New-Object Windows.Forms.CheckBox
  $MaterialInPlaceCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $MaterialInPlaceCheck.Location = DPISize (New-Object Drawing.Point(192, 22))
  $MaterialInPlaceCheck.Name = 'InPlaceMaterial'
  $MaterialInPlaceCheck.Checked = $InPlaceMaterial
  $MaterialInPlaceCheck.Text = ' Create Materials In-Place'
  $MaterialInPlaceCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MaterialMapsGroup.Controls.Add($MaterialInPlaceCheck)

  # 07: Material Maps - Create In-Place - Create a tooltip.
  $MaterialInPlaceTip = New-Object Windows.Forms.ToolTip
  $MaterialInPlaceTip.InitialDelay = $ToolTipDelay
  $MaterialInPlaceTip.AutoPopDelay = $ToolTipDuration
  $MaterialInPlaceTipString =  'This option replaces the materials in{0}'
  $MaterialInPlaceTipString += 'the pack directly with the resulting{0}'
  $MaterialInPlaceTipString += 'material maps destroying the original{0}'
  $MaterialInPlaceTipString += 'materials (bump/spec/nrm/lum).'
  $MaterialInPlaceTipString = [String]::Format($MaterialInPlaceTipString, [Environment]::NewLine)
  $MaterialInPlaceTip.SetToolTip($MaterialInPlaceCheck, $MaterialInPlaceTipString)

  # 07: Material Maps - Ishiiruka Tool - Create a label.
  $global:MaterialIshiirukaLabel = New-Object Windows.Forms.Label
  $MaterialIshiirukaLabel.Size = DPISize (New-Object Drawing.Size(140, 14))
  $MaterialIshiirukaLabel.Location = DPISize (New-Object Drawing.Point(10, 80))
  $MaterialIshiirukaLabel.Text = 'Ishiiruka Tool Path:'
  $MaterialMapsGroup.Controls.Add($MaterialIshiirukaLabel)

  # 07: Material Maps - Ishiiruka Tool - The tooltip is recycled from the "Paths" menu tooltip.
  $MaterialIshiirukaTip = New-Object Windows.Forms.ToolTip
  $MaterialIshiirukaTip.InitialDelay = $ToolTipDelay
  $MaterialIshiirukaTip.AutoPopDelay = $ToolTipDuration
  $MaterialIshiirukaTipString = 'The path to the texture encoder by Tino that combines bump/spec/lum/nrm{0}'
  $MaterialIshiirukaTipString += 'textures into a material map. This tool is also required to work with already{0}'
  $MaterialIshiirukaTipString += 'combined material maps (meaning the "mat" file created from the previously{0}'
  $MaterialIshiirukaTipString += 'mentioned textures). If this tool is not found when material maps are found{0}'
  $MaterialIshiirukaTipString += 'then these textures will not be converted.{0}'
  $MaterialIshiirukaTipString += '{0}'
  $MaterialIshiirukaTipString += 'Required whenever a pack contains material maps or material textures.'
  $MaterialIshiirukaTipString = [String]::Format($MaterialIshiirukaTipString, [Environment]::NewLine)
  $MaterialIshiirukaTip.SetToolTip($MaterialIshiirukaLabel, $MaterialIshiirukaTipString)

  # 07: Material Maps - Ishiiruka Tool - Create a tooltip.
  $global:MaterialIshiirukaTextBox = New-Object Windows.Forms.TextBox
  $MaterialIshiirukaTextBox.Size = DPISize (New-Object Drawing.Size(334, 22))
  $MaterialIshiirukaTextBox.Location = DPISize (New-Object Drawing.Point(10, 95)) -AddY $DPIOffsetFix
  $MaterialIshiirukaTextBox.Name = 'IshiirukaTool'
  $MaterialIshiirukaTextBox.Text = $IshiirukaTool
  $MaterialIshiirukaTextBox.AllowDrop = $true
  $MaterialIshiirukaTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $MaterialIshiirukaTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName 'TextureEncoder.exe'})
  $MaterialIshiirukaTextBox.Add_Click({ ClearTextBox })
  $MaterialIshiirukaTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName 'TextureEncoder.exe' })
  $MaterialMapsGroup.Controls.Add($MaterialIshiirukaTextBox)

  # 07: Material Maps - Ishiiruka Tool - Create a button.
  $global:MaterialIshiirukaButton = New-Object Windows.Forms.Button
  $MaterialIshiirukaButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $MaterialIshiirukaButton.Location = DPISize (New-Object Drawing.Point(347, 94))
  $MaterialIshiirukaButton.Name = 'IshiirukaTool'
  $MaterialIshiirukaButton.Text = '...'
  $MaterialIshiirukaButton.Add_Click({ LoadExternalFile_Button -TextBox $MaterialIshiirukaTextBox -FileName @('TextureEncoder.exe') -Description @('Ishiiruka Tool') })
  $MaterialMapsGroup.Controls.Add($MaterialIshiirukaButton)

  # 08: PNG Optimizer - Create the groupbox that will hold the optimizer options.
  $global:OptimizeTextureGroup = New-Object Windows.Forms.GroupBox
  $OptimizeTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $OptimizeTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $OptimizeTextureGroup.Text = ' PNG Optimizer Options '
  $MainDialogPanel.Controls.Add($OptimizeTextureGroup)

  # 08: PNG Optimizer - Selected Tool - Allows selecting the tool used for optimizing textures. (PopulateOptimizerList)
  $global:OptimizerProgramCombo = New-Object Windows.Forms.ComboBox
  $OptimizerProgramCombo.Size = DPISize (New-Object Drawing.Size(76, 10))
  $OptimizerProgramCombo.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $OptimizerProgramCombo.Name = 'OptimizerTool'
  $OptimizerProgramCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $OptimizerProgramCombo.Add_SelectedIndexChanged({ OptimizerToolSelection -ComboBox $this })
  $OptimizerProgramCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $OptimizerProgramCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $OptimizerProgramCombo.Add_DrawItem({ RepopulateComboBox })
  $OptimizeTextureGroup.Controls.Add($OptimizerProgramCombo)

  # 08: PNG Optimizer - Selected Tool - Create a label.
  $global:OptimizeProgramLabel = New-Object Windows.Forms.Label
  $OptimizeProgramLabel.Size = DPISize (New-Object Drawing.Size(103, 22))
  $OptimizeProgramLabel.Location = DPISize (New-Object Drawing.Point(88, 23))
  $OptimizeProgramLabel.Text = 'PNG Optimizer'
  $OptimizeTextureGroup.Controls.Add($OptimizeProgramLabel)

  # 08: PNG Optimizer - Selected Tool - Create a tooltip.
  $OptimizeProgramTip = New-Object Windows.Forms.ToolTip
  $OptimizeProgramTip.InitialDelay = $ToolTipDelay
  $OptimizeProgramTip.AutoPopDelay = $ToolTipDuration
  $OptimizeProgramTipString = 'The tool that is currently selected{0}'
  $OptimizeProgramTipString += 'to optimize PNG textures. The tool{0}'
  $OptimizeProgramTipString += 'can be changed to a different one{0}'
  $OptimizeProgramTipString += 'by clicking on the [...] button.{0}'
  $OptimizeProgramTipString += '{0}'
  $OptimizeProgramTipString += 'Compatible Tools:{0}'
  $OptimizeProgramTipString += '- OptiPNG{0}'
  $OptimizeProgramTipString += '- OxiPNG{0}'
  $OptimizeProgramTipString += '- Pingo{0}'
  $OptimizeProgramTipString += '- Efficient Compression Tool'
  $OptimizeProgramTipString = [String]::Format($OptimizeProgramTipString, [Environment]::NewLine)
  $OptimizeProgramTip.SetToolTip($OptimizeProgramLabel, $OptimizeProgramTipString)

  # 08: PNG Optimizer - Tests - Create a number box.
  $global:OptimizeTestsNumBox = New-Object Windows.Forms.NumericUpDown
  $OptimizeTestsNumBox.Size = DPISize (New-Object Drawing.Size(76, 10))
  $OptimizeTestsNumBox.Location = DPISize (New-Object Drawing.Point(10, 46)) -AddY $DPIOffsetFix
  $OptimizeTestsNumBox.Name = 'OptimizeTests'
  $OptimizeTestsNumBox.DecimalPlaces = 0
  $OptimizeTestsNumBox.Increment = 1

  # The range of values is different depending on the tool.
  switch -wildcard ($OptimizerTool)
  {
    # OptiPNG and OxiPNG the range is 0-7.
    'O*iPNG'
    {
      $Min = $OptimizeTestsNumBox.Minimum = 0
      $Max = $OptimizeTestsNumBox.Maximum = 7
    }
    # Pingo and ECT the range is 1-9.
    default
    {
      $Min = $OptimizeTestsNumBox.Minimum = 1
      $Max = $OptimizeTestsNumBox.Maximum = 9
    }
  }
  # The value stored is in the current range.
  if ($OptimizeTests -in $Min..$Max)
  {
    # Set the value to the stored value.
    $OptimizeTestsNumBox.Value = $OptimizeTests
  }
  # It's somehow outside the range.
  else
  {
    # Just set it to the minimum value.
    $OptimizeTestsNumBox.Value = $Min
  }
  $OptimizeTestsNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptimizeTextureGroup.Controls.Add($OptimizeTestsNumBox)

  # 08: PNG Optimizer - Optimization Level - Create a label.
  $global:OptimizeTestsLabel = New-Object Windows.Forms.Label
  $OptimizeTestsLabel.Size = DPISize (New-Object Drawing.Size(103, 22))
  $OptimizeTestsLabel.Location = DPISize (New-Object Drawing.Point(88, 49))
  $OptimizeTestsLabel.Text = 'Optimization Level'
  $OptimizeTextureGroup.Controls.Add($OptimizeTestsLabel)

  # 08: PNG Optimizer - Optimization Level - Create a tooltip.
  $global:OptimizeTestsTip = New-Object Windows.Forms.ToolTip
  $OptimizeTestsTip.InitialDelay = $ToolTipDelay
  $OptimizeTestsTip.AutoPopDelay = $ToolTipDuration

  # This tooltip is for when the text is set to "Optimization Level".
  $OptimizeTestsTipStringA  = 'Optimization level of the current PNG{0}'
  $OptimizeTestsTipStringA += 'optimizer program. Each program has its{0}'
  $OptimizeTestsTipStringA += 'own range and minimum/maximum values.'
  $global:OptimizeTestsTipStringA = [String]::Format($OptimizeTestsTipStringA, [Environment]::NewLine)

  # This tooltip is for when the text is set to "Compression Level".
  $OptimizeTestsTipStringB  = 'Sets the level of compression from{0}'
  $OptimizeTestsTipStringB += 'weakest compression to strongest.'
  $global:OptimizeTestsTipStringB = [String]::Format($OptimizeTestsTipStringB, [Environment]::NewLine)

  # Start out with the optimization tooltip.
  $OptimizeTestsTip.SetToolTip($OptimizeTestsLabel, $OptimizeTestsTipStringA)

  # 08: PNG Optimizer - Threads - Don't let the user set amount exceed the core count.
  if ($OptimizeThreads -gt $LogicalCores) { $global:OptimizeThreads = $LogicalCores }

  # 08: PNG Optimizer - Threads - Create a number box.
  $global:OptimizeThreadsNumBox = New-Object Windows.Forms.NumericUpDown
  $OptimizeThreadsNumBox.Size = DPISize (New-Object Drawing.Size(76, 10))
  $OptimizeThreadsNumBox.Location = DPISize (New-Object Drawing.Point(10, 72)) -AddY $DPIOffsetFix
  $OptimizeThreadsNumBox.Name = 'OptimizeThreads'
  $OptimizeThreadsNumBox.DecimalPlaces = 0
  $OptimizeThreadsNumBox.Minimum = 1
  $OptimizeThreadsNumBox.Maximum = $LogicalCores
  $OptimizeThreadsNumBox.Increment = 1
  $OptimizeThreadsNumBox.Value = $OptimizeThreads
  $OptimizeThreadsNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $OptimizeThreadsNumBox.Enabled = ($OptimizerTool -ne 'OptiPNG')
  $OptimizeTextureGroup.Controls.Add($OptimizeThreadsNumBox)

  # 08: PNG Optimizer - Threads - Create a label.
  $global:OptimizeThreadsLabel = New-Object Windows.Forms.Label
  $OptimizeThreadsLabel.Size = DPISize (New-Object Drawing.Size(103, 22))
  $OptimizeThreadsLabel.Location = DPISize (New-Object Drawing.Point(88, 75))
  $OptimizeThreadsLabel.Text = 'Number of Threads'
  $OptimizeThreadsLabel.Enabled = ($OptimizerTool -ne 'OptiPNG')
  $OptimizeTextureGroup.Controls.Add($OptimizeThreadsLabel)

  # 08: PNG Optimizer - Threads - Create a tooltip.
  $OptimizeThreadsTip = New-Object Windows.Forms.ToolTip
  $OptimizeThreadsTip.InitialDelay = $ToolTipDelay
  $OptimizeThreadsTip.AutoPopDelay = $ToolTipDuration
  $OptimizeThreadsTipString = 'Configure the number of threads used{0}'
  $OptimizeThreadsTipString += 'when optimizing images with a program{0}'
  $OptimizeThreadsTipString += 'that supports multithreading. Number{0}'
  $OptimizeThreadsTipString += 'of threads can not exceed the logical{0}'
  $OptimizeThreadsTipString += 'number of CPU cores read by Windows.{0}'
  $OptimizeThreadsTipString += '{0}'
  $OptimizeThreadsTipString += 'Pingo enables multi-threading by default{0}'
  $OptimizeThreadsTipString += 'but the threads can not be configured. It{0}'
  $OptimizeThreadsTipString += 'is possible to disable multi-threading by{0}'
  $OptimizeThreadsTipString += 'setting the number of threads to "1".'
  $OptimizeThreadsTipString = [String]::Format($OptimizeThreadsTipString, [Environment]::NewLine)
  $OptimizeThreadsTip.SetToolTip($OptimizeThreadsLabel, $OptimizeThreadsTipString)

  # 08: PNG Optimizer - ECT: Reuse Colors - Create a checkbox.
  $global:OptimizeReuseColorsCheck = New-Object Windows.Forms.CheckBox
  $OptimizeReuseColorsCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $OptimizeReuseColorsCheck.Location = DPISize (New-Object Drawing.Point(10, 100))
  $OptimizeReuseColorsCheck.Name = 'OptimizeReuseColors'
  $OptimizeReuseColorsCheck.Checked = $OptimizeReuseColors
  $OptimizeReuseColorsCheck.Text = "Preserve Filter && Color Type"
  $OptimizeReuseColorsCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptimizeTextureGroup.Controls.Add($OptimizeReuseColorsCheck)

  # 08: PNG Optimizer - ECT: Reuse Colors - Create a tooltip.
  $OptimizeReuseColorsTip = New-Object Windows.Forms.ToolTip
  $OptimizeReuseColorsTip.InitialDelay = $ToolTipDelay
  $OptimizeReuseColorsTip.AutoPopDelay = $ToolTipDuration
  $OptimizeReuseColorsTipString  = 'This option has slightly different behavior depending{0}'
  $OptimizeReuseColorsTipString += 'on the program, but in essence they are all about the{0}'
  $OptimizeReuseColorsTipString += 'same. The idea is to preserve the PNG attributes.{0}'
  $OptimizeReuseColorsTipString += '{0}'
  $OptimizeReuseColorsTipString += 'OptiPNG/OxiPNG: Adds -nb/-nc/-np flags which prevents{0}'
  $OptimizeReuseColorsTipString += 'reduction of bit depth, color type, and palette.{0}'
  $OptimizeReuseColorsTipString += '{0}'
  $OptimizeReuseColorsTipString += 'ECT: Adds -reuse flag which preserves the PNG filter{0}'
  $OptimizeReuseColorsTipString += 'and color type. Bit depth and palette may be reduced.{0}'
  $OptimizeReuseColorsTipString += '{0}'
  $OptimizeReuseColorsTipString += 'Pingo: Adds -noconversion flag which I guess prevents{0}'
  $OptimizeReuseColorsTipString += 'PNG images from becoming JPG which seems a bit odd.'
  $OptimizeReuseColorsTipString = [String]::Format($OptimizeReuseColorsTipString, [Environment]::NewLine)
  $OptimizeReuseColorsTip.SetToolTip($OptimizeReuseColorsCheck, $OptimizeReuseColorsTipString)

  # 08: PNG Optimizer - Create In-Place - Create a checkbox.
  $global:OptimizerInPlaceCheck = New-Object Windows.Forms.CheckBox
  $OptimizerInPlaceCheck.Size = DPISize (New-Object Drawing.Size(174, 16))
  $OptimizerInPlaceCheck.Location = DPISize (New-Object Drawing.Point(192, 22))
  $OptimizerInPlaceCheck.Name = 'OptimizeInPlace'
  $OptimizerInPlaceCheck.Checked = $OptimizeInPlace
  $OptimizerInPlaceCheck.Text = ' Optimize Textures In-Place'
  $OptimizerInPlaceCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptimizeTextureGroup.Controls.Add($OptimizerInPlaceCheck)

  # 08: PNG Optimizer - Create In-Place - Create a tooltip.
  $OptimizerInPlaceTip = New-Object Windows.Forms.ToolTip
  $OptimizerInPlaceTip.InitialDelay = $ToolTipDelay
  $OptimizerInPlaceTip.AutoPopDelay = $ToolTipDuration
  $OptimizerInPlaceTipString = 'Overwrites the old texture with the{0}'
  $OptimizerInPlaceTipString += 'optimized texture directly, instead{0}'
  $OptimizerInPlaceTipString += 'of creating it in the "Output Path".'
  $OptimizerInPlaceTipString = [String]::Format($OptimizerInPlaceTipString, [Environment]::NewLine)
  $OptimizerInPlaceTip.SetToolTip($OptimizerInPlaceCheck, $OptimizerInPlaceTipString)

  # 08: PNG Optimizer - Strip Metadata - Create a checkbox.
  $global:OptimizerStripMetaDataCheck = New-Object Windows.Forms.CheckBox
  $OptimizerStripMetaDataCheck.Size = DPISize (New-Object Drawing.Size(174, 16))
  $OptimizerStripMetaDataCheck.Location = DPISize (New-Object Drawing.Point(192, 48))
  $OptimizerStripMetaDataCheck.Name = 'OptimizeStripMeta'
  $OptimizerStripMetaDataCheck.Checked = $OptimizeStripMeta
  $OptimizerStripMetaDataCheck.Text = " Strip Metadata From Images"
  $OptimizerStripMetaDataCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptimizeTextureGroup.Controls.Add($OptimizerStripMetaDataCheck)

  # 08: PNG Optimizer - Strip Metadata - Create a tooltip.
  $OptimizerStripMetaDataTip = New-Object Windows.Forms.ToolTip
  $OptimizerStripMetaDataTip.InitialDelay = $ToolTipDelay
  $OptimizerStripMetaDataTip.AutoPopDelay = $ToolTipDuration
  $OptimizerStripMetaDataTipString = 'Strips all metadata from PNG images.'
  $OptimizerStripMetaDataTip.SetToolTip($OptimizerStripMetaDataCheck, $OptimizerStripMetaDataTipString)

  # 08: PNG Optimizer - Don't Break Dolphin - Create a checkbox.
  $global:OptimizerDolphinFixCheck = New-Object Windows.Forms.CheckBox
  $OptimizerDolphinFixCheck.Size = DPISize (New-Object Drawing.Size(178, 16))
  $OptimizerDolphinFixCheck.Location = DPISize (New-Object Drawing.Point(192, 74))
  $OptimizerDolphinFixCheck.Name = 'OptiDolphinCheck'
  $OptimizerDolphinFixCheck.Checked = $OptiDolphinCheck
  $OptimizerDolphinFixCheck.Text = " Don't Break Dolphin Textures"
  $OptimizerDolphinFixCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptimizeTextureGroup.Controls.Add($OptimizerDolphinFixCheck)

  # 08: PNG Optimizer - Don't Break Dolphin - Create a tooltip.
  $OptimizeDolphinFixTip = New-Object Windows.Forms.ToolTip
  $OptimizeDolphinFixTip.InitialDelay = $ToolTipDelay
  $OptimizeDolphinFixTip.AutoPopDelay = $ToolTipDuration
  $OptimizeDolphinFixTipString = 'Certain optimizations can break loading{0}'
  $OptimizeDolphinFixTipString += 'some PNG textures in Dolphin emulator.{0}'
  $OptimizeDolphinFixTipString += 'Enabling this does not allow optimizers{0}'
  $OptimizeDolphinFixTipString += 'to perform changes that break support.'
  $OptimizeDolphinFixTipString = [String]::Format($OptimizeDolphinFixTipString, [Environment]::NewLine)
  $OptimizeDolphinFixTip.SetToolTip($OptimizerDolphinFixCheck, $OptimizeDolphinFixTipString)

  # 08: PNG Optimizer - ECT: Strict Losslessness - Create a checkbox.
  $global:OptimizeStrictLosslessCheck = New-Object Windows.Forms.CheckBox
  $OptimizeStrictLosslessCheck.Size = DPISize (New-Object Drawing.Size(162, 16))
  $OptimizeStrictLosslessCheck.Location = DPISize (New-Object Drawing.Point(192, 100))
  $OptimizeStrictLosslessCheck.Name = 'OptimizeLossless'
  $OptimizeStrictLosslessCheck.Checked = $OptimizeLossless
  $OptimizeStrictLosslessCheck.Text = " Enable Strict Losslessness"
  $OptimizeStrictLosslessCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $OptimizeStrictLosslessCheck.Enabled = ($OptimizerTool -eq 'ECT')
  $OptimizeTextureGroup.Controls.Add($OptimizeStrictLosslessCheck)

  # 08: PNG Optimizer - ECT: Strict Losslessness - Create a tooltip.
  $OptimizeStrictLosslessTip = New-Object Windows.Forms.ToolTip
  $OptimizeStrictLosslessTip.InitialDelay = $ToolTipDelay
  $OptimizeStrictLosslessTip.AutoPopDelay = $ToolTipDuration
  $OptimizeStrictLosslessTipString  = 'Enforces lossless output. Depending on{0}'
  $OptimizeStrictLosslessTipString += 'the program this behaves differently,{0}'
  $OptimizeStrictLosslessTipString += 'but it always ensures lossless output.{0}'
  $OptimizeStrictLosslessTipString += '{0}'
  $OptimizeStrictLosslessTipString += 'Pingo: When enabled, forces lossless{0}'
  $OptimizeStrictLosslessTipString += 'compression; the level set is ignored.{0}'
  $OptimizeStrictLosslessTipString += '{0}'
  $OptimizeStrictLosslessTipString += 'ECT: Enforces lossless compression but{0}'
  $OptimizeStrictLosslessTipString += 'the level set still affects compression.'
  $OptimizeStrictLosslessTipString = [String]::Format($OptimizeStrictLosslessTipString, [Environment]::NewLine)
  $OptimizeStrictLosslessTip.SetToolTip($OptimizeStrictLosslessCheck, $OptimizeStrictLosslessTipString)

  # 09: Upscale Filter - Create the groupbox that will hold the upscaling filter options.
  $global:UpscaleFiltersGroup = New-Object Windows.Forms.GroupBox
  $UpscaleFiltersGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $UpscaleFiltersGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $UpscaleFiltersGroup.Text = ' Upscale Filter Options '
  $MainDialogPanel.Controls.Add($UpscaleFiltersGroup)

  # 09: Upscale Filter - Filter Selection - Allows selecting the upscale filter.
  $global:UpscaleSelection = New-Object Windows.Forms.ComboBox
  $UpscaleSelection.Size = DPISize (New-Object Drawing.Size(72, 10))
  $UpscaleSelection.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $UpscaleSelection.Name = 'FilterSelected'
  $UpscaleSelection.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $UpscaleSelection.Add_SelectedIndexChanged({ UpscaleFilterSelection })
  $UpscaleSelection.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $UpscaleSelection.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $UpscaleSelection.Add_DrawItem({ RepopulateComboBox })
  $UpscaleFiltersGroup.Controls.Add($UpscaleSelection)

  # 09: Upscale Filter - Filter Selection - Create a label.
  $global:UpscaleSelectionLabel = New-Object Windows.Forms.Label
  $UpscaleSelectionLabel.Size = DPISize (New-Object Drawing.Size(96, 22))
  $UpscaleSelectionLabel.Location = DPISize (New-Object Drawing.Point(84, 23))
  $UpscaleSelectionLabel.Text = 'Upscale Filter'
  $UpscaleFiltersGroup.Controls.Add($UpscaleSelectionLabel)

  # 09: Upscale Filter - Filter Selection - Create a tooltip.
  $UpscaleSelectionTip = New-Object Windows.Forms.ToolTip
  $UpscaleSelectionTip.InitialDelay = $ToolTipDelay
  $UpscaleSelectionTip.AutoPopDelay = $ToolTipDuration
  $UpscaleSelectionTipString = 'Selects the upscaling filter used when{0}'
  $UpscaleSelectionTipString += 'upscaling textures. Some filters need{0}'
  $UpscaleSelectionTipString += "the corresponding program added to{0}"
  $UpscaleSelectionTipString += 'the tool on the "Options/Paths" tab.'
  $UpscaleSelectionTipString = [String]::Format($UpscaleSelectionTipString, [Environment]::NewLine)
  $UpscaleSelectionTip.SetToolTip($UpscaleSelectionLabel, $UpscaleSelectionTipString)

  # 09: Upscale Filter - Upscale Factor - The upscale factor is the multiplier for the dimensions when it is upscaled.
  $global:UpscaleFactorNumBox = New-Object Windows.Forms.NumericUpDown
  $UpscaleFactorNumBox.Size = DPISize (New-Object Drawing.Size(72, 10))
  $UpscaleFactorNumBox.Location = DPISize (New-Object Drawing.Point(10, 46)) -AddY $DPIOffsetFix
  $UpscaleFactorNumBox.Name = 'UpscaleFactor'
  $UpscaleFactorNumBox.DecimalPlaces = 0
  $UpscaleFactorNumBox.Minimum = 2
  $UpscaleFactorNumBox.Maximum = 16
  $UpscaleFactorNumBox.Increment = 1
  $UpscaleFactorNumBox.Value = $UpscaleFactor
  $UpscaleFactorNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' ; UpdateUpscaleFilter -NewValue $this.Value })
  $UpscaleFiltersGroup.Controls.Add($UpscaleFactorNumBox)

  # 09: Upscale Filter - Upscale Factor - Create a label.
  $global:UpscaleFactorLabel = New-Object Windows.Forms.Label
  $UpscaleFactorLabel.Size = DPISize (New-Object Drawing.Size(96, 22))
  $UpscaleFactorLabel.Location = DPISize (New-Object Drawing.Point(84, 49))
  $UpscaleFactorLabel.Text = 'Upscale Factor'
  $UpscaleFiltersGroup.Controls.Add($UpscaleFactorLabel)

  # 09: Upscale Filter - Upscale Factor - Create a tooltip.
  $UpscaleFactorTip = New-Object Windows.Forms.ToolTip
  $UpscaleFactorTip.InitialDelay = $ToolTipDelay
  $UpscaleFactorTip.AutoPopDelay = $ToolTipDuration
  $UpscaleFactorTipString = 'The factor used to calculate the{0}'
  $UpscaleFactorTipString += 'upscaled dimensions. The formula{0}'
  $UpscaleFactorTipString += "is simply the texture's dimensions{0}"
  $UpscaleFactorTipString += 'multiplied by the upscale factor.{0}'
  $UpscaleFactorTipString += '{0}'
  $UpscaleFactorTipString += 'Most filters allow max 16x upscale.{0}'
  $UpscaleFactorTipString += 'ESRGAN is locked to 4x upscale.{0}'
  $UpscaleFactorTipString += 'SFTGAN can do up to 1-4x upscale.'
  $UpscaleFactorTipString = [String]::Format($UpscaleFactorTipString, [Environment]::NewLine)
  $UpscaleFactorTip.SetToolTip($UpscaleFactorLabel, $UpscaleFactorTipString)

  # 09: Upscale Filter - Seamless Method - Selects the seamless method which tiles a texture 9 times and crops the center tile.
  $global:UpscaleSeamlessCombo = New-Object Windows.Forms.ComboBox
  $UpscaleSeamlessCombo.Size = DPISize (New-Object Drawing.Size(72, 10))
  $UpscaleSeamlessCombo.Location = DPISize (New-Object Drawing.Point(10, 72)) -AddY $DPIOffsetFix
  $UpscaleSeamlessCombo.Name = 'SeamlessMethod'
  $UpscaleSeamlessCombo.Items.Add('Disable') | Out-Null
  $UpscaleSeamlessCombo.Items.Add('Opaque') | Out-Null
  $UpscaleSeamlessCombo.Items.Add('All') | Out-Null
  $UpscaleSeamlessCombo.SelectedItem = $SeamlessMethod
  $UpscaleSeamlessCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $UpscaleSeamlessCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem ; $UpscaleSeamlessPixels.Enabled = $UpscaleSeamlessPixelsLabel.Enabled = ($this.SelectedItem -ne 'Disable') })
  $UpscaleSeamlessCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $UpscaleSeamlessCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $UpscaleSeamlessCombo.Add_DrawItem({ RepopulateComboBox })
  $UpscaleFiltersGroup.Controls.Add($UpscaleSeamlessCombo)

  # 09: Upscale Filter - Seamless Method - Create a label.
  $global:UpscaleSeamlessLabel = New-Object Windows.Forms.Label
  $UpscaleSeamlessLabel.Size = DPISize (New-Object Drawing.Size(96, 22))
  $UpscaleSeamlessLabel.Location = DPISize (New-Object Drawing.Point(84, 75))
  $UpscaleSeamlessLabel.Text = 'Seamless Method'
  $UpscaleFiltersGroup.Controls.Add($UpscaleSeamlessLabel)

  # 09: Upscale Filter - Seamless Method - Create a tooltip.
  $UpscaleSeamlessTip = New-Object Windows.Forms.ToolTip
  $UpscaleSeamlessTip.InitialDelay = $ToolTipDelay
  $UpscaleSeamlessTip.AutoPopDelay = $ToolTipDuration
  $UpscaleSeamlessTipString = 'The "Seamless Method" is a technique that involves copying the {0}'
  $UpscaleSeamlessTipString += 'edges of a texture, and adding the copied pieces to the edges as if{0}'
  $UpscaleSeamlessTipString += 'the image was tiled in a 3x3 grid with the centerpiece cropped out.{0}'
  $UpscaleSeamlessTipString += 'This gives the upscaling filter neighboring pixels to work with, and{0}'
  $UpscaleSeamlessTipString += 'prevents the texture having visible seams when tiled in-game. The{0}'
  $UpscaleSeamlessTipString += 'added buffer pixels are cropped away from the final result.{0}'
  $UpscaleSeamlessTipString += '{0}'
  $UpscaleSeamlessTipString += 'Disable: Do not apply the seamless method to any textures.{0}'
  $UpscaleSeamlessTipString += 'Opaque: Apply this method when there are no transparent pixels.{0}'
  $UpscaleSeamlessTipString += 'All: Apply this method to all textures regardless of transparency.{0}'
  $UpscaleSeamlessTipString += '{0}'
  $UpscaleSeamlessTipString += 'This option is only useful for seamless textures. It adds processing{0}'
  $UpscaleSeamlessTipString += 'time and may add noise that spills over into the edges of textures{0}'
  $UpscaleSeamlessTipString += 'that are not seamless. Most textures that have seamless edges do{0}'
  $UpscaleSeamlessTipString += 'not contain transparent pixels, but this is not always true so when{0}'
  $UpscaleSeamlessTipString += 'to apply this method is configurable.'
  $UpscaleSeamlessTipString = [String]::Format($UpscaleSeamlessTipString, [Environment]::NewLine)
  $UpscaleSeamlessTip.SetToolTip($UpscaleSeamlessLabel, $UpscaleSeamlessTipString)

  # 09: Upscale Filter - Seamless Buffer - Create a Number Box.
  $global:UpscaleSeamlessPixels = New-Object Windows.Forms.NumericUpDown
  $UpscaleSeamlessPixels.Size = DPISize (New-Object Drawing.Size(72, 10))
  $UpscaleSeamlessPixels.Location = DPISize (New-Object Drawing.Point(10, 98)) -AddY $DPIOffsetFix
  $UpscaleSeamlessPixels.Name = 'SeamlessPixels'
  $UpscaleSeamlessPixels.DecimalPlaces = 0
  $UpscaleSeamlessPixels.Minimum = 8
  $UpscaleSeamlessPixels.Maximum = 32
  $UpscaleSeamlessPixels.Increment = 2
  $UpscaleSeamlessPixels.Value = $SeamlessPixels
  $UpscaleSeamlessPixels.Enabled = ($UpscaleSeamlessCombo.SelectedItem -ne 'Disable')
  $UpscaleSeamlessPixels.Add_ValueChanged({ NumericUpDownEnforceEven })
  $UpscaleFiltersGroup.Controls.Add($UpscaleSeamlessPixels)

  # 09: Upscale Filter - Seamless Buffer - Create a label.
  $global:UpscaleSeamlessPixelsLabel = New-Object Windows.Forms.Label
  $UpscaleSeamlessPixelsLabel.Size = DPISize (New-Object Drawing.Size(96, 20))
  $UpscaleSeamlessPixelsLabel.Location = DPISize (New-Object Drawing.Point(84, 101))
  $UpscaleSeamlessPixelsLabel.Text = 'Seamless Buffer'
  $UpscaleSeamlessPixelsLabel.Enabled = ($UpscaleSeamlessCombo.SelectedItem -ne 'Disable')
  $UpscaleFiltersGroup.Controls.Add($UpscaleSeamlessPixelsLabel)

  # 09: Upscale Filter - Seamless Buffer - Create a tooltip.
  $UpscaleSeamlessPixelsTip = New-Object Windows.Forms.ToolTip
  $UpscaleSeamlessPixelsTip.InitialDelay = $ToolTipDelay
  $UpscaleSeamlessPixelsTip.AutoPopDelay = $ToolTipDuration
  $UpscaleSeamlessPixelsTipString = 'Configures the number of rows/columns of pixels{0}'
  $UpscaleSeamlessPixelsTipString += 'that are added to textures before upscaling. The{0}'
  $UpscaleSeamlessPixelsTipString += 'more pixels added, the higher the chance the image{0}'
  $UpscaleSeamlessPixelsTipString += 'will remain seamless. But increasing this value will{0}'
  $UpscaleSeamlessPixelsTipString += 'slightly impact the total amount of processing time.'
  $UpscaleSeamlessPixelsTipString = [String]::Format($UpscaleSeamlessPixelsTipString, [Environment]::NewLine)
  $UpscaleSeamlessPixelsTip.SetToolTip($UpscaleSeamlessPixelsLabel, $UpscaleSeamlessPixelsTipString)

  # 09: Upscale Filter - Upscale Format - The output format to create textures, PNG or DDS.
  $global:UpscaleFormatCombo = New-Object Windows.Forms.ComboBox
  $UpscaleFormatCombo.Size = DPISize (New-Object Drawing.Size(72, 10))
  $UpscaleFormatCombo.Location = DPISize (New-Object Drawing.Point(192, 20)) -AddY $DPIOffsetFix
  $UpscaleFormatCombo.Name = 'UpscaleFormat'
  $UpscaleFormatCombo.Items.Add('PNG') | Out-Null
  $UpscaleFormatCombo.Items.Add('DDS') | Out-Null
  $UpscaleFormatCombo.SelectedItem = ExtensionToText -Extension $UpscaleFormat
  $UpscaleFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $UpscaleFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue (Get-Variable -Name $this.SelectedItem -ValueOnly) })
  $UpscaleFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $UpscaleFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $UpscaleFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $UpscaleFiltersGroup.Controls.Add($UpscaleFormatCombo)

  # 09: Upscale Filter - Upscale Format - Create a label.
  $global:UpscaleFormatLabel = New-Object Windows.Forms.Label
  $UpscaleFormatLabel.Size = DPISize (New-Object Drawing.Size(100, 22))
  $UpscaleFormatLabel.Location = DPISize (New-Object Drawing.Point(266, 23))
  $UpscaleFormatLabel.Text = 'Output Format'
  $UpscaleFiltersGroup.Controls.Add($UpscaleFormatLabel)

  # 09: Upscale Filter - Upscale Format - Create a tooltip.
  $UpscaleFormatTip = New-Object Windows.Forms.ToolTip
  $UpscaleFormatTip.InitialDelay = $ToolTipDelay
  $UpscaleFormatTip.AutoPopDelay = $ToolTipDuration
  $UpscaleFormatTipString = 'The file extension/output format{0}'
  $UpscaleFormatTipString += 'that textures will be created with.'
  $UpscaleFormatTipString = [String]::Format($UpscaleFormatTipString, [Environment]::NewLine)
  $UpscaleFormatTip.SetToolTip($UpscaleFormatLabel, $UpscaleFormatTipString)

  # 09: Upscale Filter: Factor As Target Checkbox String
  $UpscaleFactorString = " Upscale Factor as Target{0} (Dolphin Textures Only)"
  $UpscaleFactorString = [String]::Format($UpscaleFactorString, [Environment]::NewLine)

  # 09: Upscale Filter - Factor As Target - Sets the upscale factor as the target upscale factor rather than the resulting upscale factor.
  $global:UpscaleFactorTarget = New-Object Windows.Forms.CheckBox
  $UpscaleFactorTarget.Size = DPISize (New-Object Drawing.Size(160, 30))
  $UpscaleFactorTarget.Location = DPISize (New-Object Drawing.Point(192, 49))
  $UpscaleFactorTarget.Name = 'UpscaleAsTarget'
  $UpscaleFactorTarget.Checked = $UpscaleAsTarget
  $UpscaleFactorTarget.Text = $UpscaleFactorString
  $UpscaleFactorTarget.Add_CheckStateChanged({ CheckBoxStateToggled })
  $UpscaleFactorTarget.Visible = ($CTTPSSelectedMode -eq 'Dolphin Mode')
  $UpscaleFiltersGroup.Controls.Add($UpscaleFactorTarget)

  # 09: Upscale Filter - Factor As Target - Create a tooltip.
  $UpscaleFactorTargetTip = New-Object Windows.Forms.ToolTip
  $UpscaleFactorTargetTip.InitialDelay = $ToolTipDelay
  $UpscaleFactorTargetTip.AutoPopDelay = $ToolTipDuration
  $UpscaleFactorTargetTipString =  ''
  $UpscaleFactorTargetTipString += 'Multiply the upscale factor by the texture{0}'
  $UpscaleFactorTargetTipString += 'original dimensions instead of the current{0}'
  $UpscaleFactorTargetTipString += 'dimensions. This only works with Dolphin{0}'
  $UpscaleFactorTargetTipString += 'tex1 images (dimensions are in filename).{0}'
  $UpscaleFactorTargetTipString += '{0}'
  $UpscaleFactorTargetTipString += 'This ensures the resulting dimensions are{0}'
  $UpscaleFactorTargetTipString += 'an integer upscale of the original image.{0}'
  $UpscaleFactorTargetTipString += 'If the resulting dimensions are larger than{0}'
  $UpscaleFactorTargetTipString += 'the target, dimensions are downscaled to{0}'
  $UpscaleFactorTargetTipString += '(Upscale Factor * Original Dimensions).'
  $UpscaleFactorTargetTipString = [String]::Format($UpscaleFactorTargetTipString, [Environment]::NewLine)
  $UpscaleFactorTargetTip.SetToolTip($UpscaleFactorTarget, $UpscaleFactorTargetTipString)

  # 09: Upscale Filter - Additional Options - The extra options. 
  $global:UpscaleAdditionalOptions = New-Object Windows.Forms.Button
  $UpscaleAdditionalOptions.Size = DPISize (New-Object Drawing.Size(128, 23))
  $UpscaleAdditionalOptions.Location = DPISize (New-Object Drawing.Point(192, 90))
  $UpscaleAdditionalOptions.Text = 'Additional Options'
  $UpscaleAdditionalOptions.Add_Click({ AdditionalOptionsButton })
  $UpscaleAdditionalOptions.Visible = (($FilterSelected -eq 'Waifu2x') -or ($FilterSelected -like '*GAN'))
  $UpscaleFiltersGroup.Controls.Add($UpscaleAdditionalOptions)

  # 10: Calculate VRAM - Create the groupbox that will hold the calculate VRAM options.
  $global:VRAMRequirementGroup = New-Object Windows.Forms.GroupBox
  $VRAMRequirementGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $VRAMRequirementGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $VRAMRequirementGroup.Text = ' Calculate VRAM '
  $MainDialogPanel.Controls.Add($VRAMRequirementGroup)

  # 10: Calculate VRAM - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:VRAMDescriptionTTBox = New-Object TransparentLabel
  $VRAMDescriptionTTBox.Size = DPISize (New-Object Drawing.Size(358, 50))
  $VRAMDescriptionTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $VRAMDescriptionTTBox.Text = ""
  $VRAMRequirementGroup.Controls.Add($VRAMDescriptionTTBox)

  # 10: Calculate VRAM - Add a short description of this dialog.
  $global:VRAMDescriptionLabel = New-Object AdvRichTextBox
  $VRAMDescriptionLabel.Size = DPISize (New-Object Drawing.Size(358, 50))
  $VRAMDescriptionLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $VRAMDescriptionString = 'Scans the "Input Path" and all sub-folders and reports the amount of VRAM the textures will collectively consume. The '
  $VRAMDescriptionString += 'Input Path can be temporarily overwritten by providing a custom path below.'
  $VRAMDescriptionLabel.Text = $VRAMDescriptionString
  $VRAMDescriptionLabel.SelectionAlignment = [TextAlign]::Justify
  $VRAMDescriptionLabel.TabStop = $false
  $VRAMDescriptionLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $VRAMDescriptionLabel.ReadOnly = $true
  $VRAMDescriptionLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $VRAMRequirementGroup.Controls.Add($VRAMDescriptionLabel)

  # 10: Calculate VRAM - Input Path Override - Create a label that explains that this is where a texture path goes.
  $global:VRAMPathLabel = New-Object Windows.Forms.Label
  $VRAMPathLabel.Size = DPISize (New-Object Drawing.Size(314, 14))
  $VRAMPathLabel.Location = DPISize (New-Object Drawing.Point(10, 78))
  $VRAMPathLabel.Text = 'Input Path Override:'
  $VRAMRequirementGroup.Controls.Add($VRAMPathLabel)

  # 10: Calculate VRAM - Input Path Override - Create a tooltip.
  $VRAMPathLabelTip = New-Object Windows.Forms.ToolTip
  $VRAMPathLabelTip.InitialDelay = $ToolTipDelay
  $VRAMPathLabelTip.AutoPopDelay = $ToolTipDuration
  $VRAMPathLabelTipString = 'The path to the textures to calculate VRAM usage.'
  $VRAMPathLabelTip.SetToolTip($VRAMPathLabel, $VRAMPathLabelTipString)

  # 10: Calculate VRAM - Input Path Override - Create the text box that will hold the VRAM path. The button can also be used to add the path.
  $global:VRAMPathTextBox = New-Object Windows.Forms.TextBox
  $VRAMPathTextBox.Size = DPISize (New-Object Drawing.Size(334, 22))
  $VRAMPathTextBox.Location = DPISize (New-Object Drawing.Point(10, 95)) -AddY $DPIOffsetFix
  $VRAMPathTextBox.Name = 'VRAMPackPath'
  $VRAMPathTextBox.Text = '<<-- Add with the button or drag and drop a folder -->>'
  $VRAMPathTextBox.AllowDrop = $true
  $VRAMPathTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $VRAMPathTextBox.Add_DragDrop({ VRAM_UpdateFolderPathDragAndDrop })
  $VRAMPathTextBox.Add_Click({ ClearTextBox })
  $VRAMPathTextBox.Add_Leave({ VRAM_UpdateFolderPathTextBox })
  $VRAMRequirementGroup.Controls.Add($VRAMPathTextBox)

  # 10: Calculate VRAM - Input Path Override - Create a button to select path.
  $global:VRAMPathButton = New-Object Windows.Forms.Button
  $VRAMPathButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $VRAMPathButton.Location = DPISize (New-Object Drawing.Point(347, 94))
  $VRAMPathButton.Name = 'VRAMPackPath'
  $VRAMPathButton.Text = '...'
  $VRAMPathButton.Add_Click({ VRAM_UpdateFolderPathButton })
  $VRAMRequirementGroup.Controls.Add($VRAMPathButton)

  # 11: Generate New Mipmaps - Generates brand spanking new mipmaps directly into the texture pack.
  $global:GenNewMipmapsGroup = New-Object Windows.Forms.GroupBox
  $GenNewMipmapsGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $GenNewMipmapsGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $GenNewMipmapsGroup.Text = ' Description '
  $MainDialogPanel.Controls.Add($GenNewMipmapsGroup)

  # 11: Generate New Mipmaps - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:GenNewMipmapsTTBox = New-Object TransparentLabel
  $GenNewMipmapsTTBox.Size = DPISize (New-Object Drawing.Size(358, 56))
  $GenNewMipmapsTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $GenNewMipmapsTTBox.Text = ""
  $GenNewMipmapsGroup.Controls.Add($GenNewMipmapsTTBox)

  # 11: Generate New Mipmaps - Add a short description of this dialog.
  $global:GenNewMipmapsLabel = New-Object AdvRichTextBox
  $GenNewMipmapsLabel.Size = DPISize (New-Object Drawing.Size(358, 56))
  $GenNewMipmapsLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $GenNewMipmapsString = 'This option generates new mipmaps for all Dolphin mipmap "m" textures. Arbitrary mipmaps are preserved unless the "Force New Mipmaps" option is ticked. '
  $GenNewMipmapsString += 'Care must be taken with this option as textures with incorrect dimensions will have incorrect mipmaps.'
  $GenNewMipmapsLabel.Text = $GenNewMipmapsString
  $GenNewMipmapsLabel.SelectionAlignment = [TextAlign]::Justify
  $GenNewMipmapsLabel.TabStop = $false
  $GenNewMipmapsLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $GenNewMipmapsLabel.ReadOnly = $true
  $GenNewMipmapsLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $GenNewMipmapsGroup.Controls.Add($GenNewMipmapsLabel)

  # 11: Generate New Mipmaps - Allow hiding "OK" textures, or rather ones that didn't have invalid mipmaps.
  $global:GenNewMipmapsCheck = New-Object Windows.Forms.CheckBox
  $GenNewMipmapsCheck.Size = DPISize (New-Object Drawing.Size(160, 16))
  $GenNewMipmapsCheck.Location = DPISize (New-Object Drawing.Point(12, 94))
  $GenNewMipmapsCheck.Name = 'InPlaceMipmaps'
  $GenNewMipmapsCheck.Checked = $InPlaceMipmaps
  $GenNewMipmapsCheck.Text = ' Create Mipmaps In-Place'
  $GenNewMipmapsCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $GenNewMipmapsGroup.Controls.Add($GenNewMipmapsCheck)

  # 11: Generate New Mipmaps - Create a tooltip.
  $GenNewMipmapsCheckTip = New-Object Windows.Forms.ToolTip
  $GenNewMipmapsCheckTip.InitialDelay = $ToolTipDelay
  $GenNewMipmapsCheckTip.AutoPopDelay = $ToolTipDuration
  $GenNewMipmapsCheckTipString = 'Modify the textures directly rather than{0}'
  $GenNewMipmapsCheckTipString += 'recreating them in the output folder.'
  $GenNewMipmapsCheckTipString = [String]::Format($GenNewMipmapsCheckTipString, [Environment]::NewLine)
  $GenNewMipmapsCheckTip.SetToolTip($GenNewMipmapsCheck, $GenNewMipmapsCheckTipString)

  # 11: Generate New Mipmaps - Enable AutoSharpen - Create a checkbox.
  $global:GenNewEnableSharpen = New-Object Windows.Forms.CheckBox
  $GenNewEnableSharpen.Size = DPISize (New-Object Drawing.Size(130, 16))
  $GenNewEnableSharpen.Location = DPISize (New-Object Drawing.Point(192, 94))
  $GenNewEnableSharpen.Name = 'EnableSharpen'
  $GenNewEnableSharpen.Checked = $EnableSharpen
  $GenNewEnableSharpen.Text = ' Enable Sharpening'
  $GenNewEnableSharpen.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleEnableSharpen })
  $GenNewMipmapsGroup.Controls.Add($GenNewEnableSharpen)

  # 11: Generate New Mipmaps - Enable AutoSharpen - Create a tooltip.
  $GenNewEnableSharpenTip = New-Object Windows.Forms.ToolTip
  $GenNewEnableSharpenTip.InitialDelay = $ToolTipDelay
  $GenNewEnableSharpenTip.AutoPopDelay = $ToolTipDuration
  $GenNewEnableSharpenTipString =  'Applies a sharpening filter to all textures{0}'
  $GenNewEnableSharpenTipString += 'when they are resized for any reason. The{0}'
  $GenNewEnableSharpenTipString += 'amount of sharpening is calculated based{0}'
  $GenNewEnableSharpenTipString += 'on the amount of change in resolution. It{0}'
  $GenNewEnableSharpenTipString += 'affects resized textures and all mipmaps,{0}'
  $GenNewEnableSharpenTipString += 'material maps, and generated icons.{0}'
  $GenNewEnableSharpenTipString += '{0}'
  $GenNewEnableSharpenTipString += 'In the past, this was always applied. This{0}'
  $GenNewEnableSharpenTipString += 'option was added in v50.0 as sharpening{0}'
  $GenNewEnableSharpenTipString += 'may not look so good for certain images.'
  $GenNewEnableSharpenTipString = [String]::Format($GenNewEnableSharpenTipString, [Environment]::NewLine)
  $GenNewEnableSharpenTip.SetToolTip($GenNewEnableSharpen, $GenNewEnableSharpenTipString)

  # 12: Invalid Mipmaps - Create the groupbox that will hold the remove invalid mipmaps description.
  $global:InvalidMipmapsGroup = New-Object Windows.Forms.GroupBox
  $InvalidMipmapsGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $InvalidMipmapsGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $InvalidMipmapsGroup.Text = ' Description '
  $MainDialogPanel.Controls.Add($InvalidMipmapsGroup)

  # 12: Invalid Mipmaps - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:InvalidMipmapsTTBox = New-Object TransparentLabel
  $InvalidMipmapsTTBox.Size = DPISize (New-Object Drawing.Size(358, 66))
  $InvalidMipmapsTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $InvalidMipmapsTTBox.Text = ""
  $InvalidMipmapsGroup.Controls.Add($InvalidMipmapsTTBox)

  # 12: Invalid Mipmaps - Add a short description of this dialog.
  $global:InvalidMipmapsLabel = New-Object AdvRichTextBox
  $InvalidMipmapsLabel.Size = DPISize (New-Object Drawing.Size(358, 66))
  $InvalidMipmapsLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $InvalidMipmapsString = 'Checks Dolphin textures that contain the "tex1" prefix that have included mipmap levels but are not actually a mipmap texture. This will find both invalid '
  $InvalidMipmapsString += 'external and internal DDS mipmaps and delete them. Dolphin can now use mipmaps for non-mipmap textures, so use this operation wisely.'
  $InvalidMipmapsLabel.Text = $InvalidMipmapsString
  $InvalidMipmapsLabel.SelectionAlignment = [TextAlign]::Justify
  $InvalidMipmapsLabel.TabStop = $false
  $InvalidMipmapsLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $InvalidMipmapsLabel.ReadOnly = $true
  $InvalidMipmapsLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $InvalidMipmapsGroup.Controls.Add($InvalidMipmapsLabel)

  # 12: Invalid Mipmaps - Allow hiding "OK" textures, or rather ones that didn't have invalid mipmaps.
  $global:InvalidHideOKTextures = New-Object Windows.Forms.CheckBox
  $InvalidHideOKTextures.Size = DPISize (New-Object Drawing.Size(120, 16))
  $InvalidHideOKTextures.Location = DPISize (New-Object Drawing.Point(12, 94))
  $InvalidHideOKTextures.Name = 'HideOKTextures'
  $InvalidHideOKTextures.Checked = $HideOKTextures
  $InvalidHideOKTextures.Text = ' Hide OK Textures'
  $InvalidHideOKTextures.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleOKTextures })
  $InvalidMipmapsGroup.Controls.Add($InvalidHideOKTextures)

  # 12: Invalid Mipmaps - Create a tooltip.
  $InvalidHideOKTexturesTip = New-Object Windows.Forms.ToolTip
  $InvalidHideOKTexturesTip.InitialDelay = $ToolTipDelay
  $InvalidHideOKTexturesTip.AutoPopDelay = $ToolTipDuration
  $InvalidHideOKTexturesTipString = "Textures that don't have mipmaps removed{0}"
  $InvalidHideOKTexturesTipString += 'are flagged as "OK". This option prevents{0}'
  $InvalidHideOKTexturesTipString += 'these textures from showing up in the log.'
  $InvalidHideOKTexturesTipString = [String]::Format($InvalidHideOKTexturesTipString, [Environment]::NewLine)
  $InvalidHideOKTexturesTip.SetToolTip($InvalidHideOKTextures, $InvalidHideOKTexturesTipString)

  # 13: Extract DDS Mipmaps - Create the groupbox that will hold the extract DDS mipmaps description.
  $global:ExtractDDSMipmapGroup = New-Object Windows.Forms.GroupBox
  $ExtractDDSMipmapGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ExtractDDSMipmapGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ExtractDDSMipmapGroup.Text = ' Description '
  $MainDialogPanel.Controls.Add($ExtractDDSMipmapGroup)

  # 13: Extract DDS Mipmaps - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ExtractDDSMipmapTTBox = New-Object TransparentLabel
  $ExtractDDSMipmapTTBox.Size = DPISize (New-Object Drawing.Size(358, 66))
  $ExtractDDSMipmapTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ExtractDDSMipmapTTBox.Text = ""
  $ExtractDDSMipmapGroup.Controls.Add($ExtractDDSMipmapTTBox)

  # 13: Extract DDS Mipmaps - Add a short description of this dialog.
  $global:ExtractDDSMipmapLabel = New-Object AdvRichTextBox
  $ExtractDDSMipmapLabel.Size = DPISize (New-Object Drawing.Size(358, 66))
  $ExtractDDSMipmapLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ExtractDDSMipmapString = 'Extracts internal mipmaps (images) from DDS and TIFF images into the output path. Using the "In-Place" option extracts them at the '
  $ExtractDDSMipmapString += 'location of image, overwriting the old image. Images can be recombined into internal mipmaps by using "Covert Textures to Another Format".'
  $ExtractDDSMipmapLabel.Text = $ExtractDDSMipmapString
  $ExtractDDSMipmapLabel.SelectionAlignment = [TextAlign]::Justify
  $ExtractDDSMipmapLabel.TabStop = $false
  $ExtractDDSMipmapLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ExtractDDSMipmapLabel.ReadOnly = $true
  $ExtractDDSMipmapLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ExtractDDSMipmapGroup.Controls.Add($ExtractDDSMipmapLabel)

  # 13: Extract DDS Mipmaps - Allow extracting mipmaps directly into the pack.
  $global:ExtractDDSMipmapCheck = New-Object Windows.Forms.CheckBox
  $ExtractDDSMipmapCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $ExtractDDSMipmapCheck.Location = DPISize (New-Object Drawing.Point(12, 94))
  $ExtractDDSMipmapCheck.Name = 'InPlaceExtractDDS'
  $ExtractDDSMipmapCheck.Checked = $InPlaceExtractDDS
  $ExtractDDSMipmapCheck.Text = ' Extract Mipmaps In-Place'
  $ExtractDDSMipmapCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ExtractDDSMipmapGroup.Controls.Add($ExtractDDSMipmapCheck)

  # 13: Extract DDS Mipmaps - Create a tooltip.
  $ExtractDDSMipmapTip = New-Object Windows.Forms.ToolTip
  $ExtractDDSMipmapTip.InitialDelay = $ToolTipDelay
  $ExtractDDSMipmapTip.AutoPopDelay = $ToolTipDuration
  $ExtractDDSMipmapTipString = 'Extract the mipmaps directly into the{0}'
  $ExtractDDSMipmapTipString += 'texture pack rather than recreating{0}'
  $ExtractDDSMipmapTipString += 'them separately in the output folder.'
  $ExtractDDSMipmapTipString = [String]::Format($ExtractDDSMipmapTipString, [Environment]::NewLine)
  $ExtractDDSMipmapTip.SetToolTip($ExtractDDSMipmapCheck, $ExtractDDSMipmapTipString)

  # 14: Remove Alpha - Create the groupbox that will hold the remove alpha channel description.
  $global:RemoveAlphaGroup = New-Object Windows.Forms.GroupBox
  $RemoveAlphaGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $RemoveAlphaGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $RemoveAlphaGroup.Text = ' Description '
  $MainDialogPanel.Controls.Add($RemoveAlphaGroup)

  # 14: Remove Alpha - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:RemoveAlphaTTBox = New-Object TransparentLabel
  $RemoveAlphaTTBox.Size = DPISize (New-Object Drawing.Size(358, 66))
  $RemoveAlphaTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $RemoveAlphaTTBox.Text = ""
  $RemoveAlphaGroup.Controls.Add($RemoveAlphaTTBox)

  # 14: Remove Alpha - Add a short description of this dialog.
  $global:RemoveAlphaLabel = New-Object AdvRichTextBox
  $RemoveAlphaLabel.Size = DPISize (New-Object Drawing.Size(358, 66))
  $RemoveAlphaLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $RemoveAlphaString = "PNG textures that have an alpha channel but don't actually contain any transparent pixels will have the alpha channel removed. "
  $RemoveAlphaString += 'Alpha channels take up unnecessary disk space if the image does not have transparency, and they can interfere with other options of this script.'
  $RemoveAlphaLabel.Text = $RemoveAlphaString
  $RemoveAlphaLabel.SelectionAlignment = [TextAlign]::Justify
  $RemoveAlphaLabel.TabStop = $false
  $RemoveAlphaLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $RemoveAlphaLabel.ReadOnly = $true
  $RemoveAlphaLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $RemoveAlphaGroup.Controls.Add($RemoveAlphaLabel)

  # 14: Remove Alpha - Allow hiding "OK" textures, or rather ones that didn't have alpha channel removed.
  $global:RemoveAlphaHideOK = New-Object Windows.Forms.CheckBox
  $RemoveAlphaHideOK.Size = DPISize (New-Object Drawing.Size(120, 16))
  $RemoveAlphaHideOK.Location = DPISize (New-Object Drawing.Point(12, 94))
  $RemoveAlphaHideOK.Name = 'HideOKTextures'
  $RemoveAlphaHideOK.Checked = $HideOKTextures
  $RemoveAlphaHideOK.Text = ' Hide OK Textures'
  $RemoveAlphaHideOK.Add_CheckStateChanged({ CheckBoxStateToggled ; Operations_ToggleOKTextures})
  $RemoveAlphaGroup.Controls.Add($RemoveAlphaHideOK)

  # 14: Remove Alpha - Create a tooltip.
  $RemoveAlphaHideOKTtip = New-Object Windows.Forms.ToolTip
  $RemoveAlphaHideOKTtip.InitialDelay = $ToolTipDelay
  $RemoveAlphaHideOKTtip.AutoPopDelay = $ToolTipDuration
  $RemoveAlphaHideOKTtipString = 'Textures that do not have an alpha channel{0}'
  $RemoveAlphaHideOKTtipString += 'removed are flagged as "OK". This option{0}'
  $RemoveAlphaHideOKTtipString += 'will prevent these textures from showing up{0}'
  $RemoveAlphaHideOKTtipString += 'in the log file (if creating a log is enabled).'
  $RemoveAlphaHideOKTtipString = [String]::Format($RemoveAlphaHideOKTtipString, [Environment]::NewLine)
  $RemoveAlphaHideOKTtip.SetToolTip($RemoveAlphaHideOK, $RemoveAlphaHideOKTtipString)

  # 15: Combine Textures - Create the groupbox that will hold the combine textures options.
  $global:CombineTextureGroup = New-Object Windows.Forms.GroupBox
  $CombineTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $CombineTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $CombineTextureGroup.Text = ' Combine Texture Options '
  $MainDialogPanel.Controls.Add($CombineTextureGroup)

  # 15: Combine Textures - Grid Array - Configures the number of columns in the texture array.
  $global:CombineColumnsNumBox = New-Object Windows.Forms.NumericUpDown
  $CombineColumnsNumBox.Size = DPISize (New-Object Drawing.Size(44, 10))
  $CombineColumnsNumBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $CombineColumnsNumBox.Name = 'TextureCols'
  $CombineColumnsNumBox.DecimalPlaces = 0
  $CombineColumnsNumBox.Minimum = 1
  $CombineColumnsNumBox.Maximum = $SplitCombineLimits
  $CombineColumnsNumBox.Increment = 1
  $CombineColumnsNumBox.Value = $TextureCols
  $CombineColumnsNumBox.Add_ValueChanged({ UpdateTextureArrayCells })
  $CombineTextureGroup.Controls.Add($CombineColumnsNumBox)

  # 15: Combine Textures - Grid Array - Create a label.
  $global:CombineXLabel = New-Object Windows.Forms.Label
  $CombineXLabel.Size = DPISize (New-Object Drawing.Size(12, 12))
  $CombineXLabel.Location = DPISize (New-Object Drawing.Point(56, 22))
  $CombineXLabel.Text = 'x'
  $CombineTextureGroup.Controls.Add($CombineXLabel)

  # 15: Combine Textures - Grid Array - Configures the number of rows in the texture array.
  $global:CombineRowsNumBox = New-Object Windows.Forms.NumericUpDown
  $CombineRowsNumBox.Size = DPISize (New-Object Drawing.Size(44, 10))
  $CombineRowsNumBox.Location = DPISize (New-Object Drawing.Point(69, 20)) -AddY $DPIOffsetFix
  $CombineRowsNumBox.Name = 'TextureRows'
  $CombineRowsNumBox.DecimalPlaces = 0
  $CombineRowsNumBox.Minimum = 1
  $CombineRowsNumBox.Maximum = $SplitCombineLimits
  $CombineRowsNumBox.Increment = 1
  $CombineRowsNumBox.Value = $TextureRows
  $CombineRowsNumBox.Add_ValueChanged({ UpdateTextureArrayCells })
  $CombineTextureGroup.Controls.Add($CombineRowsNumBox)

  # 15: Combine Textures - Grid Array - Create a label.
  $global:CombineColumnsLabel = New-Object Windows.Forms.Label
  $CombineColumnsLabel.Size = DPISize (New-Object Drawing.Size(60, 18))
  $CombineColumnsLabel.Location = DPISize (New-Object Drawing.Point(116, 23))
  $CombineColumnsLabel.Text = 'Grid Array'
  $CombineTextureGroup.Controls.Add($CombineColumnsLabel)

  # 15: Combine Textures - Grid Array - Create a tooltip.
  $CombineColumnsTip = New-Object Windows.Forms.ToolTip
  $CombineColumnsTip.InitialDelay = $ToolTipDelay
  $CombineColumnsTip.AutoPopDelay = $ToolTipDuration
  $CombineColumnsTipString = 'The number of (columns * rows) in the grid.'
  $CombineColumnsTipString = [String]::Format($CombineColumnsTipString, [Environment]::NewLine)
  $CombineColumnsTip.SetToolTip($CombineColumnsLabel, $CombineColumnsTipString)

  # Calculate the maximum values for the width and height of the buttons.
  $CombineMaxWidth  = $Monitor.Width - ($Monitor.Width * 0.10)
  $CombineMaxHeight = $Monitor.Height - ($Monitor.Height * 0.20)

  # Make sure the values that are stored fall within range of the maximums.
  if ($CombineButtonSizeX -gt $CombineMaxWidth)  { $global:CombineButtonSizeX = $CombineMaxWidth }
  if ($CombineButtonSizeY -gt $CombineMaxHeight) { $global:CombineButtonSizeY = $CombineMaxHeight }

  # 15: Combine Textures - Button Size - Create a combobox.
  $global:CombineRatioXNumBox = New-Object Windows.Forms.NumericUpDown
  $CombineRatioXNumBox.Size = DPISize (New-Object Drawing.Size(44, 10))
  $CombineRatioXNumBox.Location = DPISize (New-Object Drawing.Point(184, 20)) -AddY $DPIOffsetFix
  $CombineRatioXNumBox.Name = 'CombineButtonSizeX'
  $CombineRatioXNumBox.DecimalPlaces = 0
  $CombineRatioXNumBox.Minimum = 1
  $CombineRatioXNumBox.Maximum = $CombineMaxWidth
  $CombineRatioXNumBox.Increment = 1
  $CombineRatioXNumBox.Value = $CombineButtonSizeX
  $CombineRatioXNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineTextureGroup.Controls.Add($CombineRatioXNumBox)

  # 15: Combine Textures - Button Size - Create a label.
  $global:CombineX2Label = New-Object Windows.Forms.Label
  $CombineX2Label.Size = DPISize (New-Object Drawing.Size(12, 12))
  $CombineX2Label.Location = DPISize (New-Object Drawing.Point(231, 22))
  $CombineX2Label.Text = 'x'
  $CombineTextureGroup.Controls.Add($CombineX2Label)

  # 15: Combine Textures - Button Size - Create a combobox.
  $global:CombineRatioYNumBox = New-Object Windows.Forms.NumericUpDown
  $CombineRatioYNumBox.Size = DPISize (New-Object Drawing.Size(44, 10))
  $CombineRatioYNumBox.Location = DPISize (New-Object Drawing.Point(244, 20)) -AddY $DPIOffsetFix
  $CombineRatioYNumBox.Name = 'CombineButtonSizeY'
  $CombineRatioYNumBox.DecimalPlaces = 0
  $CombineRatioYNumBox.Minimum = 1
  $CombineRatioYNumBox.Maximum = $CombineMaxHeight
  $CombineRatioYNumBox.Increment = 1
  $CombineRatioYNumBox.Value = $CombineButtonSizeY
  $CombineRatioYNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineTextureGroup.Controls.Add($CombineRatioYNumBox)

  # 15: Combine Textures - Button Size - Create a label.
  $global:CombineButtonRatioLabel = New-Object Windows.Forms.Label
  $CombineButtonRatioLabel.Size = DPISize (New-Object Drawing.Size(64, 18))
  $CombineButtonRatioLabel.Location = DPISize (New-Object Drawing.Point(290, 23))
  $CombineButtonRatioLabel.Text = 'Button Size'
  $CombineTextureGroup.Controls.Add($CombineButtonRatioLabel)

  # 15: Combine Textures - Button Size - Create a tooltip.
  $CombineButtonRatioTip = New-Object Windows.Forms.ToolTip
  $CombineButtonRatioTip.InitialDelay = $ToolTipDelay
  $CombineButtonRatioTip.AutoPopDelay = $ToolTipDuration
  $CombineButtonRatioTipString =  'Grid buttons are 100x100 pixels in size by{0}'
  $CombineButtonRatioTipString += 'default. These values can modify the size{0}'
  $CombineButtonRatioTipString += 'and shape of buttons for a custom size.'
  $CombineButtonRatioTipString = [String]::Format($CombineButtonRatioTipString, [Environment]::NewLine)
  $CombineButtonRatioTip.SetToolTip($CombineButtonRatioLabel, $CombineButtonRatioTipString)

  # 15: Combine Textures - CTT Textures - Create a checkbox.
  $global:CombineCTTTexCheck = New-Object Windows.Forms.CheckBox
  $CombineCTTTexCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $CombineCTTTexCheck.Location = DPISize (New-Object Drawing.Point(10, 57))
  $CombineCTTTexCheck.Name = 'CTTIncludeTextures'
  $CombineCTTTexCheck.Checked = $CTTIncludeTextures
  $CombineCTTTexCheck.Text = ' Include CTT File Textures'
  $CombineCTTTexCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $CombineTextureGroup.Controls.Add($CombineCTTTexCheck)

  # 15: Combine Textures - CTT Textures - Create a tooltip.
  $CombineCTTTexTip = New-Object Windows.Forms.ToolTip
  $CombineCTTTexTip.InitialDelay = $ToolTipDelay
  $CombineCTTTexTip.AutoPopDelay = $ToolTipDuration
  $CombineCTTTexTipString =  'Backup the texture segments when combining{0}'
  $CombineCTTTexTipString += 'textures into a folder that is included with the{0}'
  $CombineCTTTexTipString += 'combined texture and the CTT File. This will{0}'
  $CombineCTTTexTipString += 'reload the textures into the grid if this folder{0}'
  $CombineCTTTexTipString += 'is in the same path as the CTT when loaded.'
  $CombineCTTTexTipString = [String]::Format($CombineCTTTexTipString, [Environment]::NewLine)
  $CombineCTTTexTip.SetToolTip($CombineCTTTexCheck, $CombineCTTTexTipString)

  # 15: Combine Textures - Combined Name - Allows setting an output name for the combined textures.
  $global:CombineNameTextBox = New-Object Windows.Forms.TextBox
  $CombineNameTextBox.Size = DPISize (New-Object Drawing.Size(116, 20))
  $CombineNameTextBox.Location = DPISize (New-Object Drawing.Point(184, 54)) -AddY $DPIOffsetFix
  $CombineNameTextBox.Name = 'CombinedName'
  $CombineNameTextBox.Text = $CombinedName
  $CombineNameTextBox.Add_Click({ ClearTextBox })
  $CombineNameTextBox.Add_Leave({ CombineTextures_UpdateName })
  $CombineTextureGroup.Controls.Add($CombineNameTextBox)

  # 15: Combine Textures - Combined Name - Create a label.
  $global:CombineNameLabel = New-Object Windows.Forms.Label
  $CombineNameLabel.Size = DPISize (New-Object Drawing.Size(74, 22))
  $CombineNameLabel.Location = DPISize (New-Object Drawing.Point(304, 57))
  $CombineNameLabel.Text = 'Output Name'
  $CombineTextureGroup.Controls.Add($CombineNameLabel)

  # 15: Combine Textures - Combined Name - Create a tooltip.
  $CombineNameTip = New-Object Windows.Forms.ToolTip
  $CombineNameTip.InitialDelay = $ToolTipDelay
  $CombineNameTip.AutoPopDelay = $ToolTipDuration
  $CombineNameTipString = 'The file name of the combined texture{0}'
  $CombineNameTipString += 'forced into PNG format. This is also the{0}'
  $CombineNameTipString += 'name of the (.ctt) file created. This file{0}'
  $CombineNameTipString += 'can be loaded into the operation to split{0}'
  $CombineNameTipString += 'textures which preserves their names.'
  $CombineNameTipString = [String]::Format($CombineNameTipString, [Environment]::NewLine)
  $CombineNameTip.SetToolTip($CombineNameLabel, $CombineNameTipString)

  # 15: Combine Textures - Select Textures - Opens the texture grid to allow selecting textures to add to the grid.
  $global:CombineSelectButton = New-Object Windows.Forms.Button
  $CombineSelectButton.Size = DPISize (New-Object Drawing.Size(120, 28))
  $CombineSelectButton.Location = DPISize (New-Object Drawing.Point(65, 86))
  $CombineSelectButton.Text = 'Select Textures'
  $CombineSelectButton.Add_Click({ CombineTextures_DialogDisplay })
  $CombineTextureGroup.Controls.Add($CombineSelectButton)

  # 15: Combine Textures - Select Textures - Create a tooltip.
  $CombineSelectTip = New-Object Windows.Forms.ToolTip
  $CombineSelectTip.InitialDelay = $ToolTipDelay
  $CombineSelectTip.AutoPopDelay = $ToolTipDuration
  $CombineSelectTipString = 'Opens the grid that allows adding{0}'
  $CombineSelectTipString += 'textures into the grid array. It is also{0}'
  $CombineSelectTipString += 'possible to drop textures onto the{0}'
  $CombineSelectTipString += 'buttons themselves to import them.'
  $CombineSelectTipString = [String]::Format($CombineSelectTipString, [Environment]::NewLine) 
  $CombineSelectTip.SetToolTip($CombineSelectButton, $CombineSelectTipString)

  # 15: Combine Textures - Load CTT File - Button that allows selecting a CTT file which contains information on a texture.
  $global:CombineCTTButton = New-Object Windows.Forms.Button
  $CombineCTTButton.Size = DPISize (New-Object Drawing.Size(120, 28))
  $CombineCTTButton.Location = DPISize (New-Object Drawing.Point(195, 86))
  $CombineCTTButton.Name = 'Combine'
  $CombineCTTButton.Text = 'Load CTT File'
  $CombineCTTButton.AllowDrop = $true
  $CombineCTTButton.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $CombineCTTButton.Add_DragDrop({ LoadCTTFileDragDrop })
  $CombineCTTButton.Add_Click({ LoadCTTFileButtonClick })
  $CombineTextureGroup.Controls.Add($CombineCTTButton)

  # 15: Combine Textures - Load CTT File - Create a tooltip.
  $CombineCTTTip = New-Object Windows.Forms.ToolTip
  $CombineCTTTip.InitialDelay = $ToolTipDelay
  $CombineCTTTip.AutoPopDelay = $ToolTipDuration
  $CombineCTTTipString =  'Loading a CTT file from a previously generated{0}'
  $CombineCTTTipString += 'combined texture will automatically fill out the{0}'
  $CombineCTTTipString += 'grid array if the texture segments are still in the{0}'
  $CombineCTTTipString += 'path that they were last found in when combined.'
  $CombineCTTTipString = [String]::Format($CombineCTTTipString, [Environment]::NewLine)
  $CombineCTTTip.SetToolTip($CombineCTTButton, $CombineCTTTipString)

  # 15: Combine Textures - Zelda Panel - Opens a menu with specific textures.
  $global:CombineZeldaPanel = New-Object Windows.Forms.Panel
  $CombineZeldaPanel.Size = DPISize (New-Object Drawing.Size(22, 22))
  $CombineZeldaPanel.Name = 'CombineZeldaPanel'
  $CombineZeldaPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#8d8d8d')
  $CombineZeldaPanel.Add_MouseDown({ ShowHideZeldaTriforce })
  $CombineTextureGroup.Controls.Add($CombineZeldaPanel)

  # 15: Combine Textures - Zelda Panel - Calculate X position.
  $CombineZeldaPanelX = $CombineTextureGroup.Size.Width - $CombineZeldaPanel.Size.Width
  $CombineZeldaPanel.Location = New-Object Drawing.Point($CombineZeldaPanelX, (DPISize 6 -Round))

  # 15: Combine Textures - Zelda Button - Opens a menu with specific textures.
  $global:CombineZeldaButton = New-Object Windows.Forms.Button
  $CombineZeldaButton.Size = New-Object Drawing.Size(($CombineZeldaPanel.Size.Width - 2), ($CombineZeldaPanel.Size.Height - 2))
  $CombineZeldaButton.Location = New-Object Drawing.Point(1, 1)
  $CombineZeldaButton.Name = 'CombineZeldaButton' 
  $CombineZeldaButton.Add_MouseDown({ ZeldaOptionsToggleHelp -ResetWindow $true ; ShowZeldaOptions ; ShowHideZeldaTriforce })
  $CombineZeldaButton.Image = GetZeldaTriforceButton
  $CombineZeldaButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $CombineZeldaButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $CombineZeldaButton.FlatAppearance.BorderSize = 0
  $CombineZeldaPanel.Controls.Add($CombineZeldaButton)

  # 15: Combine Textures - Zelda Button - Create a tooltip.
  $CombineZeldaTip = New-Object Windows.Forms.ToolTip
  $CombineZeldaTip.InitialDelay = $ToolTipDelay
  $CombineZeldaTip.AutoPopDelay = $ToolTipDuration
  $CombineZeldaTipString = 'Open advanced options that allow cropping{0}'
  $CombineZeldaTipString += 'the edges of textures in various ways before{0}'
  $CombineZeldaTipString += 'combining, or adding additional pixels to all{0}'
  $CombineZeldaTipString += 'textures after they are split. All options were{0}'
  $CombineZeldaTipString += 'designed with TLoZ:OoT in mind, so there is{0}'
  $CombineZeldaTipString += 'a chance they will benefit other N64 VC titles.'
  $CombineZeldaTipString = [String]::Format($CombineZeldaTipString, [Environment]::NewLine) 
  $CombineZeldaTip.SetToolTip($CombineZeldaButton, $CombineZeldaTipString)

  # 16: Split Textures - Create the groupbox that will hold the combine textures options.
  $global:SplitTextureGroup = New-Object Windows.Forms.GroupBox
  $SplitTextureGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $SplitTextureGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $SplitTextureGroup.Text = ' Split Multi-Texture Options '
  $MainDialogPanel.Controls.Add($SplitTextureGroup)

  # 16: Split Textures - Texture Columns - The number box that allows selecting the number of columns for the texture array.
  $global:SplitTextureColsNumBox = New-Object Windows.Forms.NumericUpDown
  $SplitTextureColsNumBox.Size = DPISize (New-Object Drawing.Size(44, 10))
  $SplitTextureColsNumBox.Location = DPISize (New-Object Drawing.Point(10, 20)) -AddY $DPIOffsetFix
  $SplitTextureColsNumBox.Name = 'TextureCols'
  $SplitTextureColsNumBox.DecimalPlaces = 0
  $SplitTextureColsNumBox.Minimum = 1
  $SplitTextureColsNumBox.Maximum = $SplitCombineLimits
  $SplitTextureColsNumBox.Increment = 1
  $SplitTextureColsNumBox.Value = $TextureCols
  $SplitTextureColsNumBox.Add_ValueChanged({ UpdateTextureArrayCells })
  $SplitTextureColsNumBox.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitTextureColsNumBox)

  # 16: Split Textures - Grid Array - Create a label.
  $global:SplitXLabel = New-Object Windows.Forms.Label
  $SplitXLabel.Size = DPISize (New-Object Drawing.Size(12, 12))
  $SplitXLabel.Location = DPISize (New-Object Drawing.Point(56, 22))
  $SplitXLabel.Text = 'x'
  $SplitXLabel.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitXLabel)

  # 16: Split Textures - Grid Array - Configures the number of rows in the texture array.
  $global:SplitTextureRowsNumBox = New-Object Windows.Forms.NumericUpDown
  $SplitTextureRowsNumBox.Size = DPISize (New-Object Drawing.Size(44, 10))
  $SplitTextureRowsNumBox.Location = DPISize (New-Object Drawing.Point(69, 20)) -AddY $DPIOffsetFix
  $SplitTextureRowsNumBox.Name = 'TextureRows'
  $SplitTextureRowsNumBox.DecimalPlaces = 0
  $SplitTextureRowsNumBox.Minimum = 1
  $SplitTextureRowsNumBox.Maximum = $SplitCombineLimits
  $SplitTextureRowsNumBox.Increment = 1
  $SplitTextureRowsNumBox.Value = $TextureRows
  $SplitTextureRowsNumBox.Add_ValueChanged({ UpdateTextureArrayCells })
  $SplitTextureRowsNumBox.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitTextureRowsNumBox)

  # 16: Split Textures - Grid Array - Create a label.
  $global:SplitGridArrayLabel = New-Object Windows.Forms.Label
  $SplitGridArrayLabel.Size = DPISize (New-Object Drawing.Size(60, 18))
  $SplitGridArrayLabel.Location = DPISize (New-Object Drawing.Point(116, 23))
  $SplitGridArrayLabel.Text = 'Grid Array'
  $SplitGridArrayLabel.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitGridArrayLabel)

  # 16: Split Textures - Grid Array - Create a tooltip.
  $SplitGridArrayTip = New-Object Windows.Forms.ToolTip
  $SplitGridArrayTip.InitialDelay = $ToolTipDelay
  $SplitGridArrayTip.AutoPopDelay = $ToolTipDuration
  $SplitGridArrayTipString = 'The number of (columns * rows) in the grid.'
  $SplitGridArrayTipString = [String]::Format($SplitGridArrayTipString, [Environment]::NewLine)
  $SplitGridArrayTip.SetToolTip($SplitGridArrayLabel, $SplitGridArrayTipString)

  # 16: Split Textures - Batch Textures - Runs textures through the master loop.
  $global:SplitBatchCheck = New-Object Windows.Forms.CheckBox
  $SplitBatchCheck.Size = DPISize (New-Object Drawing.Size(140, 16))
  $SplitBatchCheck.Location = DPISize (New-Object Drawing.Point(192, 23))
  $SplitBatchCheck.Name = 'SplitBatchImages'
  $SplitBatchCheck.Checked = $SplitBatchImages
  $SplitBatchCheck.Text = ' Batch From Input Path'
  $SplitBatchCheck.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleSplitSingleMode })
  $SplitTextureGroup.Controls.Add($SplitBatchCheck)

  # 16: Split Textures - Text Box - Create a tooltip for the textbox.
  $SplitBatchTip = New-Object Windows.Forms.ToolTip
  $SplitBatchTip.InitialDelay = $ToolTipDelay
  $SplitBatchTip.AutoPopDelay = $ToolTipDuration
  $SplitBatchTipString = 'Instead of splitting a single texture, search the{0}'
  $SplitBatchTipString += '"Input Path" for CTT files and split the images{0}'
  $SplitBatchTipString += 'that are found. This will only work on textures{0}'
  $SplitBatchTipString += 'with an included CTT file from combining them.'
  $SplitBatchTipString = [String]::Format($SplitBatchTipString, [Environment]::NewLine)
  $SplitBatchTip.SetToolTip($SplitBatchCheck, $SplitBatchTipString)

  # 16: Split Textures - Text Box - The text box that holds the path to the combined texture to split.
  $global:SplitTextureTextBox = New-Object Windows.Forms.TextBox
  $SplitTextureTextBox.Size = DPISize (New-Object Drawing.Size(360, 22))
  $SplitTextureTextBox.Location = DPISize (New-Object Drawing.Point(10, 54)) -AddY $DPIOffsetFix
  $SplitTextureTextBox.Name = 'CombineSelected'
  $SplitTextureTextBox.Text = $CombineSelected
  $SplitTextureTextBox.AllowDrop = $true
  $SplitTextureTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $SplitTextureTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName '*.png' ; SplitTextures_TryUpdateGarbageOverlap })
  $SplitTextureTextBox.Add_Click({ ClearTextBox })
  $SplitTextureTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName '*.png' ; SplitTextures_TryUpdateGarbageOverlap })
  $SplitTextureTextBox.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitTextureTextBox)

  # 16: Split Textures - Text Box - Create a tooltip for the textbox.
  $SplitTextureTip = New-Object Windows.Forms.ToolTip
  $SplitTextureTip.InitialDelay = $ToolTipDelay
  $SplitTextureTip.AutoPopDelay = $ToolTipDuration
  $SplitTextureTipString = 'The path to the texture to split. Loading a{0}'
  $SplitTextureTipString += 'CTT file will automatically fill this value in{0}'
  $SplitTextureTipString += 'if the texture is in the path it was created{0}'
  $SplitTextureTipString += 'or if its in the same folder at the CTT file.'
  $SplitTextureTipString = [String]::Format($SplitTextureTipString, [Environment]::NewLine)
  $SplitTextureTip.SetToolTip($SplitTextureTextBox, $SplitTextureTipString)

  # 16: Split Textures - Load Texture - Button that allows selecting a texture to split.
  $global:SplitLoadTextureButton = New-Object Windows.Forms.Button
  $SplitLoadTextureButton.Size = DPISize (New-Object Drawing.Size(120, 28))
  $SplitLoadTextureButton.Location = DPISize (New-Object Drawing.Point(65, 86))
  $SplitLoadTextureButton.Name = 'CombineSelected'
  $SplitLoadTextureButton.Text = 'Select Texture'
  $SplitLoadTextureButton.AllowDrop = $true
  $SplitLoadTextureButton.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $SplitLoadTextureButton.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName '*.png' -TextBox $SplitTextureTextBox ; SplitTextures_TryUpdateGarbageOverlap })
  $SplitLoadTextureButton.Add_Click({ LoadExternalFile_Button -TextBox $SplitTextureTextBox -FileName '*.png' -Description 'PNG Image' ; SplitTextures_TryUpdateGarbageOverlap })
  $SplitLoadTextureButton.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitLoadTextureButton)

  # 16: Split Textures - Load Texture - Create a tooltip.
  $SplitLoadTextureTip = New-Object Windows.Forms.ToolTip
  $SplitLoadTextureTip.InitialDelay = $ToolTipDelay
  $SplitLoadTextureTip.AutoPopDelay = $ToolTipDuration
  $SplitLoadTextureTipString =  'Load in an image to split. The number of rows{0}'
  $SplitLoadTextureTipString += 'and columns defined in the grid array decide{0}'
  $SplitLoadTextureTipString += 'how the image will be split. The resolution of{0}'
  $SplitLoadTextureTipString += 'each image is (dimension / rows or columns).{0}'
  $SplitLoadTextureTipString += 'If dimensions are not evenly divisible, images{0}'
  $SplitLoadTextureTipString += 'may end up with odd dimensions (like 3x300).'
  $SplitLoadTextureTipString = [String]::Format($SplitLoadTextureTipString, [Environment]::NewLine)
  $SplitLoadTextureTip.SetToolTip($SplitLoadTextureButton, $SplitLoadTextureTipString)

  # 16: Split Textures - Load CTT File - Button that allows selecting a CTT file which contains information on a texture to split.
  $global:SplitTextureCTTButton = New-Object Windows.Forms.Button
  $SplitTextureCTTButton.Size = DPISize (New-Object Drawing.Size(120, 28))
  $SplitTextureCTTButton.Location = DPISize (New-Object Drawing.Point(195, 86))
  $SplitTextureCTTButton.Name = 'Split'
  $SplitTextureCTTButton.Text = 'Load CTT File'
  $SplitTextureCTTButton.AllowDrop = $true
  $SplitTextureCTTButton.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $SplitTextureCTTButton.Add_DragDrop({ LoadCTTFileDragDrop })
  $SplitTextureCTTButton.Add_Click({ LoadCTTFileButtonClick })
  $SplitTextureCTTButton.Enabled = !$SplitBatchImages
  $SplitTextureGroup.Controls.Add($SplitTextureCTTButton)

  # 16: Split Textures - Load CTT File - Create a tooltip.
  $SplitTextureCTTTip = New-Object Windows.Forms.ToolTip
  $SplitTextureCTTTip.InitialDelay = $ToolTipDelay
  $SplitTextureCTTTip.AutoPopDelay = $ToolTipDuration
  $SplitTextureCTTTipString = 'If a multi-texture was created with Combine Multiple Textures{0}'
  $SplitTextureCTTTipString += 'the script will also generate a file with the texture name that{0}'
  $SplitTextureCTTTipString += 'contains a (.ctt) extension. This file holds all the information{0}'
  $SplitTextureCTTTipString += 'of the textures that went into creating the combined texture.{0}'
  $SplitTextureCTTTipString += 'The CTT file should also be in the same path as the texture.{0}'
  $SplitTextureCTTTipString += '{0}'
  $SplitTextureCTTTipString += 'Loading a CTT file will automatically fill in the correct values{0}' 
  $SplitTextureCTTTipString += 'for rows and columns, and when the texture is created all split{0}'
  $SplitTextureCTTTipString += 'textures will be renamed with the hash they had before being{0}'
  $SplitTextureCTTTipString += 'combined. The path found below will attempt to update to{0}'
  $SplitTextureCTTTipString += 'where the texture is currently located. Manually selecting it is{0}'
  $SplitTextureCTTTipString += 'also possible if the texture path was not found.{0}'
  $SplitTextureCTTTipString += '{0}'
  $SplitTextureCTTTipString += 'Note that a CTT file is not required to split an image. If a CTT{0}'
  $SplitTextureCTTTipString += 'file is not selected, images are named from the main texture,{0}'
  $SplitTextureCTTTipString += 'and dimensions are calculated from rows/columns specified.'
  $SplitTextureCTTTipString = [String]::Format($SplitTextureCTTTipString, [Environment]::NewLine)
  $SplitTextureCTTTip.SetToolTip($SplitTextureCTTButton, $SplitTextureCTTTipString)

  # 16: Split Textures - Clear CTT File - Button that clears the currently loaded CTT file.
  $global:SplitClearCTTButton = New-Object Windows.Forms.Button
  $SplitClearCTTButton.Size = DPISize (New-Object Drawing.Size(24, 24))
  $SplitClearCTTButton.Location = DPISize (New-Object Drawing.Point(322, 88))
  $SplitClearCTTButton.Name = 'Clear'
  $SplitClearCTTButton.Text = ''
  $SplitClearCTTButton.Image = $Image_Remove
  $SplitClearCTTButton.Add_Click({ SplitTextures_DismissCTTFile })
  $SplitClearCTTButton.Enabled = $false
  $SplitTextureGroup.Controls.Add($SplitClearCTTButton)

  # 16: Split Textures - Load CTT File - Create a tooltip.
  $SplitClearCTTTip = New-Object Windows.Forms.ToolTip
  $SplitClearCTTTip.InitialDelay = $ToolTipDelay
  $SplitClearCTTTip.AutoPopDelay = $ToolTipDuration
  $SplitClearCTTTipString =  'Clear the currently loaded CTT file{0}'
  $SplitClearCTTTipString += 'from memory. This will "unload"{0}'
  $SplitClearCTTTipString += 'names imported from a CTT file.'
  $SplitClearCTTTipString = [String]::Format($SplitClearCTTTipString, [Environment]::NewLine)
  $SplitClearCTTTip.SetToolTip($SplitClearCTTButton, $SplitClearCTTTipString)

  # 16: Split Textures - Zelda Button - Opens a menu with specific textures.
  $global:SplitZeldaPanel = New-Object Windows.Forms.Panel
  $SplitZeldaPanel.Size = DPISize (New-Object Drawing.Size(22, 22))
  $SplitZeldaPanelX = $SplitTextureGroup.Size.Width - $SplitZeldaPanel.Size.Width
  $SplitZeldaPanel.Location = New-Object Drawing.Point($CombineZeldaPanelX, (DPISize 6 -Round))
  $SplitZeldaPanel.Name = 'SplitZeldaPanel'
  $SplitZeldaPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#8d8d8d')
  $SplitZeldaPanel.Add_MouseDown({ ShowHideZeldaTriforce })
  $SplitTextureGroup.Controls.Add($SplitZeldaPanel)

  # 16: Split Textures - Zelda Button - Opens a menu with specific textures.
  $global:SplitZeldaButton = New-Object Windows.Forms.Button
  $SplitZeldaButton.Size = New-Object Drawing.Size(($SplitZeldaPanel.Size.Width - 2), ($SplitZeldaPanel.Size.Height - 2))
  $SplitZeldaButton.Location = New-Object Drawing.Point(1, 1)
  $SplitZeldaButton.Name = 'SplitZeldaButton' 
  $SplitZeldaButton.Add_MouseDown({ ZeldaOptionsToggleHelp -ResetWindow $true ; ShowZeldaOptions ; ShowHideZeldaTriforce })
  $SplitZeldaButton.Image = GetZeldaTriforceButton
  $SplitZeldaButton.BackColor = [Drawing.ColorTranslator]::FromHtml('#e1e1e1')
  $SplitZeldaButton.FlatStyle = [Windows.Forms.FlatStyle]::Flat
  $SplitZeldaButton.FlatAppearance.BorderSize = 0
  $SplitZeldaPanel.Controls.Add($SplitZeldaButton)

  # 16: Split Textures - Zelda Button - Create a tooltip.
  $SplitZeldaTip = New-Object Windows.Forms.ToolTip
  $SplitZeldaTip.InitialDelay = $ToolTipDelay
  $SplitZeldaTip.AutoPopDelay = $ToolTipDuration
  $SplitZeldaTipString = 'Open advanced options that allow cropping{0}'
  $SplitZeldaTipString += 'the edges of textures in various ways before{0}'
  $SplitZeldaTipString += 'combining, or adding additional pixels to all{0}'
  $SplitZeldaTipString += 'textures after they are split. All options were{0}'
  $SplitZeldaTipString += 'designed with TLoZ:OoT in mind, so there is{0}'
  $SplitZeldaTipString += 'a chance they will benefit other N64 VC titles.'
  $SplitZeldaTipString = [String]::Format($SplitZeldaTipString, [Environment]::NewLine) 
  $SplitZeldaTip.SetToolTip($SplitZeldaButton, $SplitZeldaTipString)

  # 17: Arbitrary Mipmaps - Create the groupbox that will hold the combine textures options.
  $global:ArbitraryMipmapGroup = New-Object Windows.Forms.GroupBox
  $ArbitraryMipmapGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ArbitraryMipmapGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ArbitraryMipmapGroup.Text = ' Description '
  $MainDialogPanel.Controls.Add($ArbitraryMipmapGroup)

  # 17: Arbitrary Mipmaps - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ArbitraryMipmapTTBox = New-Object TransparentLabel
  $ArbitraryMipmapTTBox.Size = DPISize (New-Object Drawing.Size(358, 40))
  $ArbitraryMipmapTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ArbitraryMipmapTTBox.Text = ""
  $ArbitraryMipmapGroup.Controls.Add($ArbitraryMipmapTTBox)

  # 17: Arbitrary Mipmaps - Add a short description of this dialog.
  $global:ArbitraryMipmapLabel = New-Object AdvRichTextBox
  $ArbitraryMipmapLabel.Size = DPISize (New-Object Drawing.Size(358, 40))
  $ArbitraryMipmapLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ArbitraryMipmapString = 'Adds or removes the arbitrary mipmap suffix "_arb" to Dolphin textures and all external mipmap levels. This is done '
  $ArbitraryMipmapString += 'directly to all textures found in the Input Path, so care must be taken with this option.'
  $ArbitraryMipmapLabel.Text = $ArbitraryMipmapString
  $ArbitraryMipmapLabel.SelectionAlignment = [TextAlign]::Justify
  $ArbitraryMipmapLabel.TabStop = $false
  $ArbitraryMipmapLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ArbitraryMipmapLabel.ReadOnly = $true
  $ArbitraryMipmapLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ArbitraryMipmapGroup.Controls.Add($ArbitraryMipmapLabel)

  # 17: Arbitrary Mipmaps - Create a groupbox to hold the radio buttons panel.
  $global:ArbitraryMipmapRadioGroup = New-Object Windows.Forms.GroupBox
  $ArbitraryMipmapRadioGroup.Size = DPISize (New-Object Drawing.Size(360, 46))
  $ArbitraryMipmapRadioGroup.Location = DPISize (New-Object Drawing.Point(10, 68))
  $ArbitraryMipmapRadioGroup.Text = ' Operation '
  $ArbitraryMipmapGroup.Controls.Add($ArbitraryMipmapRadioGroup)

  # 17: Arbitrary Mipmaps - Create a panel to hold the radio buttons as they need to be part of the same parent to toggle between each other. Attach the panel to the groupbox above.
  $global:ArbitraryMipmapPanel = New-Object Windows.Forms.Panel
  $ArbitraryMipmapPanel.Size = DPISize (New-Object Drawing.Size(220, 20))
  $ArbitraryMipmapPanel.Location = DPISize (New-Object Drawing.Point(10, 20))
  $ArbitraryMipmapRadioGroup.Controls.Add($ArbitraryMipmapPanel)

  # 17: Arbitrary Mipmaps - Add the radio button that controls adding the arbitrary mipmap suffix.
  $global:ArbitraryMipmapRadioAdd = New-Object Windows.Forms.RadioButton
  $ArbitraryMipmapRadioAdd.Size = DPISize (New-Object Drawing.Size(76, 16))
  $ArbitraryMipmapRadioAdd.Location = DPISize (New-Object Drawing.Point(0, 0))
  $ArbitraryMipmapRadioAdd.Name = 'ArbSuffixChoice'
  $ArbitraryMipmapRadioAdd.Text = 'Add Suffix'
  $ArbitraryMipmapRadioAdd.Checked = ($ArbSuffixChoice -eq 'Add Suffix')
  $ArbitraryMipmapRadioAdd.Add_CheckedChanged({ if ($this.Checked) { Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' } } )
  $ArbitraryMipmapPanel.Controls.Add($ArbitraryMipmapRadioAdd)

  # 17: Arbitrary Mipmaps - Add the radio button that controls removing the arbitrary mipmap suffix.
  $global:ArbitraryMipmapRadioRem = New-Object Windows.Forms.RadioButton
  $ArbitraryMipmapRadioRem.Size = DPISize (New-Object Drawing.Size(100, 16))
  $ArbitraryMipmapRadioRem.Location = DPISize (New-Object Drawing.Point(80, 0))
  $ArbitraryMipmapRadioRem.Name = 'ArbSuffixChoice'
  $ArbitraryMipmapRadioRem.Text = 'Remove Suffix'
  $ArbitraryMipmapRadioRem.Checked = ($ArbSuffixChoice -eq 'Remove Suffix')
  $ArbitraryMipmapRadioRem.Add_CheckedChanged({ if ($this.Checked) { Set-Variable -Name $this.Name -Value $this.Text -Scope 'Global' } })
  $ArbitraryMipmapPanel.Controls.Add($ArbitraryMipmapRadioRem)

  # 18: PNG Alpha Pixel - Create the groupbox that will hold the options.
  $global:AlphaPixelGroup = New-Object Windows.Forms.GroupBox
  $AlphaPixelGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $AlphaPixelGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $AlphaPixelGroup.Text = ' Alpha Manipulation Options '
  $MainDialogPanel.Controls.Add($AlphaPixelGroup)

  # 18: PNG Alpha Pixel - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:AlphaPixelTTBox = New-Object TransparentLabel
  $AlphaPixelTTBox.Size = DPISize (New-Object Drawing.Size(358, 45))
  $AlphaPixelTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $AlphaPixelTTBox.Text = ""
  $AlphaPixelGroup.Controls.Add($AlphaPixelTTBox)

  # 18: PNG Alpha Pixel - Add a short description of this dialog.
  $global:AlphaPixelLabel = New-Object AdvRichTextBox
  $AlphaPixelLabel.Size = DPISize (New-Object Drawing.Size(358, 45))
  $AlphaPixelLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $AlphaPixelString = 'Manipulates alpha in PNG textures. Rare cases exist where alpha is used in different ways to create certain '
  $AlphaPixelString += 'effects. It is suggested to read the help topic and tooltips to gain a better understanding of how this option works.'
  $AlphaPixelLabel.Text = $AlphaPixelString
  $AlphaPixelLabel.SelectionAlignment = [TextAlign]::Justify
  $AlphaPixelLabel.TabStop = $false
  $AlphaPixelLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $AlphaPixelLabel.ReadOnly = $true
  $AlphaPixelLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $AlphaPixelGroup.Controls.Add($AlphaPixelLabel)

  # 18: PNG Alpha Pixel - Operation - Create a label for the operation and a lengthy tooltip explaining all the operations this option is capable of.
  $global:AlphaPixelOpLabel = New-Object Windows.Forms.Label
  $AlphaPixelOpLabel.Size = DPISize (New-Object Drawing.Size(62, 22))
  $AlphaPixelOpLabel.Location = DPISize (New-Object Drawing.Point(10, 73))
  $AlphaPixelOpLabel.Text = 'Operation:'
  $AlphaPixelGroup.Controls.Add($AlphaPixelOpLabel)

  # 18: PNG Alpha Pixel - Operation - Create a tooltip.
  $AlphaPixelOpLabelTip = New-Object Windows.Forms.ToolTip
  $AlphaPixelOpLabelTip.InitialDelay = $ToolTipDelay
  $AlphaPixelOpLabelTip.AutoPopDelay = $ToolTipDuration
  $AlphaPixelOpLabelTipString =  'Convert Fully Transparent Color Pixels to Opaque:{0}'
  $AlphaPixelOpLabelTipString += 'Function: Pixels where (R>0 or B>0 or G>0) and (A=0) are converted to (A=255){0}'
  $AlphaPixelOpLabelTipString += 'Sometimes images are hidden behind an alpha mask, meaning the Alpha value is 0 for every single{0}'
  $AlphaPixelOpLabelTipString += 'pixel even if the pixel has valid color data. This option allows editing texture dumps with hidden{0}'
  $AlphaPixelOpLabelTipString += 'color pixels. Alpha is set to 255 for all pixels that contain valid color data, effectively revealing the{0}'
  $AlphaPixelOpLabelTipString += 'hidden image underneath. After the image has been edited, the option found below can restore the{0}'
  $AlphaPixelOpLabelTipString += '"invisible pixel" effect by making every pixel fully transparent.{0}'
  $AlphaPixelOpLabelTipString += '{0}'
  $AlphaPixelOpLabelTipString += 'Add Full Transparency and Keep Pixel Color Data:{0}'
  $AlphaPixelOpLabelTipString += 'Function: All pixels are converted to (A=0){0}'
  $AlphaPixelOpLabelTipString += 'If an image dumped by Dolphin appears fully transparent, there is a chance the image is hidden{0}'
  $AlphaPixelOpLabelTipString += 'behind an alpha mask. This option will replicate that effect, and will make every pixel completely{0}'
  $AlphaPixelOpLabelTipString += 'invisible for the custom texture while retaining all the color values. This option should be used on{0}'
  $AlphaPixelOpLabelTipString += 'textures that had the previous option applied, to restore the alpha mask to the custom texture.{0}'
  $AlphaPixelOpLabelTipString += '{0}'
  $AlphaPixelOpLabelTipString += 'Set Fully Transparent Black Pixels to White:{0}'
  $AlphaPixelOpLabelTipString += 'Function: Pixels where (R=0 B=0 G=0 A=0) are converted to (R=255 B=255 G=255 A=0){0}'
  $AlphaPixelOpLabelTipString += 'This option sets the RGB values of all pixels to 255 that are fully transparent (0 Alpha), effectively{0}'
  $AlphaPixelOpLabelTipString += 'making an invisible "white" mask. Some textures may use this "invisible" color data for in-game{0}'
  $AlphaPixelOpLabelTipString += "effects, and if not present, the texture will look incorrect in-game. It's possible to analyze fully{0}"
  $AlphaPixelOpLabelTipString += 'transparent pixels in texture dumps using your favorite raster graphics editor to find out when this{0}'
  $AlphaPixelOpLabelTipString += 'effect is used. The pixel should read as: R=255, G=255, B=255, A=0.{0}'
  $AlphaPixelOpLabelTipString += '{0}'
  $AlphaPixelOpLabelTipString += 'Set Fully Transparent White Pixels to Black:{0}'
  $AlphaPixelOpLabelTipString += 'Function: Pixels where (R=255 B=255 G=255 A=0) are converted to (R=0 B=0 G=0 A=0){0}'
  $AlphaPixelOpLabelTipString += 'Searches for white pixels that are fully transparent (R=255, G=255, B=255, A=0) and removes the color{0}'
  $AlphaPixelOpLabelTipString += 'data from them, effectively setting them to black transparent pixels (R=0, G=0, B=0, A=0). This can{0}'
  $AlphaPixelOpLabelTipString += 'be used to remove the white mask from some tricky textures that are fully transparent, or work around{0}'
  $AlphaPixelOpLabelTipString += "an issue with Photoshop outputting some images with white invisible pixels that shouldn't be there.{0}"
  $AlphaPixelOpLabelTipString += '{0}'
  $AlphaPixelOpLabelTipString += 'Remove All Color Data From Fully Transparent Pixels:{0}'
  $AlphaPixelOpLabelTipString += 'Function: Pixels where (R>0 or B>0 or G>0) and (A=0) are converted to (R=0 B=0 G=0 A=0){0}'
  $AlphaPixelOpLabelTipString += 'Searches for fully transparent pixels that contain color data (RGB>0, A=0) and sets all RGB values{0}'
  $AlphaPixelOpLabelTipString += 'to 0 which effectively removes the hidden color data. This is a niche option that can be used to {0}'
  $AlphaPixelOpLabelTipString += 'repair textures that have these hidden values, as they can actually show up in some games even{0}'
  $AlphaPixelOpLabelTipString += 'though the pixel is fully transparent.'
  $AlphaPixelOpLabelTipString = [String]::Format($AlphaPixelOpLabelTipString, [Environment]::NewLine)
  $AlphaPixelOpLabelTip.SetToolTip($AlphaPixelOpLabel, $AlphaPixelOpLabelTipString)

  # 18: PNG Alpha Pixel - Operation - Create a combobox that allows selecting the operation.
  $global:AlphaPixelCombo = New-Object Windows.Forms.ComboBox
  $AlphaPixelCombo.Size = DPISize (New-Object Drawing.Size(298, 10))
  $AlphaPixelCombo.Location = DPISize (New-Object Drawing.Point(73, 70)) -AddY $DPIOffsetFix
  $AlphaPixelCombo.Name = 'AlphaPixelMode'
  $AlphaPixelCombo.Items.Add('Convert Fully Transparent Color Pixels to Opaque') | Out-Null
  $AlphaPixelCombo.Items.Add('Add Full Transparency and Keep Pixel Color Data') | Out-Null
  $AlphaPixelCombo.Items.Add('Set Fully Transparent Black Pixels to White') | Out-Null
  $AlphaPixelCombo.Items.Add('Set Fully Transparent White Pixels to Black') | Out-Null
  $AlphaPixelCombo.Items.Add('Remove All Color Data From Fully Transparent Pixels') | Out-Null
  $AlphaPixelCombo.Items.Add('Customize Data For Transparent Pixels') | Out-Null
  $AlphaPixelCombo.SelectedIndex = $AlphaPixelMode
  $AlphaPixelCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $AlphaPixelCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedIndex ; ToggleAlphaPixelButton})
  $AlphaPixelCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $AlphaPixelCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $AlphaPixelCombo.Add_DrawItem({ RepopulateComboBox })
  $AlphaPixelGroup.Controls.Add($AlphaPixelCombo)

  # 18: PNG Alpha Pixel - Operation - Customize Button
  $global:AlphaPixelCustomButton = New-Object Windows.Forms.Button
  $AlphaPixelCustomButton.Size = DPISize (New-Object Drawing.Size(100, 23))
  $AlphaPixelCustomButton.Location = DPISize (New-Object Drawing.Point(272, 95))
  $AlphaPixelCustomButton.Text = 'Customize'
  $AlphaPixelCustomButton.Visible = ($AlphaPixelCombo.SelectedIndex -eq 5)
  $AlphaPixelCustomButton.Add_Click({ $PNGAlphaDialog.ShowDialog() | Out-Null })
  $AlphaPixelGroup.Controls.Add($AlphaPixelCustomButton)

  # 18: PNG Alpha Pixel - Create In-Place - Allow modifying the textures directly rather than create them in the output folder.
  $global:AlphaPixelInPlaceCheck = New-Object Windows.Forms.CheckBox
  $AlphaPixelInPlaceCheck.Size = DPISize (New-Object Drawing.Size(170, 16))
  $AlphaPixelInPlaceCheck.Location = DPISize (New-Object Drawing.Point(12, 100))
  $AlphaPixelInPlaceCheck.Name = 'InPlaceAlphaPixel'
  $AlphaPixelInPlaceCheck.Checked = $InPlaceAlphaPixel
  $AlphaPixelInPlaceCheck.Text = ' Modify Textures In-Place'
  $AlphaPixelInPlaceCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $AlphaPixelGroup.Controls.Add($AlphaPixelInPlaceCheck)

  # 18: PNG Alpha Pixel - Create In-Place - Create a tooltip.
  $AlphaPixelInPlaceTip = New-Object Windows.Forms.ToolTip
  $AlphaPixelInPlaceTip.InitialDelay = $ToolTipDelay
  $AlphaPixelInPlaceTip.AutoPopDelay = $ToolTipDuration
  $AlphaPixelInPlaceTipString = 'Modify the textures directly rather than{0}'
  $AlphaPixelInPlaceTipString += 'recreating them in the output folder.'
  $AlphaPixelInPlaceTipString = [String]::Format($AlphaPixelInPlaceTipString, [Environment]::NewLine)
  $AlphaPixelInPlaceTip.SetToolTip($AlphaPixelInPlaceCheck, $AlphaPixelInPlaceTipString)

  # 19: RGBA Channels - Create the groupbox that will hold the options.
  $global:RGBAChannelsGroup = New-Object Windows.Forms.GroupBox
  $RGBAChannelsGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $RGBAChannelsGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $RGBAChannelsGroup.Text = ' RGBA Channels Options '
  $MainDialogPanel.Controls.Add($RGBAChannelsGroup)

  # 19: RGBA Channels - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:RGBAChannelsTTBox = New-Object TransparentLabel
  $RGBAChannelsTTBox.Size = DPISize (New-Object Drawing.Size(358, 42))
  $RGBAChannelsTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $RGBAChannelsTTBox.Text = ""
  $RGBAChannelsGroup.Controls.Add($RGBAChannelsTTBox)

  # 19: RGBA Channels - Add a short description of this dialog.
  $global:RGBAChannelsMsgLabel = New-Object AdvRichTextBox
  $RGBAChannelsMsgLabel.Size = DPISize (New-Object Drawing.Size(358, 42))
  $RGBAChannelsMsgLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $RGBAChannelsString  = 'This can split images into multiple images based on their channel data, or combine channel images into a single image. Channel '
  $RGBAChannelsString += 'images are defined by flags as a suffix in the image name: *_!R, *_!G, *_!B, *_!A. '
  $RGBAChannelsMsgLabel.Text = $RGBAChannelsString
  $RGBAChannelsMsgLabel.SelectionAlignment = [TextAlign]::Justify
  $RGBAChannelsMsgLabel.TabStop = $false
  $RGBAChannelsMsgLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $RGBAChannelsMsgLabel.ReadOnly = $true
  $RGBAChannelsMsgLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $RGBAChannelsGroup.Controls.Add($RGBAChannelsMsgLabel)

  # 19: RGBA Channels - Operation - Create a combobox that allows selecting the operation.
  $global:RGBAChannelsCombo = New-Object Windows.Forms.ComboBox
  $RGBAChannelsCombo.Size = DPISize (New-Object Drawing.Size(118, 10))
  $RGBAChannelsCombo.Location = DPISize (New-Object Drawing.Point(10, 70)) -AddY $DPIOffsetFix
  $RGBAChannelsCombo.Name = 'RGBAChannelChoice'
  $RGBAChannelsCombo.Items.Add('Split into Channels') | Out-Null
  $RGBAChannelsCombo.Items.Add('Combine Channels') | Out-Null
  $RGBAChannelsCombo.SelectedItem = $RGBAChannelChoice
  $RGBAChannelsCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $RGBAChannelsCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $RGBAChannelsCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $RGBAChannelsCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $RGBAChannelsCombo.Add_DrawItem({ RepopulateComboBox })
  $RGBAChannelsGroup.Controls.Add($RGBAChannelsCombo)

  # 19: RGBA Channels - Operation - Create a label for the groupbox.
  $global:RGBAChannelsLabel = New-Object Windows.Forms.Label
  $RGBAChannelsLabel.Size = DPISize (New-Object Drawing.Size(60, 15))
  $RGBAChannelsLabel.Location = DPISize (New-Object Drawing.Point(130, 73))
  $RGBAChannelsLabel.Text = 'Operation'
  $RGBAChannelsGroup.Controls.Add($RGBAChannelsLabel)

  # 19: RGBA Channels - Operation - Create a tooltip.
  $RGBAChannelsLabelTip = New-Object Windows.Forms.ToolTip
  $RGBAChannelsLabelTip.InitialDelay = $ToolTipDelay
  $RGBAChannelsLabelTip.AutoPopDelay = $ToolTipDuration
  $RGBAChannelsLabelTipString = 'Chooses the RGBA Channel operation.{0}'
  $RGBAChannelsLabelTipString += '{0}'
  $RGBAChannelsLabelTipString += 'Split into Channels: Extracts the RGBA data{0}'
  $RGBAChannelsLabelTipString += 'and splits each channel into its own image.{0}'
  $RGBAChannelsLabelTipString += 'The output textures will be 32-bit RGBA with{0}'
  $RGBAChannelsLabelTipString += 'only the corresponding channels having data.{0}'
  $RGBAChannelsLabelTipString += '{0}'
  $RGBAChannelsLabelTipString += 'Combine Channels: Searches for textures with{0}'
  $RGBAChannelsLabelTipString += 'channel flags: "_!R","_!G","_B!", and/or "_!A"{0}'
  $RGBAChannelsLabelTipString += 'and combine only the data from the channels{0}'
  $RGBAChannelsLabelTipString += 'that the flags represent into a single image.'
  $RGBAChannelsLabelTipString = [String]::Format($RGBAChannelsLabelTipString, [Environment]::NewLine)
  $RGBAChannelsLabelTip.SetToolTip($RGBAChannelsLabel, $RGBAChannelsLabelTipString)

  # 19: RGBA Channels - Background - Create a combobox that allows selecting the bacgkround.
  $global:RGBABackgroundCombo = New-Object Windows.Forms.ComboBox
  $RGBABackgroundCombo.Size = DPISize (New-Object Drawing.Size(90, 10))
  $RGBABackgroundCombo.Location = DPISize (New-Object Drawing.Point(196, 70)) -AddY $DPIOffsetFix
  $RGBABackgroundCombo.Name = 'RGBABackGroundChoice'
  $RGBABackgroundCombo.Items.Add('Black') | Out-Null
  $RGBABackgroundCombo.Items.Add('Transparent') | Out-Null
  $RGBABackgroundCombo.SelectedItem = $RGBABackGroundChoice
  $RGBABackgroundCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $RGBABackgroundCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $RGBABackgroundCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $RGBABackgroundCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $RGBABackgroundCombo.Add_DrawItem({ RepopulateComboBox })
  $RGBAChannelsGroup.Controls.Add($RGBABackgroundCombo)

  # 19: RGBA Channels - Background - Create a label for the groupbox.
  $global:RGBABackgroundLabel = New-Object Windows.Forms.Label
  $RGBABackgroundLabel.Size = DPISize (New-Object Drawing.Size(70, 15))
  $RGBABackgroundLabel.Location = DPISize (New-Object Drawing.Point(288, 73))
  $RGBABackgroundLabel.Text = 'Background'
  $RGBAChannelsGroup.Controls.Add($RGBABackgroundLabel)

  # 19: RGBA Channels - Background - Create a tooltip.
  $RGBABackgroundLabelTip = New-Object Windows.Forms.ToolTip
  $RGBABackgroundLabelTip.InitialDelay = $ToolTipDelay
  $RGBABackgroundLabelTip.AutoPopDelay = $ToolTipDuration
  $RGBABackgroundLabelTipString  = 'Fills the background of the split images{0}'
  $RGBABackgroundLabelTipString += 'with either black or transparent pixels.{0}'
  $RGBABackgroundLabelTipString += "Transparency is tricky to handle and only{0}"
  $RGBABackgroundLabelTipString += "fills areas that would be 100% black, so{0}"
  $RGBABackgroundLabelTipString += "the result may not be desireable."
  $RGBABackgroundLabelTipString = [String]::Format($RGBABackgroundLabelTipString, [Environment]::NewLine)
  $RGBABackgroundLabelTip.SetToolTip($RGBABackgroundLabel, $RGBABackgroundLabelTipString)

  # 19: RGBA Channels - Utilize Alpha Channel
  $global:RGBAKeepAlphaCheck = New-Object Windows.Forms.CheckBox
  $RGBAKeepAlphaCheck.Size = DPISize (New-Object Drawing.Size(300, 16))
  $RGBAKeepAlphaCheck.Location = DPISize (New-Object Drawing.Point(12, 100))
  $RGBAKeepAlphaCheck.Name = 'RGBAUtilizeAlpha'
  $RGBAKeepAlphaCheck.Checked = $RGBAUtilizeAlpha
  $RGBAKeepAlphaCheck.Text = ' Extract Alpha Channel / Combine Alpha Channel'
  $RGBAKeepAlphaCheck.Add_CheckStateChanged({ CheckBoxStateToggled })
  $RGBAChannelsGroup.Controls.Add($RGBAKeepAlphaCheck)

  # 20: ToCS Extract PKA - Create the groupbox that will hold the options.
  $global:ToCSExtractPKAGroup = New-Object Windows.Forms.GroupBox
  $ToCSExtractPKAGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ToCSExtractPKAGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ToCSExtractPKAGroup.Text = ' Extract PKA Options'
  $MainDialogPanel.Controls.Add($ToCSExtractPKAGroup)

  # 20: ToCS Extract PKA - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ToCSExtractPKATTBox = New-Object TransparentLabel
  $ToCSExtractPKATTBox.Size = DPISize (New-Object Drawing.Size(358, 56))
  $ToCSExtractPKATTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ToCSExtractPKATTBox.Text = ""
  $ToCSExtractPKAGroup.Controls.Add($ToCSExtractPKATTBox)

  # 20: ToCS Extract PKA - Add a short description of this dialog.
  $global:ToCSExtractPKALabel = New-Object AdvRichTextBox
  $ToCSExtractPKALabel.Size = DPISize (New-Object Drawing.Size(358, 56))
  $ToCSExtractPKALabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ToCSExtractPKALabelString  = 'Notice that extracting all files requires 70 GB of storage! This extracts PKG files from the "assets.pka" file that is found in the "assets > D3D11" '
  $ToCSExtractPKALabelString += 'folder in The Legend of Heroes: Trails of Cold Steel III/IV. This operation requires Python v3.9.x and uses the python script (built-in) by CeruleanSky.'
  $ToCSExtractPKALabel.Text = $ToCSExtractPKALabelString
  $ToCSExtractPKALabel.SelectionAlignment = [TextAlign]::Justify
  $ToCSExtractPKALabel.TabStop = $false
  $ToCSExtractPKALabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ToCSExtractPKALabel.ReadOnly = $true
  $ToCSExtractPKALabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ToCSExtractPKAGroup.Controls.Add($ToCSExtractPKALabel)

  # 20: ToCS Extract PKA - Allow selecting the extraction type.
  $global:ToCSExtractPKACombo = New-Object Windows.Forms.ComboBox
  $ToCSExtractPKACombo.Size = DPISize (New-Object Drawing.Size(110, 28))
  $ToCSExtractPKACombo.Location = DPISize (New-Object Drawing.Point(10, 86))
  $ToCSExtractPKACombo.Name = 'PhyrePKAType'
  $ToCSExtractPKACombo.Items.Add('All Possible Files') | Out-Null
  $ToCSExtractPKACombo.Items.Add('CS3 Specific File') | Out-Null
  $ToCSExtractPKACombo.Items.Add('CS4 Specific File') | Out-Null
  $ToCSExtractPKACombo.SelectedItem = $PhyrePKAType
  $ToCSExtractPKACombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ToCSExtractPKACombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $ToCSExtractPKACombo.Add_SelectedIndexChanged({ ToCSPKAComboHandleSelected ; ComboBoxStateChanged -NewValue $this.SelectedItem })
  $ToCSExtractPKACombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ToCSExtractPKACombo.Add_DrawItem({ RepopulateComboBox })
  $ToCSExtractPKAGroup.Controls.Add($ToCSExtractPKACombo)

  # 20: ToCS Extract PKA - Create a label for the combobox.
  $global:ToCSExtractPKAComboLabel = New-Object Windows.Forms.Label
  $ToCSExtractPKAComboLabel.Size = DPISize (New-Object Drawing.Size(70, 18))
  $ToCSExtractPKAComboLabel.Location = DPISize (New-Object Drawing.Point(122, 89))
  $ToCSExtractPKAComboLabel.Text = 'Extract Files'
  $ToCSExtractPKAGroup.Controls.Add($ToCSExtractPKAComboLabel)

  # 20: ToCS Extract PKA - Create a tooltip for the combobox.
  $ToCSExtractPKAComboTip = New-Object Windows.Forms.ToolTip
  $ToCSExtractPKAComboTip.InitialDelay = $ToolTipDelay
  $ToCSExtractPKAComboTip.AutoPopDelay = $ToolTipDuration
  $ToCSExtractPKAComboTipString = 'Notice this is only for Cold Steel III and IV.{0}'
  $ToCSExtractPKAComboTipString += '{0}'
  $ToCSExtractPKAComboTipString += 'Extract all PKG files or extract a specific file from{0}'
  $ToCSExtractPKAComboTipString += 'the assets.pka found in both CS3/CS4. Extracting{0}'
  $ToCSExtractPKAComboTipString += 'all files requires about 65-70 GB free HDD space.{0}'
  $ToCSExtractPKAComboTipString += '{0}'
  $ToCSExtractPKAComboTipString += 'Currently there is no way to recompress the PKG{0}'
  $ToCSExtractPKAComboTipString += 'files back into the assets.pka file, nor can they be{0}'
  $ToCSExtractPKAComboTipString += 'repacked with CS3/CS4 compression (LZ4).{0}'
  $ToCSExtractPKAComboTipString += '{0}'
  $ToCSExtractPKAComboTipString += 'Extracted CS3/CS4 PKG files can be repacked using{0}'
  $ToCSExtractPKAComboTipString += 'the CS1/CS2 compression method (LZ77) and they{0}'
  $ToCSExtractPKAComboTipString += 'will work if replacing the assets.pka file but with an{0}'
  $ToCSExtractPKAComboTipString += 'increase in HDD space and performance penalty.'
  $ToCSExtractPKAComboTipString = [String]::Format($ToCSExtractPKAComboTipString, [Environment]::NewLine)
  $ToCSExtractPKAComboTip.SetToolTip($ToCSExtractPKAComboLabel, $ToCSExtractPKAComboTipString)

  # 20: ToCS Extract PKA - Create a combobox to select a specific entry.
  $global:ToCSPKASpecificCombo = New-Object Windows.Forms.ComboBox
  $ToCSPKASpecificCombo.Size = DPISize (New-Object Drawing.Size(176, 28))
  $ToCSPKASpecificCombo.Location = DPISize (New-Object Drawing.Point(197, 86))
  $ToCSPKASpecificCombo.IntegralHeight = $false
  $ToCSPKASpecificCombo.MaxDropDownItems = 16
  $ToCSPKASpecificCombo.Name = 'PhyrePKASelected'
  if ($ToCSExtractPKACombo.SelectedIndex -gt 0) { ToCSPKASpecificCombo_Populate -Index $ToCSExtractPKACombo.SelectedIndex }
  $ToCSPKASpecificCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ToCSPKASpecificCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $ToCSPKASpecificCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $ToCSPKASpecificCombo.Visible = ($ToCSExtractPKACombo.SelectedIndex -gt 0)
  $ToCSPKASpecificCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ToCSPKASpecificCombo.Add_DrawItem({ RepopulateComboBox })
  $ToCSExtractPKAGroup.Controls.Add($ToCSPKASpecificCombo)

  # 21: ToCS Extract PKG - Create the groupbox that will hold the options.
  $global:ToCSExtractPKGGroup = New-Object Windows.Forms.GroupBox
  $ToCSExtractPKGGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ToCSExtractPKGGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ToCSExtractPKGGroup.Text = ' Extract PKG Options'
  $MainDialogPanel.Controls.Add($ToCSExtractPKGGroup)

  # 21: ToCS Extract PKG - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ToCSExtractPKGTTBox = New-Object TransparentLabel
  $ToCSExtractPKGTTBox.Size = DPISize (New-Object Drawing.Size(358, 44))
  $ToCSExtractPKGTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ToCSExtractPKGTTBox.Text = ""
  $ToCSExtractPKGGroup.Controls.Add($ToCSExtractPKGTTBox)

  # 21: ToCS Extract PKG - Add a short description of this dialog.
  $global:ToCSExtractPKGLabel = New-Object AdvRichTextBox
  $ToCSExtractPKGLabel.Size = DPISize (New-Object Drawing.Size(358, 44))
  $ToCSExtractPKGLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ToCSExtractPKGLabelString =  'Cold Steel 1/2 requires .NET Core 2 and Kiseki-PKG-Sharp by Sewer56.{0}'
  $ToCSExtractPKGLabelString += 'Cold Steel 3/4 requires Python v3.9.x and uses the scripts by CeruleanSky.{0}'
  $ToCSExtractPKGLabelString += 'The script will automatically detect which game the PKG came from.'
  $ToCSExtractPKGLabelString = [String]::Format($ToCSExtractPKGLabelString, [Environment]::NewLine)
  $ToCSExtractPKGLabel.Text = $ToCSExtractPKGLabelString
  $ToCSExtractPKGLabel.SelectionAlignment = [TextAlign]::Justify
  $ToCSExtractPKGLabel.TabStop = $false
  $ToCSExtractPKGLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ToCSExtractPKGLabel.ReadOnly = $true
  $ToCSExtractPKGLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ToCSExtractPKGGroup.Controls.Add($ToCSExtractPKGLabel)

  # 21: ToCS Extract PKG - PKG Tool Path - A label that acts as a header to the PKG tool path.
  $global:ToCSExtractPKGToolLabel = New-Object Windows.Forms.Label
  $ToCSExtractPKGToolLabel.Size = DPISize (New-Object Drawing.Size(140, 14))
  $ToCSExtractPKGToolLabel.Location = DPISize (New-Object Drawing.Point(10, 80))
  $ToCSExtractPKGToolLabel.Text = 'PKG Tool Path:'
  $ToCSExtractPKGGroup.Controls.Add($ToCSExtractPKGToolLabel)

  # 21: ToCS Extract PKG - PKG Tool Path - The text box that holds the path to the PKG tool. 
  $global:ToCSExtractPKGTextBox = New-Object Windows.Forms.TextBox
  $ToCSExtractPKGTextBox.Size = DPISize (New-Object Drawing.Size(334, 22))
  $ToCSExtractPKGTextBox.Location = DPISize (New-Object Drawing.Point(10, 95)) -AddY $DPIOffsetFix
  $ToCSExtractPKGTextBox.Name = 'PhyrePKGTool'
  $ToCSExtractPKGTextBox.Text = $PhyrePKGTool
  $ToCSExtractPKGTextBox.AllowDrop = $true
  $ToCSExtractPKGTextBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ToCSExtractPKGTextBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('PKGToolCmd.dll', 'PKGTool.exe') })
  $ToCSExtractPKGTextBox.Add_Click({ ClearTextBox })
  $ToCSExtractPKGTextBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('PKGToolCmd.dll', 'PKGTool.exe') })
  $ToCSExtractPKGGroup.Controls.Add($ToCSExtractPKGTextBox)

  # 21: ToCS Extract PKG - PKG Tool Path - Allow adding a PKG tool by using a button.
  $global:ToCSExtractPKGButton = New-Object Windows.Forms.Button
  $ToCSExtractPKGButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $ToCSExtractPKGButton.Location = DPISize (New-Object Drawing.Point(347, 94))
  $ToCSExtractPKGButton.Name = 'PhyrePKGTool'
  $ToCSExtractPKGButton.Text = '...'
  $ToCSExtractPKGButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $ToCSExtractPKGTextBox -FileName @('PKGToolCmd.dll', 'PKGTool.exe') -Description 'PKG Tool' })
  $ToCSExtractPKGGroup.Controls.Add($ToCSExtractPKGButton)

  # 22: Convert Phyre - Create the groupbox that will hold the options.
  $global:ToCSConvertGroup = New-Object Windows.Forms.GroupBox
  $ToCSConvertGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ToCSConvertGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ToCSConvertGroup.Text = ' Convert Phyre Options '
  $MainDialogPanel.Controls.Add($ToCSConvertGroup)

  # 22: Convert Phyre - Unswizzle - Allow unswizzling textures as they are converted. This flips them to their proper position.
  $global:ToCSConvertUnswizzle = New-Object Windows.Forms.CheckBox
  $ToCSConvertUnswizzle.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ToCSConvertUnswizzle.Location = DPISize (New-Object Drawing.Point(10, 20))
  $ToCSConvertUnswizzle.Name = 'PhyreSwizzle'
  $ToCSConvertUnswizzle.Checked = $PhyreSwizzle
  $ToCSConvertUnswizzle.Text = ' Unswizzle Textures'
  $ToCSConvertUnswizzle.Add_CheckStateChanged({ CheckBoxStateToggled ; $ToCSCreateSwizzle.Checked = $this.Checked })
  $ToCSConvertGroup.Controls.Add($ToCSConvertUnswizzle)

  # 22: Convert Phyre - Unswizzle - Create a tooltip.
  $ToCSConvertUnswizzleTip = New-Object Windows.Forms.ToolTip
  $ToCSConvertUnswizzleTip.InitialDelay = $ToolTipDelay
  $ToCSConvertUnswizzleTip.AutoPopDelay = $ToolTipDuration
  $ToCSConvertUnswizzleTipString = 'When creating a texture, this option will{0}'
  $ToCSConvertUnswizzleTipString += 'flip the result. This is equal to rotating 180{0}'
  $ToCSConvertUnswizzleTipString += 'degrees, then flipping horizontally.'
  $ToCSConvertUnswizzleTipString = [String]::Format($ToCSConvertUnswizzleTipString, [Environment]::NewLine)
  $ToCSConvertUnswizzleTip.SetToolTip($ToCSConvertUnswizzle, $ToCSConvertUnswizzleTipString)

  # 22: Convert Phyre - Store Header - Saves the header file from the phyre image. This allows converting the PNG back into a phyre texture.
  $global:ToCSConvertHeader = New-Object Windows.Forms.CheckBox
  $ToCSConvertHeader.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ToCSConvertHeader.Location = DPISize (New-Object Drawing.Point(10, 42))
  $ToCSConvertHeader.Name = 'PhyreSaveHeader'
  $ToCSConvertHeader.Checked = $PhyreSaveHeader
  $ToCSConvertHeader.Text = ' Store Phyre Header'
  $ToCSConvertHeader.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ToCSConvertGroup.Controls.Add($ToCSConvertHeader)

  # 22: Convert Phyre - Store Header - Create a tooltip.
  $ToCSConvertHeaderTip = New-Object Windows.Forms.ToolTip
  $ToCSConvertHeaderTip.InitialDelay = $ToolTipDelay
  $ToCSConvertHeaderTip.AutoPopDelay = $ToolTipDuration
  $ToCSConvertHeaderTipString = 'Stores the header from the phyre texture{0}'
  $ToCSConvertHeaderTipString += 'to a separate ".header" file. This will be{0}'
  $ToCSConvertHeaderTipString += 'needed to convert the texture back to the{0}'
  $ToCSConvertHeaderTipString += 'phyre format to be used with Cold Steel.'
  $ToCSConvertHeaderTipString = [String]::Format($ToCSConvertHeaderTipString, [Environment]::NewLine)
  $ToCSConvertHeaderTip.SetToolTip($ToCSConvertHeader, $ToCSConvertHeaderTipString)

  # 22: Convert Phyre - Extract Mipmaps - When converting to PNG, also converts all internal DDS mipmaps into separate PNG files.
  $global:ToCSConvertDDSMipmaps = New-Object Windows.Forms.CheckBox
  $ToCSConvertDDSMipmaps.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ToCSConvertDDSMipmaps.Location = DPISize (New-Object Drawing.Point(10, 64))
  $ToCSConvertDDSMipmaps.Name = 'PhyreSaveMipmaps'
  $ToCSConvertDDSMipmaps.Checked = $PhyreSaveMipmaps
  $ToCSConvertDDSMipmaps.Text = ' Extract DDS Mipmaps'
  $ToCSConvertDDSMipmaps.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ToCSConvertGroup.Controls.Add($ToCSConvertDDSMipmaps)

  # 22: Convert Phyre - Extract Mipmaps - Create a tooltip.
  $ToCSConvertDDSMipmapsTip = New-Object Windows.Forms.ToolTip
  $ToCSConvertDDSMipmapsTip.InitialDelay = $ToolTipDelay
  $ToCSConvertDDSMipmapsTip.AutoPopDelay = $ToolTipDuration
  $ToCSConvertDDSMipmapsTipString = 'Extracts all mipmaps from DDS textures and{0}'
  $ToCSConvertDDSMipmapsTipString += 'converts them to PNG in separate images. It{0}'
  $ToCSConvertDDSMipmapsTipString += 'is not suggested to ever use this option as{0}'
  $ToCSConvertDDSMipmapsTipString += 'these games do not have unique mipmaps,{0}'
  $ToCSConvertDDSMipmapsTipString += 'and the script will automatically generate{0}'
  $ToCSConvertDDSMipmapsTipString += 'new ones if the original textures had them.'
  $ToCSConvertDDSMipmapsTipString = [String]::Format($ToCSConvertDDSMipmapsTipString, [Environment]::NewLine)
  $ToCSConvertDDSMipmapsTip.SetToolTip($ToCSConvertDDSMipmaps, $ToCSConvertDDSMipmapsTipString)

  # 22: Convert Phyre - Extracted Path - Allow using the extracted PKG folder found in the output path.
  $global:ToCSConvertPrevPath = New-Object Windows.Forms.CheckBox
  $ToCSConvertPrevPath.Size = DPISize (New-Object Drawing.Size(170, 16))
  $ToCSConvertPrevPath.Location = DPISize (New-Object Drawing.Point(190, 20))
  $ToCSConvertPrevPath.Name = 'PhyrePreviousPath'
  $ToCSConvertPrevPath.Checked = $PhyrePreviousPath
  $ToCSConvertPrevPath.Text = ' Use Extracted PKG Path'
  $ToCSConvertPrevPath.Add_CheckStateChanged({ CheckBoxStateToggled ; ToCS_TogglePreviousPathChecks })
  $ToCSConvertGroup.Controls.Add($ToCSConvertPrevPath)

  # 22: Convert Phyre - Extracted Path - Create a tooltip.
  $ToCSConvertPrevPathTip = New-Object Windows.Forms.ToolTip
  $ToCSConvertPrevPathTip.InitialDelay = $ToolTipDelay
  $ToCSConvertPrevPathTip.AutoPopDelay = $ToolTipDuration
  $ToCSConvertPrevPathTipString = 'Rather than use the Input Path to search for{0}'
  $ToCSConvertPrevPathTipString += 'PKG files, use the "PKG_Extracted" folder found{0}'
  $ToCSConvertPrevPathTipString += 'in the Output Path that was created with the{0}'
  $ToCSConvertPrevPathTipString += 'previous option to extract PKG files.'
  $ToCSConvertPrevPathTipString = [String]::Format($ToCSConvertPrevPathTipString, [Environment]::NewLine)
  $ToCSConvertPrevPathTip.SetToolTip($ToCSConvertPrevPath, $ToCSConvertPrevPathTipString)

  # 22: Convert Phyre - Scan Textures - Scan the textures instead of converting them.
  $global:ToCSConvertPhyreScan = New-Object Windows.Forms.CheckBox
  $ToCSConvertPhyreScan.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ToCSConvertPhyreScan.Location = DPISize (New-Object Drawing.Point(190, 42))
  $ToCSConvertPhyreScan.Name = 'PhyreOnlyScan'
  $ToCSConvertPhyreScan.Checked = $PhyreOnlyScan
  $ToCSConvertPhyreScan.Text = ' Only Scan Phyre Files'
  $ToCSConvertPhyreScan.Add_CheckStateChanged({ CheckBoxStateToggled ; ToCS_ToggleOnlyScanPhyreChecks})
  $ToCSConvertGroup.Controls.Add($ToCSConvertPhyreScan)

  # 22: Convert Phyre - Scan Textures - Create a tooltip.
  $ToCSConvertPhyreScanTip = New-Object Windows.Forms.ToolTip
  $ToCSConvertPhyreScanTip.InitialDelay = $ToolTipDelay
  $ToCSConvertPhyreScanTip.AutoPopDelay = $ToolTipDuration
  $ToCSConvertPhyreScanTipString = 'Simply scan the files to gather information{0}'
  $ToCSConvertPhyreScanTipString += 'about the phyre texture rather than do any{0}'
  $ToCSConvertPhyreScanTipString += 'actual converting. This information can be{0}'
  $ToCSConvertPhyreScanTipString += 'found in the log file or the texture list.'
  $ToCSConvertPhyreScanTipString = [String]::Format($ToCSConvertPhyreScanTipString, [Environment]::NewLine)
  $ToCSConvertPhyreScanTip.SetToolTip($ToCSConvertPhyreScan, $ToCSConvertPhyreScanTipString)

  # 23: Create Phyre - Create the groupbox that will hold the options.
  $global:ToCSCreateGroup = New-Object Windows.Forms.GroupBox
  $ToCSCreateGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ToCSCreateGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ToCSCreateGroup.Text = ' Create Phyre Options'
  $MainDialogPanel.Controls.Add($ToCSCreateGroup)

  # 23: Create Phyre - File Extension - Allow selecting the phyre format.
  $global:ToCSCreateExtension = New-Object Windows.Forms.ComboBox
  $ToCSCreateExtension.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ToCSCreateExtension.Location = DPISize (New-Object Drawing.Point(10, 20))
  $ToCSCreateExtension.Name = 'PhyreExtension'
  $ToCSCreateExtension.Items.Add('Source') | Out-Null
  $ToCSCreateExtension.Items.Add('PNG') | Out-Null
  $ToCSCreateExtension.Items.Add('DDS') | Out-Null
  $ToCSCreateExtension.Items.Add('BMP') | Out-Null
  $ToCSCreateExtension.SelectedItem = ToCS_GetSelectedFormat
  $ToCSCreateExtension.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ToCSCreateExtension.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $ToCSCreateExtension.Add_SelectedIndexChanged({ ToCS_SelectOutputFormat })
  $ToCSCreateExtension.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ToCSCreateExtension.Add_DrawItem({ RepopulateComboBox })
  $ToCSCreateGroup.Controls.Add($ToCSCreateExtension)

  # 23: Create Phyre - File Extension - Create a label.
  $global:ToCSCreateExtensionLabel = New-Object Windows.Forms.Label
  $ToCSCreateExtensionLabel.Size = DPISize (New-Object Drawing.Size(90, 22))
  $ToCSCreateExtensionLabel.Location = DPISize (New-Object Drawing.Point(92, 23))
  $ToCSCreateExtensionLabel.Text = 'File Extension'
  $ToCSCreateGroup.Controls.Add($ToCSCreateExtensionLabel)

  # 23: Create Phyre - File Extension - Create a tooltip.
  $ToCSCreateExtensionTip = New-Object Windows.Forms.ToolTip
  $ToCSCreateExtensionTip.InitialDelay = $ToolTipDelay
  $ToCSCreateExtensionTip.AutoPopDelay = $ToolTipDuration
  $ToCSCreateExtensionTipString = 'The file extension/output format{0}'
  $ToCSCreateExtensionTipString += 'that textures will be created with.'
  $ToCSCreateExtensionTipString = [String]::Format($ToCSCreateExtensionTipString, [Environment]::NewLine)
  $ToCSCreateExtensionTip.SetToolTip($ToCSCreateExtensionLabel, $ToCSCreateExtensionTipString)

  # 23: Create Phyre - Image Format - Allow selecting the pixel format the texture will use.
  $global:ToCSCreateFormatCombo = New-Object Windows.Forms.ComboBox
  $ToCSCreateFormatCombo.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ToCSCreateFormatCombo.Location = DPISize (New-Object Drawing.Point(10, 46))
  $ToCSCreateFormatCombo.Name = 'PhyreImageFormat'
  $ToCSCreateFormatCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $ToCSCreateFormatCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $ToCSCreateFormatCombo.Add_SelectedIndexChanged({ ComboBoxStateChanged -NewValue $this.SelectedItem })
  $ToCSCreateFormatCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $ToCSCreateFormatCombo.Add_DrawItem({ RepopulateComboBox })
  $ToCSCreateGroup.Controls.Add($ToCSCreateFormatCombo)

  # 23: Create Phyre - Image Format - Create a label.
  $global:ToCSCreateFormatLabel = New-Object Windows.Forms.Label
  $ToCSCreateFormatLabel.Size = DPISize (New-Object Drawing.Size(90, 22))
  $ToCSCreateFormatLabel.Location = DPISize (New-Object Drawing.Point(92, 49))
  $ToCSCreateFormatLabel.Text = 'Image Format'
  $ToCSCreateGroup.Controls.Add($ToCSCreateFormatLabel)

  # 23: Create Phyre - Image Format - Create a tooltip.
  $ToCSCreateFormatTip = New-Object Windows.Forms.ToolTip
  $ToCSCreateFormatTip.InitialDelay = $ToolTipDelay
  $ToCSCreateFormatTip.AutoPopDelay = $ToolTipDuration
  $ToCSCreateFormatTipString = 'The image/pixel format that{0}'
  $ToCSCreateFormatTipString += 'textures will be created with.{0}'
  $ToCSCreateFormatTipString += '{0}'
  $ToCSCreateFormatTipString += 'The BC7 format only works with{0}'
  $ToCSCreateFormatTipString += 'Cold Steel III and Cold Steel IV.'
  $ToCSCreateFormatTipString = [String]::Format($ToCSCreateFormatTipString, [Environment]::NewLine)
  $ToCSCreateFormatTip.SetToolTip($ToCSCreateFormatLabel, $ToCSCreateFormatTipString)

  # 23: Create Phyre - Swizzle - Allow users to swizzle the textures when creating if they desire.
  $global:ToCSCreateSwizzle = New-Object Windows.Forms.CheckBox
  $ToCSCreateSwizzle.Size = DPISize (New-Object Drawing.Size(170, 16))
  $ToCSCreateSwizzle.Location = DPISize (New-Object Drawing.Point(10, 75))
  $ToCSCreateSwizzle.Name = 'PhyreSwizzle'
  $ToCSCreateSwizzle.Checked = $PhyreSwizzle
  $ToCSCreateSwizzle.Text = ' Swizzle Textures'
  $ToCSCreateSwizzle.Add_CheckStateChanged({ CheckBoxStateToggled ; $ToCSConvertUnswizzle.Checked = $this.Checked })
  $ToCSCreateGroup.Controls.Add($ToCSCreateSwizzle)

  # 23: Create Phyre - Swizzle - Create a tooltip.
  $ToCSCreateSwizzleTip = New-Object Windows.Forms.ToolTip
  $ToCSCreateSwizzleTip.InitialDelay = $ToolTipDelay
  $ToCSCreateSwizzleTip.AutoPopDelay = $ToolTipDuration
  $ToCSCreateSwizzleTipString = 'When creating a texture, this option will{0}'
  $ToCSCreateSwizzleTipString += 'flip the result. This is equal to rotating 180{0}'
  $ToCSCreateSwizzleTipString += 'degrees, then flipping horizontally.'
  $ToCSCreateSwizzleTipString = [String]::Format($ToCSCreateSwizzleTipString, [Environment]::NewLine)
  $ToCSCreateSwizzleTip.SetToolTip($ToCSCreateSwizzle, $ToCSCreateSwizzleTipString)

  # 23: Create Phyre - Update XML - Add the convenience of automatically updating the XML file that holds information about the textures.
  $global:ToCSCreateUpdateXML = New-Object Windows.Forms.CheckBox
  $ToCSCreateUpdateXML.Size = DPISize (New-Object Drawing.Size(170, 16))
  $ToCSCreateUpdateXML.Location = DPISize (New-Object Drawing.Point(10, 96))
  $ToCSCreateUpdateXML.Name = 'PhyreXMLUpdate'
  $ToCSCreateUpdateXML.Checked = $PhyreXMLUpdate
  $ToCSCreateUpdateXML.Text = ' Update Asset XML File'
  $ToCSCreateUpdateXML.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ToCSCreateGroup.Controls.Add($ToCSCreateUpdateXML)

  # 23: Create Phyre - Update XML - Create a tooltip.
  $ToCSCreateUpdateXMLTip = New-Object Windows.Forms.ToolTip
  $ToCSCreateUpdateXMLTip.InitialDelay = $ToolTipDelay
  $ToCSCreateUpdateXMLTip.AutoPopDelay = $ToolTipDuration
  $ToCSCreateUpdateXMLTipString = 'Automatically updates the XML file included{0}'
  $ToCSCreateUpdateXMLTipString += 'within PKG files with the new texure names.'
  $ToCSCreateUpdateXMLTipString = [String]::Format($ToCSCreateUpdateXMLTipString, [Environment]::NewLine)
  $ToCSCreateUpdateXMLTip.SetToolTip($ToCSCreateUpdateXML, $ToCSCreateUpdateXMLTipString)

  # 23: Create Phyre - Converted Path - Allow using the PNG Phyre folder found in the output path.
  $global:ToCSCreatePrevPath = New-Object Windows.Forms.CheckBox
  $ToCSCreatePrevPath.Size = DPISize (New-Object Drawing.Size(170, 16))
  $ToCSCreatePrevPath.Location = DPISize (New-Object Drawing.Point(190, 20))
  $ToCSCreatePrevPath.Name = 'PhyrePreviousPath'
  $ToCSCreatePrevPath.Checked = $PhyrePreviousPath
  $ToCSCreatePrevPath.Text = ' Use Converted Phyre Path'
  $ToCSCreatePrevPath.Add_CheckStateChanged({ CheckBoxStateToggled ; ToCS_TogglePreviousPathChecks })
  $ToCSCreateGroup.Controls.Add($ToCSCreatePrevPath)

  # 23: Create Phyre - Converted Path - Create a tooltip.
  $ToCSCreatePrevPathTip = New-Object Windows.Forms.ToolTip
  $ToCSCreatePrevPathTip.InitialDelay = $ToolTipDelay
  $ToCSCreatePrevPathTip.AutoPopDelay = $ToolTipDuration
  $ToCSCreatePrevPathTipString = 'Rather than use the Input Path to search for{0}'
  $ToCSCreatePrevPathTipString += 'PKG files, use the "ConvertedPhyre" folder found{0}'
  $ToCSCreatePrevPathTipString += 'in the Output Path that was created with the{0}'
  $ToCSCreatePrevPathTipString += 'previous option to convert phyre images to PNG.'
  $ToCSCreatePrevPathTipString = [String]::Format($ToCSCreatePrevPathTipString, [Environment]::NewLine)
  $ToCSCreatePrevPathTip.SetToolTip($ToCSCreatePrevPath, $ToCSCreatePrevPathTipString)

  # 23: Create Phyre - DXT1 to DXT5 - Allow using the PNG Phyre folder found in the output path.
  $global:ToCSDDXT1AlphaDXT5 = New-Object Windows.Forms.CheckBox
  $ToCSDDXT1AlphaDXT5.Size = DPISize (New-Object Drawing.Size(180, 16))
  $ToCSDDXT1AlphaDXT5.Location = DPISize (New-Object Drawing.Point(190, 42))
  $ToCSDDXT1AlphaDXT5.Name = 'PhyreDXT1AToDXT5'
  $ToCSDDXT1AlphaDXT5.Checked = $PhyreDXT1AToDXT5
  $ToCSDDXT1AlphaDXT5.Text = ' DXT1 Alpha to DXT5'
  $ToCSDDXT1AlphaDXT5.Add_CheckStateChanged({ CheckBoxStateToggled })
  $ToCSCreateGroup.Controls.Add($ToCSDDXT1AlphaDXT5)

  # 23: Create Phyre - DXT1 to DXT5 - Create a tooltip.
  $ToCSDDXT1AlphaDXT5Tip = New-Object Windows.Forms.ToolTip
  $ToCSDDXT1AlphaDXT5Tip.InitialDelay = $ToolTipDelay
  $ToCSDDXT1AlphaDXT5Tip.AutoPopDelay = $ToolTipDuration
  $ToCSDDXT1AlphaDXT5TipString = 'When a source DXT1 texture is using 1-bit{0}'
  $ToCSDDXT1AlphaDXT5TipString += 'alpha, create the destination as DXT5. This{0}'
  $ToCSDDXT1AlphaDXT5TipString += 'option only works when selecting "Source"{0}'
  $ToCSDDXT1AlphaDXT5TipString += 'as the output image format.'
  $ToCSDDXT1AlphaDXT5TipString = [String]::Format($ToCSDDXT1AlphaDXT5TipString, [Environment]::NewLine)
  $ToCSDDXT1AlphaDXT5Tip.SetToolTip($ToCSDDXT1AlphaDXT5, $ToCSDDXT1AlphaDXT5TipString)

  # 23: Create Phyre - Scan Headers - Scan the textures instead of Createing them.
  $global:ToCSCreatePhyreScan = New-Object Windows.Forms.CheckBox
  $ToCSCreatePhyreScan.Size = DPISize (New-Object Drawing.Size(150, 16))
  $ToCSCreatePhyreScan.Location = DPISize (New-Object Drawing.Point(190, 64))
  $ToCSCreatePhyreScan.Name = 'PhyreOnlyScan'
  $ToCSCreatePhyreScan.Checked = $PhyreOnlyScan
  $ToCSCreatePhyreScan.Text = ' Only Scan Header Files'
  $ToCSCreatePhyreScan.Add_CheckStateChanged({ CheckBoxStateToggled ; ToCS_ToggleOnlyScanPhyreChecks})
  $ToCSCreateGroup.Controls.Add($ToCSCreatePhyreScan)

  # 23: Create Phyre - Scan Headers - Create a tooltip.
  $ToCSCreatePhyreScanTip = New-Object Windows.Forms.ToolTip
  $ToCSCreatePhyreScanTip.InitialDelay = $ToolTipDelay
  $ToCSCreatePhyreScanTip.AutoPopDelay = $ToolTipDuration
  $ToCSCreatePhyreScanTipString = 'Simply scan the files to gather information{0}'
  $ToCSCreatePhyreScanTipString += 'about the phyre header rather than do any{0}'
  $ToCSCreatePhyreScanTipString += 'actual converting. This information can be{0}'
  $ToCSCreatePhyreScanTipString += 'found in the log file or the texture list.'
  $ToCSCreatePhyreScanTipString = [String]::Format($ToCSCreatePhyreScanTipString, [Environment]::NewLine)
  $ToCSCreatePhyreScanTip.SetToolTip($ToCSCreatePhyreScan, $ToCSCreatePhyreScanTipString)

  # 24: Repack PKG - Create the groupbox that will hold the options.
  $global:ToCSRepackGroup = New-Object Windows.Forms.GroupBox
  $ToCSRepackGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ToCSRepackGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ToCSRepackGroup.Text = ' Repack PKG Options'
  $MainDialogPanel.Controls.Add($ToCSRepackGroup)

  # 24: Repack PKG - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ToCSRepackTTBox = New-Object TransparentLabel
  $ToCSRepackTTBox.Size = DPISize (New-Object Drawing.Size(358, 26))
  $ToCSRepackTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ToCSRepackTTBox.Text = ""
  $ToCSRepackGroup.Controls.Add($ToCSRepackTTBox)

  # 24: Repack PKG - Add a short description of this dialog.
  $global:ToCSRepackLabel = New-Object AdvRichTextBox
  $ToCSRepackLabel.Size = DPISize (New-Object Drawing.Size(358, 26))
  $ToCSRepackLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ToCSRepackLabel.Text = 'Packs folders into PKG files. A folder must contain "asset_D3D11.xml" in order to be packed. Requires a valid path to one of the PKG Tools.'
  $ToCSRepackLabel.SelectionAlignment = [TextAlign]::Justify
  $ToCSRepackLabel.TabStop = $false
  $ToCSRepackLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ToCSRepackLabel.ReadOnly = $true
  $ToCSRepackLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ToCSRepackGroup.Controls.Add($ToCSRepackLabel)

  # 24: Repack PKG - Created Path - Allow using the PNG Phyre folder found in the output path.
  $global:ToCSRepackPrevPath = New-Object Windows.Forms.CheckBox
  $ToCSRepackPrevPath.Size = DPISize (New-Object Drawing.Size(170, 16))
  $ToCSRepackPrevPath.Location = DPISize (New-Object Drawing.Point(10, 56))
  $ToCSRepackPrevPath.Name = 'PhyrePreviousPath'
  $ToCSRepackPrevPath.Checked = $PhyrePreviousPath
  $ToCSRepackPrevPath.Text = ' Use Created Phyre Path'
  $ToCSRepackPrevPath.Add_CheckStateChanged({ CheckBoxStateToggled ; ToCS_TogglePreviousPathChecks })
  $ToCSRepackGroup.Controls.Add($ToCSRepackPrevPath)

  # 24: Repack PKG - Created Path - Create a tooltip.
  $ToCSRepackPrevPathTip = New-Object Windows.Forms.ToolTip
  $ToCSRepackPrevPathTip.InitialDelay = $ToolTipDelay
  $ToCSRepackPrevPathTip.AutoPopDelay = $ToolTipDuration
  $ToCSRepackPrevPathTipString = 'Rather than use the Input Path to search for{0}'
  $ToCSRepackPrevPathTipString += 'PKG files, use the "CreatedPhyre" folder found{0}'
  $ToCSRepackPrevPathTipString += 'in the Output Path that was created with the{0}'
  $ToCSRepackPrevPathTipString += 'previous option to create phyre images from PNG.'
  $ToCSRepackPrevPathTipString = [String]::Format($ToCSRepackPrevPathTipString, [Environment]::NewLine)
  $ToCSRepackPrevPathTip.SetToolTip($ToCSRepackPrevPath, $ToCSRepackPrevPathTipString)

  # 24: Repack PKG - PKG Tool Path - A label that acts as a header to the PKG tool path.
  $global:ToCSRepackPKGToolLabel = New-Object Windows.Forms.Label
  $ToCSRepackPKGToolLabel.Size = DPISize (New-Object Drawing.Size(140, 14))
  $ToCSRepackPKGToolLabel.Location = DPISize (New-Object Drawing.Point(10, 80))
  $ToCSRepackPKGToolLabel.Text = 'PKG Tool Path:'
  $ToCSRepackGroup.Controls.Add($ToCSRepackPKGToolLabel)

  # 24: Repack PKG - PKG Tool Path - The text box that holds the path to the PKG tool. 
  $global:ToCSRepackPKGToolBox = New-Object Windows.Forms.TextBox
  $ToCSRepackPKGToolBox.Size = DPISize (New-Object Drawing.Size(334, 22))
  $ToCSRepackPKGToolBox.Location = DPISize (New-Object Drawing.Point(10, 95)) -AddY $DPIOffsetFix
  $ToCSRepackPKGToolBox.Name = 'PhyrePKGTool'
  $ToCSRepackPKGToolBox.Text = $PhyrePKGTool
  $ToCSRepackPKGToolBox.AllowDrop = $true
  $ToCSRepackPKGToolBox.Add_DragEnter({ $_.Effect = [Windows.Forms.DragDropEffects]::Copy })
  $ToCSRepackPKGToolBox.Add_DragDrop({ LoadExternalFile_DragAndDrop -FileName @('PKGToolCmd.dll', 'PKGTool.exe') })
  $ToCSRepackPKGToolBox.Add_Click({ ClearTextBox })
  $ToCSRepackPKGToolBox.Add_Leave({ LoadExternalFile_TextBox -FileName @('PKGToolCmd.dll', 'PKGTool.exe') })
  $ToCSRepackGroup.Controls.Add($ToCSRepackPKGToolBox)

  # 24: Repack PKG - PKG Tool Path - Allow adding a PKG tool by using a button.
  $global:ToCSRepackPKGToolButton = New-Object Windows.Forms.Button
  $ToCSRepackPKGToolButton.Size = DPISize (New-Object Drawing.Size(24, 22))
  $ToCSRepackPKGToolButton.Location = DPISize (New-Object Drawing.Point(347, 94))
  $ToCSRepackPKGToolButton.Name = 'PhyrePKGTool'
  $ToCSRepackPKGToolButton.Text = '...'
  $ToCSRepackPKGToolButton.Add_Click({ LoadExternalFile_ButtonX -TextBox $ToCSRepackPKGToolBox -FileName @('PKGToolCmd.dll', 'PKGTool.exe') -Description 'PKG Tool' })
  $ToCSRepackGroup.Controls.Add($ToCSRepackPKGToolButton)

  # 25: Basic Image Viewer - Create the groupbox that will hold the image viewer description.
  $global:ImageViewerGroup = New-Object Windows.Forms.GroupBox
  $ImageViewerGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ImageViewerGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ImageViewerGroup.Text = ' Description'
  $MainDialogPanel.Controls.Add($ImageViewerGroup)

  # 25: Basic Image Viewer - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ImageViewerTTBox = New-Object TransparentLabel
  $ImageViewerTTBox.Size = DPISize (New-Object Drawing.Size(358, 72))
  $ImageViewerTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ImageViewerTTBox.Text = ""
  $ImageViewerGroup.Controls.Add($ImageViewerTTBox)

  # 25: Basic Image Viewer - Add a short description of this dialog.
  $global:ImageViewerLabel = New-Object AdvRichTextBox
  $ImageViewerLabel.Size = DPISize (New-Object Drawing.Size(358, 72))
  $ImageViewerLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ImageViewString  = 'A simple image viewer that allows viewing images in various formats. To load an image into the viewer, simply drag and drop an image or group of images into the window, or click on '
  $ImageViewString += 'the window to manually select an image. This viewer works with most image formats, and can also work with The Legend of Heroes: Trails of Cold Steel PKG files and phyre textures.'
  $ImageViewerLabel.Text = $ImageViewString
  $ImageViewerLabel.SelectionAlignment = [TextAlign]::Justify
  $ImageViewerLabel.TabStop = $false
  $ImageViewerLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ImageViewerLabel.ReadOnly = $true
  $ImageViewerLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ImageViewerGroup.Controls.Add($ImageViewerLabel)

  # 26: Resource Pack - Create the groupbox that will hold the options.
  $global:ResourcePackGroup = New-Object Windows.Forms.GroupBox
  $ResourcePackGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ResourcePackGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ResourcePackGroup.Text = ' Description'
  $MainDialogPanel.Controls.Add($ResourcePackGroup)

  # 26: Resource Pack - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ResourcePackTTBox = New-Object TransparentLabel
  $ResourcePackTTBox.Size = DPISize (New-Object Drawing.Size(358, 66))
  $ResourcePackTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ResourcePackTTBox.Text = ""
  $ResourcePackGroup.Controls.Add($ResourcePackTTBox)

  # 26: Resource Pack - Add a short description of this dialog.
  $global:ResourcePackLabel = New-Object AdvRichTextBox
  $ResourcePackLabel.Size = DPISize (New-Object Drawing.Size(358, 66))
  $ResourcePackLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ResourceString  = 'Provides several options to generate and manage Dolphin resource packs. Resource packs are more powerful than standard Dolphin texture '
  $ResourceString += "packs. They can be configured with Dolphin's resource pack GUI to install, uninstall, or toggle the resource pack textures on/off."
  $ResourcePackLabel.Text = $ResourceString
  $ResourcePackLabel.SelectionAlignment = [TextAlign]::Justify
  $ResourcePackLabel.TabStop = $false
  $ResourcePackLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ResourcePackLabel.ReadOnly = $true
  $ResourcePackLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ResourcePackGroup.Controls.Add($ResourcePackLabel)

  # 27: Metroid Prime Replace Fonts - Create the groupbox that will hold the options.
  $global:MetroidReplaceGroup = New-Object Windows.Forms.GroupBox
  $MetroidReplaceGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $MetroidReplaceGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $MetroidReplaceGroup.Text = ' Create Fonts Options'
  $MainDialogPanel.Controls.Add($MetroidReplaceGroup)

  # 27: Metroid Prime Replace Fonts - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:MetroidReplaceTTBox = New-Object TransparentLabel
  $MetroidReplaceTTBox.Size = DPISize (New-Object Drawing.Size(358, 40))
  $MetroidReplaceTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $MetroidReplaceTTBox.Text = ""
  $MetroidReplaceGroup.Controls.Add($MetroidReplaceTTBox)

  # 27: Metroid Prime Replace Fonts - Add a short description of this dialog.
  $global:MetroidReplaceLabel = New-Object AdvRichTextBox
  $MetroidReplaceLabel.Size = DPISize (New-Object Drawing.Size(358, 40))
  $MetroidReplaceLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $MetroidReplaceLabel.Text = 'Searches for font textures and recreates them with replacement textures while preserving their colors. Replacement textures should have white fonts with RGBA colorspace, and can be a higher resolution than the originals.'
  $MetroidReplaceLabel.SelectionAlignment = [TextAlign]::Justify
  $MetroidReplaceLabel.TabStop = $false
  $MetroidReplaceLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $MetroidReplaceLabel.ReadOnly = $true
  $MetroidReplaceLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $MetroidReplaceGroup.Controls.Add($MetroidReplaceLabel)

  # 27: Metroid Prime Replace Fonts - Create a checkbox for the sorted folder seek.
  $global:MetroidHighQualityCheckBox = New-Object Windows.Forms.CheckBox
  $MetroidHighQualityCheckBox.Size = DPISize (New-Object Drawing.Size(178, 16))
  $MetroidHighQualityCheckBox.Location = DPISize (New-Object Drawing.Point(10, 69))
  $MetroidHighQualityCheckBox.Name = 'MetroidHighQuality'
  $MetroidHighQualityCheckBox.Checked = $MetroidHighQuality
  $MetroidHighQualityCheckBox.Text = ' HD Example Preview Images'
  $MetroidHighQualityCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $MetroidReplaceGroup.Controls.Add($MetroidHighQualityCheckBox)

  # 27: Metroid Prime Replace Fonts - Create a tooltip.
  $MetroidHighQualityTip = New-Object Windows.Forms.ToolTip
  $MetroidHighQualityTip.InitialDelay = $ToolTipDelay
  $MetroidHighQualityTip.AutoPopDelay = $ToolTipDuration
  $MetroidHighQualityTipString  = 'Generate higher quality preview images that{0}'
  $MetroidHighQualityTipString += 'scale to the current DPI, which are stored in{0}'
  $MetroidHighQualityTipString += 'the "CTT-PS Data Folder" within a sub-folder{0}'
  $MetroidHighQualityTipString += 'named "Prime2". This only needs done once.'
  $MetroidHighQualityTipString = [String]::Format($MetroidHighQualityTipString, [Environment]::NewLine)
  $MetroidHighQualityTip.SetToolTip($MetroidHighQualityCheckBox, $MetroidHighQualityTipString)

  # 27: Metroid Prime Replace Fonts - Open texture selection menu.
  $global:MetroidSelectButton = New-Object Windows.Forms.Button
  $MetroidSelectButton.Size = DPISize (New-Object Drawing.Size(120, 24))
  $MetroidSelectButton.Location = DPISize (New-Object Drawing.Point(128, 92))
  $MetroidSelectButton.Text = 'Select Textures'
  $MetroidSelectButton.Add_Click({ ShowMetroidPreview })
  $MetroidReplaceGroup.Controls.Add($MetroidSelectButton)

  # 28: Custom CLI Executable - Programs - Create the main groupbox that will hold the options. 
  $global:CLIExecutableGroup = New-Object Windows.Forms.GroupBox
  $CLIExecutableGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $CLIExecutableGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $CLIExecutableGroup.Text = ' Custom CLI Executable Options'
  $MainDialogPanel.Controls.Add($CLIExecutableGroup)

  # 28: Custom CLI Executable - Programs - Create a label for the group.
  $global:CLIProgramLabel = New-Object Windows.Forms.Label
  $CLIProgramLabel.Size = DPISize (New-Object Drawing.Size(140, 14))
  $CLIProgramLabel.Location = DPISize (New-Object Drawing.Point(10, 15))
  $CLIProgramLabel.Text = 'Executables:'
  $CLIExecutableGroup.Controls.Add($CLIProgramLabel)

  # 28: Custom CLI Executable - Programs - Create a tooltip for the label.
  $CLIProgramTip = New-Object Windows.Forms.ToolTip
  $CLIProgramTip.InitialDelay = $ToolTipDelay
  $CLIProgramTip.AutoPopDelay = $ToolTipDuration
  $CLIProgramTipString  = 'The list of command line executables to{0}'
  $CLIProgramTipString += 'run through the CTT-PS Master Loop. Use{0}'
  $CLIProgramTipString += 'the [+]/[-] buttons to add/remove them.'
  $CLIProgramTipString = [String]::Format($CLIProgramTipString, [Environment]::NewLine)
  $CLIProgramTip.SetToolTip($CLIProgramLabel, $CLIProgramTipString)

  # 28: Custom CLI Executable - Programs - Create the combobox to store the imported programs.
  $global:CLIProgramCombo = New-Object Windows.Forms.ComboBox
  $CLIProgramCombo.Size = DPISize (New-Object Drawing.Size(140, 28))
  $CLIProgramCombo.Location = DPISize (New-Object Drawing.Point(10, 30)) -AddY $DPIOffsetFix
  $CLIProgramCombo.Name = 'CustomCLIExecutables'
  $CLIProgramCombo.Add_SelectedIndexChanged({ $MainFocusLabel.Focus() })
  $CLIProgramCombo.Add_SelectedIndexChanged({ SelectCustomCLIExecutable })
  $CLIProgramCombo.DropDownStyle = [Windows.Forms.ComboBoxStyle]::DropDownList
  $CLIProgramCombo.DrawMode = [Windows.Forms.DrawMode]::OwnerDrawFixed
  $CLIProgramCombo.Add_DrawItem({ RepopulateComboBox })
  $CLIExecutableGroup.Controls.Add($CLIProgramCombo)

  # 28: Custom CLI Executable - Programs - Create an "Add" button.
  $global:CLIProgramAddButton = New-Object Windows.Forms.TextBox
  $CLIProgramAddButton.Size = DPISize (New-Object Drawing.Size(20, 22))
  $CLIProgramAddButton.Location = DPISize (New-Object Drawing.Point(154, 31)) -AddY $DPIOffsetFix
  $CLIProgramAddButton.Name = 'CustomCLIExecutables'
  $CLIProgramAddButton.Text = '+'
  $CLIProgramAddButton.ReadOnly = $True
  $CLIProgramAddButton.TextAlign = [Windows.Forms.HorizontalAlignment]::Center
  $CLIProgramAddButton.TabStop = $false
  $CLIProgramAddButton.AcceptsTab = $false
  $CLIProgramAddButton.Cursor = [Windows.Forms.Cursors]::Arrow
  $CLIProgramAddButton.ForeColor = '#000000'
  $CLIProgramAddButton.BackColor = '#E1E1E1'
  $CLIProgramAddButton.BorderStyle = [Windows.Forms.BorderStyle]::FixedSingle
  $CLIProgramAddButton.Add_MouseDown({ AddCustomCLIExecutable })
  $CLIProgramAddButton.Add_GotFocus({ $MainOperations.Focus() })
  $CLIProgramAddButton.Add_MouseEnter({ $this.BackColor = '#E5F1FB' })
  $CLIProgramAddButton.Add_MouseLeave({ $this.BackColor = '#E1E1E1' })
  $CLIExecutableGroup.Controls.Add($CLIProgramAddButton)

  # 28: Custom CLI Executable - Programs - Create a "Remove" button.
  $global:CLIProgramRemButton = New-Object Windows.Forms.TextBox
  $CLIProgramRemButton.Size = DPISize (New-Object Drawing.Size(20, 22))
  $CLIProgramRemButton.Location = DPISize (New-Object Drawing.Point(178, 31)) -AddY $DPIOffsetFix
  $CLIProgramRemButton.Name = 'CustomCLIExecutables'
  $CLIProgramRemButton.Text = '-'
  $CLIProgramRemButton.ReadOnly = $True
  $CLIProgramRemButton.TextAlign = [Windows.Forms.HorizontalAlignment]::Center
  $CLIProgramRemButton.TabStop = $false
  $CLIProgramRemButton.AcceptsTab = $false
  $CLIProgramRemButton.Cursor = [Windows.Forms.Cursors]::Arrow
  $CLIProgramRemButton.ForeColor = '#000000'
  $CLIProgramRemButton.BackColor = '#E1E1E1'
  $CLIProgramRemButton.BorderStyle = [Windows.Forms.BorderStyle]::FixedSingle
  $CLIProgramRemButton.Add_MouseDown({ RemoveCustomCLIExecutable })
  $CLIProgramRemButton.Add_GotFocus({ $MainOperations.Focus() })
  $CLIProgramRemButton.Add_MouseEnter({ $this.BackColor = '#E5F1FB' })
  $CLIProgramRemButton.Add_MouseLeave({ $this.BackColor = '#E1E1E1' })
  $CLIExecutableGroup.Controls.Add($CLIProgramRemButton)

  # 28: Custom CLI Executable - Input Extensions - Create a label for the group.
  $global:CLIExtensionsLabel = New-Object Windows.Forms.Label
  $CLIExtensionsLabel.Size = DPISize (New-Object Drawing.Size(94, 14))
  $CLIExtensionsLabel.Location = DPISize (New-Object Drawing.Point(10, 55))
  $CLIExtensionsLabel.Text = 'Input Extensions:'
  $CLIExecutableGroup.Controls.Add($CLIExtensionsLabel)

  # 28: Custom CLI Executable - Input Extensions - Create a tooltip for the label.
  $CLIExtensionsTip = New-Object Windows.Forms.ToolTip
  $CLIExtensionsTip.InitialDelay = $ToolTipDelay
  $CLIExtensionsTip.AutoPopDelay = $ToolTipDuration
  $CLIExtensionsTipString  = 'This is the list of extensions that are{0}'
  $CLIExtensionsTipString += 'allowed to be passed to the program.{0}'
  $CLIExtensionsTipString += 'Extensions should be separated by a{0}'
  $CLIExtensionsTipString += 'space, but commas should also work.'
  $CLIExtensionsTipString = [String]::Format($CLIExtensionsTipString, [Environment]::NewLine)
  $CLIExtensionsTip.SetToolTip($CLIExtensionsLabel, $CLIExtensionsTipString)

  # 28: Custom CLI Executable - Input Extensions - Create a textbox that stores the extensions.
  $global:CLIInputExtensionsBox = New-Object Windows.Forms.TextBox
  $CLIInputExtensionsBox.Size = DPISize (New-Object Drawing.Size(90, 28))
  $CLIInputExtensionsBox.Location = DPISize (New-Object Drawing.Point(10, 70)) -AddY $DPIOffsetFix
  $CLIInputExtensionsBox.Name = 'CLIInputExtensions'
  $CLIInputExtensionsBox.Text = ''
  $CLIInputExtensionsBox.Add_Leave({ UpdateCustomCLIExecutableINI -Executable $CustomCLISelected })
  $CLIExecutableGroup.Controls.Add($CLIInputExtensionsBox)

  # 28: Custom CLI Executable - Output Extension - Create a label for the group.
  $global:CLIOutExtensionsLabel = New-Object Windows.Forms.Label
  $CLIOutExtensionsLabel.Size = DPISize (New-Object Drawing.Size(94, 14))
  $CLIOutExtensionsLabel.Location = DPISize (New-Object Drawing.Point(107, 55))
  $CLIOutExtensionsLabel.Text = 'Output Extension:'
  $CLIExecutableGroup.Controls.Add($CLIOutExtensionsLabel)

  # 28: Custom CLI Executable - Output Extension - Create a tooltip for the label.
  $CLIOutExtensionsTip = New-Object Windows.Forms.ToolTip
  $CLIOutExtensionsTip.InitialDelay = $ToolTipDelay
  $CLIOutExtensionsTip.AutoPopDelay = $ToolTipDuration
  $CLIOutExtensionsTipString  = 'Enter the expected output extension here. This{0}'
  $CLIOutExtensionsTipString += 'does NOT guarantee that output files will be{0}'
  $CLIOutExtensionsTipString += 'created with this extension, but it must be set{0}'
  $CLIOutExtensionsTipString += 'for the reference variables that are used for the{0}'
  $CLIOutExtensionsTipString += 'output references in the commands list. Only{0}'
  $CLIOutExtensionsTipString += 'the program itself can control the ouput type.{0}'
  $CLIOutExtensionsTipString += '{0}'
  $CLIOutExtensionsTipString += 'For example, if the program is expected to{0}'
  $CLIOutExtensionsTipString += 'create a file at "C:\image.png", the output here{0}'
  $CLIOutExtensionsTipString += 'should be set to ".png". This ensures that the{0}'
  $CLIOutExtensionsTipString += 'variable "$OutputFile" has the correct value{0}'
  $CLIOutExtensionsTipString += 'when used in the commands list as it uses the{0}'
  $CLIOutExtensionsTipString += 'file extension that is set here.'
  $CLIOutExtensionsTipString = [String]::Format($CLIOutExtensionsTipString, [Environment]::NewLine)
  $CLIOutExtensionsTip.SetToolTip($CLIOutExtensionsLabel, $CLIOutExtensionsTipString)

  # 28: Custom CLI Executable - Output Extension - Create a textbox that stores the extensions.
  $global:CLIOutputExtensionBox = New-Object Windows.Forms.TextBox
  $CLIOutputExtensionBox.Size = DPISize (New-Object Drawing.Size(90, 28))
  $CLIOutputExtensionBox.Location = DPISize (New-Object Drawing.Point(108, 70)) -AddY $DPIOffsetFix
  $CLIOutputExtensionBox.Name = 'CLIOutputExtensions'
  $CLIOutputExtensionBox.Text = ''
  $CLIOutputExtensionBox.Add_Leave({ UpdateCustomCLIExecutableINI -Executable $CustomCLISelected })
  $CLIExecutableGroup.Controls.Add($CLIOutputExtensionBox)

  # 28: Custom CLI Executable - Output Folder Name - Create a label for the option.
  $global:CLIOutFolderNameLabel = New-Object Windows.Forms.Label
  $CLIOutFolderNameLabel.Size = DPISize (New-Object Drawing.Size(78, 14))
  $CLIOutFolderNameLabel.Location = DPISize (New-Object Drawing.Point(9, 100))
  $CLIOutFolderNameLabel.Text = 'Output Folder:'
  $CLIExecutableGroup.Controls.Add($CLIOutFolderNameLabel)

  # 28: Custom CLI Executable - Output Folder Name - Create a tooltip for the label.
  $CLIOutFolderNameTip = New-Object Windows.Forms.ToolTip
  $CLIOutFolderNameTip.InitialDelay = $ToolTipDelay
  $CLIOutFolderNameTip.AutoPopDelay = $ToolTipDuration
  $CLIOutFolderNameTipString  = 'This is the name of the output folder{0}'
  $CLIOutFolderNameTipString += 'created in the "Output Path" which is{0}'
  $CLIOutFolderNameTipString += 'where files will go when created with{0}'
  $CLIOutFolderNameTipString += 'the custom imported CLI program.'
  $CLIOutFolderNameTipString = [String]::Format($CLIOutFolderNameTipString, [Environment]::NewLine)
  $CLIOutFolderNameTip.SetToolTip($CLIOutFolderNameLabel, $CLIOutFolderNameTipString)

  # 28: Custom CLI Executable - Output Folder Name - Create a textbox that stores the output folder name.
  $global:CLIOutFolderNameBox = New-Object Windows.Forms.TextBox
  $CLIOutFolderNameBox.Size = DPISize (New-Object Drawing.Size(110, 28)) -Round
  $CLIOutFolderNameBox.Location = DPISize (New-Object Drawing.Point(88, 97)) -AddY $DPIOffsetFix
  $CLIOutFolderNameBox.Text = 'CustomExecutable'
  $CLIOutFolderNameBox.Add_Leave({ SetCustomCLIExecutableOutputFolder ; UpdateCustomCLIExecutableINI -Executable $CustomCLISelected })
  $CLIExecutableGroup.Controls.Add($CLIOutFolderNameBox)

  # 28: Custom CLI Executable - Commands - Create a label for the command list.
  $global:CLICommandsLabel = New-Object Windows.Forms.Label
  $CLICommandsLabel.Size = DPISize (New-Object Drawing.Size(100, 14))
  $CLICommandsLabel.Location = DPISize (New-Object Drawing.Point(210, 15))
  $CLICommandsLabel.Text = 'Command List:'
  $CLIExecutableGroup.Controls.Add($CLICommandsLabel)

  # 28: Custom CLI Executable - Commands - Create a tooltip for the label.
  $CLICommandsTip = New-Object Windows.Forms.ToolTip
  $CLICommandsTip.InitialDelay = $ToolTipDelay
  $CLICommandsTip.AutoPopDelay = $ToolTipDuration
  $CLICommandsTipString  = 'This is the list of commands to feed the program. Each{0}'
  $CLICommandsTipString += 'command must be entered onto a new line. If commands{0}'
  $CLICommandsTipString += "are two parts, each must be put onto a new line if there is{0}"
  $CLICommandsTipString += "a space between them (ex: -size 25). The simplest thing to{0}"
  $CLICommandsTipString += "do is write out the full command, and each time there is a{0}"
  $CLICommandsTipString += "space, this signifies when to start a new line.{0}"
  $CLICommandsTipString += "{0}"
  $CLICommandsTipString += "There is also a number of variables that the user can use{0}"
  $CLICommandsTipString += 'to reference the input and output files. Do note that the{0}'
  $CLICommandsTipString += '"Output" variables use the extension that the user set as{0}'
  $CLICommandsTipString += 'the "Output Extension" and not from the actual file itself.{0}'
  $CLICommandsTipString += "{0}"
  $CLICommandsTipString += '- $InputBase: Base name without extension.{0}'
  $CLICommandsTipString += '- $InputName: Base name with output extension.{0}'
  $CLICommandsTipString += '- $InputPath: Path to file without filename.{0}'
  $CLICommandsTipString += '- $InputFile: Path to file with the filename.{0}'
  $CLICommandsTipString += '- $OutputBase: Base name without extension.{0}'
  $CLICommandsTipString += '- $OutputName: Base name with output extension.{0}'
  $CLICommandsTipString += '- $OutputPath: Path to file without filename.{0}'
  $CLICommandsTipString += '- $OutputFile: Path to file with the filename.{0}'
  $CLICommandsTipString += '- $ImageWidth: If an image, the input width.{0}'
  $CLICommandsTipString += '- $ImageHeight: If an image, the input height.{0}'
  $CLICommandsTipString += '- $ImageDimensions: Dimensions as width x height.{0}'
  $CLICommandsTipString += "{0}"
  $CLICommandsTipString += "Multiplied versions of the dimensions can also be used{0}"
  $CLICommandsTipString += 'such as $ImageHeightx2 to get 2 times the size, or even{0}'
  $CLICommandsTipString += '$ImageHeightx6 to get 6 times the size. This works up{0}'
  $CLICommandsTipString += 'to x8 and also works on the ImageDimensions variable.{0}'
  $CLICommandsTipString += "{0}"
  $CLICommandsTipString += "These variables can be used when a program requires the{0}"
  $CLICommandsTipString += "input and output files. Sometimes just an output path is{0}"
  $CLICommandsTipString += "needed, others both the output path + file is needed. The{0}"
  $CLICommandsTipString += "variables allow referencing the files with varying amounts{0}"
  $CLICommandsTipString += "of information to fit the required situation."
  $CLICommandsTipString = [String]::Format($CLICommandsTipString, [Environment]::NewLine)
  $CLICommandsTip.SetToolTip($CLICommandsLabel, $CLICommandsTipString)

  # 28: Custom CLI Executable - Commands - Create a button to remove a single command.
  $global:CLICommandsMinusButton = New-Object Windows.Forms.Button
  $CLICommandsMinusButton.Size = DPISize (New-Object Drawing.Size(20, 20))
  $CLICommandsMinusButton.Location = DPISize (New-Object Drawing.Point(329, 10))
  $CLICommandsMinusButton.Text = '-'
  $CLICommandsMinusButton.Add_Click({ CLIClearSelectedCommand })
  $CLIExecutableGroup.Controls.Add($CLICommandsMinusButton)

  # 28: Custom CLI Executable - Commands - Create a tooltip for the remove button.
  $CLICommandsMinusTip = New-Object Windows.Forms.ToolTip
  $CLICommandsMinusTip.InitialDelay = $ToolTipDelay
  $CLICommandsMinusTip.AutoPopDelay = $ToolTipDuration
  $CLICommandsMinusTipString =  'Clear the currently selected{0}'
  $CLICommandsMinusTipString += 'commands from the list.'
  $CLICommandsMinusTipString = [String]::Format($CLICommandsMinusTipString, [Environment]::NewLine)
  $CLICommandsMinusTip.SetToolTip($CLICommandsMinusButton, $CLICommandsMinusTipString)

  # 28: Custom CLI Executable - Commands - Create a button to clear the commands list.
  $global:CLICommandsClearButton = New-Object Windows.Forms.Button
  $CLICommandsClearButton.Size = DPISize (New-Object Drawing.Size(20, 20))
  $CLICommandsClearButton.Location = DPISize (New-Object Drawing.Point(351, 10))
  $CLICommandsClearButton.Text = 'x'
  $CLICommandsClearButton.Add_Click({ $CLIGridView.Rows.Clear() })
  $CLIExecutableGroup.Controls.Add($CLICommandsClearButton)

  # 28: Custom CLI Executable - Commands - Create a tooltip for the clear button.
  $CLICommandsClearTip = New-Object Windows.Forms.ToolTip
  $CLICommandsClearTip.InitialDelay = $ToolTipDelay
  $CLICommandsClearTip.AutoPopDelay = $ToolTipDuration
  $CLICommandsClearTipString =  'Clears all commands{0}'
  $CLICommandsClearTipString += 'from the current list.'
  $CLICommandsClearTipString = [String]::Format($CLICommandsClearTipString, [Environment]::NewLine)
  $CLICommandsClearTip.SetToolTip($CLICommandsClearButton, $CLICommandsClearTipString)

  # 28: Custom CLI Executable - Commands - Create a DataGridView to allow the user to create a command list.
  $global:CLIGridView = New-Object Windows.Forms.DataGridView
  $CLIGridView.Location = DPISize (New-Object Drawing.Point(210, 32))
  $CLIGridView.ColumnCount = 1
  $CLIGridView.Font = New-Object Drawing.Font('Courier New', (DPISize 10), [System.Drawing.FontStyle]::Regular, [System.Drawing.GraphicsUnit]::Pixel)
  $CLIGridView.AllowUserToAddRows = $true
  $CLIGridView.AllowUserToResizeRows = $false
  $CLIGridView.AllowUserToResizeColumns = $false
  $CLIGridView.RowHeadersVisible = $false
  $CLIGridView.AutoSizeColumnsMode = [Windows.Forms.DataGridViewAutoSizeColumnsMode]::Fill
  $CLIGridView.AutoSizeRowsMode = [Windows.Forms.DataGridViewAutoSizeRowsMode]::None
  $CLIGridView.SelectionMode = [Windows.Forms.DataGridViewSelectionMode]::CellSelect
  $CLIGridView.ColumnHeadersVisible = $false
  $CLIGridView.ColumnHeadersHeightSizeMode = [Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::AutoSize
  $CLIGridView.RowHeadersWidthSizeMode = [Windows.Forms.DataGridViewRowHeadersWidthSizeMode]::DisableResizing
  $CLIGridView.Columns[0].Width = 100
  $CLIGridView.Columns[0].SortMode = [Windows.Forms.DataGridViewColumnSortMode]::NotSortable
  $CLIGridView.Size = New-Object Drawing.Size((DPISize 160), ($CLIGridView.Rows[0].Height * 4 + 3))
  $CLIGridView.Add_CellValueChanged({ UpdateCustomCLIExecutableINI -Executable $CustomCLISelected })
  $CLIExecutableGroup.Controls.Add($CLIGridView)

  # 29: Extract Textures With TextureExtraction Tool - Create the main groupbox that will hold the options. 
  $global:ExtractTexturesGroup = New-Object Windows.Forms.GroupBox
  $ExtractTexturesGroup.Size = DPISize (New-Object Drawing.Size(380, 124))
  $ExtractTexturesGroup.Location = DPISize (New-Object Drawing.Point(10, 214))
  $ExtractTexturesGroup.Text = ' Extract Textures Options'
  $MainDialogPanel.Controls.Add($ExtractTexturesGroup)

  # 29: Extract Textures With TextureExtraction Tool - Use a transparent label that is equal in size to the rich text box so it can't be clicked on.
  $global:ExtractTexturesTTBox = New-Object TransparentLabel
  $ExtractTexturesTTBox.Size = DPISize (New-Object Drawing.Size(358, 72))
  $ExtractTexturesTTBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ExtractTexturesTTBox.Text = ""
  $ExtractTexturesGroup.Controls.Add($ExtractTexturesTTBox)

  # 29: Extract Textures With TextureExtraction Tool - Add a short description of this dialog.
  $global:ExtractTexturesLabel = New-Object AdvRichTextBox
  $ExtractTexturesLabel.Size = DPISize (New-Object Drawing.Size(358, 72))
  $ExtractTexturesLabel.Location = DPISize (New-Object Drawing.Point(10, 22))
  $ExtractTexturesString  = "The TextureExtraction Tool by Venomalia allows extracting textures directly from Gamecube/Wii disc images in PNG format with the naming scheme that Dolphin uses, which can "
  $ExtractTexturesString += "be edited to create Dolphin texture packs. The tool can extract textures from ISO files or the extracted disc contents. "
  $ExtractTexturesLabel.Text = $ExtractTexturesString
  $ExtractTexturesLabel.SelectionAlignment = [TextAlign]::Justify
  $ExtractTexturesLabel.TabStop = $false
  $ExtractTexturesLabel.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ExtractTexturesLabel.ReadOnly = $true
  $ExtractTexturesLabel.BackColor = [Drawing.ColorTranslator]::FromHtml('#f0f0f0')
  $ExtractTexturesGroup.Controls.Add($ExtractTexturesLabel)

  # 29: Extract Textures With TextureExtraction Tool
  $global:ExtractTexConfigButton = New-Object Windows.Forms.Button
  $ExtractTexConfigButton.Size = DPISize (New-Object Drawing.Size(120, 24))
  $ExtractTexConfigButton.Location = DPISize (New-Object Drawing.Point(130, 94))
  $ExtractTexConfigButton.Text = 'Configure Options'
  $ExtractTexConfigButton.Add_Click({ $TexExtractDialog.ShowDialog() | Out-Null  })
  $ExtractTexturesGroup.Controls.Add($ExtractTexConfigButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES & SPLIT COMBINED MULTI-TEXTURE - ZELDA OPTIONS
#==============================================================================================================================================================================================
#  Toggles the option for allowing user specified top-left texture when auto-stacking.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleZeldaStack()
{
  $CombineZeldaTopLeftCheckBox.Enabled = $this.Checked

  if ($this.Checked)
  {
    $CombineZeldaTopLeftLinkIconA.Image = $Image_OptionLinkOn
    $CombineZeldaTopLeftLinkIconB.Image = $Image_OptionLinkOn
  }
  else
  {
    $global:UserSpecifyTopLeft           = $false
    $CombineZeldaTopLeftCheckBox.Checked = $false
    $CombineZeldaTopLeftLinkIconA.Image  = $Image_OptionLinkOff
    $CombineZeldaTopLeftLinkIconB.Image  = $Image_OptionLinkOff
  }
}
#==============================================================================================================================================================================================
#  Toggles the combine garbage removal options when overlap is checked/unchecked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleCombinePixelOverlap()
{
  $CombinePixelCropCheckBox.Enabled = !$this.Checked
  $CombinePixelCropLNumBox.Enabled  = !$this.Checked
  $CombinePixelCropLabelL.Enabled   = !$this.Checked
  $CombinePixelCropRNumBox.Enabled  = !$this.Checked
  $CombinePixelCropLabelR.Enabled   = !$this.Checked
  $CombinePixelCropTNumBox.Enabled  = !$this.Checked
  $CombinePixelCropLabelT.Enabled   = !$this.Checked
  $CombinePixelCropBNumBox.Enabled  = !$this.Checked
  $CombinePixelCropLabelB.Enabled   = !$this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the combine overlap options when garbage removal is checked/unchecked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleCombineGarbageRemoval()
{
  $CombineZeldaOverlapCheckBox.Enabled = !$this.Checked
  $CombineOverlapNumBox.Enabled        = !$this.Checked
}
#==============================================================================================================================================================================================
#  Toggles forcing the dimensions of segments when splitting textures.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleSplitSegmentsOverlap()
{
  # Toggle the pixel overlap stuff.
  $SplitZeldaOverlapCheckBox.Enabled  = !$this.Checked
  $SplitOverlapNumBox.Enabled         = !$this.Checked

  # Toggle all the garbage pixels stuff.
  $SplitZeldaResCheckBox.Enabled = !$this.Checked
  $SplitZeldaRestoreL.Enabled    = !$this.Checked
  $SplitZeldaLabelL.Enabled      = !$this.Checked
  $SplitZeldaRestoreR.Enabled    = !$this.Checked
  $SplitZeldaLabelR.Enabled      = !$this.Checked
  $SplitZeldaRestoreT.Enabled    = !$this.Checked
  $SplitZeldaLabelT.Enabled      = !$this.Checked
  $SplitZeldaRestoreB.Enabled    = !$this.Checked
  $SplitZeldaLabelB.Enabled      = !$this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the split garbage removal options when overlap is checked/unchecked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleSplitPixelOverlap()
{
  # Toggle the define dimensions stuff.
  $SplitBoundariesCheckBox.Enabled     = !$this.Checked
  $SplitBoundariesWidthNumBox.Enabled  = !$this.Checked
  $SplitBoundariesXLabel.Enabled       = !$this.Checked
  $SplitBoundariesHeightNumBox.Enabled = !$this.Checked

  # Toggle all the garbage pixels stuff.
  $SplitZeldaResCheckBox.Enabled = !$this.Checked
  $SplitZeldaRestoreL.Enabled    = !$this.Checked
  $SplitZeldaLabelL.Enabled      = !$this.Checked
  $SplitZeldaRestoreR.Enabled    = !$this.Checked
  $SplitZeldaLabelR.Enabled      = !$this.Checked
  $SplitZeldaRestoreT.Enabled    = !$this.Checked
  $SplitZeldaLabelT.Enabled      = !$this.Checked
  $SplitZeldaRestoreB.Enabled    = !$this.Checked
  $SplitZeldaLabelB.Enabled      = !$this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the split overlap options when garbage removal is checked/unchecked.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleSplitGarbageRemoval()
{
  # Toggle the pixel overlap stuff.
  $SplitZeldaOverlapCheckBox.Enabled = !$this.Checked
  $SplitOverlapNumBox.Enabled        = !$this.Checked
  
  # Toggle the define dimensions stuff.
  $SplitBoundariesCheckBox.Enabled     = !$this.Checked
  $SplitBoundariesWidthNumBox.Enabled  = !$this.Checked
  $SplitBoundariesXLabel.Enabled       = !$this.Checked
  $SplitBoundariesHeightNumBox.Enabled = !$this.Checked
}
#==============================================================================================================================================================================================
#  Toggles the help box that explains these insane options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ZeldaOptionsToggleHelp([bool]$ResetWindow)
{
  # Check to see if the help message is currently hidden.
  if (!$ResetWindow)
  {
    # Set the positions and show the help message.
    $CombineZeldaDialog.Size        = DPISize (New-Object Drawing.Size(362, 518))
    $CombineZeldaDialog.MinimumSize = DPISize (New-Object Drawing.Size(362, 518))
    $CombineZeldaDialog.MaximumSize = DPISize (New-Object Drawing.Size(362, 518))
    $ZeldaOkayButton.Location       = DPISize (New-Object Drawing.Point(257, 442))
    $ZeldaHelpButton.Location       = DPISize (New-Object Drawing.Point(224, 442))
    $ZeldaHelpPanel.Visible         = $true
  }
  # The help message is currently shown.
  else
  {
    # Set the positions and hide the help message.
    $CombineZeldaDialog.Size        = DPISize (New-Object Drawing.Size(362, 414))
    $CombineZeldaDialog.MinimumSize = DPISize (New-Object Drawing.Size(362, 414))
    $CombineZeldaDialog.MaximumSize = DPISize (New-Object Drawing.Size(362, 414))
    $ZeldaOkayButton.Location       = DPISize (New-Object Drawing.Point(257, 338))
    $ZeldaHelpButton.Location       = DPISize (New-Object Drawing.Point(224, 338))
    $ZeldaHelpPanel.Visible         = $false
  }
}
#==============================================================================================================================================================================================
#  Hide the triforce button with a right click.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowHideZeldaTriforce()
{
  # Check to make sure its a right click.
  if ($_.Button -eq [Windows.Forms.MouseButtons]::Right)
  {
    # Perform a check to make sure the correct button/panel is being checked.
    switch -wildcard ($this.Name)
    {
      # If the correct button/panel is not clicked, it will cause bugs.
      'Combine*'  { $Clicked = $CombineZeldaButton }
      'Split*'    { $Clicked = $SplitZeldaButton }
    }
    # Show/hide depending on the current visibility.
    switch ($Clicked.Visible)
    {
      # The buttons are currently visible.
      $true   {
                # Hide the buttons on the panels.
                $CombineZeldaButton.Visible  = $false
                $SplitZeldaButton.Visible    = $false

                # Set the color of the panel to the color of the main dialog.
                $CombineZeldaPanel.BackColor = $MainDialog.BackColor
                $SplitZeldaPanel.BackColor   = $MainDialog.BackColor

                # Set the position of the panels.
                $CombineZeldaPanel.Location  = New-Object Drawing.Point(($CombineZeldaPanel.Location.X - 1), ($CombineZeldaPanel.Location.Y + 1))
                $SplitZeldaPanel.Location    = New-Object Drawing.Point(($SplitZeldaPanel.Location.X - 1), ($SplitZeldaPanel.Location.Y + 1))
              }
      # The buttons are currently hidden.
      $false  {
                # Show the buttons on the panels.
                $CombineZeldaButton.Visible  = $true
                $SplitZeldaButton.Visible    = $true

                # Set the color of the panel to a dark gray.
                $CombineZeldaPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#8d8d8d')
                $SplitZeldaPanel.BackColor   = [Drawing.ColorTranslator]::FromHtml('#8d8d8d')

                # Set the position of the panels.
                $CombineZeldaPanel.Location  = New-Object Drawing.Point(($CombineZeldaPanel.Location.X + 1), ($CombineZeldaPanel.Location.Y - 1))
                $SplitZeldaPanel.Location    = New-Object Drawing.Point(($SplitZeldaPanel.Location.X + 1), ($SplitZeldaPanel.Location.Y - 1))
              }
    }
  }
}
#==============================================================================================================================================================================================
#  Show the dialog for the Zelda options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowZeldaOptions()
{
  # Check to make sure its a right click.
  if ($_.Button -eq [Windows.Forms.MouseButtons]::Left)
  {
    # Show the dialog.
    $CombineZeldaDialog.ShowDialog() | Out-Null

    # Set the color of the zelda buttons.
    $CombineZeldaButton.Image = GetZeldaTriforceButton
    $SplitZeldaButton.Image   = GetZeldaTriforceButton
  }
}
#==============================================================================================================================================================================================
#  Create the dialog for the Zelda options.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ZeldaOptions()
{
  # Create the dialog and set up properties.
  $global:CombineZeldaDialog = New-Object Windows.Forms.Form
  $CombineZeldaDialog.Size = DPISize (New-Object Drawing.Size(362, 414))
  $CombineZeldaDialog.MinimumSize = DPISize (New-Object Drawing.Size(362, 414))
  $CombineZeldaDialog.MaximumSize = DPISize (New-Object Drawing.Size(362, 414))
  $CombineZeldaDialog.Text = 'CTT-PS Combine/Split Advanced Options'
  $CombineZeldaDialog.MaximizeBox = $false
  $CombineZeldaDialog.MinimizeBox = $false
  $CombineZeldaDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $CombineZeldaDialog.FormBorderStyle = [Windows.Forms.FormBorderStyle]::FixedDialog
  $CombineZeldaDialog.StartPosition = "CenterScreen"
  $CombineZeldaDialog.Topmost = !$DisableTopMost
  $CombineZeldaDialog.KeyPreview = $true
  $CombineZeldaDialog.Add_KeyDown({ EscapeCloseDialog })
  $CombineZeldaDialog.Add_FormClosing({ $CombineZeldaDialog.Hide() ; $_.Cancel = $true })
  $CombineZeldaDialog.Icon = $Icon_CTTPSGreen

  # Create a panel to hold all the shit.
  $global:CombineZeldaMainPanel = New-Object Windows.Forms.Panel
  $CombineZeldaMainPanel.Size = DPISize (New-Object Drawing.Size(364, 560))
  $CombineZeldaMainPanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $CombineZeldaDialog.Controls.Add($CombineZeldaMainPanel)

  # Create a label.
  $global:CombineZeldaLabel = New-Object Windows.Forms.Label
  $CombineZeldaLabel.Size = DPISize (New-Object Drawing.Size(340, 26))
  $CombineZeldaLabel.Location = DPISize (New-Object Drawing.Point(10, 10))
  $CombineZeldaLabel.Text = 'Provides several options to crop/add duplicate pixels between textures, or crop/add garbage pixels to the edges of textures.'
  $CombineZeldaMainPanel.Controls.Add($CombineZeldaLabel)

  # Create a groupbox to hold all the shit.
  $global:CombineZeldaGroupBox = New-Object Windows.Forms.GroupBox
  $CombineZeldaGroupBox.Size = DPISize (New-Object Drawing.Size(326, 152))
  $CombineZeldaGroupBox.Location = DPISize (New-Object Drawing.Point(10, 44))
  $CombineZeldaGroupBox.Text = 'Combine Texture Options'
  $CombineZeldaMainPanel.Controls.Add($CombineZeldaGroupBox)

  # Zelda64 Auto-Background - Create a checkbox.
  $global:CombineAutoArrangeCheckBox = New-Object Windows.Forms.CheckBox
  $CombineAutoArrangeCheckBox.Size = DPISize (New-Object Drawing.Size(300, 16))
  $CombineAutoArrangeCheckBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $CombineAutoArrangeCheckBox.Name = 'CombineAutoArrange'
  $CombineAutoArrangeCheckBox.Checked = $CombineAutoArrange
  $CombineAutoArrangeCheckBox.Text = ' Attempt Auto-Arrange When Importing'
  $CombineAutoArrangeCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleZeldaStack })
  $CombineZeldaGroupBox.Controls.Add($CombineAutoArrangeCheckBox)

  # Zelda64 Auto-Background - Create a tooltip.
  $CombineAutoArrangeTip = New-Object Windows.Forms.ToolTip
  $CombineAutoArrangeTip.InitialDelay = $ToolTipDelay
  $CombineAutoArrangeTip.AutoPopDelay = $ToolTipDuration
  $CombineAutoArrangeTipString =  'The Legend of Zelda: Ocarina of Time and possibly other N64{0}'
  $CombineAutoArrangeTipString += 'VC games may have skybox (and other "box" backgrounds) that{0}'
  $CombineAutoArrangeTipString += 'consist of multiple textures that overlap 1 row and 1 column of{0}'
  $CombineAutoArrangeTipString += 'pixels along the edges where they meet. When importing images{0}'
  $CombineAutoArrangeTipString += 'into the grid with a drag and drop, this option will attempt to{0}'
  $CombineAutoArrangeTipString += 'auto-arrange the textures based on those duplicate pixels. This{0}'
  $CombineAutoArrangeTipString += 'saves a ton of effort required to assemble them manually.{0}'
  $CombineAutoArrangeTipString += '{0}'
  $CombineAutoArrangeTipString += 'Note this option will only work if there are duplicate pixels{0}'
  $CombineAutoArrangeTipString += 'on the outer edges between the boundaries of the tiles.'
  $CombineAutoArrangeTipString = [String]::Format($CombineAutoArrangeTipString, [Environment]::NewLine)
  $CombineAutoArrangeTip.SetToolTip($CombineAutoArrangeCheckBox, $CombineAutoArrangeTipString)

  # Create an icon that links the above option with the below option.
  $global:CombineZeldaTopLeftLinkIconA = New-Object Windows.Forms.PictureBox
  $CombineZeldaTopLeftLinkIconA.Size = DPISize (New-Object Drawing.Size(10, 10))
  $CombineZeldaTopLeftLinkIconA.Location = DPISize (New-Object Drawing.Point(16, 41))
  $CombineZeldaGroupBox.Controls.Add($CombineZeldaTopLeftLinkIconA)
  
  # Create a second icon that links the above option with the below option.
  $global:CombineZeldaTopLeftLinkIconB = New-Object Windows.Forms.PictureBox
  $CombineZeldaTopLeftLinkIconB.Size = DPISize (New-Object Drawing.Size(10, 10))
  $CombineZeldaTopLeftLinkIconB.Location = DPISize (New-Object Drawing.Point(16, 47))
  $CombineZeldaGroupBox.Controls.Add($CombineZeldaTopLeftLinkIconB)
  $CombineZeldaTopLeftLinkIconB.BringToFront()

  # Set the images based on the auto-arrange state.
  if ($CombineAutoArrange) { $CombineZeldaTopLeftLinkIconA.Image = $Image_OptionLinkOn } else { $CombineZeldaTopLeftLinkIconA.Image = $Image_OptionLinkOff }
  if ($CombineAutoArrange) { $CombineZeldaTopLeftLinkIconB.Image = $Image_OptionLinkOn } else { $CombineZeldaTopLeftLinkIconB.Image = $Image_OptionLinkOff }

  # Zelda64 Pixel Overlap - Create a checkbox.
  $global:CombineZeldaTopLeftCheckBox = New-Object Windows.Forms.CheckBox
  $CombineZeldaTopLeftCheckBox.Size = DPISize (New-Object Drawing.Size(280, 16))
  $CombineZeldaTopLeftCheckBox.Location = DPISize (New-Object Drawing.Point(32, 46))
  $CombineZeldaTopLeftCheckBox.Name = 'UserSpecifyTopLeft'
  $CombineZeldaTopLeftCheckBox.Checked = $UserSpecifyTopLeft
  $CombineZeldaTopLeftCheckBox.Text = ' Allow Selecting "Top-Left" Texture'
  $CombineZeldaTopLeftCheckBox.Enabled = $CombineAutoArrange
  $CombineZeldaTopLeftCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled })
  $CombineZeldaGroupBox.Controls.Add($CombineZeldaTopLeftCheckBox)

  # Zelda64 Pixel Overlap - Create a tooltip.
  $CombineZeldaTopLeftTip = New-Object Windows.Forms.ToolTip
  $CombineZeldaTopLeftTip.InitialDelay = $ToolTipDelay
  $CombineZeldaTopLeftTip.AutoPopDelay = $ToolTipDuration
  $CombineZeldaTopLeftTipString =  'When attempting to auto-arrange textures, sometimes{0}'
  $CombineZeldaTopLeftTipString += 'the left and right sides wrap around. This can force a{0}'
  $CombineZeldaTopLeftTipString += 'top-left to reference when finding the other textures.{0}'
  $CombineZeldaTopLeftTipString += 'Required to auto-arrange Super Mario 64 backgrounds.'
  $CombineZeldaTopLeftTipString = [String]::Format($CombineZeldaTopLeftTipString, [Environment]::NewLine)
  $CombineZeldaTopLeftTip.SetToolTip($CombineZeldaTopLeftCheckBox, $CombineZeldaTopLeftTipString)

  # Zelda64 Pixel Overlap - Create a checkbox.
  $global:CombineZeldaOverlapCheckBox = New-Object Windows.Forms.CheckBox
  $CombineZeldaOverlapCheckBox.Size = DPISize (New-Object Drawing.Size(224, 16))
  $CombineZeldaOverlapCheckBox.Location = DPISize (New-Object Drawing.Point(10, 70))
  $CombineZeldaOverlapCheckBox.Text = ' Simulate Inner Pixel Overlap   ---------->'
  $CombineZeldaOverlapCheckBox.Name = 'CombineOverlapEnable'
  $CombineZeldaOverlapCheckBox.Checked = $CombineOverlapEnable
  $CombineZeldaOverlapCheckBox.Enabled = !$CombinePixelCrop
  $CombineZeldaOverlapCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleCombinePixelOverlap })
  $CombineZeldaGroupBox.Controls.Add($CombineZeldaOverlapCheckBox)

  # Zelda64 Pixel Overlap - Numeric up/down to select the overlap value.
  $global:CombineOverlapNumBox = New-Object Windows.Forms.NumericUpDown
  $CombineOverlapNumBox.Size = DPISize (New-Object Drawing.Size(40, 10))
  $CombineOverlapNumBox.Location = DPISize (New-Object Drawing.Point(244, 69))
  $CombineOverlapNumBox.Name = 'CombineOverlapValue'
  $CombineOverlapNumBox.DecimalPlaces = 0
  $CombineOverlapNumBox.Minimum = 0
  $CombineOverlapNumBox.Maximum = ($SplitCombineLimits / 4)
  $CombineOverlapNumBox.Increment = 1
  $CombineOverlapNumBox.Value = $CombineOverlapValue
  $CombineOverlapNumBox.Enabled = !$CombinePixelCrop
  $CombineOverlapNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineZeldaGroupBox.Controls.Add($CombineOverlapNumBox)

  # Zelda64 Pixel Overlap - Create a tooltip.
  $CombineOverlapTip = New-Object Windows.Forms.ToolTip
  $CombineOverlapTip.InitialDelay = $ToolTipDelay
  $CombineOverlapTip.AutoPopDelay = $ToolTipDuration
  $CombineOverlapTipString =  'The Legend of Zelda: Ocarina of Time and possibly other N64{0}'
  $CombineOverlapTipString += 'VC games may have skybox (and other "box" backgrounds) that{0}'
  $CombineOverlapTipString += 'consist of multiple textures that overlap 1 row and 1 column of{0}'
  $CombineOverlapTipString += 'pixels along the edges where they meet. This option can crop 1{0}'
  $CombineOverlapTipString += 'row and 1 column of overlapping pixels to simulate the way it{0}'
  $CombineOverlapTipString += 'would be seen ingame rather than creating the duplicate pixels{0}'
  $CombineOverlapTipString += 'between the seams which ruins the image. The resulting image{0}'
  $CombineOverlapTipString += 'can now be upscaled/reworked, and options exist in the Split{0}'
  $CombineOverlapTipString += 'Multi-Texture operation to add back the overlapping pixels.'
  $CombineOverlapTipString = [String]::Format($CombineOverlapTipString, [Environment]::NewLine)
  $CombineOverlapTip.SetToolTip($CombineZeldaOverlapCheckBox, $CombineOverlapTipString)

  # Zelda64 Remove Garbage - Create a checkbox.
  $global:CombinePixelCropCheckBox = New-Object Windows.Forms.CheckBox
  $CombinePixelCropCheckBox.Size = DPISize (New-Object Drawing.Size(310, 16))
  $CombinePixelCropCheckBox.Location = DPISize (New-Object Drawing.Point(10, 94))
  $CombinePixelCropCheckBox.Name = 'CombinePixelCrop'
  $CombinePixelCropCheckBox.Checked = $CombinePixelCrop
  $CombinePixelCropCheckBox.Text = ' Remove Garbage Pixel Columns and Rows'
  $CombinePixelCropCheckBox.Enabled = !$CombineOverlapEnable
  $CombinePixelCropCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleCombineGarbageRemoval })
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropCheckBox)

  # Zelda64 Remove Garbage - Create a tooltip.
  $CombinePixelCropTip = New-Object Windows.Forms.ToolTip
  $CombinePixelCropTip.InitialDelay = $ToolTipDelay
  $CombinePixelCropTip.AutoPopDelay = $ToolTipDuration
  $CombinePixelCropTipString =  'The Legend of Zelda: Ocarina of Time and possibly other N64{0}'
  $CombinePixelCropTipString += 'VC games may have background textures that are composed of{0}'
  $CombinePixelCropTipString += '40 textures stacked on top of each other with dimensions that{0}'
  $CombinePixelCropTipString += 'are 324x8 in size. There are 2 rows of garbage pixels along the{0}'
  $CombinePixelCropTipString += 'bottom, and 4 rows of garbage pixels along the right side. This{0}'
  $CombinePixelCropTipString += 'option can remove those garbage pixels before combining the{0}'
  $CombinePixelCropTipString += 'images, resulting in an image that has the proper dimensions{0}'
  $CombinePixelCropTipString += 'of 320x240. This image can be upscaled and reworked, and the{0}'
  $CombinePixelCropTipString += 'options in the Split Multi-Texture section can restore garbage{0}'
  $CombinePixelCropTipString += 'pixels and even add additional garbage if it was upscaled.'
  $CombinePixelCropTipString = [String]::Format($CombinePixelCropTipString, [Environment]::NewLine)
  $CombinePixelCropTip.SetToolTip($CombinePixelCropCheckBox, $CombinePixelCropTipString)

  # Add a numeric up/down to select the new scale.
  $global:CombinePixelCropLNumBox = New-Object Windows.Forms.NumericUpDown
  $CombinePixelCropLNumBox.Size = DPISize (New-Object Drawing.Size(40, 12))
  $CombinePixelCropLNumBox.Location = DPISize (New-Object Drawing.Point(10, 118))
  $CombinePixelCropLNumBox.Name = 'CombinePixelCropL'
  $CombinePixelCropLNumBox.DecimalPlaces = 0
  $CombinePixelCropLNumBox.Minimum = 0
  $CombinePixelCropLNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropLNumBox.Value = $CombinePixelCropL
  $CombinePixelCropLNumBox.Increment = 1
  $CombinePixelCropLNumBox.Enabled = !$CombineOverlapEnable
  $CombinePixelCropLNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropLNumBox)

  # Create a label.
  $global:CombinePixelCropLabelL = New-Object Windows.Forms.Label
  $CombinePixelCropLabelL.Size = DPISize (New-Object Drawing.Size(32, 20))
  $CombinePixelCropLabelL.Location = DPISize (New-Object Drawing.Point(53, 120))
  $CombinePixelCropLabelL.Text = 'Left'
  $CombinePixelCropLabelL.Enabled = !$CombineOverlapEnable
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropLabelL)

  # Add a numeric up/down to select the new scale.
  $global:CombinePixelCropTNumBox = New-Object Windows.Forms.NumericUpDown
  $CombinePixelCropTNumBox.Size = DPISize (New-Object Drawing.Size(40, 12))
  $CombinePixelCropTNumBox.Location = DPISize (New-Object Drawing.Point(88, 118))
  $CombinePixelCropTNumBox.Name = 'CombinePixelCropT'
  $CombinePixelCropTNumBox.DecimalPlaces = 0
  $CombinePixelCropTNumBox.Minimum = 0
  $CombinePixelCropTNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropTNumBox.Value = $CombinePixelCropT
  $CombinePixelCropTNumBox.Increment = 1
  $CombinePixelCropTNumBox.Enabled = !$CombineOverlapEnable
  $CombinePixelCropTNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropTNumBox)

  # Create a label.
  $global:CombinePixelCropLabelT = New-Object Windows.Forms.Label
  $CombinePixelCropLabelT.Size = DPISize (New-Object Drawing.Size(32, 20))
  $CombinePixelCropLabelT.Location = DPISize (New-Object Drawing.Point(131, 120))
  $CombinePixelCropLabelT.Text = 'Top'
  $CombinePixelCropLabelT.Enabled = !$CombineOverlapEnable
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropLabelT)

  # Add a numeric up/down to select the new scale.
  $global:CombinePixelCropBNumBox = New-Object Windows.Forms.NumericUpDown
  $CombinePixelCropBNumBox.Size = DPISize (New-Object Drawing.Size(40, 12))
  $CombinePixelCropBNumBox.Location = DPISize (New-Object Drawing.Point(166, 118))
  $CombinePixelCropBNumBox.Name = 'CombinePixelCropB'
  $CombinePixelCropBNumBox.DecimalPlaces = 0
  $CombinePixelCropBNumBox.Minimum = 0
  $CombinePixelCropBNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropBNumBox.Value = $CombinePixelCropB
  $CombinePixelCropBNumBox.Increment = 1
  $CombinePixelCropBNumBox.Enabled = !$CombineOverlapEnable
  $CombinePixelCropBNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropBNumBox)

  # Create a label.
  $global:CombinePixelCropLabelB = New-Object Windows.Forms.Label
  $CombinePixelCropLabelB.Size = DPISize (New-Object Drawing.Size(32, 20))
  $CombinePixelCropLabelB.Location = DPISize (New-Object Drawing.Point(209, 120))
  $CombinePixelCropLabelB.Text = 'Bot'
  $CombinePixelCropLabelB.Enabled = !$CombineOverlapEnable
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropLabelB)

  # Add a numeric up/down to select the new scale.
  $global:CombinePixelCropRNumBox = New-Object Windows.Forms.NumericUpDown
  $CombinePixelCropRNumBox.Size = DPISize (New-Object Drawing.Size(40, 12))
  $CombinePixelCropRNumBox.Location = DPISize (New-Object Drawing.Point(244, 118))
  $CombinePixelCropRNumBox.Name = 'CombinePixelCropR'
  $CombinePixelCropRNumBox.DecimalPlaces = 0
  $CombinePixelCropRNumBox.Minimum = 0
  $CombinePixelCropRNumBox.Maximum = $SplitCombineLimits
  $CombinePixelCropRNumBox.Value = $CombinePixelCropR
  $CombinePixelCropRNumBox.Increment = 1
  $CombinePixelCropRNumBox.Enabled = !$CombineOverlapEnable
  $CombinePixelCropRNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropRNumBox)

  # Create a label.
  $global:CombinePixelCropLabelR = New-Object Windows.Forms.Label
  $CombinePixelCropLabelR.Size = DPISize (New-Object Drawing.Size(32, 20))
  $CombinePixelCropLabelR.Location = DPISize (New-Object Drawing.Point(287, 120))
  $CombinePixelCropLabelR.Text = 'Right'
  $CombinePixelCropLabelR.Enabled = !$CombineOverlapEnable
  $CombineZeldaGroupBox.Controls.Add($CombinePixelCropLabelR)

  # Create a groupbox to hold all the shit.
  $global:SplitZeldaGroupBox = New-Object Windows.Forms.GroupBox
  $SplitZeldaGroupBox.Size = DPISize (New-Object Drawing.Size(326, 124))
  $SplitZeldaGroupBox.Location = DPISize (New-Object Drawing.Point(10, 204))
  $SplitZeldaGroupBox.Text = 'Split Texture Options'
  $CombineZeldaMainPanel.Controls.Add($SplitZeldaGroupBox)

  # Split Textures - Define boundaries - Create a checkbox.
  $global:SplitBoundariesCheckBox = New-Object Windows.Forms.CheckBox
  $SplitBoundariesCheckBox.Size = DPISize (New-Object Drawing.Size(147, 16))
  $SplitBoundariesCheckBox.Location = DPISize (New-Object Drawing.Point(10, 22))
  $SplitBoundariesCheckBox.Text = ' Define Cell Dimensions: '
  $SplitBoundariesCheckBox.Name = 'SplitDefineBoundary'
  $SplitBoundariesCheckBox.Checked = $SplitDefineBoundary
  $SplitBoundariesCheckBox.Enabled = ((!$SplitOverlapEnable) -and (!$SplitZeldaRestore))
  $SplitBoundariesCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleSplitSegmentsOverlap })
  $SplitZeldaGroupBox.Controls.Add($SplitBoundariesCheckBox)

  # Split Textures - Define boundaries width - Numeric up/down to select the value.
  $global:SplitBoundariesWidthNumBox = New-Object Windows.Forms.NumericUpDown
  $SplitBoundariesWidthNumBox.Size = DPISize (New-Object Drawing.Size(54, 10))
  $SplitBoundariesWidthNumBox.Location = DPISize (New-Object Drawing.Point(162, 21))
  $SplitBoundariesWidthNumBox.Name = 'SplitBoundaryWidth'
  $SplitBoundariesWidthNumBox.DecimalPlaces = 0
  $SplitBoundariesWidthNumBox.Minimum = 0
  $SplitBoundariesWidthNumBox.Maximum = 32768
  $SplitBoundariesWidthNumBox.Increment = 1
  $SplitBoundariesWidthNumBox.Value = $SplitBoundaryWidth
  $SplitBoundariesWidthNumBox.Enabled = ((!$SplitOverlapEnable) -and (!$SplitZeldaRestore))
  $SplitBoundariesWidthNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaGroupBox.Controls.Add($SplitBoundariesWidthNumBox)

  # Split Textures - Define boundaries X label.
  $global:SplitBoundariesXLabel = New-Object Windows.Forms.Label
  $SplitBoundariesXLabel.Size = DPISize (New-Object Drawing.Size(12, 12))
  $SplitBoundariesXLabel.Location = DPISize (New-Object Drawing.Point(218, 23))
  $SplitBoundariesXLabel.Text = 'x'
  $SplitBoundariesXLabel.Enabled = ((!$SplitOverlapEnable) -and (!$SplitZeldaRestore))
  $SplitZeldaGroupBox.Controls.Add($SplitBoundariesXLabel)

  # Split Textures - Define boundaries height - Numeric up/down to select the value.
  $global:SplitBoundariesHeightNumBox = New-Object Windows.Forms.NumericUpDown
  $SplitBoundariesHeightNumBox.Size = DPISize (New-Object Drawing.Size(54, 10))
  $SplitBoundariesHeightNumBox.Location = DPISize (New-Object Drawing.Point(230, 21))
  $SplitBoundariesHeightNumBox.Name = 'SplitBoundaryHeight'
  $SplitBoundariesHeightNumBox.DecimalPlaces = 0
  $SplitBoundariesHeightNumBox.Minimum = 0
  $SplitBoundariesHeightNumBox.Maximum = 32768
  $SplitBoundariesHeightNumBox.Increment = 1
  $SplitBoundariesHeightNumBox.Value = $SplitBoundaryHeight
  $SplitBoundariesHeightNumBox.Enabled = ((!$SplitOverlapEnable) -and (!$SplitZeldaRestore))
  $SplitBoundariesHeightNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaGroupBox.Controls.Add($SplitBoundariesHeightNumBox)

  # Split Textures - Define boundaries - Create a tooltip.
  $SplitBoundariesTip = New-Object Windows.Forms.ToolTip
  $SplitBoundariesTip.InitialDelay = $ToolTipDelay
  $SplitBoundariesTip.AutoPopDelay = $ToolTipDuration
  $SplitBoundariesTipString =  'Not useful for any known N64 games, this was{0}'
  $SplitBoundariesTipString += 'added at the request of modders to be able to{0}'
  $SplitBoundariesTipString += 'split textures in a way where most pieces are{0}'
  $SplitBoundariesTipString += 'squares with a few rectangles along the edges.{0}'
  $SplitBoundariesTipString += 'AKA: non-square environment textures.{0}'
  $SplitBoundariesTipString += '{0}'
  $SplitBoundariesTipString += 'Because this allows modifying the resolution of{0}'
  $SplitBoundariesTipString += 'the segments directly, the values set for the Grid{0}'
  $SplitBoundariesTipString += 'Array are ignored. The number of rows/columns{0}'
  $SplitBoundariesTipString += 'created will be equal to how many segments can{0}'
  $SplitBoundariesTipString += 'be cropped from the image using the resolution{0}'
  $SplitBoundariesTipString += 'that was entered, plus whatever is left over.{0}'
  $SplitBoundariesTipString += '{0}'
  $SplitBoundariesTipString += 'For example, a 256x288 wall texture that will be{0}'
  $SplitBoundariesTipString += 'split up into segments at 64x64, with the smaller{0}'
  $SplitBoundariesTipString += 'pieces along the bottom being 64x32. CTT-PS will{0}'
  $SplitBoundariesTipString += 'try to create as many segments as possible using{0}'
  $SplitBoundariesTipString += 'the entered resolution, and whatever is left over{0}'
  $SplitBoundariesTipString += 'uses the resolution of the remaining pixels.'
  $SplitBoundariesTipString = [String]::Format($SplitBoundariesTipString, [Environment]::NewLine)
  $SplitBoundariesTip.SetToolTip($SplitBoundariesCheckBox, $SplitBoundariesTipString)

  # Zelda64 Split Pixel Overlap - Create a checkbox.
  $global:SplitZeldaOverlapCheckBox = New-Object Windows.Forms.CheckBox
  $SplitZeldaOverlapCheckBox.Size = DPISize (New-Object Drawing.Size(224, 16))
  $SplitZeldaOverlapCheckBox.Location = DPISize (New-Object Drawing.Point(10, 46))
  $SplitZeldaOverlapCheckBox.Text = ' Insert Removed Overlap Pixels  ------->'
  $SplitZeldaOverlapCheckBox.Name = 'SplitOverlapEnable'
  $SplitZeldaOverlapCheckBox.Checked = $SplitOverlapEnable
  $SplitZeldaOverlapCheckBox.Enabled = ((!$SplitDefineBoundary) -and (!$SplitZeldaRestore))
  $SplitZeldaOverlapCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleSplitPixelOverlap })
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaOverlapCheckBox)

  # Zelda64 Split Pixel Overlap - Numeric up/down to select the overlap value.
  $global:SplitOverlapNumBox = New-Object Windows.Forms.NumericUpDown
  $SplitOverlapNumBox.Size = DPISize (New-Object Drawing.Size(40, 10))
  $SplitOverlapNumBox.Location = DPISize (New-Object Drawing.Point(244, 45))
  $SplitOverlapNumBox.Name = 'SplitPixelOverlap'
  $SplitOverlapNumBox.DecimalPlaces = 0
  $SplitOverlapNumBox.Minimum = 0
  $SplitOverlapNumBox.Maximum = $SplitCombineLimits
  $SplitOverlapNumBox.Value = $SplitPixelOverlap
  $SplitOverlapNumBox.Increment = 1
  $SplitOverlapNumBox.Enabled = ((!$SplitDefineBoundary) -and (!$SplitZeldaRestore))
  $SplitOverlapNumBox.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaGroupBox.Controls.Add($SplitOverlapNumBox)

  # Zelda64 Split Pixel Overlap - Create a tooltip.
  $SplitOverlapTip = New-Object Windows.Forms.ToolTip
  $SplitOverlapTip.InitialDelay = $ToolTipDelay
  $SplitOverlapTip.AutoPopDelay = $ToolTipDuration
  $SplitOverlapTipString =  'This option restores overlap pixels that may have been{0}'
  $SplitOverlapTipString += 'removed using the option above. The amount of pixel{0}'
  $SplitOverlapTipString += 'overlap that should added back should be the amount{0}'
  $SplitOverlapTipString += 'that was used when combining multiplied by the factor{0}'
  $SplitOverlapTipString += 'used when upscaling. For example the base image had{0}'
  $SplitOverlapTipString += 'dimensions of 253x249 (4x upscale is 1012x996), and if{0}'
  $SplitOverlapTipString += 'the pixel overlap used was 1, then the value used here{0}'
  $SplitOverlapTipString += 'should be 4 because there are now 4 overlapping rows{0}'
  $SplitOverlapTipString += 'and columns of pixels between textures in-game.'
  $SplitOverlapTipString = [String]::Format($SplitOverlapTipString, [Environment]::NewLine)
  $SplitOverlapTip.SetToolTip($SplitZeldaOverlapCheckBox, $SplitOverlapTipString)

  # Zelda64 Add Garbage - Create a checkbox.
  $global:SplitZeldaResCheckBox = New-Object Windows.Forms.CheckBox
  $SplitZeldaResCheckBox.Size = DPISize (New-Object Drawing.Size(310, 16))
  $SplitZeldaResCheckBox.Location = DPISize (New-Object Drawing.Point(10, 70))
  $SplitZeldaResCheckBox.Name = 'SplitZeldaRestore'
  $SplitZeldaResCheckBox.Checked = $SplitZeldaRestore
  $SplitZeldaResCheckBox.Text = ' Restore Garbage Pixel Columns and Rows'
  $SplitZeldaResCheckBox.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaResCheckBox.Add_CheckStateChanged({ CheckBoxStateToggled ; ToggleSplitGarbageRemoval })
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaResCheckBox)

  # Zelda64 Add Garbage - Create a tooltip.
  $SplitZeldaResTip = New-Object Windows.Forms.ToolTip
  $SplitZeldaResTip.InitialDelay = $ToolTipDelay
  $SplitZeldaResTip.AutoPopDelay = $ToolTipDuration
  $SplitZeldaResTipString =  'This option restores garbage pixels that have been removed{0}'
  $SplitZeldaResTipString += 'when combining. The number of rows and columns of pixels{0}'
  $SplitZeldaResTipString += 'that were used when combining should be multiplied by the{0}'
  $SplitZeldaResTipString += 'upscaling factor used when upscaling the image. If the image{0}'
  $SplitZeldaResTipString += 'was 320x240 when combined, removed 2x bottom rows and{0}'
  $SplitZeldaResTipString += '4x right columns, upscaled to 1280x960, the number of pixels{0}'
  $SplitZeldaResTipString += 'restored should be 8x bottom rows and 16x right columns. It{0}'
  $SplitZeldaResTipString += 'should always be: (upscale factor * remove garbage value).'
  $SplitZeldaResTipString = [String]::Format($SplitZeldaResTipString, [Environment]::NewLine)
  $SplitZeldaResTip.SetToolTip($SplitZeldaResCheckBox, $SplitZeldaResTipString)

  # Add a numeric up/down to select the new scale.
  $global:SplitZeldaRestoreL = New-Object Windows.Forms.NumericUpDown
  $SplitZeldaRestoreL.Size = DPISize (New-Object Drawing.Size(40, 12))
  $SplitZeldaRestoreL.Location = DPISize (New-Object Drawing.Point(10, 92))
  $SplitZeldaRestoreL.Name = 'SplitPixelRestoreL'
  $SplitZeldaRestoreL.DecimalPlaces = 0
  $SplitZeldaRestoreL.Minimum = 0
  $SplitZeldaRestoreL.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreL.Value = $SplitPixelRestoreL
  $SplitZeldaRestoreL.Increment = 1
  $SplitZeldaRestoreL.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaRestoreL.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaRestoreL)

  # Create a label.
  $global:SplitZeldaLabelL = New-Object Windows.Forms.Label
  $SplitZeldaLabelL.Size = DPISize (New-Object Drawing.Size(32, 20))
  $SplitZeldaLabelL.Location = DPISize (New-Object Drawing.Point(53, 94))
  $SplitZeldaLabelL.Text = 'Left'
  $SplitZeldaLabelL.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaLabelL)

  # Add a numeric up/down to select the new scale.
  $global:SplitZeldaRestoreT = New-Object Windows.Forms.NumericUpDown
  $SplitZeldaRestoreT.Size = DPISize (New-Object Drawing.Size(40, 12))
  $SplitZeldaRestoreT.Location = DPISize (New-Object Drawing.Point(88, 92))
  $SplitZeldaRestoreT.Name = 'SplitPixelRestoreT'
  $SplitZeldaRestoreT.DecimalPlaces = 0
  $SplitZeldaRestoreT.Minimum = 0
  $SplitZeldaRestoreT.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreT.Value = $SplitPixelRestoreT
  $SplitZeldaRestoreT.Increment = 1
  $SplitZeldaRestoreT.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaRestoreT.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaRestoreT)

  # Create a label.
  $global:SplitZeldaLabelT = New-Object Windows.Forms.Label
  $SplitZeldaLabelT.Size = DPISize (New-Object Drawing.Size(32, 20))
  $SplitZeldaLabelT.Location = DPISize (New-Object Drawing.Point(131, 94))
  $SplitZeldaLabelT.Text = 'Top'
  $SplitZeldaLabelT.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaLabelT)

  # Add a numeric up/down to select the new scale.
  $global:SplitZeldaRestoreB = New-Object Windows.Forms.NumericUpDown
  $SplitZeldaRestoreB.Size = DPISize (New-Object Drawing.Size(40, 12))
  $SplitZeldaRestoreB.Location = DPISize (New-Object Drawing.Point(166, 92))
  $SplitZeldaRestoreB.Name = 'SplitPixelRestoreB'
  $SplitZeldaRestoreB.DecimalPlaces = 0
  $SplitZeldaRestoreB.Minimum = 0
  $SplitZeldaRestoreB.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreB.Value = $SplitPixelRestoreB
  $SplitZeldaRestoreB.Increment = 1
  $SplitZeldaRestoreB.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaRestoreB.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaRestoreB)

  # Create a label.
  $global:SplitZeldaLabelB = New-Object Windows.Forms.Label
  $SplitZeldaLabelB.Size = DPISize (New-Object Drawing.Size(32, 20))
  $SplitZeldaLabelB.Location = DPISize (New-Object Drawing.Point(209, 94))
  $SplitZeldaLabelB.Text = 'Bot'
  $SplitZeldaLabelB.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaLabelB)

  # Add a numeric up/down to select the new scale.
  $global:SplitZeldaRestoreR = New-Object Windows.Forms.NumericUpDown
  $SplitZeldaRestoreR.Size = DPISize (New-Object Drawing.Size(40, 12))
  $SplitZeldaRestoreR.Location = DPISize (New-Object Drawing.Point(244, 92))
  $SplitZeldaRestoreR.Name = 'SplitPixelRestoreR'
  $SplitZeldaRestoreR.DecimalPlaces = 0
  $SplitZeldaRestoreR.Minimum = 0
  $SplitZeldaRestoreR.Maximum = $SplitCombineLimits
  $SplitZeldaRestoreR.Value = $SplitPixelRestoreR
  $SplitZeldaRestoreR.Increment = 1
  $SplitZeldaRestoreR.Add_ValueChanged({ NumericUpDownModified -TypeDefinition 'integer' })
  $SplitZeldaRestoreR.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaRestoreR)

  # Create a label.
  $global:SplitZeldaLabelR = New-Object Windows.Forms.Label
  $SplitZeldaLabelR.Size = DPISize (New-Object Drawing.Size(34, 20))
  $SplitZeldaLabelR.Location = DPISize (New-Object Drawing.Point(287, 94))
  $SplitZeldaLabelR.Text = 'Right'
  $SplitZeldaLabelR.Enabled = ((!$SplitDefineBoundary) -and (!$SplitOverlapEnable))
  $SplitZeldaGroupBox.Controls.Add($SplitZeldaLabelR)

  # Create a panel to hold the help window.
  $global:ZeldaHelpPanel = New-Object Windows.Forms.Panel
  $ZeldaHelpPanel.Size = DPISize (New-Object Drawing.Size(326, 100))
  $ZeldaHelpPanel.Location = DPISize (New-Object Drawing.Point(10, 334))
  $ZeldaHelpPanel.BackColor = [Drawing.ColorTranslator]::FromHtml('#CCCCCC')
  $ZeldaHelpPanel.Visible = $false
  $CombineZeldaMainPanel.Controls.Add($ZeldaHelpPanel)

  # Create help text to explain the options.
  $ZeldaHelpBoxString = 'These options were designed for The Legend of Zelda: Ocarina of Time custom textures using Dolphin emulator. There are two main types of backgrounds made up of '
  $ZeldaHelpBoxString += 'overlapping tiles:{0}'
  $ZeldaHelpBoxString += '{0}'
  $ZeldaHelpBoxString += 'Type 1: 32 Tiles - 64x32 - 4 Cols x 8 Rows{0}'
  $ZeldaHelpBoxString += 'Type 2: 40 Tiles - 324x8 - 1 Cols x 40 Rows{0}'
  $ZeldaHelpBoxString += '{0}'
  $ZeldaHelpBoxString += 'Type 1: Skybox, Market, Houses{0}'
  $ZeldaHelpBoxString += 'The 64x32 tiles have a single row of duplicate pixels between the textures where the seams meet. In-game, these duplicate pixels overlap each other. When combined, '
  $ZeldaHelpBoxString += 'these duplicate pixels must be removed. This is where it is useful to simulate the inner pixel overlap when combining. The final result when combined when setting '
  $ZeldaHelpBoxString += 'the inner pixel overlap to "1", will yield dimensions of 253x249, not the expected 256x256.{0}'
  $ZeldaHelpBoxString += '{0}'
  $ZeldaHelpBoxString += 'The newly combined image can be upscaled, the value 4x will be used for upscale factor in examples. Upscaling the 253x249 by 4x gives an image size of 1012x996. '
  $ZeldaHelpBoxString += 'This can now be used to create new tiles. Since the upscale is 4x, the number of overlapping pixels is also now 4x. So when splitting the new texture, the insert '
  $ZeldaHelpBoxString += 'pixel overlap value should be 4 so the tiles will be seamless in-game. Pixels will be duplicated from each next/previous texture in the grid, resulting in 32 tiles '
  $ZeldaHelpBoxString += 'with dimensions that are the expected 256x128 and will be seamless in-game.{0}'
  $ZeldaHelpBoxString += '{0}'
  $ZeldaHelpBoxString += 'Type 2: Static Backgrounds{0}'
  $ZeldaHelpBoxString += 'The 324x8 tiles have 2 rows of garbage pixels at the bottom of the texture, and 4 columns of garbage pixels on the right. This is unique to Dolphin, as N64 '
  $ZeldaHelpBoxString += 'emulators dump these textures properly at 320x6. With that said, garbage needs to be removed before combined, to create an image of 320x240. In this example, we '
  $ZeldaHelpBoxString += 'enable the option to remove 2 bottom rows and 4 right columns of garbage and combine the texture. An upscaled version of the image of 4x will have dimensions of '
  $ZeldaHelpBoxString += '1280x960.{0}'
  $ZeldaHelpBoxString += '{0}'
  $ZeldaHelpBoxString += 'Dolphin expects the garbage pixels, so when splitting the image it needs to be added back in. This script stretches the corresponding column/row into the garbage '
  $ZeldaHelpBoxString += 'area so textures remain seamless at any Internal Resolution. Since the texture was increased by 4x, that much more garbage is needed. So where 2 bottom rows and '
  $ZeldaHelpBoxString += '4 right columns had garbage removed, 8 bottom rows and 16 right columns of garbage must be added. With the proper settings, the 40x tiles should have dimensions '
  $ZeldaHelpBoxString += 'that are 1296x32 when the image is split.{0}'
  $ZeldaHelpBoxString += '{0}'
  $ZeldaHelpBoxString += 'Last word of advice, CTT files are helpful! When combining a texture, a CTT file is created. When the combined texture is upscaled/reworked, the CTT file can be '
  $ZeldaHelpBoxString += 'loaded, and all the proper overlap/garbage values will be automatically calculated! This can save a lot of the headache!'

  # Create a help window since these options are confusing as fuck.
  $global:ZeldaHelpBox = New-Object Windows.Forms.RichTextBox
  $ZeldaHelpBox.Size = New-Object Drawing.Size(($ZeldaHelpPanel.Size.Width - 2), ($ZeldaHelpPanel.Size.Height - 2))
  $ZeldaHelpBox.Location = New-Object Drawing.Point(1, 1)
  $ZeldaHelpBox.Font = New-Object Drawing.Font("Consolas", 8)
  $ZeldaHelpBox.Text = [String]::Format($ZeldaHelpBoxString, [Environment]::NewLine)
  $ZeldaHelpBox.ReadOnly = $true
  $ZeldaHelpBox.BackColor = [Drawing.ColorTranslator]::FromHtml('#FFFFFF')
  $ZeldaHelpBox.BorderStyle = [Windows.Forms.BorderStyle]::None
  $ZeldaHelpPanel.Controls.Add($ZeldaHelpBox)

  # Create a button to toggle the help window.
  $global:ZeldaHelpButton = New-Object Windows.Forms.Button
  $ZeldaHelpButton.Size = DPISize (New-Object Drawing.Size(28, 28))
  $ZeldaHelpButton.Location = DPISize (New-Object Drawing.Point(224, 338))
  $ZeldaHelpButton.Text = '?'
  $ZeldaHelpButton.Add_Click({ ZeldaOptionsToggleHelp -ResetWindow $ZeldaHelpPanel.Visible })
  $CombineZeldaMainPanel.Controls.Add($ZeldaHelpButton)
  
  # Create a button to close the window.
  $global:ZeldaOkayButton = New-Object Windows.Forms.Button
  $ZeldaOkayButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ZeldaOkayButton.Location = DPISize (New-Object Drawing.Point(257, 338))
  $ZeldaOkayButton.Text = 'Close'
  $ZeldaOkayButton.Add_Click({ $CombineZeldaDialog.Hide() })
  $CombineZeldaMainPanel.Controls.Add($ZeldaOkayButton)
  $CombineZeldaDialog.AcceptButton = $ZeldaOkayButton
}
#==============================================================================================================================================================================================
#  CTT GUI: COMBINE MULTIPLE TEXTURES - MULTIPLE SEGMENT MATCHES
#==============================================================================================================================================================================================
#  Shows the multiple segment matches dialog to show options to pick the matching segment.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowAutoArrangeMultipleChoices([string[]]$MatchList)
{
  # Clear all items from the listbox.
  $AutoArrangeListBox.Items.Clear()
  $AutoArrangeTextBox.Text = ''

  # Loop through all matching textures. Add the textures to the listbox.
  foreach ($Match in $MatchList) { $AutoArrangeListBox.Items.Add($Match) | Out-Null }

  # By default select the first choice.
  $AutoArrangeListBox.SelectedIndex = 0

  # Set the last texture in the arranged list to compare.
  $LastInList = $ArrangedList[$ArrangedList.Count - 1]

  # Create the image to add to the button.
  $ImgObject = [Drawing.Image]::FromFile($LastInList)
  $ImgBitmap = New-Object Drawing.Bitmap($ImgObject, (DPISize 100), (DPISize 100))
  $ImgObject.Dispose()

  # Add the image to the button.
  $AutoArrangePreviousImage.Image = $ImgBitmap

  # Loop through all matching textures. Add the textures to the listbox.
  foreach ($Arrange in $ArrangedList) { $AutoArrangeTextBox.AppendText($Arrange + [Environment]::NewLine) | Out-Null }

  # Show the dialog.
  $CombineAADialog.ShowDialog() | Out-Null
}
#==============================================================================================================================================================================================
#  Sets the image on the auto-arrange image selection window.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function UpdateAutoArrangeSelectedImage()
{
  # Get the image that was selected.
  $SelectedImage = $this.SelectedItem

  # SETUP: Create the image to add to the button.
  $ImgObject = [Drawing.Image]::FromFile($SelectedImage)
  $ImgBitmap = New-Object Drawing.Bitmap($ImgObject, (DPISize 100), (DPISize 100))
  $ImgObject.Dispose()

  # SETUP: Add the image to the button.
  $AutoArrangeSelectedImage.Image = $ImgBitmap
}
#==============================================================================================================================================================================================
#  Create the window for the combine textures auto-arrange segment selection.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_AutoArrangeChoices()
{
  # Create the dialog and set up properties.
  $global:CombineAADialog = New-Object Windows.Forms.Form
  $CombineAADialog.Size = DPISize (New-Object Drawing.Size(700, 452))
  $CombineAADialog.MinimumSize = DPISize (New-Object Drawing.Size(700, 452))
  $CombineAADialog.MaximumSize = DPISize (New-Object Drawing.Size(700, 452))
  $CombineAADialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8)
  $CombineAADialog.Text = 'Choose Matching Texture'
  $CombineAADialog.MaximizeBox = $false
  $CombineAADialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $CombineAADialog.FormBorderStyle = GetFormBorderStyle
  $CombineAADialog.StartPosition = "CenterScreen"
  $CombineAADialog.Topmost = !$DisableTopMost
  $CombineAADialog.KeyPreview = $true
  $CombineAADialog.Add_FormClosing({ $CombineAADialog.Hide() ; $_.Cancel = $true })
  $CombineAADialog.Icon = $Icon_CTTPSGreen

  # Create a panel to hold all the shit.
  $global:AutoArrangePanel = New-Object Windows.Forms.Panel
  $AutoArrangePanel.Size = DPISize (New-Object Drawing.Size(700, 452))
  $AutoArrangePanel.Location = DPISize (New-Object Drawing.Point(0, 0))
  $CombineAADialog.Controls.Add($AutoArrangePanel)

  # Create a label for the textbox.
  $global:AutoArrangeListLabel = New-Object Windows.Forms.Label
  $AutoArrangeListLabel.Size = DPISize (New-Object Drawing.Size(450, 14))
  $AutoArrangeListLabel.Location = New-Object Drawing.Point((DPISize 10), (DPISize 8 -Round))
  $AutoArrangeListLabel.Text = 'The previous image has multiple matches along the duplicate pixel boudaries:'
  $AutoArrangePanel.Controls.Add($AutoArrangeListLabel)

  # Create a listbox to hold the duplicate matches.
  $global:AutoArrangeListBox = New-Object System.Windows.Forms.ListBox
  $AutoArrangeListBox.Size = DPISize (New-Object System.Drawing.Size(664, 70))
  $AutoArrangeListBox.Location = New-Object System.Drawing.Size((DPISize 10), (DPISize 26 -Round))
  $AutoArrangeListBox.Add_SelectedIndexChanged({ UpdateAutoArrangeSelectedImage })
  $AutoArrangePanel.Controls.Add($AutoArrangeListBox)

  # Create a label for the textbox.
  $global:AutoArrangePreviousLabel = New-Object Windows.Forms.Label
  $AutoArrangePreviousLabel.Size = DPISize (New-Object Drawing.Size(100, 14))
  $AutoArrangePreviousLabel.Location = DPISize (New-Object Drawing.Point(38, 100))
  $AutoArrangePreviousLabel.Text = 'Previous Image:'
  $AutoArrangePanel.Controls.Add($AutoArrangePreviousLabel)

  # Create a picturebox to hold the image.
  $global:AutoArrangePreviousImage = New-Object Windows.Forms.PictureBox
  $AutoArrangePreviousImage.Size = DPISize (New-Object Drawing.Size(100, 100))
  $AutoArrangePreviousImage.Location = DPISize (New-Object Drawing.Point(30, 118))
  $AutoArrangePanel.Controls.Add($AutoArrangePreviousImage)

  # Create an arrow to point to the next image.
  $global:AutoArrangeCompareLabel = New-Object Windows.Forms.Label
  $AutoArrangeCompareLabel.Size = DPISize (New-Object Drawing.Size(30, 40))
  $AutoArrangeCompareLabel.Location = DPISize (New-Object Drawing.Point(142, 148))
  $AutoArrangeCompareLabel.Font = New-Object Drawing.Font('Courier New', 30, [Drawing.FontStyle]::Bold)
  $AutoArrangeCompareLabel.Text = '>'
  $AutoArrangePanel.Controls.Add($AutoArrangeCompareLabel)

  # Create a label for the textbox.
  $global:AutoArrangeSelectedLabel = New-Object Windows.Forms.Label
  $AutoArrangeSelectedLabel.Size = DPISize (New-Object Drawing.Size(100, 14))
  $AutoArrangeSelectedLabel.Location = DPISize (New-Object Drawing.Point(208, 100))
  $AutoArrangeSelectedLabel.Text = 'Next Image:'
  $AutoArrangePanel.Controls.Add($AutoArrangeSelectedLabel)

  # Create a picturebox to hold the image.
  $global:AutoArrangeSelectedImage = New-Object Windows.Forms.PictureBox
  $AutoArrangeSelectedImage.Size = DPISize (New-Object Drawing.Size(100, 100))
  $AutoArrangeSelectedImage.Location = DPISize (New-Object Drawing.Point(190, 118))
  $AutoArrangePanel.Controls.Add($AutoArrangeSelectedImage)

  # Create a label for the textbox.
  $global:AutoArrangeTextBoxLabel = New-Object Windows.Forms.Label
  $AutoArrangeTextBoxLabel.Size = DPISize (New-Object Drawing.Size(450, 14))
  $AutoArrangeTextBoxLabel.Location = New-Object Drawing.Point((DPISize 10), (DPISize 228 -Round))
  $AutoArrangeTextBoxLabel.Text = 'This lists the consecutive textures that have been found so far:'
  $AutoArrangePanel.Controls.Add($AutoArrangeTextBoxLabel)

  # Create a list of all texture that were found so far.
  $global:AutoArrangeTextBox = New-Object Windows.Forms.RichTextBox
  $AutoArrangeTextBox.Size = DPISize (New-Object Drawing.Size(664, 120))
  $AutoArrangeTextBox.Location = New-Object Drawing.Point((DPISize 10), (DPISize 246 -Round))
  $AutoArrangeTextBox.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8)
  $AutoArrangeTextBox.Text = ''
  $AutoArrangeTextBox.TabStop = $false
  $AutoArrangeTextBox.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $AutoArrangePanel.Controls.Add($AutoArrangeTextBox)

  # Create a button to close the window.
  $global:AutoArrangeButton = New-Object Windows.Forms.Button
  $AutoArrangeButton.Size = DPISize (New-Object Drawing.Size(80, 30))
  $AutoArrangeButton.Location = DPISize (New-Object Drawing.Point(595, 374))
  $AutoArrangeButton.Text = 'Choose'
  $AutoArrangeButton.Add_Click({ $CombineAADialog.Hide() })
  $AutoArrangePanel.Controls.Add($AutoArrangeButton)
  $CombineAADialog.AcceptButton = $AutoArrangeButton
}
#==============================================================================================================================================================================================
#  CTT GUI - HELP DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $HelpDialog             - Form          - Global
#  $HelpTopicsLabel        - Label         - Local
#  $HelpTopics             - TreeView      - Local
#  $HelpDescriptionLabel   - Label         - Local
#  $HelpDescription        - RichTextBox   - Global
#  $HelpZoomInButton       - Button        - Local
#  $HelpZoomOutButton      - Button        - Local
#  $HelpResetZoomButton    - Button        - Local
#  $HelpCloseButton        - Button        - Local
#==============================================================================================================================================================================================
#  CTT GUI: HELP DIALOG TOPICS
#==============================================================================================================================================================================================
#  Takes an array of strings found in the help textbox and applies a bold faced font to them from a font array.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetStringFont([string[]]$FindString, [Drawing.Font[]]$Font)
{
  # If I messed up somewhere and they are uneven, then use the array with the smallest count.
  $MaxLoops = [Math]::Min($FindString.Count, $Font.Count)

  # Loop through the arrays. Both should be of equal size.
  for ($i=0 ; $i -lt $FindString.Count ; $i++)
  {
    # Find the matching string and apply the font.
    $HelpDescription.Find($FindString[$i])
    $HelpDescription.SelectionFont = $Font[$i]
  }
}
#==============================================================================================================================================================================================
#  Displays the selected help topic in the help textbox.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GUI_DisplayHelpTopic()
{
  # Convert the object into a string.
  $Topic = $this.SelectedNode.ToString().Replace('TreeNode: ','')

  # Reset all formatting before displaying the new description.
  $HelpDescription.SelectionStart = 0
  $HelpDescription.ScrollToCaret()
  $HelpDescription.SelectAll()

  # Adjust the height depending on the DPI.
  $HelpDescription.SelectionFont = New-Object Drawing.Font('Tahoma', 10)
  $FontSize10 = New-Object Drawing.Font('Tahoma', 10, [Drawing.FontStyle]::Bold)
  $FontSize11 = New-Object Drawing.Font('Tahoma', 11, [Drawing.FontStyle]::Bold)
  $FontSize12 = New-Object Drawing.Font('Tahoma', 12, [Drawing.FontStyle]::Bold)
  $FontSize13 = New-Object Drawing.Font('Tahoma', 13, [Drawing.FontStyle]::Bold)

  # This rewrite is going to take an eternity. I can feel it in my bones.
  switch -Wildcard ($Topic)
  {
    # A brief introduction to the script.
    'Introduction'    {
                        # Assemble the string.
                        $Text = ($ScriptName + "{0}") +
                                "By Bighead{0}" +
                                "{0}" +
                                "This is a PowerShell script for Windows with a GUI that makes use of the command line options of several external programs, that can perform a variety of functions for " +
                                "custom textures. It can be used to convert textures between PNG and DDS, and supports a wide range of DDS formats: BC1-BC7, RGBA, ARGB, L8, A8, and LA8. Other supported " +
                                "image formats are TIF/TIFF, TGA, and JPG for niche situations. The script automatically handles mipmaps which can be manipulated or disabled, it will auto-repair many " +
                                "issues found in DDS headers, and can seamlessly rescale textures and apply advanced upscale filters.{0}" +
                                "{0}" +
                                "This texture tool was designed for Dolphin emulator texture packs, so many of the core features revolve around Dolphin. Over time it has become powerful enough to manage " +
                                'many types of texture packs, and can also convert/create "phyre" textures from The Legend of Heroes: Trails of Cold Steel series and Final Fantasy X/X2 HD remaster. The tool ' +
                                "has a built-in help menu (which you are viewing now) that covers everything it can do in detail.{0}" +
                                "{0}" +
                                "If there are any questions, concerns, bug reports, feel free to drop a post on the Dolphin thread.{0}" +
                                $Link_CTTPS +
                                "{0}" +
                                "I can also be contacted via my email address at:{0}" +
                                "bighead.0@gmail{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @($ScriptName, "By Bighead", "bighead.0@gmail") -Font @($FontSize13, $FontSize11, $FontSize10)
                      }
    # A collection of random but useful tips.
    'Requirements'    {
                        # Assemble the string.
                        $Text = "Requirements{0}" +
                                "{0}" +
                                "Minimum:{0}" +
                                "{0}" +
                                "- Windows 7/8/10 x64{0}" +
                                "- PowerShell v3+{0}" +
                                "- ImageMagick v7+{0}" +
                                "- Microsoft .NET Framework v3.5+{0}" +
                                "{0}" +
                                "* Windows 8 comes with .NET Framework v3.5 and PowerShell v3.0 already installed. Windows 10 comes with PowerShell v5.0. Windows 7 users will need to download the update " +
                                "for Windows Management Framework below which will install PowerShell v5.0. Windows 8 users can also install it if they wish.{0}" +
                                "{0}" +
                                "Windows Management Framework v5.1{0}" +
                                "{0}" +
                                "https://www.microsoft.com/en-us/download/details.aspx?id=54616{0}" +
                                "{0}" +
                                "Windows Management Framework 5.1 includes updates to Windows PowerShell, Windows PowerShell Desired State Configuration (DSC), Windows Remote Management (WinRM), Windows Management Instrumentation (WMI).{0}"
                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Requirements","Minimum:","Windows Management Framework v5.1") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # A short list of the features.
    'Features'        {
                        # Assemble the string.
                        $Text = "Features{0}" +
                                "{0}" +
                                "Some of the most prominent features include:{0}" +
                                "{0}" +
                                "- Generate Dolphin Resource Packs.{0}" +
                                "- Supports PNG, DDS, JPG, TIF/TIFF, and TGA image formats.{0}" +
                                "- Rescale all textures at a fixed integer scale.{0}" +
                                "- DDS can be created with DXT1, DXT5, BC7, or uncompressed ARGB8.{0}" +
                                "- Check textures for a variety of issues (scaling factors, aspect ratios, etc.).{0}" +
                                "- Copy textures identified with issues to a folder for manual fixing.{0}" +
                                "- Auto-repair most textures that are identified with issues.{0}" +
                                "- Missing mipmaps are automatically generated when repairing/converting.{0}" +
                                "- Custom mipmaps can be provided or the script can be forced to generate new ones.{0}" +
                                "- The type of DDS mipmaps generated (internal/external) can be configured.{0}" +
                                "- Create material maps from color, bump, spec, nrm, and lum textures (required Ishiiruka Tool).{0}" +
                                "- Rescale/Convert already combined material maps (the generated nrm texture).{0}" +
                                "- Existing material maps and/or materials are automatically handled when found.{0}" +
                                '- Optimize PNG file sizes using OptiPNG. Can be written "in-place" or optionally output files to a folder.{0}' +
                                "- Apply various upscaling filters to all textures including xBRZ and Waifu2x.{0}" +
                                "- And much much more!{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Features") -Font @($FontSize13)
                      }
    # A collection of random but useful tips.
    'Information'     {
                        # Assemble the string.
                        $Text = "Information{0}" +
                                "{0}" +
                                "This section is a collection of random but useful information.{0}" +
                                "{0}" +
                                "- ALWAYS BACKUP YOUR TEXTURE PACK. This script should be 100% safe, but I will not be held responsible for any issues that may occur.{0}" + 
                                "- This script can not be in a base path that contains an apostrophe or the ~ symbol or it will not work! Sub-folders may contain an apostrophe, however.{0}" + 
                                "- It is possible to force the script to skip a file or folder and all of its containing sub-folders by placing a ~ character in the file or folder name.{0}" + 
                                "- This script is compatible with PNG and DDS packs, but it is suggested to resolve all issues with PNG textures before converting to other formats.{0}" + 
                                "- ImageMagick installation path is pulled from the registry when the script is launched. Manually changing this path removes this functionality.{0}" + 
                                "- The script will generate missing mipmaps from the last provided mipmap in a chain of mipmaps. It can also be forced to generate missing mipmaps from the top level.{0}" + 
                                "- JPG is supported by this script, but is no longer supported by Dolphin. JPG does not support transparency, so textures with alpha will not be created as JPEG.{0}" + 
                                "- Ishiiruka material maps are exclusive to Ishiiruka and do not work in anything else, including the master branch of Dolphin and all image editors.{0}" + 
                                "- If the script finds a DDS Ishiiruka color texture with a missing material map, the header will be 'repaired' to a compatible DDS format.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Information") -Font @($FontSize13)
                      }
    # Helps users quickly set up the script to a working state.
    'Quick Guide'     {
                        # Assemble the string.
                        $Text = "Quick Guide{0}" +
                                "{0}" +
                                "This section quickly explains which programs are needed to unlock all features without having to read anything else. The paths to these programs can be set in the Options " +
                                "menu by pressing the Configure Paths button. Detailed descriptions of these programs can be found in the 'Requirements' section of this help document.{0}" +
                                '{0}' +
                                "Step 0: Programs Pack{0}" +
                                "{0}" +
                                "If you want to unlock all features with little configuration, download the Programs Pack and install it:{0}" +
                                "{0}" +
                                "Mirror 01: " + $Link_CTTPSA + "{0}" +
                                "Mirror 02: " + $Link_CTTPSB + "{0}" +
                                "Mirror 03: " + $Link_CTTPSC + "{0}" +
                                "{0}" +
                                "After installing, simply check the box under Tools Master Path in the Options/Paths menu and all paths will be automatically filled out. You can now skip all the other steps.{0}" +
                                "{0}" +
                                "Step 1: Required Programs{0}" +
                                "{0}" +
                                "Before doing anything, ImageMagick v7 should be installed as v6 is no longer supported.{0}" +
                                "{0}" +
                                "ImageMagick: This program is used in almost every option of this script.{0}" +
                                $Link_Magick + "{0}" +
                                "{0}" +
                                "Step 2: Optional Programs{0}" +
                                "{0}" +
                                "At this point almost everything the script can do will work except a few special features. These features do require tools that must be configured in the options menu by " +
                                'pressing the "Configure Paths" button found on the "Options" menu.{0}' +
                                "{0}" +
                                "DirectXTex TexConv: Can create any type of DDS texture. Required to create BC7.{0}" +
                                $Link_TexConv + "{0}" +
                                "{0}" +
                                "Compressonator: Can create higher quality DDS textures than TexConv.{0}" +
                                $Link_Compress + "{0}" +
                                "{0}" +
                                "Material Map Generator: Generates material textures from color textures that can be sent to Ishiiruka Tool.{0}" +
                                $Link_MatMapGen + "{0}" +
                                "{0}" +
                                "Ishiiruka Tool: Required to create and work with Ishiiruka material map textures.{0}" +
                                $Link_Ishiiruka + "{0}" +
                                "{0}" +
                                "OptiPNG/OxiPNG/Pingo/ECT: Can reduce PNG file size.{0}" +
                                $Link_OptiPNG + "{0}" +
                                $Link_OxiPNG + "{0}" +
                                $Link_Pingo + "{0}" +
                                $Link_ECT + "{0}" +
                                "{0}" +
                                "xBRZ ScalerTest: Upscales textures with xBRZ filter.{0}" +
                                $Link_xBRZ + "{0}" +
                                "{0}" +
                                "Waifu2x: Upscales textures with waifu2x filter.{0}" +
                                $Link_W2x_Caffe + " - Best with Nvidia GPU{0}" +
                                $Link_W2x_CPP + " - Best with AMD GPU{0}" +
                                "{0}" +
                                "7-Zip: Required to create Dolphin Resource Packs.{0}" +
                                $Link_SevZip + "{0}" +
                                "{0}" +
                                'Python/ESRGAN/SFTGAN: Use the automatic setup in the "Options" menu.{0}' +
                                "{0}" +
                                "Step 3: Done" +
                                "{0}{0}" +
                                "If all tools are installed, and all the paths to these tools are set, then all options of the script will be fully functional. I do suggest taking the time to read some of " +
                                "the other help topics as well, especially the 'Guides' section which goes into detail of how to perform some basic operations such as creating DDS packs or rescaling textures " +
                                "to have smaller dimensions to save on VRAM.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Quick Guide","Options","Configure Paths","Step 0: Programs Pack","Tools Master Path","Step 1: Required Programs","ImageMagick:","DirectXTex TexConv:","Step 2: Optional Programs",
                                  "Compressonator:","Material Map Generator:","Ishiiruka Tool:","OptiPNG/OxiPNG/Pingo/ECT:","xBRZ ScalerTest:","Waifu2x:","7-Zip:","Python/ESRGAN/SFTGAN:","Step 3: Done")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize11,$FontSize10,$FontSize11,$FontSize10,$FontSize10,$FontSize11,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,
                                  $FontSize10,$FontSize10,$FontSize11)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # A collection of random but useful tips.
    'Supported Prog*' {
                        # Assemble the string.
                        $Text = "Required Program:{0}" +
                                "{0}" +
                                "ImageMagick - Version 7+ is required. The script will not function without it.{0}" +
                                "{0}" +
                                "Supported Programs:{0}" +
                                "{0}" +
                                "DirectXTex TexConv - Creates textures in just about any possible format.{0}" +
                                "Compressonator - Alternative program to create higher quality DDS textures.{0}" +
                                "Material Map Generator - Python scripts that can generate bump/spec/nrm materials.{0}" +
                                "Ishiiruka Tool - Creates materials from bump/spec/lum/nrm or existing materials.{0}" +
                                "OptiPNG/OxiPNG/Pingo/ECT - Attempts to reduce the file size of PNG textures.{0}" +
                                "xBRZ ScalerTest - Allows upscaling textures with the xBRZ filter up to 6x.{0}" +
                                "Waifu2x Caffe/CPP - Allows upscaling textures with the waifu2x filter up to 8x.{0}" +
                                "7-Zip - This is used to create and manage Dolphin Resource Packs.{0}" +
                                "Python v3.9.x - Required to use ESRGAN and SFTGAN upscaling filters.{0}" +
                                "ESRGAN/SFTGAN - Pair of super scaler algorithms to upscale textures.{0}" +
                                "{0}" +
                                "All DDS Generating programs are used as fallback paths if one fails in the order of: Selected Program > Compressonator > TexConv > ImageMagick.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Required Program:","ImageMagick","Supported Programs:","DirectXTex TexConv","Compressonator","7-Zip","Ishiiruka Tool","Material Map Generator","OptiPNG/OxiPNG/Pingo/ECT",
                                  "xBRZ ScalerTest","Waifu2x Caffe/CPP", "Python v3.9.x","ESRGAN/SFTGAN")
                        $Font = @($FontSize13,$FontSize10,$FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # "ImagemMagick" description page.
    'ImageMagick'     {
                        # Assemble the string.
                        $Text = "ImageMagick v7 by ImageMagick Studio LLC{0}" +
                                "{0}" +
                                $Link_Magick + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "ImageMagick(r) is a software suite to create, edit, compose, or convert bitmap images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, " +
                                "JPEG-2000, GIF, TIFF, DPX, EXR, WebP, Postscript, PDF, and SVG. Use ImageMagick to resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, " +
                                "apply various special effects, or draw text, lines, polygons, ellipses and Bezier curves.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "This is the program that makes this script possible. It supports command line processing and many features that other image processing programs lack. Custom Texture Tool PS " +
                                "makes use of it's ability to read data from and write PNG/JPG/DDS images. It is used for some of the lower tier upscaling filters such as 'Point' (Nearest Neighbor). The Seamless " +
                                "Method when applying any upscaling filter and combining multiple textures is also made possible using ImageMagick's 'montage' ability. Applying watermarks to textures using the name " +
                                "is made possible using the 'paint' and 'composite' abilities. This doesn't even begin to fully cover its usage.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("ImageMagick","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "DirectXTex TexConv" description page.
    'DirectXTex*'     {
                        # Assemble the string.
                        $Text = "DirectXTex TexConv by Microsoft{0}" +
                                "{0}" +
                                $Link_TexConv + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "This DirectXTex sample is an implementation of the texconv command-line texture utility from the legacy DirectX SDK utilizing DirectXTex rather than D3DX. This tool loads an " +
                                "image and prepares it for runtime use by resizing, format conversion, mip-map generation, block-compression, and writes the result in a file format suited for runtime use. It " +
                                "can also be used for other image-to-image processing.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "DirectXTex TexConv is capable of creating DDS textures with any type of block compression. It is required by this script to create BC7 textures. While Compressonator can also " +
                                "BC7 textures, it is not nearly as advanced as TexConv and randomly fails to create some textures. TexConv is powerful in that it can also convert BC7 textures to other " +
                                "formats, which no other command line based program seems to offer.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("DirectXTex TexConv","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "Compressonator" description page.
    'Compressonator'  {
                        # Assemble the string.
                        $Text = "Compressonator by AMD{0}" +
                                "{0}" +
                                $Link_Compress + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Compressonator is a set of tools to allow artists and developers to more easily create compressed texture image assets and easily visualize the quality impact of various " +
                                "compression technologies. It consists of a GUI application, a command line application and an SDK for easy integration into a developer tool chain.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "Compressonator arguably creates the highest quality DDS textures across all block compression types. If the path to Compressonator is set, it can serve as a replacement for " +
                                "TexConv. It can also be used to create BC7 textures, which may offer better quality than TexConv. Compressonator fails to create some images, but the script will fall back " +
                                "to other programs when this happens in the order of: Selected Program > Compressonator > TexConv > ImageMagick.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Compressonator","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # Material Map Generator" description page.
    'Material Map G*' {
                        # Assemble the string.
                        $Text = "Material Map Generator by JoeyBallentine{0}" +
                                "{0}" +
                                $Link_MatMapGen + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Easily create AI generated Normal maps, Displacement maps, and Roughness maps.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "There are a few programs that can generate materials from color textures, but most of them can cost a pretty penny. This tool is both free and open source.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Material Map Generator","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # Dolphin TextureExtractor Tool
    'Dolphin Textur*' {
                        # Assemble the string.
                        $Text = "Dolphin TextureExtractor Tool by Venomalia{0}" +
                                "{0}" +
                                $Link_DolTexExt + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "GC and Wii texture dump tool, it dumps all textures at once and compatible with dolphins textures hash. it is still in an early stage, Currently, mainly typical gamecube " +
                                "formats are supported.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "It's amazing because it can dump all Dolphin format textures from a game without having to play it in Dolphin. Not all games are currently supported, but a significant " +
                                "number of games are supported. A list of games can be found here:{0}" +
                                "https://github.com/Venomalia/DolphinTextureExtraction-tool/wiki/Known-results{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Dolphin TextureExtractor","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      } 
    # "Ishiiruka Tool" description page.
    'Ishiiruka Tool'  {
                        # Assemble the string.
                        $Text = "Ishiiruka Tool by Tino{0}" +
                                "{0}" +
                                $Link_Ishiiruka + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Since Ishiiiruka 436 support for normal mapping and phong lighting has been added. To Support this additional textures are required:{0}" +
                                "* Depth Texture: deviation distance from the plane. Values greater than 127 (byte) are above the surface. required for displacement mapping.{0}" +
                                "* -Name = <TextureID>.bump.extension{0}" +
                                "* Normal Texture: normal map. Optional, if not present will be calculated from the bump texture.{0}" +
                                "* -Name = <TextureID>.nrm.extension{0}" +
                                "* Specular Texture : maps how polished is the surface of the material. A black (0) Texture will give as a result a opaque paper like material. White (255) will give a polished " +
                                "metallic like surface.{0}" +
                                "* -Name = <TextureID>.spec.extension{0}" +
                                "* Emissive Texture : maps the color of the light emitted by a material on every pixel on light emitting materials.{0}" +
                                "* -Name = <TextureID>.lum.extension{0}" +
                                "{0}" +
                                "But adding all this textures will take a huge hit in memory usage so I pack them in a single texture with the following format:{0}" +
                                "* Red Channel: Specular data 0-255 0=opaque 255=fully reflective specular exponent 64{0}" +
                                "* Green Channel: Normal Y component unsigned (reduced from [-1.0 1.0] to [0.0 1.0]){0}" +
                                "* Blue Channel: Bump map depth (reduced from [-1.0 1.0] to [0.0 1.0]){0}" +
                                "* Alpha Channel: Normal X component unsigned (reduced from [-1.0 1.0] to [0.0 1.0]){0}" +
                                "{0}" +
                                "This file has the .nrm sufix to make them compatible with raw normals to make testing easy.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "Tino's material map format is proprietary to Dolphin Ishiiruka, so there isn't a tool in existence that can create these textures other than his Ishiiruka Tool. Fortunately " +
                                "he was very willing to add command line support so its functionality could be used with this script.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Ishiiruka Tool","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "PNG Optimize Programs" description page.
    'PNG Optimizers'  {
                        # Assemble the string.
                        $Text = "OptiPNG by cosmin and rctruta{0}" +
                                "OxiPNG by shssoichiro{0}" +
                                "Pingo by Cedric Louvrier{0}" +
                                "Efficient Compression Tool by shssoichiro{0}" +
                                "{0}" +
                                $Link_OptiPNG + "{0}" +
                                $Link_OxiPNG + "{0}" +
                                $Link_Pingo + "{0}" +
                                $Link_Pingo + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "These programs are optional and are not required in texture creation, but the functionality is useful enough and a bunch of people requested them so here they are. Each one has its " +
                                "own unique advantages and disadvantages, my suggestion is to go with the one you like the most as they all do pretty much the same thing.{0}" +
                                "{0}" +
                                "OptiPNG Overview:{0}" +
                                "OptiPNG is a PNG optimizer that recompresses image files to a smaller size, without losing any information. This program also converts external " +
                                "formats (BMP, GIF, PNM and TIFF) to optimized PNG, and performs PNG integrity checks and corrections.{0}" +
                                "{0}" +
                                "OxiPNG Overview:{0}" +
                                "Oxipng is a multithreaded lossless PNG compression optimizer. It can be used via a command-line interface or as a library in other Rust programs.{0}" +
                                "{0}" +
                                "Pingo Overview:{0}" +
                                "pingo - fast web image optimizer - lossless PNG optimizer, PNG automatic compression, WebP automatic compression, WebP lossy, WebP lossless, WebP near-lossless, APNG optimizer (...){0}" +
                                "{0}" +
                                "ECT Overview:{0}" +
                                "Efficient Compression Tool (or ECT) is a C++ file optimizer. It supports PNG, JPEG, GZIP and ZIP files.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "PNG filesize reduction tools aren't really needed, but being able to shrink PNG file sizes is a nice feature to have. Some optimizations from some programs can break texture " +
                                "support though, so PNG textures should always be tested thoroughly.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("OptiPNG","OxiPNG","Pingo","Efficient Compression Tool","Description:","OptiPNG Overview:","OxiPNG Overview:","Pingo Overview:","ECT Overview:","Why it's needed:") -Font @($FontSize13,$FontSize13,$FontSize13,$FontSize13,$FontSize11,$FontSize11,$FontSize11,$FontSize11,$FontSize11,$FontSize11)
                      }
    # "xBRZ ScalerTest" description page.
    'xBRZ ScalerTest' {
                        # Assemble the string.
                        $Text = "xBRZ ScalerTest by Zenju{0}" +
                                "{0}" +
                                $Link_xBRZ + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "xBRZ is a high-quality image upscaling filter for creating beautiful HD representations from low-resolution images.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "This tool is required to apply the xBRZ upscaling filter when using the option 'Apply Upscaling Filter to All Textures'.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("xBRZ ScalerTest","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "Waifu2x" description page.
    'Waifu2x'         {
                        # Assemble the string.
                        $Text = "Waifu2x by nagadomi, -Caffe by lltcggie, -CPP by WL-Amigo/tanakamura/DeadSix27{0}" +
                                "{0}" +
                                $Link_W2x_Caffe + "{0}" +
                                $Link_W2x_CPP + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Image Super-Resolution for Anime-style art using Deep Convolutional Neural Networks. And it supports photo.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "This tool is required to apply the Waifu2x upscaling filter when using the option 'Apply Upscaling Filter to All Textures'. Waifu2x-Caffe is most likely the better choice if " +
                                "the target system has a nvidia GPU. Waifu2x-CPP is preferable for AMD graphics card because they do not support CUDA, and CPP does support OpenCL which can speed up the upscaling " +
                                "process significantly. It should be noted that Waifu2x-CPP does have a higher failure rate at preserving transparency if images have few colors.{0}" +
                                "{0}" +
                                "Although Waifu2x was designed to upscale anime art, it has proven to be extremely good at upscaling various game textures as well.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Waifu2x","-Caffe","-CPP","Description:","Why it's needed:") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize11,$FontSize11)
                      }
    # "7-Zip" description page.
    '7-Zip'           {
                        # Assemble the string.
                        $Text = "7-Zip by Igor Pavlov{0}" +
                                "{0}" +
                                $Link_SevZip + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "7-Zip is a file archiver with a high compression ratio.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "Resource Packs are packed into ZIP files with the 'Store' method which 7-Zip supports.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("7-Zip","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "Python" description page.
    'Python'          {
                        # Assemble the string.
                        $Text = "Python v3.9.9 by Python Software Foundation{0}" +
                                "{0}" +
                                $Link_Python + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Python is a programming language that lets you work quickly and integrate systems more effectively.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "Python is required when using ESRGAN and SFTGAN upscaling filters. This script is designed to work with Python v3.9.x. It is suggested to " +
                                "use the auto-setup for Python, ESRGAN, SFTGAN, and CUDA found on the Options menu > Operations tab.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Python","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "ESRGAN" description page.
    'ESRGAN'          {
                        # Assemble the string.
                        $Text = "ESRGAN by xinntao, fork by rapka{0}" +
                                "{0}" +
                                $Link_ESRGAN + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Enhanced Super-Resolution Generative Adversarial Networks. By Xintao Wang, Ke Yu, Shixiang Wu, Jinjin Gu, Yihao Liu, Chao Dong, Yu Qiao, " +
                                "Chen Change Loy.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "ESRGAN is a super resolution upscaler that can yield some nice results. It is suggested to use the auto-setup for Python, ESRGAN, SFTGAN, " +
                                "and CUDA found on the Options menu > Operations tab.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("ESRGAN","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "SFTGAN" description page.
    'SFTGAN'          {
                        # Assemble the string.
                        $Text = "SFTGAN by xinntao{0}" +
                                "{0}" +
                                $Link_SFTGAN + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "Recovering Realistic Texture in Image Super-resolution by Deep Spatial Feature Transform. By Xintao Wang, Ke Yu, Chao Dong, Chen Change Loy.{0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "SFTGAN is a super resolution upscaler that can yield some nice results. It is suggested to use the auto-setup for Python, ESRGAN, SFTGAN, " +
                                "and CUDA found on the Options menu > Operations tab.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("SFTGAN","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # "Sen-no-Kiseki PKG Tool" description page.
    'Sen-no-Kiseki*'  {
                        # Assemble the string.
                        $Text = "Sen-no-Kiseki PKG Tool by Sewer56{0}" +
                                "{0}" +
                                $Link_PKGSharp + "{0}" +
                                "{0}" +
                                "Description:{0}" +
                                "A set of .NET libraries for managing Sen no Kiseki/Trails of Cold Steel PKG archives. Includes custom high performance compression library for files inside PKGs written in D. {0}" +
                                "{0}" +
                                "Why it's needed:{0}" +
                                "This tool is for The Legend of Heroes: Trails of Cold Steel I/II. It allows extracting and compiling PKG files which contains the texture files. This PKG Tool is now the only PKG tool " +
                                "this script supports as it is capable of compressing PKG files.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Sen-no-Kiseki PKG Tool","Description:","Why it's needed:") -Font @($FontSize13,$FontSize11,$FontSize11)
                      }
    # The main window holds most of the important topics.
    'Main Window'     {
                        # Assemble the string.
                        $Text = "Main Window{0}" +
                                "{0}" +
                                "The main window is the first GUI window that shows up when the script is loaded. Here the Input Path and Output Path can be selected, the operation that will be performed " +
                                "is selected here, and a configuration window for the selected operation can be found below that. There are also options to configure DDS and mipmap options, and buttons to " +
                                "'Start' the operation, open the 'Options' panel, open this 'Help' document, and 'Exit' the script.{0}" +
                                "{0}" +
                                "Process Selected:{0}" +
                                'Pressing the little [$] button next to Start opens up a new mode called "Process Selected" which allows manually selecting a group of textures to process which temporarily ' +
                                'bypasses the "Input Path". More on this mode can be found in the corresponding help topic in this section.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Main Window","Input Path","Output Path","Process Selected") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize11)
                      }
    # Process Selected allows processing specific textures.
    'Process Select*' {
                        # Assemble the string.
                        $Text = "Process Selected{0}" +
                                "{0}" +
                                "This option allows processing textures manually selected by the user, temporarily bypassing the Input Path for a single run. To access this easily overlooked option, " +
                                'simply press the little [$] button that can be found next to the Start button. This feature does have its limitations and will not work with some operations. The [$] ' +
                                'button will not show up for operations it is not compatible with.{0}' +
                                "{0}" +
                                "Textures can be added to the array by simply dragging and dropping them onto the window or by clicking the window and manually adding them through the file browser. " +
                                "It only supports PNG, DDS, and JPG images. When two or more images are added to the array, the left and right 'Arrow' buttons can navigate through the list, or they " +
                                "can be selected from the listbox to view them if previews are not disabled.{0}" +
                                "{0}" +
                                "Skip Previews and Validation: Textures added to the window have a preview generated, which takes time. This option disables generating those previews " +
                                "which speeds up adding textures to the window.{0}" +
                                "{0}" +
                                "Overwrite Textures Directly: Rather than create textures in the Output Path, overwrite the textures directly in-place. This is a dangerous option as it will permanently " +
                                "destroy the original textures.{0}" +
                                "{0}" +
                                "Keep Input if Different Output Format: Only accessed when the above option is true. If the output texture has a different extension than the input texture, this option " +
                                "will keep both textures.{0}" +
                                "{0}" +
                                "Override Output Path: Allow setting a new Output Path just for Process Selected. This can be stored between sessions, but is lost as soon as the checkbox is unchecked.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Process Selected","Input Path","Start","Skip Previews and Validation","Overwrite Textures Directly","Keep Input if Different Output Format","Override Output Path") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # These options affect CTT-PS directly.
    'CTT-PS Options'  {
                        # Assemble the string.
                        $Text = "CTT-PS Options{0}" +
                                "{0}" +
                                'These options affect the script in different ways. The CTT-PS Mode configures the type of textures to work with (all/Dolphin/Trails of Cold Steel). The Texture ' +
                                'List option can change the way the texture list is viewed, or even hide it completely. To learn more about these options, check out their help topics below.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("CTT-PS Options","CTT-PS Mode","Texture List") -Font @($FontSize13,$FontSize10,$FontSize10)
                      }
    # Changes the mode the script is in which changes the options presented.
    'CTT-PS Mode'     {
                        # Assemble the string.
                        $Text = "CTT-PS Mode{0}" +
                                "{0}" +
                                "Changes the mode that the script is in. The mode controls which options are visible, and how some options behave.{0}" +
                                "{0}" +
                                "Dolphin Mode: This is the script's default mode. All available options and DDS compression types are tailored towards Dolphin 'tex1' textures. Images " +
                                "that are not prefixed with 'tex1' will not be processed, instead they will be copied when converting to other formats. This is important because the " +
                                "pack may contain previews or screenshots that the user wishes to copy into the new pack using the 'Copy Non-Textures' option when converting or rescaling textures.{0}" +
                                "{0}" +
                                "Expert Mode: Enabling this mode allows all images to bypass the script's 'tex1' verification process, and also unlocks multiple DDS compression types " +
                                "and enables additional options such as forcing the DX10 header for textures. Textures with the 'tex1' prefix are still identified as 'Dolphin Textures', " +
                                "but non-Dolphin images will now be able to be processed by almost all functions of this script. Enabling this option works well enough that the script " +
                                "can be used for just about any texture project whether it be for Dolphin or someone's favorite PC game.{0}" +
                                "{0}" +
                                "Database Mode: This mode allows creating and working with texture database files that store the dimensions of texture names and their dimensions. It is " +
                                "important to generate database files from unmodified dumps so the original dimensions are stored for reference. This allows textures to take advantage of " +
                                "operations and features that only Dolphin textures could take advantage of because they have the dimensions in the file name.{0}" +
                                "{0}" +
                                "Phyre Mode: Allows working with phyre engine images specifically used in the Legend of Heroes: Trails of Cold Steel series. All operations are tailored towards " +
                                "working with and converting these textures. It is also possible to work with Final Fantasy X/X2 Remaster textures in this mode.{0}" +
                                "{0}" +
                                "Metroid Prime: An operation designed specifically Metroid Prime 2. Offers a simple solution to generating the hundreds of font textures in the game."

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("CTT-PS Mode","Expert Mode","Dolphin Mode","Database Mode","Phyre Mode","Metroid Prime")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Sets how the Texture List is displayed, if it is displayed at all.
    'Texture List'    {
                        # Assemble the string.
                        $Text = "Texture List{0}" +
                                "{0}" +
                                'The texture list displays a list of all textures as they are processed by the script. This option can configure how the Texture List is displayed. If set to Window, ' +
                                'the list will be displayed in its own separate window. If set to Hidden, then the list will be hidden while the script is idle. It will, however, appear when the script ' +
                                'is processing textures, and will disappear after it is complete. The final mode is Docked, which combines the Main Window and the Texture List into a single window.{0}' +
                                "{0}" +
                                "The information that is displayed is dependent on the CTT-PS Mode that is set. This script was initially created for Dolphin textures specifically, so Dolphin Mode is the default. " +
                                "While in Dolphin Mode, the Texture List will display information such as the texture's original dimensions, new dimensions, and old/new aspects. This information is not relevant " +
                                "in Advanced Mode as there is no way to tell if an image had its dimension's changed. 'Expert Mode' and 'Phyre Mode' show alternate information that won't fit in Dolphin Mode. While " +
                                "in these modes, it will show the texture's Format, Mipmaps, and file Extension.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Texture List","Window","Hidden","Docked","CTT-PS Mode") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # The Input Path is the Input Path.
    'Input Path'      {
                        # Assemble the string.
                        $Text = "Input Path{0}" +
                                "{0}" +
                                "This is the path to the folder that contains textures to run through this script. For Dolphin textures, this should usually be a folder named to the disc's GameID (or the 3-digit " +
                                "equivalent). It can also be the root folder of any texture pack while in Expert Mode. This folder can contain any number of images, as well as sub-folders containing images, as " +
                                "the script will recursively search though all folders found in this path. Any images/folders that contain the ~ character will be skipped.{0}" +
                                "{0}" +
                                'Any PNG/DDS/JPG image can be processed if the CTT-PS Mode is set to "Expert Mode". This mode bypasses the check for Dolphin textures by skipping the search for the "tex1" prefix. ' +
                                'While this script will work with just about any image in these formats, it does have some features that are specific to Dolphin textures.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Input Path") -Font @($FontSize13)
                      }
    # The Output Path is where results will go.
    'Output Path'     {
                        # Assemble the string.
                        $Text = "Output Path{0}" +
                                "{0}" +
                                "This is where Custom Texture Tool PS will output all generated images. When selecting the Input Path, this will default to the same folder, but can be changed to anywhere.{0}" +
                                "{0}" +
                                "Selecting this folder will always append a \~CTT_Generated folder, which is where all the various output folders will be found after running one of the script's operations. The reason " +
                                "this folder is forced is to create an output path with the ~ character, which tells the script to skip processing textures found within it.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Output Path","\~CTT_Generated") -Font @($FontSize13,$FontSize10)
                      }
    # Operations are the meat and potatoes of this script.
    'Operation'       {
                        # Assemble the string.
                        $Text = "Operation{0}" +
                                "{0}" +
                                'This is the primary list where every operation that this script can perform can be selected and ran. When the Start button is pressed, the selected operation will look for ' +
                                'files or images in the Input Path recursively, and will create output textures in the Output Path within a sub-folder named "\~CTT_Generated". Recursive functionality can be ' +
                                'disabled in the Options menu on the Preferences tab.{0}' +
                                "{0}" +
                                "Most Operations usually do not modify the texture pack directly, with the exception of the In-Place options when running certain operations. Some operations do modify the " +
                                "pack directly, so be careful to read the description of each option carefully if one is presented. Refer to specific operations in this help guide for more information.{0}" +
                                "{0}" +
                                "This is a good time to mention that you should always create a backup of your texture pack before using any image tools, including this one.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Operation","Start","Input Path","Output Path","Preferences","In-Place") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Scan Dolphin/Database Textures For Issues
    'Scan D*'         {
                        # Assemble the string.
                        $Text = "Scan Dolphin/Database Textures For Issues{0}" +
                                "{0}" +
                                "Scans textures for known issues and offers the ability to automatically repair them if possible. Several options are available to configure which issues are found and how " +
                                "repaired textures will be generated. Detailed information about these options can be found by hovering the mouse over them which displays a tooltip. Below is a list of all " +
                                "issues that can be found when scanning.{0}" +
                                "{0}" +
                                "NotHD Texture: A texture with the original dimensions or lower.{0}" +
                                "Duplicate Texture: Multiple textures that contain the same name.{0}" +
                                "Dolphin Duplicate: Dolphin named duplicates with .1, .2, etc. suffixes.{0}" +
                                "Uneven Scale: Width and height were not scaled with the same factor.{0}" +
                                "Non-Integer Scale: The custom texture width or height was not scaled with an integer scale and contains a decimal value.{0}" +
                                "Bad Aspect Ratio: Original and custom texture contain a different aspect ratio.{0}" +
                                "Mipmaps Missing: Detects any missing mipmap levels for mipmap [m] textures and lists the number of them missing.{0}" +
                                "Mipmaps Bad Scale: Detects bad mipmap scales for [m] textures and lists the number of mipmaps with bad scaling values found.{0}" +
                                "Material Textures: Texture contains material textures (bump/spec/lum/nrm). Repairing the texture will create a material map.{0}" +
                                "Bad DDS Dimensions: When DDS texture dimensions do not match the best possible dimensions calculated from the original dimensions.{0}" +
                                "{0}" +
                                "Several folders can be created when using this option to easily identify which textures have the issue in the pack, or if they were repaired.{0}" +
                                "{0}" +
                                "BrokenTextures: Textures that are found with issues and were not repaired.{0}" +
                                "RepairedTextures: Textures that are found with issues but were repaired.{0}" +
                                "NotHDTextures: Textures that have the original dimensions or lower.{0}" +
                                "DuplicateTextures: Textures found that have the same name as other textures.{0}" +
                                "DolphinDuplicates: Textures found with the '.#' suffix appended by Dolphin.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Scan Dolphin/Database Textures For Issues","NotHD Texture:","Dolphin Duplicate:","Duplicate Texture:", "Uneven Scale:", "Non-Integer Scale:","Bad Aspect Ratio:","Mipmaps Missing:",
                                  "Mipmaps Bad Scale:","Material Textures","Bad DDS Dimensions:","BrokenTextures:","RepairedTextures:","NotHDTextures:","DuplicateTextures:","DolphinDuplicates:")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,
                                  $FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Create Texture Size Database
    'Create Texture*' {
                        # Assemble the string.
                        $Text = "Create Texture Size Database{0}" +
                                "{0}" +
                                'This operation creates a texture database file for a collection of textures that stores their dimensions in an external file with the extension (.tdb). The file itself is just a text ' + 
                                'file with a custom extension, one that CTT-PS recognizes. This operation should only be used on "dumped" textures that are still in the original resolution they were dumped with. ' +
                                'The database will be referenced for textures in any operations that require referencing the original texture dimensions (example: Rescale Textures With New Scaling Factor).{0}' +
                                '{0}' +
                                'Databases must be created with this operation, and the CTT-PS Mode must be set to Database Mode for Custom Texture Tool PS to make use of them. The reason this operation was created ' +
                                'was to allow further control over the output of textures, akin to how Dolphin textures are handled in CTT-PS. There are a few options available, explained below:{0}' +
                                "{0}" +
                                'Overwrite Existing Entries: Texture names that are already in the list will have their dimensions updated instead of being skipped.{0}' +
                                'Database Filename: Sets the name of the currently used database. If this name does not exist in the database folder, it can be created using this option.{0}' +
                                'Texture Database Folder: The location where database files will be stored. The default location is in the CTT-PS Data folder. It is not suggested to change it, but it is possible to do so here.{0}' +
                                '{0}' +
                                'Tip:{0}' +
                                'Because the original textures are required to create a database, it is possible to "fake" the original textures by rescaling them to their original resolutions then generating the ' +
                                'databases from them. But do be absolutely sure that all the dimensions are correct before generating a database from them.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Create Texture Size Database","CTT-PS Mode","Database Mode","Overwrite Existing Entries:","Database Filename:","Texture Database Folder:","Tip:")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize11)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Convert Textures to Another Format
    'Convert Textur*' {
                        # Assemble the string.
                        $Text = "Convert Textures to Another Format{0}" +
                                "{0}" +
                                "This option performs a 1:1 conversion of all textures to the chosen format. In Dolphin Mode, there are three formats to pick from: PNG, DDS, and JPG. Expert Mode unlocks additional " +
                                "image formats such as BMP, TGA, and TIF/TIFF which are not suitable for Dolphin texture packs.{0}" +
                                "{0}" +
                                "PNG Textures are losslessly compressed and have no reduction in quality. When converting any image to PNG, the representation of pixels will not change. PNG textures are best used for " +
                                "archival purposes, as it is not an optimized format for GPU processing. Very large PNG textures, or PNG textures that are accessed by the game often, can create noticeable stutter " +
                                'when used in texture packs because of the time it takes to decode the images on the GPU. Dolphin has "Prefetch Custom Textures" to attempt to remedy this, but PNG is still not as ' +
                                'fast as DDS even with this option enabled.{0}' +
                                "{0}" +
                                "JPG Textures are not suggested for texture packs. Like PNG, they are slow to decode, and quality is permanently lost when converting to JPG. There was a time when JPG may have been " +
                                "useful as textures, but these days DDS is a far better choice. This script is not limited to textures, and can work with any images, and JPG is a common format when posting images " +
                                "online. This is the only reason I keep the JPG option around, as there are times I want to mass convert a bunch of PNG images to JPG to post on the internet.{0}" +
                                "{0}" +
                                "DDS Textures can be created with multiple types of block compression, but the three most common ones used for Dolphin texture packs are: BC1 (DXT1), BC3 (DXT5), and BC7. Textures can " +
                                "also be created as uncompressed, usually referred to as RGBA8 and ARGB8. Dolphin will work with either, but ARGB8 must be used for Ishiiruka or the red and blue channels will be reversed. " +
                                'The DDS format can be chosen on the Options menu which is labeled "DDS Format". While there are many types of DDS textures, the most relevant ones will be described below.{0}' +
                                "{0}" +
                                "BC1: Also known as DXT1. This type of DDS is the most efficient, but also has the lowest quality. They are effectively half the file size and require half the amount of VRAM as BC3 " +
                                'textures. They only support 1-bit alpha, so they are not very useful for most textures that contain transparency. Textures will only be created with BC1 compression if they are opaque, and ' +
                                'the "DDS Format" option is set to "BC1/BC3".{0}' +
                                "{0}" +
                                "BC3: Also known as DXT5. This format requires twice the storage and VRAM as BC1, yields slightly higher quality, and has much better support for alpha channels. BC3 was once the number one " +
                                'choice for most textures during the D3D9 era, but has since been succeeded by BC7 (introduced in D3D11). Textures will always be created as BC3 if the "BC3" option is selected as ' +
                                'the "DDS Format". If the "BC1/BC3" option is selected, textures will only be created as BC3 if they have an alpha channel.{0}' +
                                "{0}" +
                                "BC7: This format is the same size and requires the same amount of VRAM as BC3 (DXT5), but provides much higher quality. BC7 is a newer format that was introduced with DirectX 11 " +
                                "and requires a D3D11+/OpenGL4+ compatible GPU. This includes the Nvidia GTX 400 series and newer, Intel 7th generation graphics and newer (depending on drivers), and AMD Radeon " +
                                'HD 5000 series and newer. Anything older and BC7 textures will fail to load in Dolphin. All textures will be created with BC7 if it is selected as the "DDS Format".{0}' +
                                "{0}" +
                                "ARGB8: This is an uncompressed/lossless format that matches PNG in terms of quality, but requires 4x the amount of disk space and VRAM as BC3/BC7. To put it into perspective, an " +
                                "8192x8192 texture compressed with BC7 will consume 64MB of VRAM, while an uncompressed texture with the same dimensions will consume 256MB. Images should only be created as " +
                                "uncompressed in situations where quality is essential (such as fonts and UI textures). It should not be used for environment textures, as the pack will be enormous in file size " +
                                'with over the top VRAM requirements. All textures will be created as uncompressed DDS if "ARGB8" is selected as the "DDS Compression".{0}' +
                                "{0}" +
                                "Copy Non-Textures: This option does exactly what it says, and copies any files that the script did not identify as a texture into the newly generated pack. This holds true for " +
                                "images that do not contain the 'tex1' prefix, as well as any text documents, script files, project files, basically anything that is not a Dolphin texture. If the CTT-PS Mode " +
                                "is set to 'Expert Mode', all images will be treated by the script as textures, meaning they will be processed by the current operation and not copied as non-textures.{0}" +
                                "{0}" +
                                "Auto-Repair Textures: The user may choose to auto-repair textures by checking the box. This will ensure the texture has the most accurate dimensions, but there is the possibility " +
                                "it could screw up the dimensions if textures were purposely created with a bad integer scale. This option is not suggested for textures with very low scaling values with a " +
                                'purposefully uneven integer scale. For example, if the texture is upscaled with a value of 1.80, there is a chance CTT-PS will ignore the decimal and use the integer scale "1". If ' +
                                "this happens, the texture will be created with the original dimensions (the dimensions that it dumped with).{0}" +
                                "{0}" +
                                "Scale-Fix Threshold: This option is part of Auto-Repair Textures. When enabled, it can scale the integer up if the decimal part of the aspect ratio is beyond the value set. For " +
                                'example, when repairing a texture with an aspect of 1.80, if the Scale-Fix Threshold is set to 0.80 and below, the decimal will round the integer to 2, and the texture will be ' +
                                '"repaired".{0}' +
                                '{0}' +
                                'Auto-Rename Output: Simply renames the output folder to whatever is entered into the field found below the checkbox. This should usually be the 3-digit GameID that the texture ' +
                                'pack is for.{0}' +
                                "{0}" +
                                "Textures generated with this option are output to a ConvertedTextures folder followed by the chosen file extension. After the conversion process is finished, this folder can safely " +
                                "be renamed to the 3-digit GameID and used as a Dolphin texture pack. There are a few options available that can modify the output of textures.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Convert Textures to Another Format","Dolphin Mode","Expert Mode","PNG Textures","JPG Textures","DDS Textures","BC1:","BC3:","BC7:","ARGB8:","Copy Non-Textures","Auto-Repair Textures",
                                  "Scale-Fix Threshold","Auto-Rename Output","ConvertedTextures")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Rescale Textures With New Scaling Factor
    'Rescale Textur*' {
                        # Assemble the string.
                        $Text = "Rescale Textures With New Scaling Factor{0}" +
                                "{0}" +
                                "In Dolphin Mode, this option can rescale all textures with new dimensions that are calculated from multiplying the Rescale Factor by the texture's original dimensions. This means that " +
                                "this option completely ignores the 'current' dimensions of the custom texture, as they have no use in this case. While in Expert Mode, the current dimensions are used as the original " +
                                "dimensions are unknown. Textures can be created as PNG, DDS, or JPG (see 'Convert Textures to Another Format' topic for more info).{0}" +
                                "{0}" +
                                "Textures should almost always be rescaled with an integer value such as 2, 3, 4, etc. Decimals are allowed in the Rescale Factor, but are not suggested. Dolphin prefers to see " +
                                "textures upscaled with an integer upscale, using decimal values can slightly reduce performance. For non-Dolphin texture packs, the only available dimensions are the 'current' " +
                                "dimensions and not the 'original' dimensions. This means that this option will not work the same as it does with Dolphin textures as the original dimensions are faked to the current " +
                                "dimensions. Since the original dimensions are unknown, all texture dimensions will be calculated from multiplying the 'Rescale Factor' by the texture's current dimension.{0}" +
                                "{0}" +
                                "Copy Non-Textures: This option does exactly what it says, and copies any files that the script did not identify as a texture into the newly generated pack. This holds true for " +
                                "images that do not contain the 'tex1' prefix, as well as any text documents, script files, project files, basically anything that is not a Dolphin texture. If the CTT-PS Mode " +
                                "is set to 'Expert Mode', all images will be treated by the script as textures, meaning they will be processed by the current operation and not copied as non-textures.{0}" +
                                '{0}' +
                                "Rescale Condition: This option tells the script which textures to rescale. When set to 'Always', all textures are rescaled. The 'Downscale' setting will only rescale textures " +
                                "that have a larger scale than the Rescale Factor. The 'Upscale' setting will only rescale textures that have a smaller scale than the Rescale Factor.{0}" +
                                '{0}' +
                                "Use Real Dimensions: This option simply mimics the behavior of rescaling Dolphin textures as if they are not Dolphin textures. Instead of rescaling the texture using the dimensions " +
                                "found in the name of the image, the actual dimensions of the texture are used. This can be useful to create a half-sized pack by setting the Rescale Factor to 0.50 (or 50% of normal). {0}" +
                                '{0}' +
                                "Manual Rescale: This option changes how this operation works. When enabled, the Rescale Factor acts as a default scaling value and a prompt appears for each texture to rescale " +
                                "them individually from 1-100. If 0 is entered as the scale, the texture is effectively skipped. It is not suggested to use Manual Rescale on an entire texture pack, as it could take " +
                                "a very long time to manually rescale each texture individually. This option is most useful to rescale a handful of textures at different scales.{0}" +
                                "{0}" +
                                'Auto-Rename Output: Simply renames the output folder to whatever is entered into the field found below the checkbox. This should usually be the 3-digit GameID that the texture ' +
                                'pack is for.{0}' +
                                "{0}" +
                                "Textures generated with this option are output to a RescaledTextures folder followed by the chosen file extension. After the rescaling process is finished, this folder can safely " +
                                "be renamed to the 3-digit GameID and used as a Dolphin texture pack.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Rescale Textures With New Scaling Factor","Rescale Factor","Copy Non-Textures","Rescale Condition","Use Real Dimensions","Manual Rescale","Auto-Rename Output","RescaledTextures")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Resize Textures With Specific Dimensions
    'Resize Texture*' {
                        # Assemble the string.
                        $Text = "Resize Textures With Specific Dimensions{0}" +
                                "{0}" +
                                "There is not really much to say about this operation, as the title of it is relatively self-explanatory. What this does is force a specific resolution for ALL textures. It does " +
                                "not respect any of the texture properties such as the aspect ratio, the upscale factor, etc. Like the previous operations, the output format of the textures can be specified.{0}" +
                                "{0}" +
                                "Copy Non-Textures: This option does exactly what it says, and copies any files that the script did not identify as a texture into the newly generated pack. This holds true for " +
                                "images that do not contain the 'tex1' prefix, as well as any text documents, script files, project files, basically anything that is not a Dolphin texture. If the CTT-PS Mode " +
                                "is set to 'Expert Mode', all images will be treated by the script as textures, meaning they will be processed by the current operation and not copied as non-textures.{0}" +
                                '{0}' +
                                'Auto-Rename Output: Simply renames the output folder to whatever is entered into the field found below the checkbox. This should usually be the 3-digit GameID that the texture ' +
                                'pack is for.{0}' +
                                "{0}" +
                                "Textures generated with this option are output to a ResizedTextures folder followed by the chosen file extension.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Resize Textures With Specific Dimensions","Copy Non-Textures","Auto-Rename Output","ResizedTextures")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Add Identifying Watermark to All Textures
    'Add Identifyin*' {
                        # Assemble the string.
                        $Text = "Add Identifying Watermark to All Textures{0}" +
                                "{0}" +
                                "Generates a watermark in the center of all textures that displays the texture name. The purpose of this option is to be able to easily identify where textures are located when loaded " +
                                "into a game. All textures will be created as PNG images with a minimum width of 256 pixels so the text is easily readable, and several options are available to configure the output. " +
                                "This option works with all supported formats (PNG/DDS/JPG).{0}" +
                                "{0}" +
                                "Note that DDS textures created with Ishiiruka Tool will require a valid path to Ishiiruka Tool to successfully create the watermark. If Ishiiruka Tool is not found, the texture will " +
                                "be generated as a black image that contains the watermark. This is still useful as it will still notify where the texture is in-game when loaded into Dolphin. The same holds true for " +
                                "DDS BC7 textures. TexConv is required to generate the watermark, and if it's not found, a black image will be created instead.{0}" +
                                "{0}" +
                                "Textures generated with this option are output to a WatermarkTextures folder.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Add Identifying Watermark to All Textures","WatermarkTextures") -Font @($FontSize13,$FontSize10)
                      }
    # Create Materials With Material Map Generator
    'Create Materials *' {
                        $Text = "Create Materials With Material Map Generator{0}" +
                                "{0}" +
                                "This handy tool based on ESRGAN allows generating material textures from color textures that can be converted into material maps for use in Dolphin Ishiiruka. Python v3.9.x is required. The " +
                                "options for this operation provide a Check Dependencies button to make sure that Python and any required dependencies are properly installed. There are a few options to configure the operation and output.{0}" +
                                "{0}" +
                                "Tile Size: I think this is similar to the workaround I implemented in ESRGAN/SFTGAN. If the GPU runs out of memory, smaller tile sizes can work around it.{0}" +
                                'Edge Pixels: Also similar to my upscaling methods, this can set different ways to handle the edge pixels. I have not tested it enough to understand how "Mirror" and "Replicate" work.{0}' +
                                "Disable GPU Acceleration: Pretty self explanatory. This shouldn't be used unless the GPU is made by AMD as CUDA is nvidia only.{0}" +
                                "{0}" +
                                "Textures generated with this option are output to a MaterialsCreated folder. Converting straight to material maps is currently not possible. The bump/spec/nrm textures created with this tool still need to be " +
                                "passed through Ishiiruka Tool.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Create Materials With Material Map Generator","Check Dependencies","Tile Size:","Edge Pixels:","Disable GPU Acceleration:","MaterialsCreated") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Create Material Maps With Ishiiruka Tool
    'Create Material M*' {
                        # Assemble the string.
                        $Text = "Create Material Maps With Ishiiruka Tool{0}" +
                                "{0}" +
                                "Requires a valid path to Ishiiruka Tool which can be set in the Options menu.{0}" +
                                "{0}" +
                                "Finds textures that have accompanying material textures (bump/spec/nrm/lum) and generates a material map (mat) from them. At this time, material maps are only usable by Dolphin " +
                                "Ishiiruka. These textures are capable of adding further graphical enhancements to the in-game textures such as bump map displacement using the bumpmap and normal map textures, and " +
                                "additional lighting effects using the specularity and luminance materials.{0}" +
                                "{0}" +
                                "Older versions of Ishiiruka Tool generated the combined material as a normal map (nrm), but newer versions now generate the result with a new format (mat). I can only assume this is " +
                                "so Ishiiruka (nrms) were not confused with standard (nrms). It is important to always use the latest version of Ishiiruka Tool with this script as it relies on its behavior. Younger " +
                                "iterations of the tool suffer from bugs and some features may not be compatible.{0}" +
                                "{0}" +
                                "It is not required to use this option to generate material maps from material textures. Using any option that creates textures such as Scan + Repair, Convert, and Rescale will also " +
                                "generate material maps from any materials found. These options may be even better since it creates a full pack and they preserve the original materials in the base pack you are " +
                                "generating from.{0}" +
                                "{0}" +
                                "Textures generated with this option are output to a MaterialMaps folder. It is also possible to generate material maps directly in the pack using the 'Create Materials In-Place' " +
                                "option. Do note that this will destroy the original materials! I do not suggest the in-place option because I believe in backups.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Create Material Maps With Ishiiruka Tool","MaterialMaps") -Font @($FontSize13,$FontSize10)
                      }
    # Optimize PNG Textures With Optimizer Progra
    'Optimize PNG T*' {
                        # Assemble the string.
                        $Text = "Optimize PNG Textures With Optimizer Program{0}" +
                                "{0}" +
                                "Compatible PNG Optimizers:{0}" +
                                "- OptiPNG{0}" +
                                "- OxiPNG{0}" +
                                "- Pingo{0}" +
                                "- Efficient Compression Tool{0}" +
                                "{0}" +
                                'The use of this operation requires a valid path to one of the PNG optimizer programs listed above. The path can be set in the Options menu on the "Paths" tab, or on the operation{0}' +
                                'options menu itself by clicking on the [...] button next to "PNG Optimizer Tool".{0}' +
                                "{0}" +
                                "These programs attempt to recompresses PNG files in order to shrink their file size by running a number of different tests and going with the best results.{0}" +
                                "{0}" +
                                "Textures generated with this option are output to a OptimizedTextures folder. Textures may also be created 'In-Place' which overwrites the unoptimized texture within the texture " +
                                "pack itself.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Optimize PNG Textures With Optimizer Program","Compatible PNG Optimizers:","OptimizedTextures") -Font @($FontSize13,$FontSize11,$FontSize10)
                      }
    # Apply Upscaling Filter to All Textures
    'Apply Upscalin*' {
                        # Assemble the string.
                        $Text = "Apply Upscaling Filter to All Textures{0}" +
                                "{0}" +
                                "This option is used to apply an upscaling filter to all textures. The output size of filtered textures is calculated by multiplying each of the current dimensions of the texture by the " +
                                "entered Upscale Factor. Several filters are available, and most require external programs. The resulting filtered texture dimensions can not exceed 32768x32768, which is insanely large " +
                                "and I do not suggest trying to create textures this big (I don't even know if works). If the maximum resolution is exceeded, the script will automatically and continuously decrement " +
                                "the Upscale Factor by 1 in an attempt to create a texure below the maximum. It will keep trying to find a lower value until it reaches 2, where it will then give up if 2x still yields " +
                                "dimensions above 32768x32768. This means the lowest resolution a texture can have is 16384x16384 if any filter is going to be applied.{0}" +
                                "{0}" +
                                "Supported Filters:{0}" +
                                "xBRZ - Requires ScalerTest{0}" +
                                "Waifu2x - Requires Caffe or CPP{0}" +
                                "Point - Nearest neighbor, uses ImageMagick{0}" +
                                "Cubic - Blurry upscale, uses ImageMagick{0}" +
                                "ESRGAN - Requires Python and ESRGAN scripts{0}" +
                                "SFTGAN - Requires Python and SFTGAN scripts{0}" +
                                "{0}" +
                                "Seamless Method{0}" +
                                "One great feature that this script has is the Seamless Method. This tiles a texture 9 times in a 3x3 grid, crops some percentage of the outer 8 tiles, applies the upscaling filter, and " +
                                "then crops whatever remains of the outer 8 tiles. This gives the upscaling filter neighboring pixels around the texture edges to work with so the resulting texture does not have " +
                                "visible seams when tiled in-game. This is obviously only useful for seamless textures, and it adds processing time, so when to apply this method and how much of the outer tiles are " +
                                "cropped before processing is configurable.{0}" +
                                "{0}" +
                                "It should be noted that the Seamless Method does not (usually) break non-seamless textures. By default the method is set to 'Opaque' which means the Seamless Method is only applied to " +
                                "textures that don't have transparent pixels. The vast majority of seamless textures are used in game environments such as floors, walls, and skies. But this is not always true, so the " +
                                "option 'All' is available to force the Seamless Method on all textures even if they contain transparent pixels. It's also possible to disable the Seamless Method altogether if you are " +
                                "absolutely sure the textures you are upscaling are not seamless.{0}" +
                                "{0}" +
                                "Seamless Buffer{0}" +
                                "This specifies the number of pixels to keep in the outer 8 tiles before upscaling. The more seamless pixels used in the buffer, the higher the chance the texture will actually remain " +
                                "seamless after upscaling. Increasing the number of pixels does increase the time it takes to generate the texture, and larger textures may need larger pixel buffers. The default of 24 " +
                                "pixels usually works for the most common texture sizes, but increasing it 32 pixels should handle images of any size.{0}" +
                                "{0}" +
                                "Upscale Factor as Target{0}" +
                                "Only for Dolphin textures, this upscales the texture using the dimensions in the texture name instead of the texture's current dimensions. If the output dimensions exceed the target " +
                                "resolution, the script will automatically downscale the image to satisfy the target resolution. This option ensures that textures will be upscaled using an integer scale, as upscaling " +
                                "textures using their current dimensions will have unpredictable results.{0}" +
                                "{0}" +
                                "Textures generated with this option are output to a FilteredTextures folder followed by the chosen filter.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Apply Upscaling Filter to All Textures","FilteredTextures","Upscale Factor","Supported Filters:","Seamless Method","Seamless Buffer","Upscale Factor as Target")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize11,$FontSize11,$FontSize11,$FontSize11)
                      }
    # Calculate Textures VRAM Requirement
    'Calculate Text*' {
                        # Assemble the string.
                        $Text = "Calculate Textures VRAM Requirement{0}" +
                                "{0}" +
                                "This option allows selecting a texture pack separate from the Output Path to analyze and calculate the amount of VRAM that textures will require individually and collectively. While " +
                                "it is 100% accurate, duplicate textures and optional textures can throw off the total calculation. If the pack contains a mix of texture formats (PNG, DDS BC7, DDS ARGB8, etc.), this " +
                                "option will report the total number of each type of texture when all texture formats and sizes have been calculated.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Calculate Textures VRAM Requirement") -Font @($FontSize13)
                      }
    # Generate New Mipmaps For Dolphin Textures
    'Generate New M*' {
                        # Assemble the string.
                        $Text = "Generate New Mipmaps For Dolphin Textures{0}" +
                                "{0}" +
                                "This option generates new mipmaps within the texture pack itself. Arbitrary mipmaps are preserved unless 'Force New Mipmaps' is ticked on the options menu. Care must be taken " +
                                "as textures with incorrect dimensions will be created with incorrect mipmaps. If in doubt, use 'Scan Dolphin Textures For Issues' and check 'Auto-Repair' to generate mipmaps for " +
                                "textures that are missing them. The new textures with generated mipmaps can then be found in the RepairedTextures folder, and can be merged into the main pack. Alternatively, " +
                                "converting packs or rescaling them will automatically generate mipmaps for all textures in the resulting pack.{0}" +
                                "{0}" +
                                "This option is only useful as a shortcut to creating new mipmaps when it is certain all textures have the correct dimensions.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Generate New Mipmaps For Dolphin Textures",'RepairedTextures') -Font @($FontSize13,$FontSize10)
                      }
    # Remove Invalid Mipmaps From Dolphin Textures
    'Remove Invalid*' {
                        # Assemble the string.
                        $Text = "Remove Invalid Mipmaps From Dolphin Textures{0}" +
                                "{0}" +
                                "Scans a texture pack for textures that contain external mipmap levels that are not actually a mipmap [m] texture and deletes them. This option can also detect invalid internal mipmaps " +
                                "that are stored within DDS textures and remove those as well.{0}" +
                                "{0}" +
                                "Example:{0}" +
                                "{0}" +
                                "tex1_32x32_d0f9034aa0ff4873_14 is not a Mipmap texture, but contains external Mipmap levels...{0}" +
                                "{0}" +
                                "tex1_32x32_d0f9034aa0ff4873_14_mip1{0}" +
                                "tex1_32x32_d0f9034aa0ff4873_14_mip2{0}" +
                                "tex1_32x32_d0f9034aa0ff4873_14_mip3{0}" +
                                "{0}" +
                                "Because this is not a Mipmap texture, these Mipmap levels will be removed. If it were a mipmap texture, the name would contain an [m], as in the example:{0}" +
                                "{0}" +
                                "tex1_32x32_m_d0f9034aa0ff4873_14{0}" +
                                "{0}" +
                                "Do note that this option is not as useful as it used to be, and may even be destructive, as Dolphin has gained the ability to use mipmaps for textures that did not originally have them.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Remove Invalid Mipmaps From Dolphin Textures","Example:") -Font @($FontSize13,$FontSize11)
                      }
    # Extract Internal Mipmaps
    'Extract Intern*' {
                        # Assemble the string.
                        $Text = "Extract Internal Mipmaps{0}" +
                                "{0}" +
                                "Extracts mipmaps from DDS textures or stacked images from TIF/TIFF images into the Output Path within a folder named ExtractedMipmaps. Mipmaps can also be extracted directly into the texture pack " +
                                "using the Extract Mipmaps In-Place option. This can not be undone without recreating all of the textures, so I highly suggest not performing this option on an entire texture pack. Extracted mipmaps " +
                                'will be named with the texture name plus the "mip" suffix ' + "along with the mipmap's level.{0}" +
                                "{0}" +
                                "Example:{0}" +
                                "{0}" +
                                "tex1_512x512_m_e7acdfe411dfcd00_14.dds{0}" +
                                "tex1_512x512_m_e7acdfe411dfcd00_14_mip1.dds{0}" +
                                "tex1_512x512_m_e7acdfe411dfcd00_14_mip2.dds{0}" +
                                "tex1_512x512_m_e7acdfe411dfcd00_14_mip3.dds{0}" +
                                "tex1_512x512_m_e7acdfe411dfcd00_14_mip4.dds{0}" +
                                "and so on...{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Extract Internal Mipmaps","ExtractedMipmaps","Extract Mipmaps In-Place","Example:") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize11)
                      }
    # Remove Alpha Channel From Opaque Textures
    'Remove Alpha*'   {
                        # Assemble the string.
                        $Text = "Remove Alpha Channel From Opaque Textures{0}" +
                                "{0}" +
                                "Occasionally texture artists will create a fully opaque texture but mistakenly include an alpha channel. This adds unnecessary file size to the texture because an alpha channel is " +
                                "not required if there are no transparent pixels. This option will strip the alpha channel from the texture if there are no transparent pixels, reducing file size.{0}" +
                                "{0}" +
                                "While this option works on both PNG and DDS textures, it is probably most useful on PNG textures. When using this script to convert to DDS using any option, the resulting texture " +
                                "already has its alpha channel removed if does not contain any transparent pixels.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Remove Alpha Channel From Opaque Textures") -Font @($FontSize13)
                      }
    # Remove Alpha Channel From Opaque Textures
    'Combine Multip*' {
                        # Assemble the string.
                        $Text = "Combine Multiple Textures{0}" +
                                "{0}" +
                                "Allows combining multiple textures into a single texture. This option is useful if the game has skybox, backgrounds, or other types of textures that are composed of multiple textures in " +
                                "a grid. A good example of this is Virtual Console Nintendo 64 games like Super Mario 64 and The Legend of Zelda: Ocarina of Time. The grid in this option is defined by the number of " +
                                "rows and columns that are entered, so the total number of textures can be calculated by multiplying the number of rows by the number of columns.{0}" +
                                "{0}" +
                                "Using this option to combine textures will also generate a (.ctt) file along with the texture that can be used in the option below this one to resplit the texture and rename each " +
                                "individual texture back to their original names, even if it was retextured with different dimensions. Over time this operation has become very powerful in what it can do, and it is " +
                                "rather hard to explain everything it can accomplish.{0}" +
                                "{0}" +
                                "The Triforce Button - Combine Texture Options{0}" +
                                "Pressing this button opens a bunch of new options tailored towards working with textures in N64 VC games, specifically the Zelda games and Super Mario 64.{0}" +
                                "{0}" +
                                "Attempt Auto-Arrange When Importing{0}" +
                                "Some multi-textures have a single line of duplicate pixels between the edges where they meet. This duplicate line of pixels can be used to determine which textures connect with each other " +
                                "along which border. To attempt auto-arranging the images, enable this option, then grab the entire collection of textures in file explorer (Control+A), and drag them onto the grid array. " +
                                "The script will attempt to build the image starting with the top-left texture, and work out each texture in the sequence until it finishes at the bottom-right. It is possible that multiple " +
                                "textures can create false matches if two or more textures contain the same edge pixels. In this case, a dialog will appear allowing the user to select the next texture in the sequence. While " +
                                "this is not ideal as the user may have no idea which texture comes next, it is still much easier than trying to assemble the textures manually. If the result is wrong, simply try again.{0}" +
                                "{0}" +
                                'Allow Selecting "Top-Left" Texture{0}' +
                                "A sub-option of the one above. Some textures combine together to make up a skybox or some other repeating pattern that is tiled in-game. This means that the left and right and/or top and " +
                                'bottom of the constructed image is seamless with each other. In this case, there is no "top-left" texture because it is an infinite pattern. The script needs a top-left texture to start the ' +
                                "auto-arrange sequence, so this option allows choosing a single texture to serve as the starting point. As mentioned before, this is most useful for Mario 64 or Zelda:OoT skyboxes.{0}" +
                                "{0}" +
                                "Simulate Inner Pixel Overlap{0}" +
                                "Remember how some multi-textures that combine to form a larger image can have duplicate pixels between them along the edges? Examples of games that do this are Super Mario 64, Zelda: Ocarina " +
                                "of Time, and Zelda: Majora's Mask. When the textures are tiled in-game, these duplicate pixels overlap each other, most likely to prevent lines from appearing when the camera is shifted. So " +
                                "you do NOT want to assemble the texture segments in a way that they do not overlap each other. This is especially important when retexturing the image, as the result will be wrong. This " +
                                "option allows simulating that overlap when assembling the image, the number of pixel rows and columns that overlap can be adjusted. As far as I know, this should never be a number greater " +
                                "than 1 (for N64 VC games at least), but its possible to use larger values if the need ever arises.{0} " +
                                "{0}" +
                                "Remove Garbage Pixel Columns and Rows{0}" +
                                "So now we come to the final unique situation. Some Zelda: Ocarina of Time and Majora's Mask textures when dumped in Dolphin, are dumped with a few rows and columns of garbage pixels, that are " +
                                "NOT present when dumped in N64 emulators using plugins like Rice, Glide64, or GlideN64. In Dolphin, they are dumped with a resolution of 324x8, while in N64 emulators, a resolution of 320x6. " +
                                "This is a problem because these pixels are not visible in-game, and are nothing but garbage filler (probably to align them in memory). They must be removed before building the image and retexturing " +
                                "it. In this specific situation, 4 garbage pixels can be removed from the right, and 2 garbage pixels from the bottom.{0}" +
                                "{0}" +
                                "Combining these types of textures is only half the battle, the other half is properly splitting them after retexturing/upscaling the result. See the next section to learn more.{0}{0}"
                                
                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Combine Multiple Textures","The Triforce Button - Combine Texture Options","Attempt Auto-Arrange When Importing",'Allow Selecting "Top-Left" Texture',"Simulate Inner Pixel Overlap","Remove Garbage Pixel Columns and Rows")
                        $Font = @($FontSize13,$FontSize11,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Split Combined Multi-Texture
    'Split Combined*' {
                        # Assemble the string.
                        $Text = "Split Combined Multi-Texture{0}" +
                                "{0}" +
                                "This option can split large multi-textures into multiple smaller textures. The number of images created is determined by the number of rows and columns entered, and the dimensions " +
                                "are also calculated from these values. Width is calculated by dividing the texture's width by the number of columns, and height is calculated from dividing the textures height by the " +
                                "number of rows.{0}" +
                                "{0}" +
                                "Each new texture that is created from the chosen texture will be named from that texture unless a (.ctt) file generated from Combine Multiple Textures is selected. Do note that a " +
                                "(.ctt) file is not necessary to split textures.{0}" +
                                "{0}" +
                                "The Triforce Button - Split Texture Options{0}" +
                                "Pressing this button opens a bunch of new options tailored towards working with textures in N64 VC games, specifically the Zelda games and Super Mario 64.{0}" +
                                "{0}" +
                                "Define Cell Dimensions{0}" +
                                "This is kind of a stand-alone option that allows defining the dimensions of each segment when splitting. When enabled, the values set for the Grid Array are ignored. The texture will " +
                                "be split into as many segments as possible that match the input resolution, and anything left over will be created into smaller tiles.{0}" +
                                "{0}" +
                                "Insert Removed Overlap Pixels{0}" +
                                "If working with a combined texture that was combined with pixel overlap, and needs to be re-split, the overlapping pixels need to be added back to the result. If the combined image was " +
                                "upscaled before splitting, the value used here should be equal to the upscale factor used. So if the simulated pixel overlap was 1 pixel, then upscaled by 4x, the value used here needs " +
                                "to be 4 because now 4 pixels will overlap in-game. The script will intelligently clone the correct pixel rows and columns between split textures.{0}" +
                                "{0}" +
                                "Restore Garbage Pixel Columns and Rows{0}" +
                                "When garbage pixels were removed when combining, they will need to be added back in when splitting. This option will fill the garbage pixel rows and columns by duplicating the last row " +
                                "or column to the amount specified. Like inserting overlap pixels, the amount of garbage that needs to be added back has to be multiplied by the upscale factor. So if 4 pixel lines were " +
                                "removed from the right, 2 from the bottom, and the combined texture was upscaled by 4x, then 16 pixels need to be added to the right, and 8 to the bottom.{0}" +
                                "{0}" +
                                "When opening the menu via the triforce button, a [?] button can be found next to the [Close] button. Click this for addition information and examples.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Split Combined Multi-Texture","The Triforce Button - Split Texture Options","Define Cell Dimensions","Insert Removed Overlap Pixels","Restore Garbage Pixel Columns and Rows")
                        $Font = @($FontSize13,$FontSize11,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Add/Remove Arbitrary Mipmap Suffix
    'Add/Remove Arb*' {
                        # Assemble the string.
                        $Text = "Add/Remove Arbitrary Mipmap Suffix{0}" +
                                "{0}" +
                                "This option automates adding the arbitrary mipmap suffix '_arb' to mipmap textures and all mipmap levels. This is performed on all textures found in the Input Path, so care must be " +
                                "taken when using this option.{0}" +
                                "{0}" +
                                "Arbitrary mipmaps contain images that differ from the base image/top level. The purpose of arbitrary mipmaps is to create effects that appear/disappear depending on how far the " +
                                "texture is away from the camera. The vast majority of games for the Gamecube and Wii do not use arbitrary mipmap effects, but there are a few that do. One of the greatest examples " +
                                "is the Super Mario Galaxy games which make heavy use of these effects.{0}" +
                                "{0}" +
                                "Textures that have these mipmap effects will dump with the '_arb' suffix under the condition that GPU Texture Decoding is disabled. If it is enabled, textures will not dump with the " +
                                "'_arb' suffix and it may be difficult to know which textures have these effects. Dolphin has the ability to draw these mipmap effects at a fixed distance at any Internal Resolution " +
                                "setting in order to see them the way they were 'meant to be seen' by the game's developers, but again, GPU Texture Decoding must be disabled.{0}" +
                                "{0}" +
                                "The '_arb' suffix can even be used on mipmap textures that did not originally contain arbitrary mipmap effects. This allows the artist the ability to draw mipmaps at a fixed distance " +
                                "for any mipmap texture, and properly add arbitrary mipmap effects to textures that did not originally have them.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Add/Remove Arbitrary Mipmap Suffix") -Font @($FontSize13)
                      }
    # PNG Alpha Pixel Manipulation
    'PNG Alpha *'     {
                        # Assemble the string.
                        $Text = "PNG Alpha Pixel Manipulation{0}" +
                                "{0}" +
                                "This option allows manipulation of alpha in textures in various ways.{0}" +
                                "{0}" +
                                "Convert Fully Transparent Color Pixels to Opaque{0}" +
                                "Function: Pixels where (R>0 or B>0 or G>0) and (A=0) are converted to (A=255){0}" +
                                "{0}" +
                                "Sometimes images are hidden behind an alpha mask, meaning the Alpha value is 0 for every single pixel even if the image has valid color data. This option allows editing texture dumps " +
                                "with hidden color pixels. Alpha is set to 255 for all pixels that contain valid color data, effectively revealing the hidden image underneath. After the image has been edited, the " +
                                "option found below can restore the 'invisible pixel' effect by making every pixel fully transparent.{0}" +
                                "{0}" +
                                "Add Full Transparency and Keep Pixel Color Data{0}" +
                                "Function: All pixels are converted to (A=0){0}" +
                                "{0}" +
                                "If an image dumped by Dolphin appears fully transparent, there is a chance that the image is hidden behind an alpha mask. This option will replicate that effect, and will make every " +
                                "pixel completely invisible for the custom texture while retaining the color values. This option should be used on textures that had the previous option applied to them, to restore " +
                                "the alpha mask to the custom texture.{0}" +
                                "{0}" +
                                "Set Fully Transparent Black Pixels to White{0}" +
                                "Function: Pixels where (R=0 B=0 G=0 A=0) are converted to (R=255 B=255 G=255 A=0){0}" +
                                "{0}" +
                                "This option sets the RGB values of all pixels to 255 that are fully transparent (0 Alpha), effectively making an invisible 'white' mask. Some textures may use this 'invisible' color " +
                                "data for in-game effects, and if not present, the texture will not look correct in-game. It's possible to analyze transparent pixels in texture dumps using your favorite raster " +
                                "graphics editor to find when this effect is used. The pixel should read as: R=255, G=255, B=255, A=0.{0}" +
                                "{0}" +
                                "Set Fully Transparent White Pixels to Black{0}" +
                                "Function: Pixels where (R=255 B=255 G=255 A=0) are converted to (R=0 B=0 G=0 A=0){0}" +
                                "{0}" +
                                "Searches for white pixels that are fully transparent (R=255, G=255, B=255, A=0) and removes the color data from them, effectively setting them to black transparent pixels (R=0, G=0, " +
                                "B=0, A=0). This can be used to remove the white mask from some tricky textures that are fully transparent, or work around an issue with Photoshop outputting some images with white " +
                                "invisible pixels that shouldn't be there.{0}" +
                                "{0}" +
                                "Remove All Color Data From Fully Transparent Pixels{0}" +
                                "Function: Pixels where (R>0 or B>0 or G>0) and (A=0) are converted to (R=0 B=0 G=0 A=0){0}" +
                                "{0}" +
                                "Searches for fully transparent pixels that contain color data (RGB>0, A=255) and sets all RGB values to 0 which effectively removes the hidden color data. This is a niche option that " +
                                "can be used to repair textures that have these hidden values, as they can actually show up in some games even though the pixel is fully transparent.{0}" +
                                "{0}" +
                                "Customize Data For Transparent Pixels{0}" +
                                "Function: Full customization of alpha pixels{0}" +
                                "{0}" +
                                "This is a very powerful option that can manipulate alpha pixels in very specific ways.{0}" +
                                "Search Type: Allows selecting pixels that have color data (R/G/B > 0) or no color data (R/G/B = 0).{0}" +
                                "Search Threshold: Specifies the maximum level of alpha for pixels to be selected.{0}" +
                                "Custom RGBA Fill Values tells the script what values to fill the selected.{0}" +
                                "{0}" +
                                "It can be hard to imagine what this option can be used for, so I will provide a few links with further examples here:{0}" +
                                "https://forums.dolphin-emu.org/Thread-custom-texture-tool-ps-v46-2?pid=479243#pid479243{0}" +
                                "https://leonelvidals.blogspot.com/2020/03/ssx-3-hd-texture-pack.html{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("PNG Alpha Pixel Manipulation","Convert Fully Transparent Color Pixels to Opaque","Add Full Transparency and Keep Pixel Color Data","Set Fully Transparent Black Pixels to White",
                                  "Set Fully Transparent White Pixels to Black","Remove All Color Data From Fully Transparent Pixels","Customize Data For Transparent Pixels","Search Type","Search Threshold","Custom RGBA Fill Values")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize11,$FontSize11,$FontSize11,$FontSize11,$FontSize11,$FontSize11,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Separate/Combine Texture RGBA Channels
    'Separate/Combi*' {
                        # Assemble the string.
                        $Text = "Separate/Combine Texture RGBA Channels{0}" +
                                "{0}" +
                                "A rather unique operation in that it allows spliting a texture into multiple images that represent the image color channels. Splitting a texture will result in 3-4 images depending " +
                                "on whether or not it has an alpha channel and the user wants to work with the alpha channel. It can also combine 'channel' images back into a single texture. Only the color channel " +
                                "that the image represents will have actual data in it, the other channels are zeroed out.{0}" +
                                "{0}" +
                                "Operation: Split into Channels{0}" +
                                "This is the operation that will split an image into 'channel' textures. The output textures will contain the flags _!R, _!G, _!B, and _!A if alpha was enabled. These images can now " +
                                "be edited and/or upscaled from each other independently making it easier to work with textures that use each channel for alpha and have a separate image in each channel.{0}" +
                                "{0}" +
                                "Operation: Combine Channels{0}" +
                                "Combines channel images back into a single texture. The _!R channel is used as the primary channel to perform the operation, but does require the _!G and _!B channel to complete. An " +
                                "alpha channel can be thrown into the mix but is completely optional. When the textures are combined, color data is pulled only from the channel that the flag represents and the other " +
                                "channels are ignored. For example, when 'texture_!G.png' is used when combining, only the green channel will be pulled from this texture.{0}" +
                                "{0}" +
                                "Background{0}" +
                                "This tells what kind of data to fill the other color channels with when splitting. Black fills the background with black (obviously), and Transparent makes the rest of the image, well, " +
                                "transparent. Because a channel texture will only have a single channel with actual data in it, transparency may not give a desirable effect. Either way, the background makes no difference " +
                                "when it comes to recombining the channel textures as CTT-PS only uses the associated color channel data.{0}" +
                                "{0}" +
                                "Extract Alpha Channel / Combine Alpha Channel{0}" +
                                "This rather simple option just tells the script to utilize the alpha channel when splitting into channels or combining the color channels. Only the _!A channel is regarded here when " +
                                "it comes to applying actual alpha. Any transparency added to the individual channel images using a transparent background is ignored, as the background option is cosmetic only.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Separate/Combine Texture RGBA Channels","Operation: Split into Channels","Operation: Combine Channels","Background","Extract Alpha Channel / Combine Alpha Channel")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize11,$FontSize11,$FontSize11,$FontSize11)
                      }
    # Basic Image Viewer
    'Basic Image Vi*' {
                        # Assemble the string.
                        $Text = "Basic Image Viewer{0}" +
                                "{0}" +
                                "A simple image viewer which allows viewing various image formats, although there is very little use for this outside of uncompressed ARGB8/RGBA8 and compressed BC7 DDS textures. This " +
                                "viewer is slow when decoding images because the script does not have a built-in method to decode DDS files. Instead, the image and all mipmaps are converted to PNG, which is then " +
                                "displayed in the viewer.{0}" +
                                "{0}" +
                                "Adding an image to the viewer is as simple as dragging and dropping the image into the window. Images can also be added by clicking the window and selecting an image. The viewer is " +
                                "compatible with PNG, DDS, and JPG images, and is also compatible with The Legend of Heroes: Trails of Cold Steel I/II PKG files and phyre images. {0}" +
                                "{0}" +
                                "When loading an image that is not PNG, a button becomes available to export the image as PNG. This is a convenience option that allows quickly creating a PNG file from any image.{0}{0}"
                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Basic Image Viewer") -Font @($FontSize13)
                      }
    # Dolphin Resource Pack Manager
    'Dolphin Resour*' {
                        # Assemble the string.
                        $Text = "Dolphin Resource Pack Manager{0}" +
                                "{0}" +
                                "Resource packs extend the functionality of texture packs. A resource pack is a zip file that consists of three elements: the textures, a logo.png image, and a manifest.json file. " +
                                "A resource pack can be loaded into Dolphin through a GUI, and from there the textures can be installed/uninstalled with the press of a button. This makes it much easier for the user " +
                                "to install texture packs. For more specific information on resource packs, check out the URL below.{0}" +
                                "{0}" +
                                "Resource Pack Specification:{0}" +
                                "https://gist.github.com/spycrab/9d05056755d8d7908bdb871a99d050bf{0}" +
                                "{0}" +
                                "Custom Texture Tool PS allows generating resource packs by simply filling out a form. Below is a brief explanation of each field.{0}" +
                                "{0}" +
                                "Operation: Choose to create a full resource pack, or only the 'json' file included with a pack.{0}" +
                                "GameID: The 3/6 digit ID for the game the pack modifies. This is also the name of the texture pack folder.{0}" +
                                "Pack Name: The name of the texture/resource pack.{0}" +
                                "Pack ID: A unique ID for the pack. This is automatically generated from the name but can be modified.{0}" +
                                "Version: The current version of the texture/resource pack.{0}" +
                                "Authors: The authors of the pack. These should be separated by commas.{0}" +
                                "Website: The website where the pack is hosted (can be a dolphin forum post).{0}" +
                                "Description: A brief description of the pack. Can explain what it does for what game it does it for.{0}" +
                                "ZIP Name: The name of the resource pack zip file that the script will create.{0}" +
                                "Compress Resource Pack: Compresses the ZIP file. If Dolphin ever gains the ability to load textures directly from ZIP files, it will not work with compressed ZIPs.{0}" +
                                "Logo: Icon that displays on Dolphin's Resource Pack manager. Max of 256x256 resolution.{0}" +
                                "Formatting: Options to manipulate the output of the logo. All options limit the resolution to 256x256.{0}" +
                                "{0}" +
                                "For discussion on resource packs, visit the link below.{0}" +
                                "https://forums.dolphin-emu.org/Thread-introducing-resource-packs-a-new-feature-to-manage-and-install-texture-packs{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Dolphin Resource Pack Manager","Resource Pack Specification:","Operation:","Pack Name:","Pack ID:","Version:","Authors:","Website:","Description:",
                                  "GameID:","Formatting:","ZIP Name:","Logo:","Compress Resource Pack:")
                        $Font = @($FontSize13,$FontSize11,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Run Custom CLI Executable With CTT-PS
    'Run Custom CLI*' {
                        # Assemble the string.
                        $Text = "Run Custom CLI Executable With CTT-PS{0}" +
                                "{0}" +
                                "Is there a command line program you want to run with CTT-PS that it does not currently support? Well this operation allows running just about any CLI program through " +
                                "the CTT-PS 'Master Loop'.{0}" +
                                "{0}" +
                                "Executables: This is where programs can be imported with the [+] button or removed with the [-] button.{0}" +
                                "Input Extensions: Determines which file types are processed; a filter to single out which files you want to run through the program.{0}" +
                                "Output Extension: Should be set to what the expected output extension will be. This does not guarantee that the output will be created with this extension! The value here is " +
                                "used in some variables that will be explained later.{0}" +
                                'Output Folder: Used to name the folder that will be created in the master "Output Path" that contains the processed files.{0}' +
                                "Command List: This is where a list of commands to send the program can be assembled.{0}" +
                                "{0}" +
                                'Each command needs to be entered onto a new line. Multiple part commands must have each part entered onto a new line. For example, if part of the command is something like "-setsize 200", then both "-setsize" and "200" should ' +
                                "be entered as new commands. A good rule to follow is wherever there is a space in the full command, create a new command in the list.{0}" +
                                "{0}" +
                                "Information entered into the operation's configuration panel will be stored in its own ini file named CLIExecutables.ini found within the CTT-PS Data Folder.{0}" +
                                "{0}" +
                                "There is a number of variables that can be accessed to get the paths and sizes of the input/output files. These are critical to getting a CLI program to work as the path to the input file will be needed, as well as the " +
                                "path to the output folder or the output file. Variables that can be used in the commands can be found below.{0}" +
                                "{0}" +
                                "Example Input: C:\Custom Texture Tool PS\Example.png{0}" +
                                "Example Output: C:\Custom Texture Tool PS\~CTT_Generated\CustomExecutable\Example.png{0}" +
                                "{0}" +
                                "`$InputBase: Base name without extension. (Example){0}" +
                                "`$InputName: Base name with output extension. (Example.png){0}" +
                                "`$InputPath: Path to file without filename. (C:\Custom Texture Tool PS\){0}" +
                                "`$InputFile: Path to file with the filename. (C:\Custom Texture Tool PS\Example.png){0}" +
                                "`$OutputBase: Base name without extension. (Example){0}" +
                                "`$OutputName: Base name with output extension. (Example.png){0}" +
                                "`$OutputPath: Path to file without filename. (C:\Custom Texture Tool PS\~CTT_Generated\CustomExecutable\){0}" +
                                "`$OutputFile: Path to file with the filename. (C:\Custom Texture Tool PS\~CTT_Generated\CustomExecutable\Example.png){0}" +
                                "`$ImageWidth: If an image, the input width. (1000){0}" +
                                "`$ImageHeight: If an image, the input height. (1000){0}" +
                                "`$ImageDimensions: Dimensions as width x height. (1000x1000){0}" +
                                "{0}" +
                                'Multiplied versions of the dimensions can also be used such as $ImageHeightx2 to get 2 times the size, or even $ImageHeightx6 to get 6 times the size. This works up to x8 and also works on the "$ImageDimensions" variable.{0}' +
                                "{0}" +
                                "The reason so many variations exist is because programs tend to want different types of information. Some of these are pretty redundant and will probably be removed later. Comparing ImageMagick and TexConv, the output for " +
                                "ImageMagick wants the full output path to the filename with the output extension (OutputFile), and the output for TexConv wants just the output path without the filename (OutputPath).{0}" +
                                "{0}" +
                                "Remember the Output Extension field? This is where the (OutputName) and (OutputFile) variables get the output extension from. So if the output extension is incorrect, the variables that store the path to filename will be " +
                                "incorrect. Or in the case of ImageMagick, it would create the wrong file type completely!{0}" +
                                "{0}" +
                                "Going back to the ImageMagick example, suppose we wanted to create a command to double the dimensions of processed images. The input file path is needed, the -resize command, the new dimensions, and the output file path. The command " +
                                'for the output filename determines the extension that is created, so setting the output extension actually forces the correct extension in this case. The first file that is process is named "TestFile.png" and it is 1000x1000 pixels.{0}' +
                                "{0}" +
                                "This is the full command that will be used to achieve this:{0}" +
                                "`$InputFile -resize `$ImageDimensionsx2! `$OutputFile{0}" +
                                "{0}" +
                                "Using my current files and paths, this roughly translates into:{0}" +
                                "C:\Custom Texture Tool PS\TestFile.png -resize 2000x2000! C:\Custom Texture Tool PS\~CTT_Generated\CustomMagick\TestFile.png{0}" +
                                "{0}" +
                                "Breaking down the command:{0}" +
                                "`$InputFile{0}" +
                                "-resize{0}" +
                                "`$ImageDimensionsx2!{0}" +
                                "`$OutputFile{0}" +
                                "{0}" +
                                "Because its difficult to explain without images, you can find more info at the link below:{0}" +
                                "https://forums.dolphin-emu.org/Thread-custom-texture-tool-ps-v46-2?pid=517255#pid517255{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Run Custom CLI Executable With CTT-PS","Executables:","Input Extensions:","Output Extension:","Output Folder:","Command List:","CLIExecutables.ini","`$InputBase","`$InputName","`$InputPath","`$InputFile",
                                  "`$OutputBase","`$OutputName","`$OutputPath","`$OutputFile","`$ImageWidth","`$ImageHeight","`$ImageDimensions","`$ImageHeightx2","`$ImageHeightx6",'"$ImageDimensions"')
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,
                                  $FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }      

    # Extract Textures With TextureExtraction Tool
    '*Extract Text*'  {
                        # Assemble the string.
                        $Text = "Extract Textures With TextureExtraction Tool{0}" +
                                "{0}" +
                                "Uses the Dolphin TextureExtraction Tool program by Venomalia to extract textures from loose files on the game disc. Discs must be extracted with Dolphin Emulator before running " +
                                "this program.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Extract Textures With TextureExtraction Tool","Dolphin TextureExtraction Tool","Venomalia") -Font @($FontSize13,$FontSize10,$FontSize10)
                      }
    # Extract Trails of Cold Steel PKA Files
    '*Steel PKA Files*' {
                        # Assemble the string.
                        $Text = "Extract Trails of Cold Steel PKA Files{0}" +
                                "{0}" +
                                "This option extracts the contents of PKA files found in The Legend of Heroes: Trails of Cold Steel III/IV.{0}" +
                                "{0}" +
                                "Python v3.9.x is required to use this operation, as it relies on some scripts created by CeruleanSky. You can think of PKA files as an archive of PKG files that contain the majority of the game's " +
                                "core files in a single, nearly 20GB archive. These files are compressed with LZ4 compression. Unfortunately at this time, there does not exist a compressor for LZ4, but CS3 and CS4 do work with LZ77 at " +
                                "the cost of significantly increased file size, especially since there is currently no way to recreate the assets.pka files. There is a single option available:{0}" +
                                "{0}" +
                                "Extract Files: Can be set to extract all files, or extract a specific file from CS3 or CS4. The PKG file lists are built into the script, so no external files are required other than Python v3.9.x.{0}" +
                                "{0}" +
                                "When extracting a specific file from a specific game, do make sure the Input Path points to a folder that contains the correct assets.pka file that matches the game or you may get an incorrect result. Both " +
                                "games share many PKG file names with the potential the contents may have changed from game to game. Before getting too excited, do note that there are quite a few caveats and things to be aware of.{0}" +
                                "{0}" +
                                "- Extracting all files at once will require about 65-70GB per game! So, about 130-140GB to extract the assets.pka from both games!{0}" +
                                "- This operation is currently not reversible! PKG files can be extracted from PKA, but there is currently no way to recreate a PKA file.{0}" +
                                "- While it is possible to replace the assets.pka with PKG files, there is currently no way to repack them with LZ4 (used in CS3 and CS4), only LZ77 (used in CS1 and CS2).{0}" +
                                "- It will require significantly more space to use PKG files over the PKA file. CS3 for example requires 37.6 GB for PKG files compressed with LZ77 (compared to 18.3 GB assets.pka).{0}" +
                                "{0}" +
                                "PKA files that have been extracted can be found in the PKA_Extracted folder in the Output Path.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Extract Trails of Cold Steel PKA Files","Extract Files:","assets.pka","PKA_Extracted") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Extract Trails of Cold Steel PKG Files
    '*Steel PKG Files*' {
                        # Assemble the string.
                        $Text = "Extract Trails of Cold Steel PKG Files{0}" +
                                "{0}" +
                                "This option extracts the contents of PKG files found in The Legend of Heroes: Trails of Cold Steel I/II. PKG files contain important game files, including what we want: the textures.{0}" +
                                "{0}" +
                                "Sen-no-Kiseki PKG Tool by Sewer56{0}" +
                                $Link_PKGSharp + "{0}" +
                                "{0}" +
                                "The PKG Tool by Sewer56 is now the only tool this script supports as his tool is capable of compressing PKG files PKG files that have been extracted can be found in the " +
                                "PKG_Extracted folder found in the Output Path.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Extract Trails of Cold Steel PKG Files","Sen-no-Kiseki PKG Tool","PKG_Extracted") -Font @($FontSize13,$FontSize13,$FontSize10)
                      }
    # Convert Phyre Textures to PNG Textures
    'Convert Phyre*'  {
                        # Assemble the string.
                        $Text = "Convert Phyre Textures to PNG Textures{0}" +
                                "{0}" +
                                "Trails of Cold Steel games do not use standard image files, instead they use a proprietary format known as the 'phyre' format. These images can be identified by their file extension, " +
                                "which will end with 'png.phyre' or 'dds.phyre'. This option converts these textures to the standard PNG format so they can be edited, while also saving the header of the phyre image " +
                                "into a 'header' file. This file stores information about the old texture and allows converting it back to phyre.{0}" +
                                "{0}" +
                                "Unswizzle Textures: Phyre images are swizzled, which when converted to PNG they will appear flipped. This flips the images upright when converting.{0}" +
                                "Store Phyre Header: Stores the header from the phyre image. This is required to convert the newly created PNG back to a phyre format.{0}" +
                                "Extract DDS Mipmaps: If the texture has mipmaps, this will extract them all into separate PNG images, suffixed with (_mip#.png).{0}" +
                                "Use Extracted PKG Path: Search the output folder PKG_Extracted for phyre images instead of searching the Input Path.{0}" +
                                "Only Scan Phyre Files: Scans for phyre textures and logs some basic information about them. When enabled, textures are not converted to PNG.{0}" +
                                "{0}" +
                                'Using the extracted path can save a lot of hassle when trying to seamlessly extract textures, edit them, convert them back to phyre, and re-PKG them. Textures that have been ' +
                                'converted to the PNG format can be found in the ConvertedPhyre folder found in the Output Path.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Convert Phyre Textures to PNG Textures","Unswizzle Textures:","Store Phyre Header:","Extract DDS Mipmaps:","Use Extracted PKG Path:","Only Scan Phyre Files:","PKG_Extracted","ConvertedPhyre")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Create Phyre Textures From PNG/Phyre
    'Create Phyre *'  {
                        # Assemble the string.
                        $Text = "Create Phyre Textures From PNG/Phyre{0}" +
                                "{0}" +
                                "After the PNG images have been edited, this option is capable of converting them back to a phyre format. It is possible to create phyre images as PNG, DDS, or BMP, and " +
                                "the image format can be forced to multiple image types including: RGBA8, ARGB8, DXT1, DXT3, DXT5, L8, and LA8. Cold Steel III and IV also support the BC7 format, and make up " +
                                "the majority of the game's textures. Some textures do not like their image format to be changed and may crash the game if changed. I have only seen this when converting certain DDS " +
                                "DXTN textures to PNG. The safest bet for compressed DDS files is to convert them to DDS ARGB8 if you want to use a lossless format, or just use 'Source' for the extension and format.{0}" +
                                "{0}" +
                                "Information about the image is retrieved from the header file that was created with 'Convert Phyre Textures to PNG Textures'. If this file is missing, the image can not be " +
                                "converted back to a phyre format. This header file is updated with the information from the user selected options, and the pixel data from the PNG is combined with it to " +
                                "create the new phyre image.{0}" +
                                "{0}" +
                                "File Extension: Create images as png.phyre, dds.phyre, or use the extension of the source image. PNG/BMP can only use RGBA8 or ARGB8 formats.{0}" +
                                "Image Format: Create with the pixel format RGBA8, ARGB8, DXT1, DXT3, DXT5, BC7, L8, LA8, BC7, or use the format of the source image found in the header file.{0}" +
                                "Swizzle Textures: If textures were unswizzled, or modified to be in the 'upright' position, this will flip them back to the way the game expects.{0}" +
                                "Update Asset XML File: This document stores the file names found in the PKG. If the extension of any file was changed, this document will need to be updated.{0}" +
                                "Use Converted Phyre Path: Search the output folder ConvertedPhyre for PNG images/header files instead of searching the Input Path.{0}" +
                                "Only Scan Header Files: Scans for phyre textures and logs some basic information about them. When enabled, textures are not created as phyre images.{0}" +
                                "{0}" +
                                "In short, if you are unsure about changing the extension or format, just use 'Source' to be safe. If you want to replace a compressed DDS format with a lossless format, always choose " +
                                "DDS for the extension, and ARGB8 for the format (do not use PNG). Textures that have been converted back to a phyre format can be found in the CreatedPhyre folder found in " +
                                "the Output Path.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Create Phyre Textures From PNG/Phyre","File Extension:","Image Format:","Swizzle Textures:","Update Asset XML File:","Use Converted Phyre Path:","Only Scan Header Files:","ConvertedPhyre","CreatedPhyre")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Repack Folders/Textures Into PKG Files
    'Repack Folders*' {
                        # Assemble the string.
                        $Text = "Repack Folders/Textures Into PKG Files{0}" +
                                "{0}" +
                                "This option repacks a folder containing phyre files and asset_D3D11.xml back into a PKG file. This requires a tool that can work with PKG files (links can be found below). Like " +
                                "previous 'Phyre Mode' operations, there is an option to search the 'CreatedPhyre' folder instead of the Input Path. A folder must contain 'asset_D3D11.xml' or it will not be packed.{0}" +
                                "{0}" +
                                "Sen-no-Kiseki PKG Tool by Sewer56{0}" +
                                $Link_PKGSharp + "{0}" +
                                "{0}" +
                                'PKG files that have been repacked can be found in the PKG_Repacked folder found in the Output Path.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Repack Folders/Textures Into PKG Files","Sen-no-Kiseki PKG Tool","PKG_Repacked","CreatedPhyre")
                        $Font = @($FontSize13,$FontSize13,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Create New Metroid Prime 2 Fonts From Base Textures
    'Create New Met*' {
                        # Assemble the string.
                        $Text = "Create New Metroid Prime 2 Fonts From Base Textures{0}" +
                                "{0}" +
                                'This operation can generate the many, many color variations of HD font textures for Metroid Prime 2 using a set of user provided "base" HD textures and the font textures dumped from ' +
                                'the game. The caveat to this is that the many color variations actually need to be dumped from each version of the game and supplied to the script.{0}' +
                                "{0}" +
                                'The Input Path should point to a folder that contains all the dumped font textures from the various versions of Metroid Prime 2. After that criteria is met, pressing the [Select Textures] ' +
                                'button opens the window that shows which font textures can be automatically recolored/replaced with HD versions. Simply drag and drop the HD versions of the textures onto the "Drag & Drop ' +
                                'Image" panels. It is not required to have every single dump, nor do you need to provide an HD texture for each variation, just the ones you want to retexture.{0}' +
                                '{0}' +
                                'The HD base textures should be created using only the color "white" (#FFFFFF, R=255 G=255 B=255), but can have varying levels of alpha throughout its pixels. While other colors may work, ' +
                                'creating the fonts as white guarantees that the output texture will be correct since it is much easier to work with the maximum values when creating new colors. Think of it like dying ' +
                                'a piece of clothing; you get much better results dying a white shirt blue, than trying to dye a red shirt blue and ending up with purple.{0}' +
                                '{0}' +
                                'To wrap this up simply, the dumped font textures are only required to get the texture names and the colors of the fonts, the actual pixel data is not used at all. The names and colors of ' +
                                'the dumped font textures are applied to the white retextures, which in turn automates generating HD versions of all the available names and colors.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Create New Metroid Prime 2 Fonts From Base Textures","[Select Textures]","[Select Textures]") -Font @($FontSize13,$FontSize10,$FontSize10)
                      }
    # DDS Options configure stuff for DDS textures.
    'DDS Options'     {
                        # Assemble the string.
                        $Text = "DDS Options{0}" +
                                "{0}" +
                                "These options directly affect DDS generation when performing any operation that creates DDS textures. Some options are disabled unless other options are selected. For example, " +
                                'the DDS Fallback format only becomes available when setting the DDS Format to "Search Flags" or "Passthrough". Search flags are very powerful in that you can directly affect which ' +
                                "textures get what compression type in a single run. It is suggested to read all of the information in all of the DDS help topics below to gain a better understanding of using flags, " +
                                "as it can save a lot of headache in the long run. Being able to control the texture format with ease allows creating packs where DDS ARGB8 textures can be used for UI and BC7 can be " +
                                "used for environments.{0}" +
                                "{0}" +
                                'The CTT-PS Mode also affects which options are available. While in "Expert Mode", an option to force DX10 headers onto DDS textures becomes available, and while in "Phyre Mode", the ' +
                                'only two options available are the DDS Tool and its configuration button. This is because the DDS Format while in Phyre Mode is selected in the "Create Phyre Textures" operation. If ' +
                                'an option is either unavailable or grayed out, then it means it currently has no effect on the current operation.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("DDS Options","DDS Fallback","DDS Format","CTT-PS Mode") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10)
                      }
    # The DDS Tool is the program that generates DDS textures.
    'DDS Tool'        {
                        # Assemble the string.
                        $Text = "DDS Tool{0}" +
                                "{0}" +
                                "Allows selecting which program to use when creating DDS textures. A program will not show up on the list until the path to the program is set. This can be accomplished by selecting " +
                                "Add Tool and locating a program's executable file, or by adding the path in the Options menu by clicking the Configure Paths button and setting the tool's path.{0}" +
                                "{0}" +
                                "Compressonator: Creates high quality BC1, BC3, and BC7 textures.{0}" +
                                "Microsoft TexConv: Creates the lowest quality textures but is much faster than the others.{0}" +
                                "ImageMagick: Creates the lowest quality textures, never reccommended (but it works).{0}" +
                                "{0}" +
                                "If confused on which program to use, I suggest all of them. If a program fails to create a texture, it will fall back to another one and continue to do so until the image is " +
                                "created.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("DDS Tool","Add Tool","Compressonator:","Microsoft TexConv:","ImageMagick:","Configure Paths") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # The DDS Format is the output format of DDS textures.
    'DDS Format'      {
                        # Assemble the string.
                        $Text = "DDS Format{0}" +
                                "{0}" +
                                'This option tells the script which type of block compression to use when creating DDS texures. For more DDS information, reference the section:{0}' +
                                'Main Window \ Operations \ Convert Textures to Another Format.{0}' +
                                "{0}" +
                                "When using BC1/BC3, opaque images are created with BC1, and images with transparency are created with BC3. BC1 is not very good at handling alpha channels (it only supports 1-bit " +
                                "alpha), but the quality is usually good enough for opaque images. BC1 consumes half the resources that BC3 does, including disk space and VRAM. BC3 has slightly higher quality, and " +
                                "has full alpha support, so it is chosen for images with transparency.{0}" +
                                "{0}" +
                                "The BC3 option forces all textures to use BC3 compression, even if the image does not have transparency. BC3 textures are twice the size of BC1 textures and consume twice as much " +
                                "VRAM, but can also provide slightly higher quality depending on the tool used.{0}" +
                                "{0}" +
                                "BC7 compression yields much higher quality than BC3, while consuming the same amount of resources, and can only be created with TexConv or Compressonator. BC7 requires D3D11 and/or " +
                                "OpenGL4 compatible GPUs. This includes the Nvidia GTX 400 series and newer, Intel 7th generation graphics and newer (depending on drivers), and AMD Radeon HD 5000 series and newer. " +
                                "Anything older and BC7 textures will fail to load in Dolphin.{0}" +
                                "{0}" +
                                "ARGB8/RGBA8 are uncompressed formats and have the highest possible quality, but takes 4x the amount of resources. This includes requiring 4x as much disc space, as well as consuming " +
                                "4x as much VRAM. It is not suggested to create very large packs using only uncompressed textures. They should only be created for smaller textures where detail is crucial such as UI " +
                                "textures. Uncompressed textures do not have the same limitations as BC7. They have existed since the D3D9 era, so they should work on any computer that can actually run Dolphin.{0}" +
                                "{0}" +
                                "Next is the *Search Flags* option. This allows setting a flag in the texture name, or the path to the texture to force the compression type. Assigning a flag to a folder full of " +
                                "textures will compress all textures in that folder with the type of compression that the flag references. This is the list of available flags:{0}" +
                                "{0}" +
                                "_BCX: Works exactly like the BC1/BC3 option.{0}" +
                                "_BC1: Creates textures using BC1 (DXT1) compression.{0}" +
                                "_BC2: Creates textures using BC2 (DXT3) compression.{0}" +
                                "_BC3: Creates textures using BC3 (DXT5) compression.{0}" +
                                "_BC4: Creates textures using BC4 compression.{0}" +
                                "_BC5: Creates textures using BC5 compression.{0}" +
                                "_BC6: Creates textures using BC6 compression.{0}" +
                                "_BC7: Creates textures using BC7 compression.{0}" +
                                "_ARGB8: Creates uncompressed DDS textures with BGRA color space.{0}" +
                                "_RGBA8: Creates uncompressed DDS textures with RGBA color space.{0}" +
                                "_L8: Creates uncompressed single channel luminosity.{0}" +
                                "_A8: Creates uncompressed single channel alpha.{0}" +
                                "_LA8: Creates uncompressed two channel luminosity + alpha.{0}" +
                                "{0}" +
                                "Example 1: Convert all images in the path to BC7.{0}" +
                                "C:\Textures\Environment_BC7\{0}" +
                                "C:\Textures\_BC7\Environment\{0}" +
                                "C:\Textures\Environ_BC7ment\{0}" +
                                "{0}" +
                                "Example 2: Convert a specific image to BC3.{0}" +
                                "C:\Textures\Environment\tex1_256x256_892a399244b8359e_2_BC3.png{0}" +
                                "{0}" +
                                "It is important to note that the flag must have an underscore before it, or the script will not find it. If a flag is not found in the texture's path, the fallback compression " +
                                "that is set will be used instead. Again, the flag can be present in either the texture name, or the path to the texture.{0}" +
                                "{0}" +
                                "I made a thorough post on the Dolphin forums that covers this option that is worth checking out:{0}" +
                                "https://forums.dolphin-emu.org/Thread-custom-texture-tool-ps-v39-5?pid=454462#pid454462{0}" +
                                "{0}" +
                                "The final item on the list is the *Passthrough* option. This only works when the input texture is a DDS texture. It basically just creates the output texture using the same block " +
                                "compression format that the input texture used. If the input texture is not a DDS texture, the DDS fallback compression will be used instead. This option can be useful if wanting " +
                                "to rescale an existing pack that uses multiple types of DDS files or mixed headers (both DX9 and DX10 headers in the same pack).{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("DDS Format","Main Window \ Operations \ Convert Textures to Another Format","BC1/BC3","BC3 option","BC7 compression","ARGB8/RGBA8","*Search Flags*","*Passthrough*","_BCX",
                                  "_BC1","_BC2","_BC3","_BC4","_BC5","_BC6", "_BC7","_ARGB8","_RGBA8","_L8","_A8","_LA8","Example 1:","Example 2:")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,
                                  $FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # DDS Fallback is the backup format when Search Flags is enabled.
    'DDS Fallback'    {
                        # Assemble the string.
                        $Text = "DDS Fallback{0}" +
                                "{0}" +
                                "This option serves as a backup to the DDS Format when it is set to *Search Flags*. There really isn't much to explain about this one. If a texture path does not contain any " +
                                "flags, this is the DDS format the texture will be created with.{0}" +
                                "{0}" +
                                "Example: DDS Format is set to *Search Flags*, and the DDS Fallback is set to BC7.{0}" +
                                "{0}" +
                                "C:\TexturePack\Environments\tex1_64x64_a68db9f31c1d62ea_12.png - Create as BC7{0}" +
                                "C:\TexturePack\Dungeon01_ARGB8\tex1_64x64_a68db9f31c1d62ea_12.png - Create as ARGB8{0}" +
                                "{0}" +
                                "I made a thorough post on the Dolphin forums that covers this option that is worth checking out:{0}" +
                                "https://forums.dolphin-emu.org/Thread-custom-texture-tool-ps-v39-5?pid=454462#pid454462{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("DDS Fallback","Example:","*Search Flags*") -Font @($FontSize13,$FontSize10,$FontSize10)
                      }
    # Allows configuring the selected DDS Tool.
    'Tool Options'    {
                        # Assemble the string.
                        $Text = "Tool Options{0}" +
                                "{0}" +
                                "Allows configuring specific options for the various DDS tools.{0}" +
                                "{0}" +
                                "ImageMagick{0}" +
                                "{0}" +
                                "DDS Alpha Weighting{0}" +
                                "This is the only option available, and I'm not even sure what it does. ImageMagick should not be used to create DDS textures anyway.{0}" +
                                "{0}" +
                                "Compressonator{0}" +
                                "{0}" +
                                "BC7 Quality Mode{0}" +
                                "When converting an entire texture pack, only the Auto option should ever be used. Auto attempts to get a good compromise between quality and speed by adjusting the quality based on " +
                                "the resolution of the texture and whether or not it contains transparency. For smaller packs, forcing High or Very High will yield better results than Auto, but the time to generate textures is increased " +
                                "significantly. The Ultra and Extreme settings will increase the time it takes and the CPU/GPU requirement exponentially. Do not use these options on large packs, or expect days, even weeks to finish " +
                                "converting. These options are only recommended for textures where quality is crucial.{0}" +
                                "{0}" +
                                "Image Compression{0}" +
                                "Selects the method for compressing textures. GPU is much faster than CPU, and I'm not too certain on the other options available.{0}" +
                                "{0}" +
                                "Image Decompression{0}" +
                                "Allows using a graphics API to decompress textures instead of using the CPU which can be much faster.{0}" +
                                "{0}" +
                                "BC7 Decoding Threads{0}" +
                                "Specifies the number of threads to use when decompressing BC7 textures.{0}" +
                                "{0}" +
                                "Swizzle Red and Blue Channels{0}" +
                                "Swaps the red and blue channels; maybe useful when converting between RGBA and ARGB.{0}" +
                                "{0}" +
                                'Disable BC7 "-Performance" Command{0}' +
                                'Works around a bug with versions between Compressonator v3.0.3707 and v4.2.518.{0}' +
                                "{0}" +
                                "TexConv{0}" +
                                "{0}" +
                                "BC7 Compression Mode{0}" +
                                "Supposedly selects the level of compression, requiring more CPU power for higher compression. I haven't noticed much difference.{0}" +
                                "{0}" +
                                "Alpha Compositing{0}" +
                                "Allows selecting between straight and premultiplied alpha.{0}" +
                                "{0}" +
                                "Flip Texture{0}" +
                                "Can flip the texture horizontally, vertically, or both.{0}" +
                                "{0}" +
                                "Disable GPU Acceleration{0}" +
                                "Disables using the GPU when creating BC7 textures.{0}" +
                                "{0}" +
                                "Force sRGB Colorspace{0}" +
                                "Does what it says, and forces the SRGB colorspace. Using this option can fix images that may come out too light or too dark.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Tool Options","Compressonator","TexConv","ImageMagick", "DDS Alpha Weighting", "BC7 Quality Mode", "Image Compression","Image Decompression","BC7 Decoding Threads","Swizzle Red and Blue Channels",
                                  'Disable BC7 "-Performance" Command',"BC7 Compression Mode","Alpha Compositing","Flip Texture","Disable GPU Acceleration","Force sRGB Colorspace")
                        $Font = @($FontSize13,$FontSize12,$FontSize12,$FontSize12,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Removes flags from texture names when DDS Format is set to "Search Flags".
    'Flag Removal'    {
                        # Assemble the string.
                        $Text = "Flag Removal{0}" +
                                "{0}" +
                                "See the DDS Format section above for more information about flags. This option is only available when the DDS Format is set to *Search Flags*.{0}" +
                                "{0}" +
                                "Flags that were added to textures and folders can be automatically removed using this option. Flags are removed immediately from a texture after they are converted, and are " +
                                "removed from folder names after all textures have been fully processed. In other words, the operation must be allowed to finish completely to remove flags from folders.{0}" +
                                "{0}" +
                                "There are three different settings for Flag Removal:{0}" +
                                "{0}" +
                                "New & Base: Removes user defined flags from both the base pack and the generated pack. Flags set by the user are a one off, meaning after converting, they are gone forever.{0}" +
                                "New Pack: Only removes flags from the generated pack. The base pack will keep the flags for a future run. This can be useful for making multiple packs or updating frequently.{0}" +
                                "None: Keep the flags in both packs, even the generated pack. I really do not suggest using this option at all.{0}" +
                                "{0}" +
                                "Not the best choice for names, but I'm seriously running out of space on the UI and I really don't feel like making any big adjustments.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Flag Removal","*Search Flags*","DDS Format","New & Base:","New Pack:","None:") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Force DX10 Header
    'Force DX10 Header' {
                        # Assemble the string.
                        $Text = "Force DX10 Header{0}" +
                                "{0}" +
                                "This option is only available in Expert Mode. When this option is enabled, DDS BC1-BC3 textures are created with the 148 byte DX10 header instead of the 128 byte DX9 header. This offers " +
                                "no advantages when it comes to creating texture packs for Dolphin emulator, or if the game you are creating the textures for can read both types of headers. The DX10 header should only " +
                                "be used when it is absolutely necessary, as some games do expect this header and may not work when using the DX9 header.{0}{0} "

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Force DX10 Header") -Font @($FontSize13)
                      }
    # Allows configuration of generating mipmaps.
    'Mipmap Options'  {
                        # Assemble the string.
                        $Text = "Mipmap Options{0}" +
                                "{0}" +
                                "These options control the output of mipmaps when performing any operation on DDS textures.{0}" +
                                "{0}" +
                                'Mipmap textures from Dolphin can be identified by a "m" flag following the texture original dimensions (Example: tex1_32x32_m_692d3f5c7b601717_14.png). This script will automatically ' +
                                "handle mipmap generation for all Dolphin mipmap textures, but several options found here can tweak the output.{0}" +
                                "{0}" +
                                "To generate mipmaps for non-Dolphin textures when the CTT-PS Mode is set to Expert Mode, simply supply a mipmap chain with each level ending with (_mip#, where #=level). You only " +
                                "need to provide a single mipmap (mip1) to generate a full mipmap chain, the script will automatically handle the missing levels. The only advantage of providing your own mipmaps is " +
                                "that it can allow creating arbitrary effects.{0}" +
                                "{0}" +
                                "Example 1:{0}" +
                                "{0}" +
                                "tex1_128x128_0123456789abcdef_8.png{0}" +
                                "tex1_128x128_0123456789abcdef_8_mip1.png{0}" +
                                "tex1_128x128_0123456789abcdef_8_mip2.png{0}" +
                                "tex1_128x128_0123456789abcdef_8_mip3.png{0}" +
                                "etc...{0}" +
                                "{0}" +
                                'A second way to generate mipmaps is to enable the option Force Create Mipmaps, which will force generating mipmaps for all textures. Do keep in mind that this means ALL textures, so ' +
                                'it is not suggested to use this option on entire texture packs as many textures (such as UI textures) will most likely not need mipmaps and will only waste hard drive space.{0}' +
                                "{0}" +
                                'The third and final way to force generating mipmaps is with a flag at the end of a texture file name: "_mm#", where #=number of levels to generate. Starting with CTT-PS v47.0, it is possible ' +
                                'to leave the # field blank and just use "_mm" to generate the maximum number of mipmaps for the texture.{0}' +
                                "{0}" +
                                "Example 2:{0}" +
                                "{0}" +
                                "tex1_128x128_0123456789abcdef_8_mm.png{0}" +
                                "{0}" +
                                "In the above example, the maximum number of mipmaps are generated for the texture.{0}" +
                                "{0}" +
                                "Example 3:{0}" +
                                "{0}" +
                                "tex1_128x128_0123456789abcdef_8_mm5.png{0}" +
                                "{0}" +
                                'In the above example, five mipmap levels will be generated for the texture.{0}'+
                                "{0}" +
                                "When textures are created in this way, the flag is automatically removed from the original texture (tex1_128x128_0123456789abcdef_8.png) and result (tex1_128x128_0123456789abcdef_8.dds). " +
                                'Creating PNG textures from PNG textures with a fixed number of mipmaps requires no special options. Simply add the "_mm" or "_mm#" flag and it will always work.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Mipmap Options",'"m"',"Force Create Mipmaps","Example 1:","Example 2:","Example 3:","Expert Mode") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize11,$FontSize11,$FontSize11,$FontSize10)
                      }
    # Disable Mipmap Generation
    'Disable Mipmap*' {
                        # Assemble the string.
                        $Text = "Disable Mipmap Generation{0}" +
                                "{0}" +
                                "This option doesn't really need further description, as it's pretty straight forward. When disabling mipmap generation, all other mipmap options are disabled. Do note that the mipmap "+
                                "specific operations may not work correctly when mipmaps are disabled.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Disable Mipmap Generation") -Font @($FontSize13)
                      }
    # Force New Mipmaps
    'Force New*'      {
                        # Assemble the string.
                        $Text = "Force New Mipmaps{0}" +
                                "{0}" +
                                "Whenever mipmaps are generated, the script will attempt to use mipmaps that are provided with the texture pack as a base to generate the new mipmaps from. This allows users to provide " +
                                'their own custom mipmaps to create "arbitrary mipmaps", which means using different images on descending layers. Arbitrary mipmaps can provide effects that are not attainable through ' +
                                'a single texture.{0} ' +
                                '{0}' +
                                'This option can override this functionality and force generating new mipmaps from the top mipmap layer (the base texture). This can actually result in higher quality mipmaps since all ' +
                                'mipmaps are regenerated from the largest possible image, but arbitrary mipmaps will be lost in the process. A few packs use arbitrary mipmaps: Xenoblade Chronicles, The Legend of Zelda: The ' +
                                "Wind Waker pack by Hypatia, and Super Mario Galaxy packs by razius/CDAMJC (arbitrary mipmaps were put to use in the updates by me).{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Force New Mipmaps") -Font @($FontSize13)
                      }
    # Create From Top Level
    'Create From *'   {
                        # Assemble the string.
                        $Text = "Create From Top Level{0}" +
                                "{0}" +
                                "Starting with CTT-PS v23.0, when lower mipmap levels are created, but the pack does not provide these mipmaps, the script will attempt to use the lowest mipmap level provided " +
                                "as a base to generate the missing mipmaps. For example, a newly generated texture requires 10 mipmap levels, but the pack only provides levels 1-5. The script will use level 5 " +
                                "as a base to generate levels 6-10. This ensures that the last levels keep the visual continuity of the mipmap chain.{0}" +
                                "{0}" +
                                "This option instead forces using the top level (base texture) to generate missing mipmap levels. Using the example above, mipmap levels 1-5 will be generated from the mipmaps provided " +
                                "with the pack, but levels 6-10 will be generated from the top level. This should only be used in special cases, as it can break the intended effect provided by arbitrary mipmaps.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Create From Top Level") -Font @($FontSize13)
                      }
    # Max Mipmap Levels
    'Max Mipmap*'     {
                        # Assemble the string.
                        $Text = "Max Mipmap Levels{0}" +
                                "{0}" +
                                "Forces the number of mipmap levels generated when creating textures. This option affects all output formats (PNG, DDS, JPG). By default, mipmaps will be generated down to 1x1 " +
                                "dimensions, but this option can override that behavior and limit the number of levels to the value entered. For example, if a value of '2' is set, then a 1024x1024 texture will only " +
                                "have two mipmaps generated: one at 512x512, and another at 256x256.{0}" +
                                "{0}" +
                                "This option should NOT be used in most cases. It exists to limit the number of mipmaps for textures where you only want so many levels available for complete control over the " +
                                "texture's distance from the camera. This is a very rare case where too many mipmap levels can actually be a decrease in perceivable quality.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Max Mipmap Levels") -Font @($FontSize13)
                      }
    # External Mipmaps
    'External Mip*'   {
                        # Assemble the string.
                        $Text = "External Mipmaps{0}" +
                                "{0}" +
                                "When DDS textures are created with mipmaps, this option can create them externally from the base texture into separate images. Internal mipmaps are built into the base texture, and " +
                                "are only available when using the DDS format. Starting with Dolphin v5.0-3506, support has been added for DDS internal mipmaps, and Ishiiruka has supported them for some time before " +
                                "that. External mipmaps each have their own texture file, with the suffix '_mip#' (# = level) in their name. It is suggested to create DDS textures with internal mipmaps from this point " +
                                "on, although external is still provided for user preference.{0}" +
                                "{0}" +
                                "This option also supports TIF/TIFF images. This image format also allows multiple images in a single file. The difference is that subsequent images in multi-layer TIFF files are usually " +
                                "the same resolution as the first image. If there is multiple layers in the image, this option can recreate the image with all the layers external from the base image. It is highly " +
                                'suggested to also use the option Do Not Resize TIFF Layers found on the "Additional Options" menu when using the Convert, Rescale, or Resize operations.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("External Mipmaps","Do Not Resize TIFF Layers") -Font @($FontSize13,$FontSize10)
                      }
    # Force Create Mipmaps
    'Force Create*'   {
                        # Assemble the string.
                        $Text = "Force Create Mipmaps{0}" +
                                "{0}" +
                                'This option forces creating mipmaps for all textures, including Dolphin textures that do not have the mipmap "m" flag. This is useful because Dolphin can make use of mipmaps even ' +
                                "for textures that didn't originally use them. It also allows this tool to work with other texture projects outside of Dolphin retexture projects, for example, a texture pack for a PC game. Almost " +
                                'all DDS software supplies a similar option, which made this tool a poor choice for creating DDS textures outside of Dolphin textures. Before this option, it was not possible to generate ' +
                                'mipmaps for textures that were not Dolphin textures.{0}' +
                                "{0}" +
                                "Another way to generate mipmaps for non-Dolphin textures when the CTT-PS Mode is set to Expert Mode, is to simply supply a mipmap chain with each level ending with (_mip#, where " +
                                "#=level). If at least 1 mipmap is found, it will generate the entire chain of mipmaps down to 1x1 dimensions. Creating mipmaps in this way allows creating arbitrary mipmap effects.{0}" +
                                "{0}" +
                                'There is one final way to force generating mipmaps for a DDS texture. The CTT-PS Mode must be set to "Expert Mode", the DDS Format must be set to *Search Flags*, and the desired ' +
                                "compression type should be set in 'DDS Fallback'. When all these conditions are met, the suffix (_mm#, where #=levels to generate) can be added to a texture name to generate a " +
                                "specific number of mipmap levels. The down side of doing it this way is that the number of mipmap levels are always forced, and the previous two methods always generate down to 1x1.{0}" +
                                "{0}" +
                                'For example, if we want "tree.png" to have 5 mipmap levels generated, the texture simply needs to be named "tree_mm5.png". When it is created, the flag is automatically removed from ' +
                                "the original texture (tree.png) and result (tree.dds). Creating PNG textures from PNG textures with a fixed number of mipmaps requires no special options. Simply add the (_mm#) suffix " +
                                "and it will always work.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Force Create Mipmaps","Expert Mode") -Font @($FontSize13,$FontSize10)
                      }
    # The Options Menu holds plenty of configurable options.
    'Options Menu'    {
                        # Assemble the string.
                        $Text = "Options Menu{0}" +
                                "{0}" +
                                "The options menu can be opened by pressing the 'Options' button found on the main window. Options are broken into six categories:{0}" +
                                "{0}" +
                                "Tool Paths: Configure the paths to all the external programs this script uses.{0}" +
                                "Preferences: Configure options that globally affect how the script behaves.{0}" +
                                "Exclusions: Allows setting up various methods to exclude certain types of textures.{0}" +
                                "Miscellaneous: Configure program options, specific operation options, or install ESRGAN/SFTGAN.{0}" +
                                "Debug: Configure options that enable some debugging features.{0}" +
                                "About: A window with some info and a button to donate to me if you like my work.{0}" +
                                "{0}" +
                                "When the script is closed, all changes that were made are stored within the StoredOptions.ini file that can be found in the CTT-PS Data folder. Alternatively, it can be configured " +
                                "to store the options in the header of the script file itself. In short, the script will automatically update itself with the new values after it is closed.{0}" +
                                "{0}" +
                                "It is possible to import these stored options from another version of CTT-PS if the options were saved directly to the script, using the Import Stored Options feature. This was originally " +
                                "created so that personal settings could be saved between versions of the script, although the newer StoredOptions.ini file has mostly negated its use. It is also possible to drag and drop " +
                                "an older version of CTT-PS onto the button to avoid having to manually select it through the GUI.{0}" +
                                "{0}" +
                                "The Restore Defaults button will restore everything to their default values should you feel you that you have made an error in your configuration.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Options Menu","Tool Paths:","Preferences:","Exclusions:","Miscellaneous:","Debug:","About:","StoredOptions.ini","CTT-PS Data","Import Stored Options","Restore Defaults")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # The "Tool Paths" is the menu where you set the paths to the external tools.
    'Tool Paths'      {
                        # Assemble the string.
                        $Text = "Tool Paths{0}" +
                                "{0}" +
                                "Pretty self-explanatory, these are the paths to the programs that this script requires. When configuring a path, the executable file must be selected to set the new location to the " +
                                "tool. It is also possible to paste the path to the executable in the text box, paste the path to the folder containing the executable, drag and drop the executable file onto the text " +
                                "box, or drag and drop the containing folder. When configuring the Waifu2x path from the GUI, a dropdown menu is available to select between the Caffe and CPP executables.{0}" +
                                "{0}" +
                                "The exception to the rule is the CTT-PS Data Folder. This location is where CTT-PS will store its configuration files, external scripts, generate temporary textures, and whatever else " +
                                "it may need that is external to the script file itself. By default, this path is set to the 'AppData' folder, but can be changed to 'Documents', the CTT-PS folder, the root of a HDD, or " +
                                "a custom location although I do not suggest this. If a custom location is specified, this path may need to be selected again each time the script is updated as it cannot know beforehand " +
                                "where this folder resides, since the configuration file is within this folder. Using any of the various preset locations avoids this issue.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Tool Paths","CTT-PS Data Folder") -Font @($FontSize13,$FontSize10)
                      }
    # The Preference tab, which like holds preferences and stuff.
    'Preferences'     {
                        # Assemble the string.
                        $Text = "Preferences{0}" +
                                "{0}" +
                                "These options configure aspects of Custom Texture Tool PS, PowerShell, and the GUI. They do not affect texture generation in any way. Most of the options explain themselves. They have " +
                                "tooltips that go into great detail, so they won't be explained much in this help document.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Preferences") -Font @($FontSize13)
                      }
    # Save option changes when the script is closed.
    'Save any chang*' {
                        # Assemble the string.
                        $Text = "Save any changes made to all options on exit{0}" +
                                "{0}" +
                                "When the script is closed, any options that were changed are saved to the StoredOptions.ini file that can be found in the CTT-PS Data Folder. The option below this one can instead save " +
                                "changes to the script file itself, rather than an external INI file. Storing changes made can be disabled by un-checking this option so that changes are forgotten between runs.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Save any changes made to all options on exit","StoredOptions.ini","CTT-PS Data Folder") -Font @($FontSize13,$FontSize10,$FontSize10)
                      }
    # Store the options externally from the script.
    'Store/load sav*' {
                        # Assemble the string.
                        $Text = 'Store/load saved changes in "CTT-PS Data" folder{0}' +
                                "{0}" +
                                'Rather than store any changes made to options within the script file itself, store them in an external file named StoredOptions.ini. This file can be located in the CTT-PS Data Folder. ' +
                                'The option that can be found above this one can disable storing changes made to options altogether.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Store/load saved changes in "CTT-PS Data" folder',"StoredOptions.ini","CTT-PS Data Folder") -Font @($FontSize13,$FontSize10,$FontSize10)
                      }
    # Alters the registry to open powershell scripts with a double click.
    'Run PowerShell*' {
                        # Assemble the string.
                        $Text = "Run PowerShell scripts with a double click (Registry Modification){0}" +
                                "{0}" +
                                "Allows opening PowerShell scripts with a double click, rather than having to right click it and selecting the Run with Powershell option. Toggling this option makes a small change " +
                                "to the Windows registry value that controls how PowerShell scripts are launched. This option is 100% safe to use.{0}" +
                                "{0}" +
                                "When the GUI is created when the script is launched, the value in the registry that controls how PowerShell scripts are executed is checked, and the GUI checkbox is created with the " +
                                'current state of the value. When the checkbox is toggled, the registry state is checked once again. Depending on the state, a small registry script is generated and executed "silently" ' +
                                "so it does not interfere with the user. This generated script simply reverses the current state of the registry setting.{0}" +
                                "{0}" +
                                "Registry scripts created by Custom Texture Tool PS can be found in the CTT-PS Data Folder in the RegMods folder.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Run PowerShell scripts with a double click (Registry Modification)","Run with Powershell","CTT-PS Data Folder","RegMods")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Creates a log file of all textures that were processed.
    'Create a log f*' {
                        # Assemble the string.
                        $Text = "Create a log file of all textures processed{0}" +
                                "{0}" +
                                "This option does exactly what it says. It's not suggested to disable the log file when running the 'Scan Dolphin Textures For Issues' option as it relies on the log file to create " +
                                "a list of issues. The issues that are found will still be printed to the texture list, but it is not a permanent list that can be referenced as it goes away forever after the script " +
                                "is closed.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Create a log file of all textures processed") -Font @($FontSize13)
                      }
    # Enable or disable directory recursion.
    'Recurse throug*' {
                        # Assemble the string.
                        $Text = 'Recurse through all folders found in the "Input Path"{0}' +
                                "{0}" +
                                "When running any operation, the script will search through the folder linked in the Input Path, as well as any sub-folders found within. This option can disable recursing " +
                                "through sub-folders, and instead only search the root of the folder set in the Input Path.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Recurse through all folders found in the "Input Path"') -Font @($FontSize13)
                      }
    # Enable or disable directory recursion.
    'Overwrite Text*' {
                        # Assemble the string.
                        $Text = 'Overwrite textures in the "Output Path" if they already exist{0}' +
                                "{0}" +
                                "When the script creates new textures, this option will skip creating the texture if the texture already exists in the Output Path. If disabled, the texture will be overwritten. Not " +
                                "all operations support this feature.{0}" +
                                "{0}" +
                                "Supported Operations{0}" +
                                "- Convert Textures to Another Format{0}" +
                                "- Rescale Textures With New Scaling Factor{0}" +
                                "- Resize Textures With Specific Dimensions{0}" +
                                "- Add Identifying Watermark to All Textures{0}" +
                                "- Optimize PNG Textures With Optimizer Program{0}" +
                                "- Apply Upscaling Filter to All Textures{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Overwrite textures in the "Output Path" if they already exist',"Supported Operations") -Font @($FontSize13,$FontSize11)
                      }
    # Enable or disable directory recursion.
    'Automatically r*'{
                        # Assemble the string.
                        $Text = 'Automatically remove empty folders from the "Output Path"{0}' +
                                "{0}" +
                                "Some operations may leave empty folders laying around, especially when using the 'In-Place' options that come with some operations that allow overwriting textures directly. If " +
                                "using the Process Selected menu, similar functionality exists there that may leave empty folders laying around. This option enables scanning for empty folders in the Output Path " +
                                "and automatically removing them if they do not contain any files.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Automatically remove empty folders from the "Output Path"') -Font @($FontSize13)
                      }
    # The rate the dialog is updated.
    'Dialog Update*'  {
                        # Assemble the string.
                        $Text = "Dialog Update Rate (in Milliseconds){0}" +
                                "{0}" +
                                "Whenever a program is running (ImageMagick, TexConv, Compressonator, etc.), it is ran in a separate thread (technically, it's actually ran in a second PowerShell instance in the " +
                                "background that is invisible to the user). While the program thread is running, the script will continuously update the dialog so it doesn't lock up. The rate that it is updated " +
                                "is whatever the value is set here. Lower values will yield a smoother dialog when processing textures, but it will consume more CPU time that could be spent on generating the image.{0}" +
                                "{0}" +
                                "It is suggested to lower this value as far as it can go if you have a decent computer, with the lowest possible setting being 1 ms.{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Dialog Update Rate (in Milliseconds)") -Font @($FontSize13)
                      }
    # Don't allow the UI to be above other windows.
    'Disable forcin*' {
                        # Assemble the string.
                        $Text = "Disable forcing the GUI as the top-most window{0}" +
                                "{0}" +
                                "This option determines whether or not the CTT-PS GUI will stay over top of other windows even while it is not the active window. This may seem inverted from other programs, in that " +
                                "it must be checked to be able to fall below other windows when not active. The reason is that all of the preferences were designed with the intention that their default values would " +
                                'be in a checked state, and making changes "beyond the norm" requires unchecking the options.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Disable forcing the GUI as the top-most window") -Font @($FontSize13)
                      }
    # When minimizing windows, minimize all of them.
    'Minimize visib*' {
                        # Assemble the string.
                        $Text = "Minimize visible windows separately from each other{0}" +
                                "{0}" +
                                "When this option is enabled, minimizing any CTT-PS window will minimize all open CTT-PS windows. When disabled, each window will minimize independently from each other.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Minimize visible windows separately from each other") -Font @($FontSize13)
                      }
    # Modern visual styles look much better than the classic style.
    'Enable modern *' {
                        # Assemble the string.
                        $Text = "Enable modern Windows visual styles{0}" +
                                "{0}" +
                                "Not much to say about this, it does exactly as it says and enables modern visual styles. When disabled, the GUI looks like it escaped from Windows 95.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Enable modern Windows visual styles") -Font @($FontSize13)
                      }
    # The Quick Help button brings us here.
    'Show a "Quick *' {
                        # Assemble the string.
                        $Text = "Show a Quick Help icon near the Operation list{0}" +
                                "{0}" +
                                "Shows or hides the [?] button near the Operations list. This button can be used to quickly navigate to the operation's help topic found here in the Help window. There was a " +
                                "point in this script's history where hiding this button made sense, since it appeared over top of the operations panel. Now the button has its own space, so this option isn't " +
                                "as relevant as it once was. It remains today as a filler option, but maybe someone out there doesn't care to see the [?] button so maybe it still has some use.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Show a Quick Help icon near the Operation list") -Font @($FontSize13)
                      }
    # Toggles showing the weblink icons on the "Tool Paths" menu.
    'Show Weblink i*' {
                        # Assemble the string.
                        $Text = 'Show Weblink icons on the "Tool Paths" Menu{0}' +
                                "{0}" +
                                'The Tool Paths tab found on the Options menu contain "weblink" buttons that can open links to the web pages that the various programs can be found. This option can toggle ' +
                                "showing/hiding these icons, as the user may no longer need to download any of these programs. In this scenario, the icons no longer serve a purpose other than taking up space.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Show Weblink icons on the "Tool Paths" Menu') -Font @($FontSize13)
                      }
    # Toggles showing the weblink icons on the "Tool Paths" menu.
    'Clear textboxe*' {
                        # Assemble the string.
                        $Text = 'Clear textboxes while holding Shift/Alt/Control when clicking{0}' +
                                "{0}" +
                                "When clicking on a textbox using any of the modifier keys (Shift/Alt/Control), the textbox will be cleared of all text. If this option is disabled, textboxes will always be " +
                                "cleared when they are clicked on. CTT-PS is picky about the contents of its textboxes, so if left blank, or the entry is invalid, textboxes will revert to their previous value.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Clear textboxes while holding Shift/Alt/Control when clicking') -Font @($FontSize13)
                      }
    # The Exclusions tab, which excludes textures from being processed.
    'Exclusions'      {
                        # Assemble the string.
                        $Text = "Exclusions{0}" +
                                "{0}" +
                                "This tab allows excluding textures from being processed. To exclude most types, simply uncheck them.{0}" +
                                "{0}" +
                                "File Extensions: Exclude PNG, DDS, or JPG textures.{0}" +
                                "Mipmaps: Exclude Dolphin mipmap textures or textures that have mipmaps.{0}" +
                                "Alpha Channel: Exclude textures with/without an alpha channel.{0}" +
                                "Material Maps: Exclude textures that have materials or material maps.{0}" +
                                "Transparency: Exclude opaque textures or ones that have transparency.{0}" +
                                "Min Dimensions: Exclude textures that are smaller than these dimensions.{0}" +
                                "Max Dimensions: Exclude textures that are larger than these dimensions.{0}" +
                                "Names/Phrases: Exclude textures that contain specific strings in the path.{0}" +
                                "{0}" +
                                "Exclusions can be useful if you only want to run specific operations on specific texture types without dividing up the pack. When a texture is excluded, the reason as to why it was " +
                                "excluded will be shown on the Texture List.{0}{0} "

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Exclusions","File Extensions:","Mipmaps:","Alpha Channel:","Transparency:","Material Maps:","Min Dimensions:","Max Dimensions:","Names/Phrases:")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # The Misc tab holds several "operation specific" options.
    'Miscellaneous'   {
                        # Assemble the string.
                        $Text = "Miscellaneous{0}" +
                                "{0}" +
                                "This tab contains buttons that link to the configuration windows for the DDS generating programs, options that are specific to certain operations, and an automatic installer for " +
                                "ESRGAN, SFTGAN, Python, and Nvidia CUDA.{0}" +
                                "{0}" +
                                'The DDS generating programs can also be configured from the main window under DDS Options by clicking the Configure Tool button next to the Tool Options label. Only the currently ' +
                                "selected tool can be configured in this manner, while this tab allows configuring any of the programs at any time.{0}" +
                                "{0}" +
                                "The buttons below this allow configuring the Additional Options found in the Convert/Rescale operations, and also allow configuring the upscale filters Waifu2x, ESRGAN, and SFTGAN. " +
                                'These upscaling filters can also be configured when selecting the Apply Upscaling Filter operation when they are selected.{0}' +
                                "{0}" +
                                "Finally, an auto-installer can also be found to install Python, Nvidia CUDA, ESRGAN, and SFTGAN. The auto-installer will download, install, and update these programs as necessary. " +
                                'It is presented in a series of "Steps" which can be skipped if a certain program is already installed (such as Python or CUDA). While this auto-installer still works well, an ' +
                                'alternative is to find, download, and install the Programs Pack from the Dolphin forum thread this script is found on. This pack can also be obtained by following the "weblink" ' +
                                'icon found on the "Tool Paths" menu, which has three download mirrors to choose from.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Miscellaneous","Configure Tool","DDS Options","Tool Options","Additional Options","Apply Upscaling Filter","Programs Pack")
                        $Font = @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # The debug menu is useful for me.
    'Debug*'          {
                        # Assemble the string.
                        $Text = "Debug{0}" +
                                "{0}" +
                                'These options are mostly for when I am developing the tool, but some users may find some of these options useful. Most of them should be relatively safe to use, although the ones ' +
                                'that affect DDS textures (force show BC7, disable CTT-PS writing headers) may cause broken or missing textures.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Debug") -Font @($FontSize13)
                      }
    # The PS Console is my best debugging tool.
    'Show the Power*' {
                        # Assemble the string.
                        $Text = "Show the PowerShell Console window{0}" +
                                "{0}" +
                                'By default, the PowerShell console is hidden when the tool is launched. This option will make the console window always visible. The PowerShell console logs several of the operations ' +
                                'that are currently taking place, which is useful to help troubleshoot logic errors. It will also display any error messages when things go wrong in red text. If you are having issues ' +
                                'with something, try enabling the console and see if anything looks out of the ordinary. This will also help me out if you can screenshot any errors when reporting bugs or other issues.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Show the PowerShell Console window") -Font @($FontSize13)
                      }
    # The PS Console is my best debugging tool.
    'Disable auto-c*' {
                        # Assemble the string.
                        $Text = "Disable auto-centering the PowerShell console on launch{0}" +
                                "{0}" +
                                'This option is nearly as old as the script itself, and has been removed and reimplemented several times over the years. It does what it says and disables the code that centers ' +
                                'the PowerShell console on launch. This code has been much improved in v47.0 and will handle all DPI scaling. This option used to exist for the reason that the PowerShell console ' +
                                'was all that was available (there was no GUI), and this option could fail on some users systems. It still has use today but mostly for my own development purposes, as it can be ' +
                                'rather annoying when launching the script over and over again and the PS console jumps on me every boot.{0}{0} '

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Disable auto-centering the PowerShell console on launch") -Font @($FontSize13)
                      }
    # No clue why anyone would want to use this option.
    'Force show BC7*' {
                        # Assemble the string.
                        $Text = "Force show BC7 on DDS Format list without TexConv{0}" +
                                "{0}" +
                                'Some users over time have wondered why the BC7 option is not visible when Compressonator is linked to the script, but TexConv is not linked. The reason is that this script requires ' +
                                'TexConv to create BC7 because Compressonator can sometimes fail to generate textures. When this happen, TexConv will pick up the slack. If for some reason you are one of those ' +
                                'people that wants BC7 support without this fallback in place, this option can be enabled to force showing BC7 on the "DDS Format" list.{0}{0}'

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Force show BC7 on DDS Format list without TexConv") -Font @($FontSize13)
                      }
    # Let's add an option that can break textures.
    'Disable CTT-PS*' {
                        # Assemble the string.
                        $Text = "Disable CTT-PS from writing custom DDS headers{0}" +
                                "{0}" +
                                "This script writes custom headers for all DDS textures that are generated, regardless of the program used. Each program has nuances where they don't follow the standard set by " +
                                "Microsoft. Some just add junk data, others can create a bad header that doesn't work in Dolphin emulator. The headers generated by this script follow Microsoft's standards as close " +
                                "as possible. Disabling this option will definitely create bad BC7 headers when using Compressonator that do not work with Dolphin.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Disable CTT-PS from writing custom DDS headers") -Font @($FontSize13)
                      }
    # Sometimes I need to dump my own icons.
    'Dump CTT-PS ic*' {
                        # Assemble the string.
                        $Text = "Dump CTT-PS icons on Desktop when launched{0}" +
                                "{0}" +
                                "This option dumps all icons that CTT-PS uses into a folder on the Desktop. Images are stored in the script as Base64 strings, and at times I want to dump and edit them. This option " +
                                "converts the Base64 strings back into PNG files.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Dump CTT-PS icons on Desktop when launched") -Font @($FontSize13)
                      }
    # Close out the script without saving options.
    'Show a `[!`] b*' {
                        # Assemble the string.
                        $Text = 'Show a [!] button near "Exit" that closes without saving{0}' +
                                "{0}" +
                                "Mostly used for development, but has lost most of its usefulness over time. This just closes the script without storing any options. I used to use this when developing because it " +
                                "was quite tedious whenever I closed the script, Notepad++ would say the file was modified do you want to reload? But now that options can be saved externally from the script, " +
                                "this button doesn't have much use anymore. But I keep it because why not, maybe someone wants it.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @('Show a [!] button near "Exit" that closes without saving') -Font @($FontSize13)
                      }
    # Do not enable high DPI settings on boot.
    'Disable High D*' {
                        # Assemble the string.
                        $Text = "Disable High DPI Scaling (Requires Restart){0}" +
                                "{0}" +
                                "Do not apply the high DPI scaling hack (or rather, no auto-scaling) when the script launches. If this option is disabled, Windows will once again auto-scale " +
                                "the GUI and the script will fall back to using 96 DPI values.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Disable High DPI Scaling (Requires Restart)") -Font @($FontSize13)
                      }
    # Allows changing the maximum values for combine and split grid array and garbage pixels.
    'Split/Combine *' {
                        # Assemble the string.
                        $Text = "Split/Combine Textures Grid Array/Garbage Pixel Limit{0}" +
                                "{0}" +
                                "By default, the Split/Combine Textures maximum values for the Grid Array and Garbage Pixels are set to a safe value where uses won't create a dialog that can " +
                                "crash the GUI or cause it to freeze up for several seconds. This option allows surpassing those limits to a custom value if the user is advanced enough to know " +
                                "the dangers of setting too high of a value, and has a need for a higher value that the default values do not provide.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Split/Combine Textures Grid Array/Garbage Pixel Limit") -Font @($FontSize13)
                      }        
    # The buttons found on the Option's menu.
    'Options Buttons' {
                        # Assemble the string.
                        $Text = "Options Buttons{0}" +
                                "{0}" +
                                "The buttons found on the Options menu can either restore all default values for all options, or even import the values from an older version of CTT-PS.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Options Buttons") -Font @($FontSize13)
                      }
    # Restores all options to their default values.
    'Restore Defaul*' {
                        # Assemble the string.
                        $Text = "Restore Defaults{0}" +
                                "{0}" +
                                "When CTT-PS is closed, any options that were changed by the user are stored into the StoredOptions.ini file, or directly to the script file if the preference for it is set. This " +
                                "option will reset the values of all options to their default values. It should be noted that this option does not reset any paths to external tools.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Restore Defaults") -Font @($FontSize13)
                      }
    # Imports options from a different version of CTT-PS.
    'Import Stored*'  {
                        # Assemble the string.
                        $Text = "Import Stored Options{0}" +
                                "{0}" +
                                "This option allows importing Stored Options from a previous version of Custom Texture Tool PS by simply selecting the script (.ps1) file. Simpler yet, it is now possible to drag and " +
                                "drop a previous version of CTT-PS onto the button. It should work on any version of the PowerShell versions of the script. This feature exists to retain personal settings when " +
                                "updating to future versions of this script, and not have to set everything back up manually every single time. It is also possible to drag and drop an older version of CTT-PS onto the " +
                                "button to avoid having to manually select it through the GUI.{0}" +
                                "{0}" +
                                "Since the creation of the StoredOptions.ini file, this button does not have much use anymore unless the user decides to store options directly to the script file.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Import Stored Options") -Font @($FontSize13)
                      }
    # Some guides for the uneducated noobs.
    'Guides'          {
                        # Assemble the string.
                        $Text = "Guides{0}" +
                                "{0}" +
                                "Okay I get it. This tool has way too many options for something as simple as creating images right? Well I can agree that maybe I went over the top in some cases, but I feel like " +
                                "every option included is necessary to personally tweak a texture pack to get the best possible results. And to be honest, this tool is still very limited, there is no replacing an " +
                                "artist's personal touch. There is only so much that can be done to automate the creation of art.{0}" +
                                "{0}" +
                                "These guides are aimed at some of the more general operations that most users will seek this tool for, such as creating DDS textures, rescaling textures, or creating material maps. " +
                                "Some guides may read more like a tutorial, while others are just a general information section. Hopefully the guides can help where the rest of this already bloated help section " +
                                "fails to.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Guides") -Font @($FontSize13)
                      }
    # Teach how to create DDS textures.
    'Creating DDS*'   {
                        # Assemble the string.
                        $Text = "Creating DDS Packs{0}" +
                                "{0}" +
                                "Because there is no way to create a tool to work perfectly with all Dolphin texture packs by default, there are a number of options available to tweak and try to get the best " +
                                "results. There are several programs that can generate DDS files from PNG/JPG files, but they do not offer enough options to fit all edge cases of Dolphin textures. This guide offers " +
                                "step-by-step instructions of how to convert a PNG/JPG pack to DDS. I can only assume ImageMagick and a DDS generating program is installed.{0}" +
                                "{0}" +
                                "(1:) Set the 'Input Path' field to the texture pack root folder.{0}" +
                                "(2:) Optional: Set the 'Output Path' to wherever you want to create textures.{0}" +
                                "(3:) Choose the Standard Option 'Convert Textures to Another Format'.{0}" +
                                "(4:) Set the 'Output Format' to DDS.{0}" +
                                "(5:) Enter the first 3 digits of the GameID into the 'Auto-Rename Output' field.{0}" +
                                "(6:) Press the Start button to start converting.{0}" +
                                "(7:) Wait for the script to finish converting textures. This can take some time!{0}" +
                                "(8:) Find the new pack in the '~CTT_Generated' folder.{0}" +
                                "(9:) If this pack exists in 'C:\User\Documents\Dolphin Emulator\Load\Textures' then remove it and move in the newly generated/renamed pack.{0}" +
                                "{0}" +
                                'DDS textures can be created with BC1/BC3, BC3, or BC7 block compression. This can be configured on the main window under "DDS Options". Going forward, it is highly suggested to ' +
                                "use BC7 as it offers the highest quality. Creating and working with BC7 textures require a valid path set to TexConv on the 'Tool Paths' tab which is found on the Options menu.{0}" +
                                "{0}" +
                                "What about this 'Auto-Repair Dimensions' option?{0}" +
                                "{0}" +
                                "This is actually a very useful feature, and I would love to enable it by default but it has the potential to break some texture packs. In almost all cases, this option 'should' be " +
                                "enabled. This option can correct common mistakes made by texture artists such as not creating textures with an integer scale, or textures having slightly bad aspect ratios. It can " +
                                "break some texture packs if the custom textures are not much larger than the original textures, or if the aspect ratios are purposely distorted to achieve some effect. An example is " +
                                "the Tales of Symphonia pack.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Creating DDS Packs","What about this 'Auto-Repair Dimensions' option?")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize11)
                      }
    # Learn how to rescale textures and also convert.
    'Rescaling Packs' {
                        # Assemble the string.
                        $Text = "Rescaling Packs{0}" +
                                "{0}" +
                                "This guide covers how to rescale all textures within a texture pack. In most cases, the purpose of doing this is to downscale a texture pack that contains very large textures, and " +
                                "the user's system struggles to keep solid frame rates or experiences a significant amount of 'stutter'. This option takes a 'Rescale Factor' which is then multiplied by the texture's " +
                                "original dimensions to calculate the new dimensions.{0}" +
                                "{0}" +
                                "(1:) Set the 'Input Path' field to the texture pack root folder.{0}" +
                                "(2:) Optional: Set the 'Output Path' to wherever you want to create textures.{0}" +
                                "(3:) Choose the option 'Rescale Textures With New Scaling Factor'.{0}" +
                                "(4:) Set the 'Rescale Factor'. A value of 4 is fine for 1080p.{0}" +
                                "(5:) Set the 'Output Format' to DDS.{0}" +
                                "(6:) Set 'Rescale Condition' to Downscale so small textures are not upscaled.{0}" +
                                "(7:) Enter the first 3 digits of the GameID into the 'Auto-Rename Output' field.{0}" +
                                "(8:) Press the Start button to start rescaling.{0}" +
                                "(9:) Wait for the script to finish rescaling textures. This can take some time!{0}" +
                                "(10:) Find the new pack in the '~CTT_Generated' folder.{0}" +
                                "(11:) If this pack exists in 'C:\User\Documents\Dolphin Emulator\Load\Textures' then remove it and move in the newly generated/renamed pack.{0}" +
                                "{0}" +
                                'DDS textures can be created with BC1/BC3, BC3, or BC7 block compression. This can be configured on the main window under "DDS Options". Going forward, it is highly suggested to ' +
                                "use BC7 as it offers the highest quality. Creating and working with BC7 textures require a valid path set to TexConv on the 'Tool Paths' tab which is found on the Options menu.{0}" +
                                "{0}" +
                                "What is this 'Manual Rescale' option?{0}" +
                                "{0}" +
                                "For most users, this option has little to no use, and is geared towards texture artists. This allows rescaling a folder full of textures one by one, setting the 'Rescale Factor' " +
                                "individually for each texture. There may be very little value in this option, I myself have only found a use for it twice when working on the Xenoblade Chronicles texture pack when " +
                                "modifying BrunoFBK's textures and when working on some of my own textures.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Rescaling Packs","What is this 'Manual Rescale' option?")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize11)
                      }
    # Let's talk about mipmaps in the most basic sense.
    'Mipmap Tutorial' {
                        # Assemble the string.
                        $Text = "Mipmap Tutorial{0}" +
                                "{0}" +
                                "Mipmap textures are a collection of images that in most cases, represent the same image at a progressively lower resolution. It may be easier to view them as a cascade of progressively " +
                                "shrinking 'layers' with the top layer having the highest resolution, and the bottom layer having the lowest resolution. Each descending layer is half of the resolution of the previous " +
                                "layer, usually all the way down to a resolution of 1x1.{0}" +
                                "{0}" +
                                "An example would be an image with the resolution of 64x64. This is the 'top layer'. The next layer down would contain a 32x32 version of the same image. Moving down one more layer " +
                                "reveals a 16x16 version of the same image. This cascade usually continues all the way down to the lowest layer which contains an image that is 1x1, but in some cases mipmap levels end " +
                                "at 8x8 or 4x4. It's up to the artist/developer.{0}" +
                                "{0}" +
                                "Mipmaps serve several purposes. For one, they reduce hardware requirements when rendering a scene. Suppose the scene is of a field that uses a grass texture that is visible from the " +
                                "camera's base and extends all the way to the horizon. As the distance from the camera increases, the renderer can make use of these additional mipmap layers. Each descending layer " +
                                "means less pixels to sample when an actual screen pixel is calculated which reduces hardware requirements.{0}" +
                                "{0}" +
                                "In the same scenario as above, mipmaps provide a reduced level of detail which adds to the perception of 'realism'. The farther the grass is from the focal point, less detail should " +
                                "be apparent. As you gaze down the street, you will notice the amount of perceivable detail in the road decreases such as the granularity, cracks, pebbles, etc. The reduced image " +
                                "quality of additional mipmap layers makes for a more convincing reduction in the level of detail in 3-Dimensional world.{0}" +
                                "{0}" +
                                "Mipmaps come in many forms. Some of us in the Dolphin community have developed our own terminology for them to help distinguish between the different forms they come in, so these are " +
                                "not 'official' terms in any way. But basically, the 3 types of mipmaps that I will explain here have been dubbed: External Mipmaps, Internal Mipmaps, and Arbitrary Mipmaps.{0}" +
                                "{0}" +
                                "External Mipmaps: The PNG format can only store a single image, so the additional layers of mipmaps must come from additional images. If the image requires 12 additional layers of " +
                                "mipmaps, then the collection will entail of 13 images in total. The largest image is commonly referred to as the 'top layer' or 'top level', and the additional layers are commonly " +
                                "referred to as the 'lower levels' or 'lower layers'. External mipmaps are not limited to the PNG format. These can be found in any format such as DDS, TGA, JPG, BMP, etc. But for " +
                                "Dolphin, PNG and DDS are the only formats supported.{0}" +
                                "{0}" +
                                "Internal Mipmaps: These types of mipmaps are exclusive to the DDS format. DDS textures are capable of storing all layers of mipmaps within a single DDS file. This has the advantage " +
                                "that it makes for a much more organized texture pack. Support for internal mipmaps has been added in Dolphin starting with v5.0-3506, and has been supported in Ishiiruka for a long " +
                                "time now. If a DDS pack is to be generated, then I personally suggest to create it using internal mipmaps. This script is also capable of generating 'arbitrary' internal mipmaps.{0}" +
                                "{0}" +
                                "Arbitrary Mipmaps: These types of mipmaps contain variations of the same image on descending layers, but are not necessarily the exact image. Texture artists make use of arbitrary " +
                                "mipmaps to add additional effects through textures, usually lighting. It is not a common practice, but these textures do exist so they are worth mentioning because it is why this " +
                                "script does not force new mipmaps by default. As of writing (April 3, 2019), the only known packs to contain them are Xenoblade Chronicles and Hyptia's Zelda: Wind Waker. And to " +
                                "update this (August 4, 2021), the Super Mario Galaxy packs also contain them. It might not be obvious, but arbitrary mipmaps can be either external or internal.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Mipmap Tutorial","External Mipmaps:","Internal Mipmaps:","Arbitrary Mipmaps:") -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10)
                      }
    # An in-depth guide to how to create Mipmaps with this script.
    'Creating Mipma*' {
                        # Assemble the string.
                        $Text = "Creating Mipmaps with CTT-PS{0}" +
                                "{0}" +
                                "So you may be asking yourself, how exactly does mipmap generation work in Custom Texture Tool PS? There are several ways this script handles mipmaps, and this section is dedicated to " +
                                "explaining them all.{0}" +
                                "{0}" +
                                "Dolphin Mipmap Handling{0}" +
                                "{0}" +
                                "For Dolphin textures, mipmaps are handled automatically for all mipmap textures, meaning textures with the [m] flag (such as tex1_64x64_m_0bd03e7ac65acbaf_14.png). When CTT-PS " +
                                "finds a mipmap texture when generating textures, and no mipmaps are provided, it will generate mipmaps for them using the top level as a base. If mipmaps are provided with the texture, " +
                                "the script will use those instead. If a mipmap chain is not complete, the script will use the last mipmap in the chain to generate any missing levels lower than that last mipmap. So if " +
                                "a texture needs 10 mipmaps, and only 7 are provided, mipmaps 8-10 will be generated from mipmap 7. That is unless the option to create from the top level is enabled.{0}" +
                                "{0}" +
                                "Custom Mipmap Handling{0}" +
                                "{0}" +
                                "When working with non-Dolphin textures while in 'Expert Mode', the script can not know which textures require mipmaps since they will most likely not have a flag in the file name. " +
                                "There are three ways to generate mipmaps for these textures. The first way is to enable the option Force Create Mipmaps, which will forcefully create mipmaps for all textures generated. " +
                                'The second way is to simply provide at least one custom mipmap with the texture. For example, suppose a texture has the file name "texture.png". To generate mipmaps for this specific ' +
                                'texture, provide one level named "texture_mip1.png". This tells the script that this is a mipmap texture, and will generate the entire mipmap chain for it, even though only a single ' +
                                'mipmap is provided. It is also possible to provide all mipmap levels, and the script will use them all. The third and final way is to add the mipmap flag to the file name "_mm#" '+
                                'where # is the number of mipmaps you wish to generate. The number can be excluded ("_mm") to generate the full mipmap chain. So using the "texture.png" example, naming it to something ' +
                                'like "texture_mm4.png" will generate four mipmaps for the texture. The flag will be automatically removed from the generated texture file name.{0}' +
                                "{0}" +
                                "Controlling Mipmap Chains{0}" +
                                "{0}" +
                                "There are a number of options that can be used to alter the output of the mipmap chain. First, a recap of how mipmap handling works by default. Mipmaps are handled automatically for "  +
                                "Dolphin textures, and must be manually identified for non-Dolphin textures. If mipmaps are not provided with the texture, mipmaps will be generated from the base texture. If mipmaps " +
                                "are provided, the script will use them to generate new mipmaps. If a provided mipmap chain is incomplete, the script will use the lowest mipmap in the chain to generate the remaining " +
                                "levels.{0}" +
                                "{0}" +
                                "The first option to manipulate how mipmaps are generated is Force New Mipmaps. This tells the script to ignore mipmaps provided with the pack, and generate new ones from the base " +
                                "textures. This can be used by users who don't like the effects of arbitrary mipmaps, meaning different images on descending layers.{0}" +
                                "{0}" +
                                "The next option Create From Top Level forces the script to use the base texture to generate mipmaps from, rather than use the lowest mipmap in the chain. Using the example from before, " +
                                " if a texture needs 10 mipmaps, and only 7 are provided, mipmap levels 8-10 will be generated from the base texture and not mipmap 7.{0}" +
                                "{0}" +
                                "Next up is External Mipmaps which creates all DDS mipmaps externally from the main texture rather than create them internally. This option has almost no use these days, but Dolphin " +
                                "can still make use of external mipmaps.{0}" +
                                "{0}" +
                                "Finally Max Mipmap Levels controls how many levels are actually generated. In almost all cases, mipmaps should be generated down to 1x1 dimensions. But sometimes mipmaps are used for " +
                                "distance attenuation of sprites. A sprite does not look so good with very small dimensions, so by controlling the number of mipmaps, we can control the number of pixels used to " +
                                "represent the smallest image.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Creating Mipmaps with CTT-PS","Dolphin Mipmap Handling","Custom Mipmap Handling","Force Create Mipmaps","Controlling Mipmap Chains",
                                  "Force New Mipmaps","Create From Top Level","Create From Top Level","External Mipmaps","Max Mipmap Levels")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                      }
    # Much information on Material Maps and Ishiiruka Tool.
    'Material Maps*'  {
                        # Assemble the string.
                        $Text = "Material Maps and Ishiiruka Tool{0}" +
                                "{0}" +
                                "A big thanks goes to Tino for supporting command line in his tool, and adding a few options that made integration into this script possible. I will categorize materials into two types: " +
                                "combined and uncombined. Uncombined materials can consist of a color texture, a normal map (.nrm), a bump map (.bump), a specularity map (.spec), and an emissive map (.lum). A combined " +
                                "material is a type of texture that is created with Ishiiruka Tool from the uncombined textures, also known as a material map.{0}" +
                                "{0}" +
                                "Combined materials can have one of two types of accompanying color textures: the standard format, or if it was generated with a (.lum) texture, the emissive data will be stored in the " +
                                "alpha channel and the texture will be named with (_lum) suffix.{0}" +
                                "{0}" +
                                "The script must know where Ishiiruka Tool is located. If 'TextureEncoder.exe' is not found when the script finds material textures or combined material maps, a 'Notice' message will be " +
                                "displayed in the texture list. The location of Ishiiruka Tool can be selected within the 'Options' panel.{0}" +
                                "{0}" +
                                "To create a material map, a color texture, a bump map, and specularity map is required. The color texture is just your normal everyday texture that you wish to apply affects to with " +
                                "materials. If a normal map is not provided, it will be calculated from the bump map texture. The emissive texture is also optional, and is not required to generate a combined material. " +
                                "All material textures must be in the same folder, including the color texture because Ishiiruka Tool looks for them together.{0}" +
                                "{0}" +
                                "Combing Materials into a Material Map{0}" +
                                "{0}" +
                                "There are several options that can create material maps from uncombined materials. Depending on the option selected depends on how and where the material map will be created.{0}" +
                                "{0}" +
                                "Scan Dolphin Textures For Issues: The 'Attempt Repairs' checkbox must also be ticked. This option sees uncombined materials as an 'issue' that can be 'fixed' so it creates the material " +
                                "map. The materials from the source pack will remain in-tact, and the combined material map will be created in the 'RepairedTextures' output folder.{0}" +
                                "{0}" +
                                "Convert Textures to Another Format: The script will automatically create material maps from uncombined materials in the newly generated pack. The materials from the source pack will " +
                                "remain in-tact, and the combined material map will be created in the 'ConvertedTextures' output folder.{0}" +
                                "{0}" +
                                "Rescale Textures With New Scaling Factor: Like the convert textures option, it will create material maps from any uncombined materials that are found. Depending on the 'Rescale Factor' " +
                                "set, all material textures will be rescaled at the calculated resolution before being combined into a material map. The materials from the source pack will remain in-tact, and the " +
                                "combined material map will be created in the 'RescaledTextures' output folder.{0}" +
                                "{0}" +
                                "Create Material Maps With Ishiiruka Tool: This option exists if all you want to do is create material maps. This can be done directly with the Ishiiruka Tool GUI. Whether or not this " +
                                "tool is used or Ishiiruka Tool is used directly is a matter of personal preference. The Ishiiruka Tool GUI offers more options which are automated in Custom Texture Tool PS. The " +
                                "materials from the source folder will remain in-tact, and the combined material maps will be created in the 'MaterialMap' output folder. There also exists an option to create the " +
                                "materials 'in-place', but this option destroys the original materials.{0}" +
                                "{0}" +
                                "Working With Combined Material Maps{0}" +
                                "{0}" +
                                "There was a time when working with an already combined material map wasn't possible. Once the materials were combined that was it, there was nothing else that could be done with it. " +
                                "Image editors have no idea what it is. Thanks to Tino and my relentless (and most likely annoying) demands, it is now possible to work with already combined material maps using " +
                                "Ishiiruka Tool.{0}" +
                                "{0}" +
                                "I have extended the capabilities by throwing in other programs which are capable of converting Ishiiruka DDS color textures into either PNG or a DDS format that most image editors will " +
                                "once again recognize. Combined materials in this script can be converted to other formats when asked, and rescaled with new dimensions using the rescaling option. Other than that, not " +
                                "much else can be done with them. Most other options will just ignore they exist. It is possible to generate watermarks on the color texture, but the material map will be discarded " +
                                "since watermarks are only used for identification.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Material Maps and Ishiiruka Tool","Combing Materials into a Material Map","Scan Dolphin Textures For Issues:","Convert Textures to Another Format:",
                                  "Rescale Textures With New Scaling Factor:","Create Material Maps With Ishiiruka Tool:","Working With Combined Material Maps")
                        SetStringFont -FindString $Find -Font @($FontSize13,$FontSize12,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize12)
                      }
    # Don't forget about the little people.
    'Credits'         {
                        # Assemble the string.
                        $Text = "Credits{0}" +
                                "{0}" +
                                "I like to give credit where credit is deserved. Although I am the sole creator of this script, it would not have come this far without the " +
                                "testing and ideas of others that helped shape it into what it is today.{0}" +
                                "{0}" +
                                "Bighead: The creator. Writes terrible code that kind of works.{0}" +
                                "Dolphin Devs: All of you are awesome for this emulator!{0}" +
                                "ImageMagick: ImageMagick is amazing and makes this script possible.{0}" +
                                "AMD: The same goes for Compressonator which makes very nice textures.{0}" +
                                "Microsoft: Since I mentioned the others may as well them for TexConv.{0}" +
                                "degasus: Planted the initial idea for this script into my head.{0}" +
                                "frozenwings: Personally tested dozens of early versions until I started to get it.{0}" +
                                "Tino: Ishiiruka Tool command line support. Thanks Tino!{0}" +
                                "Zenju: Added command line to the xBRZ ScalerTest, without hesitation!{0}" +
                                "uncleiroh: Created the initial idea of putting watermarks on textures.{0}" +
                                "MeleeHD: Alerted me of uncleiroh's idea of watermarks.{0}" +
                                "StripTheSoul: Inadvertently gave me the idea to support OptiPNG.{0}" +
                                "masterotaku: Gave me the idea to implement upscaling filters.{0}" +
                                "TheCrach: Requested progress indication which led to the title bar progress.{0}" +
                                "CyberGlitch: Solely responsible for the idea behind the Seamless Method.{0}" +
                                "Admentus: Tested several versions with many helpful bug reports.{0}" +
                                "DarthVitrial: Always reminded me to get ImageMagick v7 to work.{0}" +
                                "BennyAlex98: Idea for saving texture/output paths and waifu2x model select.{0}" +
                                "CTCaer: Motivated me to add the option to force BC3 for DDS textures.{0}" +
                                "Hypatia: Helping her with Wind Waker made me realize I needed more options.{0}" +
                                "Matrix2525: Helped test and point out many issues in v40.0 beta versions.{0}" +
                                "Spycrab: Pointed out typo that prevented resource pack compression.{0}" +
                                'Vlad1vostok: Kickstarted the idea in my brain to add the "Exclusions" tab.{0}' +
                                "iwubcode: Helped debug and made me aware of updated Waifu2x-CPP.{0}" +
                                "stealthii: Alerted me/fixed a bug with Material Map Generator.{0}" +
                                "Kupo: Idea to shutdown the PC after an operation completes.{0}" +
                                "Venomalia: Created the Dolphin TextureExtractor Tool.{0}" +
                                "GhostlyDark: Ideas and testing for texture database features.{0}" +
                                "Dolphin Community: The feedback and testing is much appreciated and helped motivate me to improve it! Thanks to anyone I failed to mentioned.{0}" +
                                "CTT-PS Icon: Site is now dead, but original concept was from: http://icons.mysitemyway.com{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        $Find = @("Credits","Bighead:","Dolphin Devs:","ImageMagick:","AMD:","Microsoft:","degasus:","frozenwings:","Tino:","Zenju:","uncleiroh:","MeleeHD:","StripTheSoul:","masterotaku:","TheCrach:","CyberGlitch:",
                                  "Admentus:","DarthVitrial:","BennyAlex98:","CTCaer:","Hypatia:","Matrix2525:","Spycrab:","Vlad1vostok:","iwubcode:","stealthii:","Kupo:","Venomalia:","Dolphin Community:","CTT-PS Icon:")
                        $Font = @($FontSize12,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,
                                  $FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10,$FontSize10)
                        SetStringFont -FindString $Find -Font $Font
                      }
    # Some guides for the uneducated noobs.
    'About'           {
                        # Assemble the string.
                        $Text = "Custom Texture Tool PS - The Beginning to the End{0}" +
                                "{0}" +
                                "Just want to say this first, it is not important to read this section. At all. This section exists only to tell the story of why this tool came to exist and the struggle that was " +
                                "involved in making it what it is today. If you don't care, then it's safe to just skip it completely and spend your time doing something far more productive.{0}" +
                                "{0}" +
                                "But if you do care, then I have to say I'm touched. Grab yourself a drink and a snack, and get settled in because it's story time...{0}" +
                                "{0}" +
                                "In what seems like forever ago, this kind of started as a simple batch script to simply generate mipmaps. Basic stuff. I have written batch scripts before because I love to automate " +
                                "monotonous tasks, and I've also scripted custom scenarios in Blizzard games dating back to StarCraft/WarCraft III (anyone remember Hydra RaNcHeRz or Wintermaul Wars TE?). I have never " +
                                "attempted to learn a programming language so I've always been limited in what I can do, so I never attempted anything major. That is until this script. If you can even call it major.{0}" +
                                "{0}" +
                                "So Dolphin emulator had this huge issue with the previous texture format when it came to paletted textures. If the texture lookup table changed, then the dumped texture hash (Name/ID) " +
                                "also changed. This wasn't a big problem for many games, but it was for Xenoblade Chronicles, and I was heavily invested in the texture pack. Many textures in that game dumped 100s to " +
                                "even 1000s of times: meaning if you want that texture to be re-textured at all times, you must find every possible hash. One of my fellow contributors to the pack (frozenwings) who has " +
                                "evolved into a dear friend of mine made it his mission to find every possible hash for the Europe version of the game. After I got bored of making textures for awhile, I joined him in " +
                                "his quest and started dumping the USA version of the game. Nearly 100k textures later for both versions of the game, we realized that like Pokemon, its nearly impossible to catch them " +
                                "all.{0}" +
                                "{0}" +
                                "So what does this have to do with this script? Well during that period I worked on a few batch scripts for us that made creating duplicates of those textures a much, much simpler task. " +
                                "My script would take a 'base' re-texture, search for all dumps within the folder with that base, and create clones of that base using the dumped names. After it was finished, all the " +
                                "dumps were deleted and we were left with a pile of re-textures ready to ship. I think by the end there ended up being near or over 120 base folders and often we would find ourselves " +
                                "filling each folder with 100s even 1000s of dumps to clone. By the end of it all, the pack size started climbing into the Gigabytes all the while nothing new was really being added. " +
                                "But a lot of good came from this, I did get much better at writing batch scripts and understanding a ton of new concepts.{0}" +
                                "{0}" +
                                "Eventually after wishing upon a star for almost 2 years, degasus took notice and introduced the new texture format that finally eliminated the issue with duplicate paletted textures. " +
                                "We rejoiced and revered him as some kind of messiah for making our dreams come true and finally putting an end to our pain. This meant all the work we put into dumping ended up being " +
                                "for naught. But I do like to think it made a great example that there was something very wrong with Dolphin in the first place. I had very little to do with this new format outside of " +
                                "testing the shit out of it and making the suggestion to flag mipmap textures with an [m] so they can easily be identified. Because I had a lot of free time and actually understood " +
                                "enough that I felt I could educate others, I created a post on the forums that explained the new custom texture format, which now exists today as a sticky labelled 'Dolphin Custom " +
                                "Textures Info'.{0}" +
                                "{0}" +
                                "Some time into that thread, degasus says:{0}" +
                                "{0}" +
                                "@Bighead: As you like scripting, do you think it's worth to have a script which check all textures and warn if{0}" +
                                "- the upscaling factor isn't an integer{0}" +
                                "- the aspect ratio is changed{0}" +
                                "- mipmaps have wrong size{0}" +
                                "- mipmaps aren't complete{0}" +
                                "- ...{0}" +
                                "{0}" +
                                "So this is where this tool really began. At first I wasn't really all that confident that I was capable of doing even those simple tasks. The scripts I wrote for Xenoblade dealt more " +
                                "with loops and directories and creating copies rather than doing any real math or any actual analysis on image files. I really didn't know much about the specifics of image files in " +
                                "general and even today I'm still a noob compared to some of the far more talented people out there. But I did attempt it, and Custom Texture Tool the batch script was born. At first " +
                                "all it could do was analyze simple issues with textures and generate mipmaps since I had already written a script to do that using ImageMagick. The initial support for this was very " +
                                "basic, it had to delete all mipmaps before generating new ones. (Unfortunately, this basic code remained for a long time.) Next came a new loop to scan folders for textures and create " +
                                "a log file of all textures that were found. Simple enough. Actual error checking has to be done now which involves math, which is where batch fails because it can only work with " +
                                "integers, and decimals are required for many of the necessary calculations.{0}" +
                                "{0}" +
                                "The first type of error checking was detecting non-integer scaling values for custom textures. The new texture format makes this very easy to calculate, since the original texture " +
                                "dimensions are stored in the dumped name and can be extracted. For example, tex1_24x24_0804541083813079_14 may be a texture for Y scale. 150/24 gives the scaled to 150x150, and knowing " +
                                "the original is 24x24, the scaling value can be found: (Custom Width/Original Width) for X scale, (Custom Height/Original Height) quotient of 6.25, which is not an integer scale and is " +
                                "detected as an issue. Since batch can not work with decimal values, the math ends up being 150x100/24 (multiply dividend by 100), which gives 625. The full decimal value can then be " +
                                "simulated by extracting the last two digits and concatenating what remains (6) with a period (.) and those last two digits (25).{0}" +
                                "{0}" +
                                "Next came checking textures for aspect ratio issues, which is again simple enough with the new custom texture format. The math is nearly identical, only this time its (Original or " +
                                "Custom Width/Height). Calculating this for both the original and the custom texture should end up with the same quotient. If they are not equal, then the textures have different aspect " +
                                "ratios and it's an issue. The same trickery (multiplying width x 100) is used to find the decimal value internally.{0}" +
                                "{0}" +
                                "Soon I realized that just checking the scaling values was not enough, 5.00x6.00 would pass because they are both integer scales. So error checking for uneven scales was implemented. I " +
                                "thought this took care of all issues, until I started running it on multiple packs. Seeing textures with 1.00x1.00 means it is not an HD texture, so that was added as an issue. There " +
                                "can also be duplicate textures named from the texture converter in dolphin that have a suffix appended such as: tex1_24x24_0804541083813079_14.1 or .2, .3, etc. So count that in too, " +
                                "and while we're at it, copy the found duplicate textures into a folder named '~DuplicateTextures'.{0}" +
                                "{0}" +
                                "Eventually came OptiPNG support. When two users named FreeEmulator and StripTheSoul were discussing this program on the Dolphin forums, and were looking for a batch solution, I figured " +
                                "why not add it to the script. This program optimizes the structure of PNG textures to help somewhat reduce their filesize losslessly. Seemed like a good feature, so I added it. The " +
                                "original code was awful as there was an entirely separate loop for it, but eventually it was written into the main loop.{0}" +
                                "{0}" +
                                "After all that was done, I released it as v2.0 and figured, okay it's good enough. But OCD eventually takes over, and I thought nope, I can do more. Mipmaps had to be deleted before " +
                                "being generated, which is gross and I wanted a much better system. Eventually I completely reworked mipmap handling:{0}" +
                                "{0}" +
                                "- Mipmap error checking: detect both missing mipmaps and and bad scales.{0}" +
                                "- Calculates what the mipmap dimensions should be.{0}" +
                                "- Calculates how many levels the mipmap texture should have.{0}" +
                                "- Find how many mipmap levels are actually in the texture folder.{0}" +
                                "- Use found mipmaps and generate missing mipmaps.{0}" +
                                "- Correctly scale mipmaps when converting textures to a fixed integer scale.{0}" +
                                "- Apply a sharpening filter to generated mipmaps.{0}" +
                                "- DDS: Combine all found mipmaps into a single texture with internal mipmaps.{0}" +
                                "{0}" +
                                "Speaking of DDS, along the way I also wanted to add support for that too. I worked on implementing both the new mipmap code and DDS support at the same time. It became a nightmare, and " +
                                "took over three weeks to get everything working properly because I'm a noob at this stuff (not constant work of course, but lots of time in those weeks). My first intentions were to use " +
                                "ImageMagick for everything and soon realized that it's not going to happen. ImageMagick DDS support was terrible and I could not accomplish anything that I wanted other than error " +
                                "checking. I then stumbled onto nvidia's DDS Utilities which had much more functionality than ImageMagick for the DDS format, and it allowed merging multiple images as mipmap layers. " +
                                "Everything I wanted.{0}" +
                                "{0}" +
                                "Actually getting everything to work the way I wanted to soon proved to be an arduous task. I have a good understanding of logic, but I am not a programmer, and doing this in batch " +
                                "started to seem hopeless. There were several issues to overcome. The first was that PNG images fed into DDS Utilities must have dimensions that are a multiple of 4, there is no auto " +
                                "correction. So, I had to do these calculations myself, and at the time I was really overthinking of how it should be done. The first solution I came up with, was to continually subtract " +
                                "4 from the dimensions, until something less than 4 was hit (0-3). With that, I knew how much the texture was off by and could just add the differences to the texture dimensions. But " +
                                "this was SLOW, and you can get bunk dimensions! Rethinking it, I came up with a simpler solution: Dimension / 4, if it has decimal, add 1 to dimension. Test again, if fails, add 1 " +
                                "again. This means only a total of up to 3 loop iterations, as opposed to potentially 100's depending on the texture resolution. Now, I needed a PNG image with these new dimensions, so " +
                                "generate a temporary image. Now use that to make a DDS file, and delete the temporary image. All of this was invisible to the user and happened in milliseconds.{0}" +
                                "{0}" +
                                "DDS can also have internal mipmaps, and while the master branch of Dolphin does not make use of them, Tino's Dolphin Ishiiruka can use them. Adding support for internal mipmaps was not " +
                                "an easy task, especially when trying to detect if a texture currently has them or not. Luckily Nvidia Toolss has the 'detach' command which can extract all mipmaps. Cool, calculate how " +
                                "many it should have, extract them, count them, and delete them. With the use of the 'stitch' command, all mipmaps found in the texture pack can now be used as internal mipmaps when " +
                                "generating DDS textures.{0}" +
                                "{0}" +
                                "Now theres the issue with scaling DDS textures to a new integer scale, and detecting problems with scaling. Some scales will not line up, a texture with dimensions 25x26 for example, " +
                                "will not end up with multiple four dimensions using an integer scale of 7. It ends up as 175x182, which are not valid DDS dimensions. Using the formula mentioned before, the new DDS " +
                                "dimensions will end up as 176x184, but now the scale will be bad (7.04x7.07). There is nothing that can be done about that, so for DDS there are only checks that validate the dimensions " +
                                "(based on the closest width integer scale, 7 in this case), and not the actual scale or aspect ratio.{0}" +
                                "{0}" +
                                "The last obstacle was that textures with transparency should be compressed with BC3, and textures without transparency should be compressed with BC1. Luckily, ImageMagick contains " +
                                "functions that can test if a PNG or DDS texture has an alpha channel and whether or not it has any transparent pixels. In the batch versions of the script, I did not know how to make " +
                                "use of the transparency feature, so all textures with an alpha channel were compressed with BC3. Of course since the PowerShell versions, this is no longer the case.{0}" +
                                "{0}" +
                                "I started to realize that Batch was far too limited, and I'm always striving for... something more. As mentioned before one of the biggest limitations of Batch is its inability to use " +
                                "decimals. Everything must be multiplied by 100 before doing the actual equations to simulate two decimal places. Another big roadblock I hit was paths using ampersands (& symbol). In " +
                                "batch this means 'AND DO', so a folder named 'Bionis Leg & Colony 6' will be seen as: '...Bions Leg' AND DO 'Colony 6', and batch will say 'WHAT!?' and the script will halt. Using " +
                                "quotes can circumvent this, but when passing a variable containing a path into a function as a parameter, the quotes are ignored within the function's actions and the same problem " +
                                "happens. Through experimentation I learned that surrounding the value within the function with even more quotes will fix this, but now the path has quotes in it that are not ignored, " +
                                "that need to be eliminated with further string manipulation. ARGH! There are many other annoyances that I came across, but these two things were the biggest roadblocks to progress.{0}" +
                                "{0}" +
                                "Okay so much of the past few paragraphs were copy and pasted from my previous story which was before the PS versions existed, so it's back to manually typing up this most likely " +
                                "pointless saga. So anyway, after realizing how weak batch was, I began to translate my code into PowerShell. It actually didn't take very long, maybe three weeks at the most. I really " +
                                "liked PowerShell because it was very similar to the scripting language used in WarCraft III. The first thing I did after getting it functional was testing the speed of the main loop " +
                                "because Batch loops were incredibly slow. The results were amazing! Analysing the PNG Paper Mario: TTYD pack was almost 5 times faster! The DDS pack didn't see the same gains " +
                                "unfortunately, but it was still about 40% faster. The reason is because I still have to rely on ImageMagick to analyze DDS textures, but PNG texture information can be retrieved using " +
                                ".NET which is much faster than ImageMagick.{0}" +
                                "{0}" +
                                "So CTT-PS was born and released. After v1.0, a user on the forums named 'MeleeHD' informed me of a method that another user 'uncleiroh' came up with that involved applying a watermark " +
                                "of the texture's name over the texture to easily identify it in-game. I thought this was a great idea, but the solution uncleiroh came up with was somewhat convoluted so I set out to " +
                                "see if I could do the same thing with ImageMagick and my script. It didn't take too long, and a new feature was born. Credits to those guys.{0}" +
                                "{0}" +
                                "After many bug fix versions and general quality of life changes later, Tino came up with a new kind of texture: the material map. This proved to be my next big conquest. Since I have " +
                                "a texture tool that is supposed to work with Dolphin textures, adding support for these textures was a top priority. I honestly did not understand much about them, the idea of bump, " +
                                "spec, and nrm textures was completely alien to me. And to make it even more complicating, Tino made a tool to combine these textures into a single texture. I attempted to find a way to " +
                                "also create these textures on my own, but I just didn't have the know-how. Then it struck me... Tino's tool can already do it, so why not ask him to support command line so his tool " +
                                "can also work with my tool? So I did just that, and he was very willing to offer his help and make modifications to his tool. I am still grateful to this day. After many weeks of bug " +
                                "testing and many failed implementations, we both eventually got everything right so working with material maps finally became a reality.{0}" +
                                "{0}" +
                                "Time passes and Dolphin forum goers continue to fill my head with ideas. For example, a Twilight Princess texture pack creator named 'Victor Rosa' had a bunch of mipmaps for textures " +
                                "that weren't actually mipmap textures in his pack. I wanted to create an option in my tool to delete these textures, but I did not want my script to actually modify texture packs " +
                                "directly. Thus, the 'Advanced Options' were born. A set of options that can specifically modify texture packs directly that are cast aside form the main options. Not long after I " +
                                "thought it would be nice to have an advanced option to directly generate new mipmaps. I know the texture pack author 'General_Han_Solo' used my very early mipmap generation scripts so " +
                                "I thought hey, if anybody will use this option maybe it will be him.{0}" +
                                "{0}" +
                                "It wasn't long after that another forum user 'masterotaku' asked if the script could apply a nearest neighbor (point) filter to all textures. The script did not have a feature to apply " +
                                "upscaling filters, so I thought why not. I then added support for several generic filters. Later, forum user 'Lumbeeslayer' asks for xBRZ support, so I contacted the xBRZ author " +
                                "'Zenju' to see if he would add command line support to his ScalerTest application. As it turns out, everyone always seems willing to help so xBRZ support was added. Later yet, another " +
                                "forum user 'CyberGlitch' mentions the waifu2x filter and how amazing the results can be. So I eventually worked on implementing that as well. He also gave me the fantastic idea of what " +
                                "is now known in the script as the 'Seamless Method' when upscaling textures with filters. This method tiles a texture 9 times before applying the filter so the texture has adjacent " +
                                "pixels to work with, then the outer 8 tiles are cropped away and you are left with a perfectly seamless texture.{0}" +
                                "{0}" +
                                "After the upscaling filters, I realized there really isn't much left I can do image-wise. So I decided to implement some ideas that I've had since the beginning but did not have the " +
                                "necessary skills to accomplish. One such feature is the ability to combine multiple textures into a single texture, and then split them back up when the combined texture has been " +
                                "retextured. I honestly don't know how useful this can be outside of making a sliding puzzle or working on N64 VC games, but I thought nobody else has done this, so why not?{0}" +
                                "{0}" +
                                "So now I really was out of ideas, and it was time to tackle the final conquest, the one I dreamed about since working on the Batch script: a GUI. I knew it was possible for a long " +
                                "time, it was no mystery PowerShell can make use of .NET framework directly as I've already done it on several occasions. The script has had some GUI elements for quite some time, " +
                                "albeit very basic elements such as Open File dialogs and the like. But now it was time to make my dream a reality and learn about Windows Forms. Holy shit is there ever a ton of  " +
                                "information to process. Remember, I'm not a programmer, so all of this was extremely confusing at first. I've made GUI's in StarCraft 2 maps but this was about 80% more complicating. " +
                                "So for a few weeks I hacked away at it in secret, eventually made a reveal, then eventually released it. Sweet, a GUI and it works! Plus I was even able to keep 'Script Mode'.{0}" +
                                "{0}" +
                                "And that's the end of my story, and I'm most likely reaching the end of this tool. It has already evolved way beyond anything I ever thought I could create. I know it's nothing " +
                                "special, but to me personally it is. I have started countless projects over the years, but I have never once saw one through to the end; meaning, reaching a point where I can say 'Yep, " +
                                "I did good. It's finally done.', nor felt that what I created could actually be useful to anyone. I'm somewhat proud of this tool, and it's gotten to a point where it can even reach " +
                                "beyond Dolphin textures with the option 'Expert Mode' option, meaning anyone could use it for their texture projects with any type of game.{0}" +
                                "{0}" +
                                "If you actually read this far, I have to compliment you on your stamina to sit through and actually read all of this. Unless you just skipped to the end, can't say I blame you.{0}{0}"

                        # Set the text on the window and highlight certain words and phrases.
                        $HelpDescription.Text = [String]::Format($Text, [Environment]::NewLine)
                        SetStringFont -FindString @("Custom Texture Tool PS - The Beginning to the End") -Font @($FontSize13)
                      }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI - HELP DIALOG CREATE
#==============================================================================================================================================================================================
#  Change the icon when the help topic is expanded.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ExpandHelpTopic()
{
  # Store this in a variable or it gets lost in the switch for some reason.
  $Topic = $_

  # Choose the correct icon based on the current image index.
  switch ($Topic.Node.ImageIndex)
  {
    "0" { $Topic.Node.ImageIndex = $Topic.Node.SelectedImageIndex = 1 }
    "3" { $Topic.Node.ImageIndex = $Topic.Node.SelectedImageIndex = 4 }
  }
}
#==============================================================================================================================================================================================
#  Change the icon when the help topic is collapsed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CollapseHelpTopic()
{
  # Store this in a variable or it gets lost in the switch for some reason.
  $Topic = $_

  # Choose the correct icon based on the current image index.
  switch ($Topic.Node.ImageIndex)
  {
    "1" { $Topic.Node.ImageIndex = $Topic.Node.SelectedImageIndex = 0 }
    "4" { $Topic.Node.ImageIndex = $Topic.Node.SelectedImageIndex = 3 }
  }
}
#==============================================================================================================================================================================================
#  Zoom in on text in the Help Dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function HelpTextZoomIn()
{
  # Do not allow the zoom factor to exceed the size of 4.
  if ($HelpDescription.ZoomFactor -lt 4)
  {
    # Increment the zoom factor in tenths.
    $HelpDescription.ZoomFactor = ($HelpDescription.ZoomFactor + 0.1)
  }
}
#==============================================================================================================================================================================================
#  Zoom out from text in the Help Dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function HelpTextZoomOut()
{
  # Do not allow the zoom factor to fall below a size of 0.6.
  if ($HelpDescription.ZoomFactor -ge 0.6)
  {
    # Decrement the zoom factor in tenths.
    $HelpDescription.ZoomFactor = ($HelpDescription.ZoomFactor - 0.1)
  }
}
#==============================================================================================================================================================================================
#  Restore the default text zoom on the Help Dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function HelpTextZoomDefault()
{
  # The default zoom factor is a solid 1.0 so set it to that.
  $HelpDescription.ZoomFactor = 1.0
}
#==============================================================================================================================================================================================
#  Alters the zoom based on key presses.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function HelpTextZoomKeyPress()
{
  # Detect the key that was pressed.
  switch ($_.KeyCode)
  {
    # Peform the corresponding zoom function.
    'Oemplus'   { HelpTextZoomIn }
    'OemMinus'  { HelpTextZoomOut }
    'Back'      { HelpTextZoomDefault }
  }
}
#==============================================================================================================================================================================================
#  The slider controls the size of the treeview window.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function HelpUpdateSliderValue()
{
  # Adjust the values of the items that will need... adjusted.
  $TopicSizeX = (DPISize 260) + $this.Value
  $TopicSizeY = (DPISize 489) + $HelpDialog.Height - (DPISize 600)
  $DescSizeX  = (DPISize 650) - $this.Value + $HelpDialog.Width - (DPISize 950)
  $DescSizeY  = (DPISize 490) + $HelpDialog.Height - (DPISize 600)
  $DescLocatX = (DPISize 276) + $this.Value

  # Set the new values to the objects.
  $HelpTopics.Size = New-Object Drawing.Size($TopicSizeX, $TopicSizeY)
  $HelpDescription.Size = New-Object Drawing.Size($DescSizeX, $DescSizeY)
  $HelpDescription.Location = New-Object Drawing.Point($DescLocatX, (DPISize 30))
  $HelpDescriptionLabel.Location = New-Object Drawing.Point($DescLocatX, (DPISize 6))
}
#==============================================================================================================================================================================================
#  Adds a topic to the list, a sub-topic if $NodeB exists, or a sub-topic of a sub-topic if $NodeC is present.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AddHelpTopic([int]$NodeA, [int]$NodeB=-1, [int]$NodeC=-1, [int]$IconIndex, [string]$Topic)
{
  # Create the main topic if there are no sub-nodes.
  if ($NodeB -lt 0)
  {
    $HelpTopics.Nodes.Add($Topic) | Out-Null
    $HelpTopics.Nodes[$NodeA].Name = $Topic
    $HelpTopics.Nodes[$NodeA].ImageIndex = $IconIndex
    $HelpTopics.Nodes[$NodeA].SelectedImageIndex = $IconIndex
  }
  # One sub-node deep if B exists.
  elseif ($NodeC -lt 0)
  {
    $HelpTopics.Nodes[$NodeA].Nodes.Add($Topic) | Out-Null
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].Name = $Topic
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].ImageIndex = $IconIndex
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].SelectedImageIndex = $IconIndex
  }
  # Now we're going two sub-nodes deep.
  else
  {
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].Nodes.Add($Topic) | Out-Null
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].Nodes[$NodeC].Name = $Topic
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].Nodes[$NodeC].ImageIndex = $IconIndex
    $HelpTopics.Nodes[$NodeA].Nodes[$NodeB].Nodes[$NodeC].SelectedImageIndex = $IconIndex
  }
}
#==============================================================================================================================================================================================
#  Gets the size of the help buttons.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function GetHelpButtonDPISize()
{
  # If we're going high DPI then we need to scale the icons.
  if ($HighDPIEnabled)
  {
    # The icons will need to be scaled to the appropriate DPI setting.
    switch ($Monitor.DPI)
    {
      # Calculating size with the DPI Multiplier would work, but I want 
      # to use the same size image for every 2 DPI settings to avoid blurring.
      {$_ -lt 168}   { return New-Object Drawing.Size(16, 16) }
      {$_ -lt 192}   { return New-Object Drawing.Size(24, 24) }
      default        { return New-Object Drawing.Size(32, 32) }
    }
  }
  # Just return the default size if high DPI is disabled.
  return New-Object Drawing.Size(16, 16)
}
#==============================================================================================================================================================================================
#  Create the help dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_HelpMenu()
{
  # Create the dialog and set up properties.
  $global:HelpDialog = New-Object Windows.Forms.Form
  $HelpDialog.Size = DPISize (New-Object Drawing.Size(950, 600))
  $HelpDialog.MinimumSize = DPISize (New-Object Drawing.Size(550, 300))
  $HelpDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $HelpDialog.Text = 'CTT-PS Help'
  $HelpDialog.MaximizeBox = $true
  $HelpDialog.MinimizeBox = $true
  $HelpDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $HelpDialog.FormBorderStyle = [Windows.Forms.FormBorderStyle]::Sizable
  $HelpDialog.StartPosition = "CenterScreen"
  $HelpDialog.KeyPreview = $true
  $HelpDialog.Add_FormClosing({$HelpDialog.Hide() ; $_.Cancel = $true})
  $HelpDialog.Add_KeyDown({ EscapeCloseDialog ; HelpTextZoomKeyPress })
  $HelpDialog.Add_Shown({ ActivateDialog -Dialog $HelpDialog })
  $HelpDialog.Add_SizeChanged({ MinimizeAllDialogs })
  $HelpDialog.Icon = $Icon_CTTPSGold

  # Create a label for the help topics.
  $global:HelpTopicsLabel = New-Object Windows.Forms.Label
  $HelpTopicsLabel.Size = DPISize (New-Object Drawing.Size(120, 18))
  $HelpTopicsLabel.Location = DPISize (New-Object Drawing.Point(8, 6))
  $HelpTopicsLabel.Font = New-Object Drawing.Font('Tahoma', 11, [Drawing.FontStyle]::Bold)
  $HelpTopicsLabel.Text = 'Help Topics:'
  $HelpDialog.Controls.Add($HelpTopicsLabel)

  # Construct the ImageList.
  $global:HelpIcons = New-Object Windows.Forms.ImageList
  $HelpIcons.Images.Add($Help_BookClosed)
  $HelpIcons.Images.Add($Help_BookOpen)
  $HelpIcons.Images.Add($Help_SinglePage)
  $HelpIcons.Images.Add($Help_StackClosed)
  $HelpIcons.Images.Add($Help_StackOpen)

  # Get the size of the buttons based on the current DPI.
  $HelpIcons.ImageSize = GetHelpButtonDPISize
  
  # Create a tree view to hold the help topics.
  $global:HelpTopics = New-Object Windows.Forms.TreeView
  $HelpTopics.Size = DPISize (New-Object Drawing.Size(260, 489))
  $HelpTopics.Location = DPISize (New-Object Drawing.Point(8, 30))
  $HelpTopics.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8)
  $HelpTopics.ImageList = $HelpIcons
  $HelpTopics.Anchor = ([Windows.Forms.AnchorStyles]::Top, [Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Left)

  # Create the introduction Help topics.
  AddHelpTopic -NodeA 0                    -IconIndex 0 -Topic 'Introduction'
  AddHelpTopic -NodeA 0 -NodeB 0           -IconIndex 2 -Topic 'Requirements'
  AddHelpTopic -NodeA 0 -NodeB 1           -IconIndex 2 -Topic 'Features'
  AddHelpTopic -NodeA 0 -NodeB 2           -IconIndex 2 -Topic 'Information'
  AddHelpTopic -NodeA 0 -NodeB 3           -IconIndex 2 -Topic 'Quick Guide'

  # Create the Requirements Help topics.
  AddHelpTopic -NodeA 1                    -IconIndex 0 -Topic 'Supported Programs'
  AddHelpTopic -NodeA 1 -NodeB 0           -IconIndex 2 -Topic 'ImageMagick'
  AddHelpTopic -NodeA 1 -NodeB 1           -IconIndex 2 -Topic 'DirectXTex TexConv'
  AddHelpTopic -NodeA 1 -NodeB 2           -IconIndex 2 -Topic 'Compressonator'
  AddHelpTopic -NodeA 1 -NodeB 3           -IconIndex 2 -Topic 'Material Map Generator'
  AddHelpTopic -NodeA 1 -NodeB 4           -IconIndex 2 -Topic 'Ishiiruka Tool'
  AddHelpTopic -NodeA 1 -NodeB 5           -IconIndex 2 -Topic 'Dolphin TextureExtractor Tool'
  AddHelpTopic -NodeA 1 -NodeB 6           -IconIndex 2 -Topic 'PNG Optimizers'
  AddHelpTopic -NodeA 1 -NodeB 7           -IconIndex 2 -Topic 'xBRZ ScalerTest'
  AddHelpTopic -NodeA 1 -NodeB 8           -IconIndex 2 -Topic 'Waifu2x'
  AddHelpTopic -NodeA 1 -NodeB 9           -IconIndex 2 -Topic '7-Zip'
  AddHelpTopic -NodeA 1 -NodeB 10          -IconIndex 2 -Topic 'Python'
  AddHelpTopic -NodeA 1 -NodeB 11          -IconIndex 2 -Topic 'ESRGAN'
  AddHelpTopic -NodeA 1 -NodeB 12          -IconIndex 2 -Topic 'SFTGAN'
  AddHelpTopic -NodeA 1 -NodeB 13          -IconIndex 2 -Topic 'Sen-no-Kiseki PKG Tool'

  # Create the Main Window Help topics.
  AddHelpTopic -NodeA 2                    -IconIndex 0 -Topic 'Main Window'
  AddHelpTopic -NodeA 2 -NodeB 0           -IconIndex 2 -Topic 'Process Selected'
  AddHelpTopic -NodeA 2 -NodeB 1           -IconIndex 3 -Topic 'CTT-PS Options'
  AddHelpTopic -NodeA 2 -NodeB 1 -NodeC 0  -IconIndex 2 -Topic 'CTT-PS Mode'
  AddHelpTopic -NodeA 2 -NodeB 1 -NodeC 1  -IconIndex 2 -Topic 'Texture List'
  AddHelpTopic -NodeA 2 -NodeB 2           -IconIndex 2 -Topic 'Input Path'
  AddHelpTopic -NodeA 2 -NodeB 3           -IconIndex 2 -Topic 'Output Path'

  # Create the Operations list.
  AddHelpTopic -NodeA 2 -NodeB 4           -IconIndex 3 -Topic 'Operation'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 0  -IconIndex 2 -Topic 'Create Texture Size Database'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 1  -IconIndex 2 -Topic 'Scan Dolphin/Database Textures For Issues'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 2  -IconIndex 2 -Topic 'Convert Textures to Another Format'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 3  -IconIndex 2 -Topic 'Rescale Textures With New Scaling Factor'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 4  -IconIndex 2 -Topic 'Resize Textures With Specific Dimensions'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 5  -IconIndex 2 -Topic 'Add Identifying Watermark to All Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 6  -IconIndex 2 -Topic 'Create Materials With Material Map Generator'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 7  -IconIndex 2 -Topic 'Create Material Maps With Ishiiruka Tool'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 8  -IconIndex 2 -Topic 'Optimize PNG Textures With Optimizer Program'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 9  -IconIndex 2 -Topic 'Apply Upscaling Filter to All Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 10 -IconIndex 2 -Topic 'Calculate Textures VRAM Requirement'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 11 -IconIndex 2 -Topic 'Generate New Mipmaps For Dolphin Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 12 -IconIndex 2 -Topic 'Remove Invalid Mipmaps From Dolphin Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 13 -IconIndex 2 -Topic 'Extract Internal Mipmaps'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 14 -IconIndex 2 -Topic 'Remove Alpha Channel From Opaque Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 15 -IconIndex 2 -Topic 'Combine Multiple Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 16 -IconIndex 2 -Topic 'Split Combined Multi-Texture'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 17 -IconIndex 2 -Topic 'Add/Remove Arbitrary Mipmap Suffix'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 18 -IconIndex 2 -Topic 'PNG Alpha Pixel Manipulation'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 19 -IconIndex 2 -Topic 'Separate/Combine Texture RGBA Channels'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 20 -IconIndex 2 -Topic 'Basic Image Viewer'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 21 -IconIndex 2 -Topic 'Dolphin Resource Pack Manager'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 22 -IconIndex 2 -Topic 'Run Custom CLI Executable With CTT-PS'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 23 -IconIndex 2 -Topic 'Extract Trails of Cold Steel PKA Files'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 24 -IconIndex 2 -Topic 'Extract Trails of Cold Steel PKG Files'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 25 -IconIndex 2 -Topic 'Convert Phyre Textures to PNG Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 26 -IconIndex 2 -Topic 'Create Phyre Textures From PNG/Phyre'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 27 -IconIndex 2 -Topic 'Repack Folders/Textures Into PKG Files'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 28 -IconIndex 2 -Topic 'Create New Metroid Prime 2 Fonts From Base Textures'
  AddHelpTopic -NodeA 2 -NodeB 4 -NodeC 29 -IconIndex 2 -Topic 'Extract Textures With TextureExtraction Tool'

  # Create DDS Options list.
  AddHelpTopic -NodeA 2 -NodeB 5           -IconIndex 3 -Topic 'DDS Options'
  AddHelpTopic -NodeA 2 -NodeB 5 -NodeC 0  -IconIndex 2 -Topic 'DDS Tool'
  AddHelpTopic -NodeA 2 -NodeB 5 -NodeC 1  -IconIndex 2 -Topic 'DDS Format'
  AddHelpTopic -NodeA 2 -NodeB 5 -NodeC 2  -IconIndex 2 -Topic 'DDS Fallback'
  AddHelpTopic -NodeA 2 -NodeB 5 -NodeC 3  -IconIndex 2 -Topic 'Tool Options'
  AddHelpTopic -NodeA 2 -NodeB 5 -NodeC 4  -IconIndex 2 -Topic 'Flag Removal'
  AddHelpTopic -NodeA 2 -NodeB 5 -NodeC 5  -IconIndex 2 -Topic 'Force DX10 Header'

  # Create Mipmap Options list.
  AddHelpTopic -NodeA 2 -NodeB 6           -IconIndex 3 -Topic 'Mipmap Options'
  AddHelpTopic -NodeA 2 -NodeB 6 -NodeC 0  -IconIndex 2 -Topic 'Disable Mipmap Generation'
  AddHelpTopic -NodeA 2 -NodeB 6 -NodeC 1  -IconIndex 2 -Topic 'Force New Mipmaps'
  AddHelpTopic -NodeA 2 -NodeB 6 -NodeC 2  -IconIndex 2 -Topic 'Create From Top Level'
  AddHelpTopic -NodeA 2 -NodeB 6 -NodeC 3  -IconIndex 2 -Topic 'Max Mipmap Levels'
  AddHelpTopic -NodeA 2 -NodeB 6 -NodeC 4  -IconIndex 2 -Topic 'External Mipmaps'
  AddHelpTopic -NodeA 2 -NodeB 6 -NodeC 5  -IconIndex 2 -Topic 'Force Create Mipmaps'

  # Create the Options Panel Help topics.
  AddHelpTopic -NodeA 3                    -IconIndex 0 -Topic 'Options Menu'
  AddHelpTopic -NodeA 3 -NodeB 0           -IconIndex 2 -Topic 'Tool Paths'

  # Create the Options Panel Preferences list.
  AddHelpTopic -NodeA 3 -NodeB 1           -IconIndex 3 -Topic 'Preferences'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 0  -IconIndex 2 -Topic 'Save any changes made to all options on exit'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 1  -IconIndex 2 -Topic 'Store/load saved changes in "CTT-PS Data" folder'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 2  -IconIndex 2 -Topic 'Run PowerShell scripts with a double click (Registry Modification)'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 3  -IconIndex 2 -Topic 'Create a log file of all textures processed'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 4  -IconIndex 2 -Topic 'Recurse through all folders found in the "Input Path"'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 5  -IconIndex 2 -Topic 'Overwrite textures in the "Output Path" if they already exist'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 6  -IconIndex 2 -Topic 'Automatically remove empty folders from the "Output Path"'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 7  -IconIndex 2 -Topic 'Dialog Update Rate (in Milliseconds)'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 8  -IconIndex 2 -Topic 'Disable forcing the GUI as the top-most window'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 9  -IconIndex 2 -Topic 'Minimize visible windows separately from each other'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 10 -IconIndex 2 -Topic 'Enable modern Windows visual styles'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 11 -IconIndex 2 -Topic 'Show a "Quick Help" icon near the "Operation" list'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 12 -IconIndex 2 -Topic 'Show WebLink icons on the "Tool Paths" menu'
  AddHelpTopic -NodeA 3 -NodeB 1 -NodeC 13 -IconIndex 2 -Topic 'Clear textboxes while holding Shift/Alt/Control when clicking'

  # Continue the Options Panel Help topics.
  AddHelpTopic -NodeA 3 -NodeB 2           -IconIndex 2 -Topic 'Exclusions'
  AddHelpTopic -NodeA 3 -NodeB 3           -IconIndex 2 -Topic 'Miscellaneous'

  # Create the debug list.
  AddHelpTopic -NodeA 3 -NodeB 4           -IconIndex 3 -Topic 'Debug'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 0  -IconIndex 2 -Topic 'Show the PowerShell Console window'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 1  -IconIndex 2 -Topic 'Disable auto-centering the PowerShell console on launch'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 2  -IconIndex 2 -Topic 'Force show BC7 on DDS Format list without TexConv'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 3  -IconIndex 2 -Topic 'Disable CTT-PS from writing custom DDS headers'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 4  -IconIndex 2 -Topic 'Dump CTT-PS icons on Desktop when launched'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 5  -IconIndex 2 -Topic 'Show a [!] button near "Exit" that closes without saving'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 6  -IconIndex 2 -Topic 'Disable High DPI Scaling (Requires Restart)'
  AddHelpTopic -NodeA 3 -NodeB 4 -NodeC 7  -IconIndex 2 -Topic 'Split/Combine Textures Grid Array/Garbage Pixel Limit'

  # Create the option buttons list.
  AddHelpTopic -NodeA 3 -NodeB 5           -IconIndex 3 -Topic 'Options Buttons'
  AddHelpTopic -NodeA 3 -NodeB 5 -NodeC 0  -IconIndex 2 -Topic 'Restore Defaults'
  AddHelpTopic -NodeA 3 -NodeB 5 -NodeC 1  -IconIndex 2 -Topic 'Import Stored Options'

  # Create the Guides Help topics.
  AddHelpTopic -NodeA 4                    -IconIndex 0 -Topic 'Guides'
  AddHelpTopic -NodeA 4 -NodeB 0           -IconIndex 2 -Topic 'Creating DDS Packs'
  AddHelpTopic -NodeA 4 -NodeB 1           -IconIndex 2 -Topic 'Rescaling Packs'
  AddHelpTopic -NodeA 4 -NodeB 2           -IconIndex 2 -Topic 'Mipmap Tutorial'
  AddHelpTopic -NodeA 4 -NodeB 3           -IconIndex 2 -Topic 'Creating Mipmaps with CTT-PS'
  AddHelpTopic -NodeA 4 -NodeB 4           -IconIndex 2 -Topic 'Material Maps and Ishiiruka Tool'

  # Create the Final sections.
  AddHelpTopic -NodeA 5                    -IconIndex 2 -Topic 'Credits'
  AddHelpTopic -NodeA 6                    -IconIndex 2 -Topic 'About'

  # Toggles the closed/open book icons when the nodes are expanded/collapsed.
  $HelpTopics.Add_AfterExpand({ ExpandHelpTopic })
  $HelpTopics.Add_AfterCollapse({ CollapseHelpTopic })

  # Set up the selection event and add the tree view to the help dialog.
  $HelpTopics.Add_AfterSelect({ GUI_DisplayHelpTopic })

  # Add the help topics treeview to the Help Dialog.
  $HelpDialog.Controls.Add($HelpTopics)

  # Create a label for the help topic description.
  $global:HelpDescriptionLabel = New-Object Windows.Forms.Label
  $HelpDescriptionLabel.Size = DPISize (New-Object Drawing.Size(120, 18))
  $HelpDescriptionLabel.Location = DPISize (New-Object Drawing.Point(276, 6))
  $HelpDescriptionLabel.Font = New-Object Drawing.Font('Tahoma', 11, [Drawing.FontStyle]::Bold)
  $HelpDescriptionLabel.Text = 'Description:'
  $HelpDialog.Controls.Add($HelpDescriptionLabel)

  # Create a textbox to hold the help topic description.
  $global:HelpDescription = New-Object Windows.Forms.RichTextBox
  $HelpDescription.Size = DPISize (New-Object Drawing.Size(650, 490))
  $HelpDescription.Location = DPISize (New-Object Drawing.Point(276, 30))
  $HelpDescription.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $HelpDescription.Text = 'I AM ERROR'
  $HelpDescription.ReadOnly = $true
  $HelpDescription.BackColor = [Drawing.SystemColors]::Window
  $HelpDescription.BulletIndent = 15
  $HelpDescription.DetectUrls = $true
  $HelpDescription.TabStop = $false
  $HelpDescription.Anchor = ([Windows.Forms.AnchorStyles]::Top, [Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Right)
  $HelpDescription.Add_LinkClicked({[Diagnostics.Process]::Start($_.LinkText)})
  $HelpDialog.Controls.Add($HelpDescription)

  # Create a panel to hold the treeview size slider.
  $global:HelpSliderGroup = New-Object Windows.Forms.Panel
  $HelpSliderGroup.Size = DPISize (New-Object Drawing.Size(200, 40))
  $HelpSliderGroup.Location = DPISize (New-Object Drawing.Point(8, 518))
  $HelpSliderGroup.Anchor = ([Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Left)
  $HelpDialog.Controls.Add($HelpSliderGroup)

  # Create a label for the panel.
  $global:HelpSliderLabel = New-Object Windows.Forms.Label
  $HelpSliderLabel.Size = DPISize (New-Object Drawing.Size(76, 18))
  $HelpSliderLabel.Location = DPISize (New-Object Drawing.Point(4, 13))
  $HelpSliderLabel.Font = New-Object Drawing.Font('Tahoma', 11, [Drawing.FontStyle]::Bold)
  $HelpSliderLabel.Text = 'List Size:'
  $HelpSliderGroup.Controls.Add($HelpSliderLabel)

  # Create a slider for the panel.
  $global:HelpSliderTrackBar = New-Object Windows.Forms.TrackBar
  $HelpSliderTrackBar.Size = DPISize (New-Object Drawing.Size(110, 10))
  $HelpSliderTrackBar.Location = DPISize (New-Object Drawing.Point(80, 12))
  $HelpSliderTrackBar.Value = 0
  $HelpSliderTrackBar.Font = New-Object Drawing.Font('Tahoma', 11, [Drawing.FontStyle]::Bold)
  $HelpSliderTrackBar.TickStyle = 'None'
  $HelpSliderTrackBar.Minimum = -260
  $HelpSliderTrackBar.Maximum = 100
  $HelpSliderTrackBar.Value = 0
  $HelpSliderTrackBar.TickFrequency = 5
  $HelpSliderTrackBar.SmallChange = 5
  $HelpSliderTrackBar.LargeChange = 10
  $HelpSliderTrackBar.Add_Scroll({ HelpUpdateSliderValue })
  $HelpSliderGroup.Controls.Add($HelpSliderTrackBar)

  # Create a panel to hold the zoom controls.
  $global:HelpZoomPanel = New-Object Windows.Forms.Panel
  $HelpZoomPanel.Size = DPISize (New-Object Drawing.Size(200, 40))
  $HelpZoomPanel.Location = DPISize (New-Object Drawing.Point(276, 518))
  $HelpZoomPanel.Anchor = ([Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Left)
  $HelpDialog.Controls.Add($HelpZoomPanel)

  # Create a label for the groupbox.
  $global:HelpZoomLabel = New-Object Windows.Forms.Label
  $HelpZoomLabel.Size = DPISize (New-Object Drawing.Size(93, 18))
  $HelpZoomLabel.Location = DPISize (New-Object Drawing.Point(4, 13))
  $HelpZoomLabel.Font = New-Object Drawing.Font('Tahoma', 11, [Drawing.FontStyle]::Bold)
  $HelpZoomLabel.Text = 'Text Zoom:'
  $HelpZoomPanel.Controls.Add($HelpZoomLabel)

  # Create a button to zoom out the text.
  $global:HelpZoomOutButton = New-Object Windows.Forms.Button
  $HelpZoomOutButton.Size = DPISize (New-Object Drawing.Size(29, 29))
  $HelpZoomOutButton.Location = DPISize (New-Object Drawing.Point(100, 8))
  $HelpZoomOutButton.Text = '-'
  $HelpZoomOutButton.Add_Click({ HelpTextZoomOut })
  $HelpZoomOutButton.TabStop = $false
  $HelpZoomPanel.Controls.Add($HelpZoomOutButton)

  # Zoom out button tooltip.
  $HelpZoomOutTip = New-Object Windows.Forms.ToolTip
  $HelpZoomOutTip.InitialDelay = $ToolTipDelay
  $HelpZoomOutTip.AutoPopDelay = $ToolTipDuration
  $HelpZoomOutTipString = 'Zoom out the text, making it smaller. (Hotkey: -)'
  $HelpZoomOutTip.SetToolTip($HelpZoomOutButton, $HelpZoomOutTipString)

  # Create a button to zoom in the text.
  $global:HelpZoomInButton = New-Object Windows.Forms.Button
  $HelpZoomInButton.Size = DPISize (New-Object Drawing.Size(29, 29))
  $HelpZoomInButton.Location = DPISize (New-Object Drawing.Point(131, 8))
  $HelpZoomInButton.Text = '+'
  $HelpZoomInButton.Add_Click({ HelpTextZoomIn })
  $HelpZoomInButton.TabStop = $false
  $HelpZoomPanel.Controls.Add($HelpZoomInButton)

  # Zoom in button tooltip.
  $HelpZoomInTip = New-Object Windows.Forms.ToolTip
  $HelpZoomInTip.InitialDelay = $ToolTipDelay
  $HelpZoomInTip.AutoPopDelay = $ToolTipDuration
  $HelpZoomInTipString = 'Zoom in on the text, making it bigger. (Hotkey: +)'
  $HelpZoomInTip.SetToolTip($HelpZoomInButton, $HelpZoomInTipString)

  # Create a button to set the text to default size.
  $global:HelpZoomRestoreButton = New-Object Windows.Forms.Button
  $HelpZoomRestoreButton.Size = DPISize (New-Object Drawing.Size(29, 29))
  $HelpZoomRestoreButton.Location = DPISize (New-Object Drawing.Point(162, 8))
  $HelpZoomRestoreButton.Text = '='
  $HelpZoomRestoreButton.Add_Click({ HelpTextZoomDefault })
  $HelpZoomRestoreButton.TabStop = $false
  $HelpZoomPanel.Controls.Add($HelpZoomRestoreButton)

  # Restore Zoom button tooltip.
  $HelpZoomRestoreTip = New-Object Windows.Forms.ToolTip
  $HelpZoomRestoreTip.InitialDelay = $ToolTipDelay
  $HelpZoomRestoreTip.AutoPopDelay = $ToolTipDuration
  $HelpZoomRestoreTipString = 'Restore the zoom to its default value. (Hotkey: Backspace)'
  $HelpZoomRestoreTip.SetToolTip($HelpZoomRestoreButton, $HelpZoomRestoreTipString)

  # Create a button to close the help menu.
  $global:HelpCloseButton = New-Object Windows.Forms.Button
  $HelpCloseButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $HelpCloseButton.Location = DPISize (New-Object Drawing.Point(845, 526))
  $HelpCloseButton.Text = 'Close'
  $HelpCloseButton.Anchor = ([Windows.Forms.AnchorStyles]::Bottom, [Windows.Forms.AnchorStyles]::Right)
  $HelpCloseButton.Add_Click({ $HelpDialog.Hide() })
  $HelpDialog.Controls.Add($HelpCloseButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: HOTCODE DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $HotCodeDialog        - Form           - Global
#  $HotCodeTextBox       - RichTextBox    - Global
#  $HotCodeRunButton     - Button         - Global
#  $HotCodeClearButton   - Button         - Global
#  $HotCodeCloseButton   - Button         - Global
#==============================================================================================================================================================================================
#  Shows the dialog to run code from.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShowHotCodeDialog()
{
  # Let the user know what's up.
  $HotCodeDialog.Add_Shown({ ActivateDialog -Dialog $HotCodeDialog })
  $HotCodeDialog.Show() | Out-Null
}
#==============================================================================================================================================================================================
#  Runs the code when the "Run Code" button is pressed.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function RunHotCode()
{
  # Make sure the textbox is not empty.
  if ($HotCodeTextBox.Lines)
  {
    # Loop through each line in the text box.
    foreach ($Line in $HotCodeTextBox.Lines)
    {
      # Make sure the line actually contains text.
      if ($Line -ne '')
      {
        # Show the command that is being run.
        DebugMessage -Message ('Run Command: ' + $Line) -FollowUp ' '

        # Run the line as code.
        Invoke-Expression -Command $Line
      }
    }
  }
}
#==============================================================================================================================================================================================
#  CTT GUI: HOTCODE DIALOG CREATION
#==============================================================================================================================================================================================
#  Create the Hot Code dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_HotCodeDialog()
{
  # Create the dialog and set up properties.
  $global:HotCodeDialog = New-Object Windows.Forms.Form
  $HotCodeDialog.Size = DPISize (New-Object Drawing.Size(640, 480))
  $HotCodeDialog.MinimumSize = DPISize (New-Object Drawing.Size(300, 150))
  $HotCodeDialog.MaximumSize = DPISize (New-Object Drawing.Size(1280, 1024))
  $HotCodeDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $HotCodeDialog.Text = 'CTT-PS Custom Code'
  $HotCodeDialog.MaximizeBox = $false
  $HotCodeDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $HotCodeDialog.FormBorderStyle = [Windows.Forms.FormBorderStyle]::Sizable
  $HotCodeDialog.StartPosition = "CenterScreen"
  $HotCodeDialog.Topmost = $false
  $HotCodeDialog.Add_FormClosing({ $this.Hide() ; $_.Cancel = $true })
  $HotCodeDialog.Icon = $Icon_CTTPSGreen

  # Create a text box.
  $global:HotCodeTextBox = New-Object Windows.Forms.RichTextBox
  $HotCodeTextBox.Size = DPISize (New-Object Drawing.Size(617, 404))
  $HotCodeTextBox.Location = DPISize (New-Object Drawing.Point(4, 4))
  $HotCodeTextBox.Font = New-Object Drawing.Font("Consolas", 10)
  $HotCodeTextBox.ForeColor = [Drawing.Color]::White
  $HotCodeTextBox.BackColor = [Drawing.ColorTranslator]::FromHtml('#012456')
  $HotCodeTextBox.TabStop = $true
  $HotCodeTextBox.BorderStyle = [Windows.Forms.BorderStyle]::Fixed3D
  $HotCodeTextBox.Anchor = ( [Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Top, [Windows.Forms.AnchorStyles]::Bottom )
  $HotCodeDialog.Controls.Add($HotCodeTextBox)

  # Create the "Run" button.
  $global:HotCodeRunButton = New-Object Windows.Forms.Button
  $HotCodeRunButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $HotCodeRunButton.Location = DPISize (New-Object Drawing.Point(4, 410))
  $HotCodeRunButton.Text = 'Run Code'
  $HotCodeRunButton.Add_Click({ RunHotCode })
  $HotCodeRunButton.Anchor = ( [Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom )
  $HotCodeDialog.Controls.Add($HotCodeRunButton)

  # Create the "Clear" button.
  $global:HotCodeClearButton = New-Object Windows.Forms.Button
  $HotCodeClearButton.Size = DPISize (New-Object Drawing.Size(90, 28))
  $HotCodeClearButton.Location = DPISize (New-Object Drawing.Point(90, 410))
  $HotCodeClearButton.Text = 'Clear'
  $HotCodeClearButton.Add_Click({ $HotCodeTextBox.Text = '' })
  $HotCodeClearButton.Anchor = ( [Windows.Forms.AnchorStyles]::Left, [Windows.Forms.AnchorStyles]::Bottom )
  $HotCodeClearButton.Enabled = $false
  $HotCodeDialog.Controls.Add($HotCodeClearButton)
  
  # Create the "Close" button.
  $global:HotCodeCloseButton = New-Object Windows.Forms.Button
  $HotCodeCloseButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $HotCodeCloseButton.Location = DPISize (New-Object Drawing.Point(540, 410))
  $HotCodeCloseButton.Text = 'Close'
  $HotCodeCloseButton.Add_Click({ $HotCodeDialog.Hide() })
  $HotCodeCloseButton.Anchor = ( [Windows.Forms.AnchorStyles]::Right, [Windows.Forms.AnchorStyles]::Bottom )
  $HotCodeDialog.Controls.Add($HotCodeCloseButton)
}
#==============================================================================================================================================================================================
#  CTT GUI: SHUTDOWN DIALOG
#==============================================================================================================================================================================================
#  Properties: (variable/type/scope)
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#  $ShutdownDialog       - Form           - Global
#  $ShutdownLabel        - Label          - Global
#  $ShutdownCancelButton - Button         - Global
#==============================================================================================================================================================================================
#  The function to run when the shutdown timer ticks.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Shutdown_TimerTick()
{
  # Subtract 1 from the time remaining.
  $global:ShutdownDuration--
  
  # Display the time remaining on the label.
  $ShutdownLabel.Text = ' Operation finished. PC will shut down in ' + $ShutdownDuration.ToString() + ' seconds...'

  # If we've reached the end, then shutdown the PC.
  if (($ShutdownDuration -eq 0) -and ($AutoShutdown))
  {
    # There is no turning back now.
    Stop-Computer -ComputerName localhost -Force
  }
}
#==============================================================================================================================================================================================
#  The function to run when the dialog is shown.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ShutdownDialogShown()
{
  # Play a beep just in case the user is around.
  [Media.SystemSounds]::Beep.Play()

  # Signal that a shutdown is about to take place.
  $global:AutoShutdown = $true

  # The amount of seconds before the shutdown takes place.
  $global:ShutdownDuration = 30

  # Create a new timer that will expire every second.
  $global:ShutdownTimer = New-Object Windows.Forms.Timer
  $ShutdownTimer.Interval = 1000
  $ShutdownTimer.Add_Tick({ Shutdown_TimerTick })
  $ShutdownTimer.Start()
}
#==============================================================================================================================================================================================
#  If the cancel button is clicked, cancel the shutdown.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CancelShutdown()
{
  # Pause the timer.
  $ShutdownTimer.Stop()

  # Cancel the automatic shutdown.
  $global:AutoShutdown = $false

  # Set the label back to 30 seconds.
  $ShutdownLabel.Text = ' Operation finished. PC will shut down in 30 seconds...'

  # Hide the dialog from the user.
  $ShutdownDialog.Hide()
}
#==============================================================================================================================================================================================
#  CTT GUI: SHUTDOWN DIALOG CREATION
#==============================================================================================================================================================================================
#  Create the Shutdown dialog.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_ShutdownDialog()
{
  # Create the dialog and set up properties.
  $global:ShutdownDialog = New-Object Windows.Forms.Form
  $ShutdownDialog.Size = DPISize (New-Object Drawing.Size(320, 130))
  $ShutdownDialog.MinimumSize = DPISize (New-Object Drawing.Size(320, 130))
  $ShutdownDialog.MaximumSize = DPISize (New-Object Drawing.Size(320, 130))
  $ShutdownDialog.Font = New-Object Drawing.Font('Microsoft Sans Serif', 8.25)
  $ShutdownDialog.Text = 'Shutting Down PC...'
  $ShutdownDialog.MaximizeBox = $false
  $ShutdownDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $ShutdownDialog.FormBorderStyle = GetFormBorderStyle
  $ShutdownDialog.StartPosition = "CenterScreen"
  $ShutdownDialog.Topmost = $false
  $ShutdownDialog.Add_FormClosing({ $this.Hide() ; $_.Cancel = $true })
  $ShutdownDialog.Add_Shown({ ShutdownDialogShown })
  $ShutdownDialog.Icon = $Icon_CTTPSRed

  # When the script is paused and a program is running display this label. Used in "StartJobLoop".
  $global:ShutdownLabel = New-Object Windows.Forms.Label
  $ShutdownLabel.Size = DPISize (New-Object Drawing.Size(450, 16))
  $ShutdownLabel.Location = DPISize (New-Object Drawing.Point(12, 20))
  $ShutdownLabel.Text = ' Operation finished. PC will shut down in 30 seconds...'
  $ShutdownDialog.Controls.Add($ShutdownLabel)

  # Create the "Cancel" button.
  $global:ShutdownCancelButton = New-Object Windows.Forms.Button
  $ShutdownCancelButton.Size = DPISize (New-Object Drawing.Size(80, 28))
  $ShutdownCancelButton.Location = DPISize (New-Object Drawing.Point(110, 52))
  $ShutdownCancelButton.Text = 'Cancel'
  $ShutdownCancelButton.Add_Click({ CancelShutdown })
  $ShutdownDialog.Controls.Add($ShutdownCancelButton)
}
#==============================================================================================================================================================================================
#  INITIALIZATION: SET MASTER INPUT/OUTPUT PATHS
#==============================================================================================================================================================================================
#  Sets the Master Input and Output paths to the base path or a stored path from a previous run.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function SetMasterPath([bool]$StoreFolder, [string]$StoredPath, [string]$BackupPath, [string]$PathAddition)
{
  # Test if the user stored a texture folder using the checkbox.
  if (($StoreFolder) -and (TestPath -LiteralPath $StoredPath))
  {
    # If the folder exists, set the master path to the stored path.
    return $StoredPath + $PathAddition
  }
  # Otherwise just use the current folder the script is in.
  return $BackupPath + $PathAddition
}
#==============================================================================================================================================================================================
#  INITIALIZATION: ENABLE VISUAL STYLES
#==============================================================================================================================================================================================
#  Toggles the GUI using the operating system's visual style.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function ToggleVisualStyle([bool]$ToggleCheck)
{
  # Enable or disable the visual style.
  switch ($ToggleCheck)
  {
    $true   { [Windows.Forms.Application]::VisualStyleState = [Windows.Forms.VisualStyles.VisualStyleState]::ClientAndNonClientAreasEnabled }
    $false  { [Windows.Forms.Application]::VisualStyleState = [Windows.Forms.VisualStyles.VisualStyleState]::NoneEnabled }
  }
}
#==============================================================================================================================================================================================
#  INITIALIZATION: BOOT MESSAGES
#==============================================================================================================================================================================================
function InitMessage([string]$Message)
{
  # Scrap whatever is shown on the console window.
  Clear-Host

  # Show a message that will most likely flash too fast for the user to read.
  Write-Host $Message
}
#==============================================================================================================================================================================================
#  INITIALIZATION: CTT-PS DATA FOLDER
#==============================================================================================================================================================================================
#  Searches for an already existing data folder.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function FindCTTPSDataFolder()
{
  # Set up the potential paths the script may be in.
  $DataPaths = New-Object string[] 5
  $DataPaths[0] = $TextureToolData
  $DataPaths[1] = [Environment]::GetFolderPath("LocalApplicationData") + '\CTT-PS Data'
  $DataPaths[2] = [Environment]::GetFolderPath("MyDocuments") + '\CTT-PS Data'
  $DataPaths[3] = $BaseFolder + '\CTT-PS Data'
  $DataPaths[4] = 'C:\CTT-PS Data'

  # Test these locations.
  for ($i = 0 ; $i -lt $DataPaths.Count ; $i++)
  {
    # Test this path to see if it exists.
    if (TestPath -LiteralPath $DataPaths[$i])
    {
      # See if its a "ghost" path, meaning there is nothing actually in the folder.
      $Count = (EnumerateFiles -LiteralPath $DataPaths[$i] -Recurse).Count

      # While not a perfect metric of the folder being useful, it's something.
      if ($Count -gt 0)
      {
        # If the path exists and it contains files, then use it.
        return $DataPaths[$i]
      }
    }
  }
  # If it doesn't exist then return an empty string.
  return ''
}
#==============================================================================================================================================================================================
#  Registers the button presses from the data folder dialog found below this function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DataFolderPrompt_ButtonClick()
{
  # Remember the text that is currently in the box.
  $StartText = $DataFolderTextBox.Text

  # Set the path depending on the selected button.
  switch ($this.Name)
  {
    'AData'   { $SetText = [Environment]::GetFolderPath("LocalApplicationData") }
    'Docs'    { $SetText = [Environment]::GetFolderPath("MyDocuments") }
    'CTTPS'   { $SetText = $BaseFolder }
    'CDrive'  { $SetText = 'C:' }
    'Custom'  { $SetText = Get-Folder -StartPath $DesktopPath }
  }
  # If the folder was not selected (particularly with "Custom" button), then default to the last selected.
  if ($SetText -eq '') { $SetText = $StartText.Replace('\CTT-PS Data','') }

  # If the chosen path already has the data folder selected by the user, roll back one folder.
  if ($SetText -like '*\CTT-PS Data') { $SetText = $SetText.Replace('\CTT-PS Data','') }

  # Set the textbox text to the selected path.
  $DataFolderTextBox.Text = $SetText + '\CTT-PS Data'
}
#==============================================================================================================================================================================================
#  Creates the dialog that allows selecting the path that CTT-PS will store and retrieve data and temporary images. 
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CreateDialog_DataFolderPrompt()
{
  # Create the dialog and set up properties.
  $global:DataFolderDialog = New-Object Windows.Forms.Form
  $DataFolderDialog.Text = 'CTT-PS Data Folder Location'
  $DataFolderDialog.Size = DPISize (New-Object Drawing.Size(556, 240))
  $DataFolderDialog.MinimumSize = DPISize (New-Object Drawing.Size(556, 240))
  $DataFolderDialog.MaximumSize = DPISize (New-Object Drawing.Size(556, 240))
  $DataFolderDialog.MinimizeBox = $false
  $DataFolderDialog.MaximizeBox = $false
  $DataFolderDialog.AutoScaleMode = [Windows.Forms.AutoScaleMode]::None
  $DataFolderDialog.FormBorderStyle = GetFormBorderStyle
  $DataFolderDialog.StartPosition = "CenterScreen"
  $DataFolderDialog.Topmost = $true
  $DataFolderDialog.KeyPreview = $true
  $DataFolderDialog.Add_FormClosing({ $DataFolderDialog.Hide() ; $_.Cancel = $true })

  # Set the info text for the window.
  $LabelText = 'Custom Texture Tool PS uses a global data folder to store settings, generate temporary images, store a resource ' +
               'pack database, and store the included DPI profiles. It can also be used as a place to store the various programs ' +
               'that this script makes use of. Where this folder is located can be configured here.'

  # Create a label for the text.
  $global:DataInfoLabel = New-Object Windows.Forms.Label
  $DataInfoLabel.Size = DPISize (New-Object Drawing.Size(530, 70))
  $DataInfoLabel.Location = DPISize (New-Object Drawing.Point(16, 10))
  $DataInfoLabel.Font = New-Object Drawing.Font('Microsoft Sans Serif', 11)
  $DataInfoLabel.Text = [String]::Format($LabelText, [Environment]::NewLine)
  $DataFolderDialog.Controls.Add($DataInfoLabel)

  # Check to see if the variable has a value.
  switch ($TextureToolData)
  {
    # If it doesn't, default to AppData folder. If it does, use that for the textbox.
    ''      { $DataFolderText = [Environment]::GetFolderPath("LocalApplicationData") + '\CTT-PS Data' }
    default { $DataFolderText = $TextureToolData }
  }
  # The text box will hold the path to the data folder.
  $global:DataFolderTextBox = New-Object Windows.Forms.TextBox
  $DataFolderTextBox.Name = 'TextureToolData'
  $DataFolderTextBox.Size = DPISize (New-Object Drawing.Size(518, 30))
  $DataFolderTextBox.Location = DPISize (New-Object Drawing.Point(11, 122))
  $DataFolderTextBox.Text = $DataFolderText
  $DataFolderTextBox.ReadOnly = $true
  $DataFolderTextBox.BackColor = '#FFFFFF'
  $DataFolderDialog.Controls.Add($DataFolderTextBox)

  # This button selects the AppData folder.
  $global:DataAppDataButton = New-Object Windows.Forms.Button
  $DataAppDataButton.Size = DPISize (New-Object Drawing.Size(100, 24))
  $DataAppDataButton.Location = DPISize (New-Object Drawing.Point(10, 88))
  $DataAppDataButton.Name = 'AData'
  $DataAppDataButton.Text = 'AppData'
  $DataAppDataButton.Add_Click({ DataFolderPrompt_ButtonClick })
  $DataFolderDialog.Controls.Add($DataAppDataButton)

  # This button selects the Documents folder.
  $global:DataDocumentsButton = New-Object Windows.Forms.Button
  $DataDocumentsButton.Size = DPISize (New-Object Drawing.Size(100, 24))
  $DataDocumentsButton.Location = DPISize (New-Object Drawing.Point(115, 88))
  $DataDocumentsButton.Name = 'Docs'
  $DataDocumentsButton.Text = 'Documents'
  $DataDocumentsButton.Add_Click({ DataFolderPrompt_ButtonClick })
  $DataFolderDialog.Controls.Add($DataDocumentsButton)

  # This button selects the CTT-PS folder.
  $global:DataCTTPSButton = New-Object Windows.Forms.Button
  $DataCTTPSButton.Size = DPISize (New-Object Drawing.Size(100, 24))
  $DataCTTPSButton.Location = DPISize (New-Object Drawing.Point(220, 88))
  $DataCTTPSButton.Name = 'CTTPS'
  $DataCTTPSButton.Text = 'CTT-PS'
  $DataCTTPSButton.Add_Click({ DataFolderPrompt_ButtonClick })
  $DataFolderDialog.Controls.Add($DataCTTPSButton)

  # This button selects the base of the main drive.
  $global:DataMainDriveButton = New-Object Windows.Forms.Button
  $DataMainDriveButton.Size = DPISize (New-Object Drawing.Size(100, 24))
  $DataMainDriveButton.Location = DPISize (New-Object Drawing.Point(325, 88))
  $DataMainDriveButton.Name = 'CDrive'
  $DataMainDriveButton.Text = 'C:\>'
  $DataMainDriveButton.Add_Click({ DataFolderPrompt_ButtonClick })
  $DataFolderDialog.Controls.Add($DataMainDriveButton)

  # This button allows selecting a custom folder.
  $global:DataCustomButton = New-Object Windows.Forms.Button
  $DataCustomButton.Size = DPISize (New-Object Drawing.Size(100, 24))
  $DataCustomButton.Location = DPISize (New-Object Drawing.Point(430, 88))
  $DataCustomButton.Name = 'Custom'
  $DataCustomButton.Text = 'Custom'
  $DataCustomButton.Add_Click({ DataFolderPrompt_ButtonClick })
  $DataFolderDialog.Controls.Add($DataCustomButton)

  # Create a button to close the window.
  $global:DataOkayButton = New-Object Windows.Forms.Button
  $DataOkayButton.Size = DPISize (New-Object Drawing.Size(140, 34))
  $DataOkayButton.Location = DPISize (New-Object Drawing.Point(390, 154))
  $DataOkayButton.Text = 'OK'
  $DataOkayButton.Add_Click({ $DataFolderDialog.Hide() })
  $DataFolderDialog.Controls.Add($DataOkayButton)
}
#==============================================================================================================================================================================================
#  INITIALIZATION: SHOW INFORMATION
#==============================================================================================================================================================================================
function ShowInitializationInfo()
{ 
  # Make this ugly shit a little bit neater.
  $WinString = $WindowsVersion.ToString()
  $PSVersion = $PSVersionTable.PSVersion.ToString()
  $ResString = $Monitor.Width.ToString() + 'x' + $Monitor.Height.ToString()
  $DPIString = $Monitor.DPI.ToString()
  $ModString = $DPIMultiplier.ToString()
  $Processor = $PhysicalCores.ToString() + ' Physical, ' + $LogicalCores.ToString() + ' Logical'

  # Show me a bunch of information.
  DebugMessage -Message '======================================================================================' -MessageColor 'Gray'
  DebugMessage -Message (' ' + $ScriptName) -MessageColor 'Yellow'
  DebugMessage -Message '======================================================================================' -MessageColor 'Gray'
  DebugMessage -Message ' System Info:' -MessageColor 'Green'
  DebugMessage -Message '======================================================================================' -MessageColor 'Gray'
  DebugMessage -Message (' Windows     ') -MessageColor 'Yellow' -FollowUp (': ' + $WinString) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Powershell  ') -MessageColor 'Yellow' -FollowUp (': ' + $PSVersion) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Resolution  ') -MessageColor 'Yellow' -FollowUp (': ' + $ResString) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Screen DPI  ') -MessageColor 'Yellow' -FollowUp (': ' + $DPIString) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Multiplier  ') -MessageColor 'Yellow' -FollowUp (': ' + $ModString) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Hard Disks  ') -MessageColor 'Yellow' -FollowUp (': ' + $HardDisks) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' CPU Cores   ') -MessageColor 'Yellow' -FollowUp (': ' + $Processor) -FollowUpColor 'White' -SameLine
  DebugMessage -Message '======================================================================================' -MessageColor 'Gray'
  DebugMessage -Message ' CTT-PS Info:' -MessageColor 'Green'
  DebugMessage -Message '======================================================================================' -MessageColor 'Gray'
  DebugMessage -Message (' CTT-PS Path ') -MessageColor 'Yellow' -FollowUp (': ' + $BaseFolder)        -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Main Data   ') -MessageColor 'Yellow' -FollowUp (': ' + $TextureToolData)   -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Stored Pref ') -MessageColor 'Yellow' -FollowUp (': ' + $StoredOptionsFile) -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' ResPack DB  ') -MessageColor 'Yellow' -FollowUp (': ' + $ResourcePackData)  -FollowUpColor 'White' -SameLine
  DebugMessage -Message (' Temp Folder ') -MessageColor 'Yellow' -FollowUp (': ' + $TempFolder)        -FollowUpColor 'White' -SameLine
  DebugMessage -Message '======================================================================================' -MessageColor 'Gray'
}
#==============================================================================================================================================================================================
#  INITIALIZATION: RESOLUTION FIX
#==============================================================================================================================================================================================
#  Resolution as seen by this script is calculated. Both the screen resolution and the simulated resolution when DPI settings are used. Because it works with decimals and not integers, there 
#  can be rounding errors. While it's not really important as it doesn't affect anything serious, this shitty function just fixes those rounding errors for "cosmetic" purposes. At the moment
#  it only fixes 4k monitor at 3840x2160 when using 216 DPI (225% scaling) but I'm assuming there will be more that needs fixing in the future with higher resolution and DPI settings.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function CheckFixScreenDimension([int]$Dimension)
{
  # Use a switch to find values with rounding errors.
  switch($Dimension.ToString())
  {
    # Replace the value with what it "should" be.
    '1707' { return 1706 }
    '3841' { return 3840 }
  }
  # If it was already dandy, return it as-is.
  return $Dimension
}
#==============================================================================================================================================================================================
#  INITIALIZATION: MAIN INITIALIZATION
#==============================================================================================================================================================================================
#  This is where all the magic begins. This can be considered the main boot function.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function MainInitialize()
{
  # Get the name of the user. Currently not using this but I'm pasting here to remember this method.
  $global:UserName = ([System.Security.Principal.WindowsIdentity]::GetCurrent().Name).Split('\') | Select-Object -Index 1

  # Enable high DPI if it's not disabled by the user.
  $global:HighDPIEnabled = !$DisableHighDPIMode

  # Make the application DPI Aware.
  if ($HighDPIEnabled) { [DPI]::SetProcessAware() }

  # Create a form that we can pull the DPI from.
  $DPI_Form = New-Object Windows.Forms.Form
  $Graphics = $DPI_Form.CreateGraphics();
  $DPIValue = [Convert]::ToInt32($Graphics.DpiX)
  $DPI_Form.Dispose();

  # Show a message to say stuff is happening.
  InitMessage -Message 'Retrieving data from Windows...'

  # Enable visual styles or double buffering will not work.
  [Windows.Forms.Application]::EnableVisualStyles()

  # Set up default values for tooltips.
  $global:ToolTipDelay    = 750
  $global:ToolTipDuration = 30000

  # Support security protocols up to TLS 1.2. Allows downloading files with PowerShell (used for ESRGAN and SFTGAN).
  [System.Net.ServicePointManager]::SecurityProtocol = "Tls, Tls11, Tls12, Ssl3"

  # Get the current version of windows.
  $GetWinVersion = ([Environment]::OSVersion.Version).ToString().Split('.')
  $GetWinVersion = $GetWinVersion[0] + '.' + $GetWinVersion[1]

  # Set the version of windows. Share versions for Vista/7 and for 8/8.1.
  switch ($GetWinVersion)
  {
    # Windows Vista
    '6.0'   { $global:WindowsVersion = 6 }

    # Windows 7
    '6.1'   { $global:WindowsVersion = 7 }

    # Windows 8
    '6.2'   { $global:WindowsVersion = 8 }

    # Windows 8.1
    '6.3'   { $global:WindowsVersion = 8 }  

    # Windows 10 / 11
    '10.0'  {
              # Get the full name of the operating system and split on the spaces.
              $WinTitle = ((Get-CimInstance -ClassName CIM_OperatingSystem).Caption).Split(' ')

              # Get the version from the split string.
              $global:WindowsVersion = [int]($WinTitle[2])
            }
    # No clue what is to come. Future proof by assuming it will work on future windows.
    default { $global:WindowsVersion = 50 }  
  }
  # Get the number of physical cores and logical cores the CPU has.
  $global:PhysicalCores = [int]([string](Get-WmiObject -Class win32_processor -Property NumberOfCores | Select-Object -Property NumberOfCores)).Replace('@{NumberOfCores=','').Replace('}','')
  $global:LogicalCores  = [int]([string](Get-WmiObject -Class win32_processor -Property NumberOfLogicalProcessors | Select-Object -Property NumberOfLogicalProcessors)).Replace('@{NumberOfLogicalProcessors=','').Replace('}','')

  # Calculate the screen resolution using the current DPI value.
  $ScreenDPI      = $DPIValue
  $ScreenWidth    = CheckFixScreenDimension -Dimension ([Windows.Forms.Screen]::PrimaryScreen.Bounds.Width)
  $ScreenHeight   = CheckFixScreenDimension -Dimension ([Windows.Forms.Screen]::PrimaryScreen.Bounds.Height)

  # Set the DPI and resolution of the primary monitor. Send it to null to prevent printing 0's on the screen.
  $global:Monitor = @{}
  $Monitor.Add('DPI', $ScreenDPI)
  $Monitor.Add('Width', $ScreenWidth)
  $Monitor.Add('Height', $ScreenHeight)

  # Get the multiplier derived from the DPI setting.
  $global:DPIMultiplier = ($Monitor.DPI / 24) * 0.25

  # Used to add just a few more pixels to textboxes and comboboxes.
  $global:DPIOffsetFix = ($DPIMultiplier - 1) * 4

  # A quick and easy reference to the desktop.
  $global:DesktopPath = [Environment]::GetFolderPath("Desktop")

  # Get all available hard drives on the system.
  $global:HardDisks = [IO.DriveInfo]::GetDrives() | Where-Object {$_.DriveType -eq 'Fixed'}

  # Grab the version of the script by splitting the name on the "v".
  $SplitVersion = $ScriptName.Replace("'","").Split('v', 2)

  # Get the path and the version of the script by grabbing everything after the "v".
  $global:ScriptPath    = $script:MyInvocation.MyCommand.Path
  $global:ScriptVersion = $SplitVersion[1]

  # Get the folder the script is in.
  $global:BaseFolder = Split-Path $ScriptPath

  # If there is a fragment of an old script laying around, delete it.
  RemovePath -LiteralPath ($BaseFolder + '\CTT-Updating.temp')

  # Show a message to say stuff is happening.
  InitMessage -Message 'Setting up CTT-PS Data folder...'

  # Attempt to find a data path if it already exists.
  $global:TextureToolData = FindCTTPSDataFolder

  # Create the dialog that allows selecting this path.
  CreateDialog_DataFolderPrompt

  # If the path has not been found or it doesn't exist.
  if ((!(TestPath -LiteralPath $TextureToolData)) -or ($TextureToolData -eq ''))
  {
     # Show the dialog.
     $DataFolderDialog.ShowDialog() | Out-Null

    # Set the path to the folder that was selected from the dialog.
    $global:TextureToolData = CreatePath -LiteralPath $DataFolderTextBox.Text
  }
  # This will house any files that CTT-PS needs and serves as a temporary folder.
  $global:StoredOptionsFile = $TextureToolData + '\StoredOptions.ini'
  $global:ResourcePackData  = $TextureToolData + '\ResourcePackDatabase.rpd'
  $global:CustomExecutables = $TextureToolData + '\CLIExecutables.ini'
  $global:CS3PKGFileList    = $TextureToolData + '\ColdSteel3PKGList.ini'
  $global:CS4PKGFileList    = $TextureToolData + '\ColdSteel4PKGList.ini'
  $global:TempFolder        = $TextureToolData + '\Temp'
  $global:ExternalScripts   = CreatePath -LiteralPath ($TextureToolData + '\Scripts') -NoReturn
  $global:PKAPyScript       = $TextureToolData + '\Scripts\pka_extract.py'
  $global:PKGPyScript       = $TextureToolData + '\Scripts\pkg_extract.py'

  # Store this variable to the script file now so it will always be remembered.
  StoreSingleGlobalVariable -VarName 'TextureToolData'

  # If the user wants to save and load options externally.
  if ($StoreToAppData)
  {
    # Show a message to say stuff is happening.
    InitMessage -Message 'Syncing "StoredOptions.ini" file...'

    # Sync the options found in AppData with the options in the script.
    SyncAppDataOptions -ImportFrom $ScriptPath -CopyInto $StoredOptionsFile

    # Load the options from the external file.
    ImportAllGlobalVariables -ImportPath $StoredOptionsFile -SkipGUI
  }
  # Show a message to say stuff is happening.
  InitMessage -Message 'Adjusting PowerShell settings...'

  # Update the PowerShell title bar to bring it in line with other windows.
  $host.UI.RawUI.WindowTitle = 'CTT-PS PowerShell'

  # I have yet not perfected setting the buffer size, as it will error out often depending on user settings.
  $ErrorActionPreference = 'SilentlyContinue'

  # Buffer size width is the max number of characters going from left to right. Height is the max number of lines going from top to bottom.
  $host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size(100, 20000)

  # I only want to silence the buffer size error. Hopefully someday I'll find a way to get max buffer size depending on the system.
  $ErrorActionPreference = 'Continue'

  # Window size width and height is how many of those characters and lines are visible at any time.
  $host.UI.RawUI.WindowSize = New-Object System.Management.Automation.Host.Size(90, 25)

  # Show a message to say stuff is happening.
  InitMessage -Message 'Initializing default values...'

  # Toggle the visibility of the visual style.
  ToggleVisualStyle -ToggleCheck $EnableVisualStyle

  # If the master tools folder was downloaded and selected.
  MasterToolsPathUpdate 

  # Test if the user stored a texture folder using the checkbox.
  $global:MasterInputPath  = SetMasterPath -StoreFolder $StoreInputFolder -StoredPath $SavedInputFolder -BackupPath $BaseFolder -PathAddition ''
  $global:MasterOutputPath = SetMasterPath -StoreFolder $StoreOutputFolder -StoredPath $SavedOutputFolder -BackupPath $BaseFolder -PathAddition '\~CTT_Generated'

  # If these paths weren't already set, try to get the paths through the registry + mild hard drive searching.
  if (!(TestPath -LiteralPath $ImageMagick)) { GetImageMagickInstallPath }
  if (!(TestPath -LiteralPath $Python))      { GetPythonInstallPath }
  if (!(TestPath -LiteralPath $7ZipPath))    { Get7ZipInstallPath }

  # Set the base log path and the path to the texture database file.
  $global:LogFile = $BaseFolder + '\' + $ScriptName.Replace("'","") + '.log'

  # If a database path is not set, then set it to the CTT-PS Data folder.
  if (!(TestPath -Literalpath $DatabasePath)) 
  {
    # Set the path to the database files.
    $global:DatabasePath = $TextureToolData + '\Database'

    # Create the path if it doesn't exist.
    CreatePath -LiteralPath $DatabasePath
  }
  # Set the full path to the database file.
  $global:DatabaseFile = $DatabasePath + '\' + $DatabaseName

  # Keeps track of the master loop in session and when a texture is being processed.
  $global:MasterLoopRunning = $false
  $global:ProcessingTexture = $false

  # Used to temporarily override the "master" input/output paths.
  $global:MasterInputSave  = ''
  $global:MasterOutputSave = ''
  $global:PathsNeedRestore = $false

  # Empty value of the "Auto-Rename" feature of the convert and rescale options.
  $global:AutoRenameValue = ''

  # Empty value of the "VRAM Path Override" feature of the calculate VRAM option.
  $global:VRAMPackPath = ''

  # Keeps track of whether or not a CTT file has been loaded.
  $global:CTTFileLoaded = $false

  # Empty value for Combine/Split operations CTT data file, the default text to display, and some default values for combine textures.
  $global:CombineSelected  = 'Select or drag and drop a texture to split into multiple textures...'
  $global:CombineCooldown  = $false
  $global:CombineHideNames = $false

  # The default state of a loaded resource pack for "Update a Resource Pack".
  $global:ResourcePack = ''

  # Can contain a list of user-input strings to exclude. This probably isn't necessary, but set its initial value to null.
  $global:ExcludeStrings = $null

  # Show a message saying vars are being updated.
  InitMessage -Message 'Updating global variables...'

  # Set up the global variables for the operations.
  CreateOperationGlobals

  # Show a message saying images are being created.
  InitMessage -Message 'Creating images from Base64 strings...'

  # Create the images from base64 strings.
  CreateImagesFromBase64

  # Set the icon for the PowerShell window.
  Set-ConsoleIcon -Icon $Icon_CTTPSRed

  # Show a message saying that the GUI is being built.
  InitMessage -Message 'Building the GUI...'

  # Create all the dialogs the script will use.
  CreateDialog_CombineTextures
  CreateDialog_CombineRename
  CreateDialog_CombineZeldaSS
  CreateDialog_ZeldaOptions
  CreateDialog_TopLeftTexture
  CreateDialog_AutoArrangeChoices
  CreateDialog_YesNoDialog
  CreateDialog_OKDialog
  CreateDialog_TextureList
  CreateDialog_ProcessSelected
  CreateDialog_ImageViewer
  CreateDialog_ResourcePack
  CreateDialog_ManualRescale
  CreateDialog_OptionsMenu
  CreateDialog_SSAutoSetup
  CreateDialog_MainDialog
  CreateDialog_MainDialogOps
  CreateDialog_HelpMenu
  CreateDialog_HotCodeDialog
  CreateDialog_ColorDialog
  CreateDialog_ESRGANDialog
  CreateDialog_TextureExtraction
  CreateDialog_AlphaManipulation
  CreateDialog_Waifu2xOptions
  CreateDialog_SuperScalerPath
  CreateDialog_WatermarkPreview
  CreateDialog_DDSToolOptions
  CreateDialog_ShutdownDialog

  # Show a message to say lists are being updated.
  InitMessage -Message 'Populating selection lists...'

  # Populate the "DDS Tool" and "DDS Format" lists. This function takes care of that and more.
  RefreshDDSLists

  # Populate the "Output Format" lists for convert and rescale options.
  PopulateFormatLists -Combobox $ConvertFormatCombo -SelectedFormat (ExtensionToText -Extension $ConvertFormat)
  PopulateFormatLists -Combobox $RescaleFormatCombo -SelectedFormat (ExtensionToText -Extension $RescaleFormat)
  PopulateFormatLists -Combobox $ResizeFormatCombo  -SelectedFormat (ExtensionToText -Extension $ResizeFormat)

  # Populate the "Upscale Filter" list and updates the visibility and position of some waifu2x options depending on which executable is found (Caffe or CPP).
  PopulateUpscaleFilterList

  # Updates the texture format list on Phyre options.
  PopulateToCSPhyreFormatList

  # Show a phrase I like from SimCity 2000 for funsies.
  InitMessage -Message 'Reticulating splines...'

  # Now that all tips have been created for "DDS Format", "DDS Fallback", and "Flag Removal", set the initial tips that are displayed on Init based on the current CTT-PS Mode.
  SetDDSOptionToolTips -ExtendedTips ($CTTPSSelectedMode -ne 'Dolphin Mode')

  # Modify the waifu2x dialog options depending on whether or not Caffe or CPP was found.
  Waifu2x_UpdateAppSpecificOptions

  # Loads user data from the "CLIExecutables.ini" file if it exists.
  PopulateCLIProgramsList

  # Default all the values on the resource pack dialog.
  ResetResourceDialog

  # Update the headers on the Texture List depending on which mode was selected.
  TexList_SetColumnHeaders -Selection $CTTPSSelectedMode

  # Show one final message before launching the GUI.
  InitMessage -Message 'Done! Launch the GUI...'

  # Show or hide the [!] button near "Exit" that exits without saving. 
  ToggleNoSaveButtons -ToggleCheck $CloseNoSaveButtons

  # Populate the "Operations" list and select the stored option.
  PopulateOperationList

  # Now that the GUI has been loaded, populate the Optimization tool list and update the options on the PNG Optimization groupbox.
  PopulateOptimizerList
  UpdateOptimizerOptions

  # Toggle the initial state of the quick help and weblink icons.
  ToggleDockedQuickHelp
  ToggleWebLinkIcons

  # Wipe out whatever remains on the screen.
  Clear-Host

  # If the console is enabled, show some stuff that is useful to know.
  if ($EnableThePSConsole) { ShowInitializationInfo }

  # Perform a cleanup from last time if the user didn't properly close the script.
  ClearPath -LiteralPath $TempFolder

  # Hide the console unless the user enabled it.
  ShowPowerShellConsole -ShowConsole $EnableThePSConsole

  # Find the number of running instances of powershell.
  $PSInstances = @(Get-Process powershell -ErrorAction SilentlyContinue).Count

  # Do not center the console if there is already a running instance or it was disabled.
  if (($PSInstances -lt 2) -and (!$DisableAutoConsole) -and ($EnableThePSConsole))
  {
    # Get information about the current PowerShell instance.
    $PowerShellInfo = GetPowerShellInfo

    # Calculate the X and Y positions for the top left corner that will center the console.
    $WindowX = [int](($Monitor.Width / 2) - ($PowerShellInfo.Width / 2))
    $WindowY = [int](($Monitor.Height / 2) - ($PowerShellInfo.Height / 2))

    # Center the PowerShell console on the primary monitor.
    [Window]::MoveWindow($PowerShellInfo.Handle, $WindowX, $WindowY, $PowerShellInfo.Width, $PowerShellInfo.Height, $True) | Out-Null
  }
  # Force dark mode off for now.
  $global:WinDarkModeEnabled = $false
}
#==============================================================================================================================================================================================
#  INITIALIZATION: LAUNCH THE MAIN WINDOW
#==============================================================================================================================================================================================
# Run the main initialization function.
MainInitialize

# Center the "Waiting for program to close" label just before the texure list is shown.
TexList_CenterWaitLabel

# Show the main dialog which is where it all starts. The script will continue past this point when the dialog is closed.
$MainDialog.ShowDialog()

# The dialog was closed, now hide the console. This allows PowerShell to work in the background for a few seconds without bothering the user.
ShowPowerShellConsole -ShowConsole $false

# Time to store the options to "StoredOptions.ini" or the script depending on the user's settings.
if (!$NoSave)
{
  # Check if the user checked the box to save options externally.
  switch ($StoreToAppData)
  {
    # Save "StoredOptions.ini" to the CTT-PS data folder if enabled. Otherwise save to the script file itself.
    $true  { StoreAllGlobalVariables -StorePath $StoredOptionsFile }
    $false { StoreAllGlobalVariables -StorePath $ScriptPath }
  }
}
# Perform one final clean up of any stray files that may be left over in the temp folder.
ClearPath -LiteralPath $TempFolder

# Not likely needed since this is the end, but force it closed anyway.
Exit
